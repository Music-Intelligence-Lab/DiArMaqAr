var nR = Object.defineProperty;
var rR = (n, t, e) => t in n ? nR(n, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: e
}) : n[t] = e;
var St = (n, t, e) => (rR(n, typeof t != "symbol" ? t + "" : t, e),
e);
(function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        r(i);
    new MutationObserver(i => {
        for (const a of i)
            if (a.type === "childList")
                for (const l of a.addedNodes)
                    l.tagName === "LINK" && l.rel === "modulepreload" && r(l)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function e(i) {
        const a = {};
        return i.integrity && (a.integrity = i.integrity),
        i.referrerPolicy && (a.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? a.credentials = "include" : i.crossOrigin === "anonymous" ? a.credentials = "omit" : a.credentials = "same-origin",
        a
    }
    function r(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const a = e(i);
        fetch(i.href, a)
    }
}
)();
/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
/*! #__NO_SIDE_EFFECTS__ */
function m1(n) {
    const t = Object.create(null);
    for (const e of n.split(","))
        t[e] = 1;
    return e => e in t
}
const Mn = {}
  , Fl = []
  , Ks = () => {}
  , sR = () => !1
  , vm = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && (n.charCodeAt(2) > 122 || n.charCodeAt(2) < 97)
  , g1 = n => n.startsWith("onUpdate:")
  , lr = Object.assign
  , v1 = (n, t) => {
    const e = n.indexOf(t);
    e > -1 && n.splice(e, 1)
}
  , iR = Object.prototype.hasOwnProperty
  , wn = (n, t) => iR.call(n, t)
  , Ot = Array.isArray
  , Rl = n => Mf(n) === "[object Map]"
  , iu = n => Mf(n) === "[object Set]"
  , iw = n => Mf(n) === "[object Date]"
  , Dt = n => typeof n == "function"
  , Kn = n => typeof n == "string"
  , Qs = n => typeof n == "symbol"
  , Nn = n => n !== null && typeof n == "object"
  , k_ = n => (Nn(n) || Dt(n)) && Dt(n.then) && Dt(n.catch)
  , z_ = Object.prototype.toString
  , Mf = n => z_.call(n)
  , oR = n => Mf(n).slice(8, -1)
  , V_ = n => Mf(n) === "[object Object]"
  , y1 = n => Kn(n) && n !== "NaN" && n[0] !== "-" && "" + parseInt(n, 10) === n
  , Uu = m1(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , ym = n => {
    const t = Object.create(null);
    return e => t[e] || (t[e] = n(e))
}
  , aR = /-(\w)/g
  , Fs = ym(n => n.replace(aR, (t, e) => e ? e.toUpperCase() : ""))
  , lR = /\B([A-Z])/g
  , Da = ym(n => n.replace(lR, "-$1").toLowerCase())
  , bm = ym(n => n.charAt(0).toUpperCase() + n.slice(1))
  , ev = ym(n => n ? `on${bm(n)}` : "")
  , Fo = (n, t) => !Object.is(n, t)
  , Vd = (n, ...t) => {
    for (let e = 0; e < n.length; e++)
        n[e](...t)
}
  , U_ = (n, t, e, r=!1) => {
    Object.defineProperty(n, t, {
        configurable: !0,
        enumerable: !1,
        writable: r,
        value: e
    })
}
  , ih = n => {
    const t = parseFloat(n);
    return isNaN(t) ? n : t
}
  , uR = n => {
    const t = Kn(n) ? Number(n) : NaN;
    return isNaN(t) ? n : t
}
;
let ow;
const wm = () => ow || (ow = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
function Na(n) {
    if (Ot(n)) {
        const t = {};
        for (let e = 0; e < n.length; e++) {
            const r = n[e]
              , i = Kn(r) ? hR(r) : Na(r);
            if (i)
                for (const a in i)
                    t[a] = i[a]
        }
        return t
    } else if (Kn(n) || Nn(n))
        return n
}
const cR = /;(?![^(]*\))/g
  , fR = /:([^]+)/
  , dR = /\/\*[^]*?\*\//g;
function hR(n) {
    const t = {};
    return n.replace(dR, "").split(cR).forEach(e => {
        if (e) {
            const r = e.split(fR);
            r.length > 1 && (t[r[0].trim()] = r[1].trim())
        }
    }
    ),
    t
}
function Of(n) {
    let t = "";
    if (Kn(n))
        t = n;
    else if (Ot(n))
        for (let e = 0; e < n.length; e++) {
            const r = Of(n[e]);
            r && (t += r + " ")
        }
    else if (Nn(n))
        for (const e in n)
            n[e] && (t += e + " ");
    return t.trim()
}
const pR = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , mR = m1(pR);
function j_(n) {
    return !!n || n === ""
}
function gR(n, t) {
    if (n.length !== t.length)
        return !1;
    let e = !0;
    for (let r = 0; e && r < n.length; r++)
        e = Ta(n[r], t[r]);
    return e
}
function Ta(n, t) {
    if (n === t)
        return !0;
    let e = iw(n)
      , r = iw(t);
    if (e || r)
        return e && r ? n.getTime() === t.getTime() : !1;
    if (e = Qs(n),
    r = Qs(t),
    e || r)
        return n === t;
    if (e = Ot(n),
    r = Ot(t),
    e || r)
        return e && r ? gR(n, t) : !1;
    if (e = Nn(n),
    r = Nn(t),
    e || r) {
        if (!e || !r)
            return !1;
        const i = Object.keys(n).length
          , a = Object.keys(t).length;
        if (i !== a)
            return !1;
        for (const l in n) {
            const f = n.hasOwnProperty(l)
              , h = t.hasOwnProperty(l);
            if (f && !h || !f && h || !Ta(n[l], t[l]))
                return !1
        }
    }
    return String(n) === String(t)
}
function b1(n, t) {
    return n.findIndex(e => Ta(e, t))
}
const H_ = n => !!(n && n.__v_isRef === !0)
  , ds = n => Kn(n) ? n : n == null ? "" : Ot(n) || Nn(n) && (n.toString === z_ || !Dt(n.toString)) ? H_(n) ? ds(n.value) : JSON.stringify(n, G_, 2) : String(n)
  , G_ = (n, t) => H_(t) ? G_(n, t.value) : Rl(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce( (e, [r,i], a) => (e[tv(r, a) + " =>"] = i,
    e), {})
} : iu(t) ? {
    [`Set(${t.size})`]: [...t.values()].map(e => tv(e))
} : Qs(t) ? tv(t) : Nn(t) && !Ot(t) && !V_(t) ? String(t) : t
  , tv = (n, t="") => {
    var e;
    return Qs(n) ? `Symbol(${(e = n.description) != null ? e : t})` : n
}
;
/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let Zr;
class W_ {
    constructor(t=!1) {
        this.detached = t,
        this._active = !0,
        this.effects = [],
        this.cleanups = [],
        this._isPaused = !1,
        this.parent = Zr,
        !t && Zr && (this.index = (Zr.scopes || (Zr.scopes = [])).push(this) - 1)
    }
    get active() {
        return this._active
    }
    pause() {
        if (this._active) {
            this._isPaused = !0;
            let t, e;
            if (this.scopes)
                for (t = 0,
                e = this.scopes.length; t < e; t++)
                    this.scopes[t].pause();
            for (t = 0,
            e = this.effects.length; t < e; t++)
                this.effects[t].pause()
        }
    }
    resume() {
        if (this._active && this._isPaused) {
            this._isPaused = !1;
            let t, e;
            if (this.scopes)
                for (t = 0,
                e = this.scopes.length; t < e; t++)
                    this.scopes[t].resume();
            for (t = 0,
            e = this.effects.length; t < e; t++)
                this.effects[t].resume()
        }
    }
    run(t) {
        if (this._active) {
            const e = Zr;
            try {
                return Zr = this,
                t()
            } finally {
                Zr = e
            }
        }
    }
    on() {
        Zr = this
    }
    off() {
        Zr = this.parent
    }
    stop(t) {
        if (this._active) {
            this._active = !1;
            let e, r;
            for (e = 0,
            r = this.effects.length; e < r; e++)
                this.effects[e].stop();
            for (this.effects.length = 0,
            e = 0,
            r = this.cleanups.length; e < r; e++)
                this.cleanups[e]();
            if (this.cleanups.length = 0,
            this.scopes) {
                for (e = 0,
                r = this.scopes.length; e < r; e++)
                    this.scopes[e].stop(!0);
                this.scopes.length = 0
            }
            if (!this.detached && this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                i.index = this.index)
            }
            this.parent = void 0
        }
    }
}
function J_(n) {
    return new W_(n)
}
function K_() {
    return Zr
}
function vR(n, t=!1) {
    Zr && Zr.cleanups.push(n)
}
let xn;
const nv = new WeakSet;
class Z_ {
    constructor(t) {
        this.fn = t,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 5,
        this.next = void 0,
        this.cleanup = void 0,
        this.scheduler = void 0,
        Zr && Zr.active && Zr.effects.push(this)
    }
    pause() {
        this.flags |= 64
    }
    resume() {
        this.flags & 64 && (this.flags &= -65,
        nv.has(this) && (nv.delete(this),
        this.trigger()))
    }
    notify() {
        this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Q_(this)
    }
    run() {
        if (!(this.flags & 1))
            return this.fn();
        this.flags |= 2,
        aw(this),
        X_(this);
        const t = xn
          , e = Zs;
        xn = this,
        Zs = !0;
        try {
            return this.fn()
        } finally {
            eL(this),
            xn = t,
            Zs = e,
            this.flags &= -3
        }
    }
    stop() {
        if (this.flags & 1) {
            for (let t = this.deps; t; t = t.nextDep)
                _1(t);
            this.deps = this.depsTail = void 0,
            aw(this),
            this.onStop && this.onStop(),
            this.flags &= -2
        }
    }
    trigger() {
        this.flags & 64 ? nv.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty()
    }
    runIfDirty() {
        o0(this) && this.run()
    }
    get dirty() {
        return o0(this)
    }
}
let Y_ = 0, ju, Hu;
function Q_(n, t=!1) {
    if (n.flags |= 8,
    t) {
        n.next = Hu,
        Hu = n;
        return
    }
    n.next = ju,
    ju = n
}
function w1() {
    Y_++
}
function E1() {
    if (--Y_ > 0)
        return;
    if (Hu) {
        let t = Hu;
        for (Hu = void 0; t; ) {
            const e = t.next;
            t.next = void 0,
            t.flags &= -9,
            t = e
        }
    }
    let n;
    for (; ju; ) {
        let t = ju;
        for (ju = void 0; t; ) {
            const e = t.next;
            if (t.next = void 0,
            t.flags &= -9,
            t.flags & 1)
                try {
                    t.trigger()
                } catch (r) {
                    n || (n = r)
                }
            t = e
        }
    }
    if (n)
        throw n
}
function X_(n) {
    for (let t = n.deps; t; t = t.nextDep)
        t.version = -1,
        t.prevActiveLink = t.dep.activeLink,
        t.dep.activeLink = t
}
function eL(n) {
    let t, e = n.depsTail, r = e;
    for (; r; ) {
        const i = r.prevDep;
        r.version === -1 ? (r === e && (e = i),
        _1(r),
        yR(r)) : t = r,
        r.dep.activeLink = r.prevActiveLink,
        r.prevActiveLink = void 0,
        r = i
    }
    n.deps = t,
    n.depsTail = e
}
function o0(n) {
    for (let t = n.deps; t; t = t.nextDep)
        if (t.dep.version !== t.version || t.dep.computed && (tL(t.dep.computed) || t.dep.version !== t.version))
            return !0;
    return !!n._dirty
}
function tL(n) {
    if (n.flags & 4 && !(n.flags & 16) || (n.flags &= -17,
    n.globalVersion === uc))
        return;
    n.globalVersion = uc;
    const t = n.dep;
    if (n.flags |= 2,
    t.version > 0 && !n.isSSR && n.deps && !o0(n)) {
        n.flags &= -3;
        return
    }
    const e = xn
      , r = Zs;
    xn = n,
    Zs = !0;
    try {
        X_(n);
        const i = n.fn(n._value);
        (t.version === 0 || Fo(i, n._value)) && (n._value = i,
        t.version++)
    } catch (i) {
        throw t.version++,
        i
    } finally {
        xn = e,
        Zs = r,
        eL(n),
        n.flags &= -3
    }
}
function _1(n, t=!1) {
    const {dep: e, prevSub: r, nextSub: i} = n;
    if (r && (r.nextSub = i,
    n.prevSub = void 0),
    i && (i.prevSub = r,
    n.nextSub = void 0),
    e.subs === n && (e.subs = r,
    !r && e.computed)) {
        e.computed.flags &= -5;
        for (let a = e.computed.deps; a; a = a.nextDep)
            _1(a, !0)
    }
    !t && !--e.sc && e.map && e.map.delete(e.key)
}
function yR(n) {
    const {prevDep: t, nextDep: e} = n;
    t && (t.nextDep = e,
    n.prevDep = void 0),
    e && (e.prevDep = t,
    n.nextDep = void 0)
}
let Zs = !0;
const nL = [];
function Ho() {
    nL.push(Zs),
    Zs = !1
}
function Go() {
    const n = nL.pop();
    Zs = n === void 0 ? !0 : n
}
function aw(n) {
    const {cleanup: t} = n;
    if (n.cleanup = void 0,
    t) {
        const e = xn;
        xn = void 0;
        try {
            t()
        } finally {
            xn = e
        }
    }
}
let uc = 0;
class bR {
    constructor(t, e) {
        this.sub = t,
        this.dep = e,
        this.version = e.version,
        this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0
    }
}
class L1 {
    constructor(t) {
        this.computed = t,
        this.version = 0,
        this.activeLink = void 0,
        this.subs = void 0,
        this.map = void 0,
        this.key = void 0,
        this.sc = 0
    }
    track(t) {
        if (!xn || !Zs || xn === this.computed)
            return;
        let e = this.activeLink;
        if (e === void 0 || e.sub !== xn)
            e = this.activeLink = new bR(xn,this),
            xn.deps ? (e.prevDep = xn.depsTail,
            xn.depsTail.nextDep = e,
            xn.depsTail = e) : xn.deps = xn.depsTail = e,
            rL(e);
        else if (e.version === -1 && (e.version = this.version,
        e.nextDep)) {
            const r = e.nextDep;
            r.prevDep = e.prevDep,
            e.prevDep && (e.prevDep.nextDep = r),
            e.prevDep = xn.depsTail,
            e.nextDep = void 0,
            xn.depsTail.nextDep = e,
            xn.depsTail = e,
            xn.deps === e && (xn.deps = r)
        }
        return e
    }
    trigger(t) {
        this.version++,
        uc++,
        this.notify(t)
    }
    notify(t) {
        w1();
        try {
            for (let e = this.subs; e; e = e.prevSub)
                e.sub.notify() && e.sub.dep.notify()
        } finally {
            E1()
        }
    }
}
function rL(n) {
    if (n.dep.sc++,
    n.sub.flags & 4) {
        const t = n.dep.computed;
        if (t && !n.dep.subs) {
            t.flags |= 20;
            for (let r = t.deps; r; r = r.nextDep)
                rL(r)
        }
        const e = n.dep.subs;
        e !== n && (n.prevSub = e,
        e && (e.nextSub = n)),
        n.dep.subs = n
    }
}
const oh = new WeakMap
  , Sa = Symbol("")
  , a0 = Symbol("")
  , cc = Symbol("");
function Rr(n, t, e) {
    if (Zs && xn) {
        let r = oh.get(n);
        r || oh.set(n, r = new Map);
        let i = r.get(e);
        i || (r.set(e, i = new L1),
        i.map = r,
        i.key = e),
        i.track()
    }
}
function Ki(n, t, e, r, i, a) {
    const l = oh.get(n);
    if (!l) {
        uc++;
        return
    }
    const f = h => {
        h && h.trigger()
    }
    ;
    if (w1(),
    t === "clear")
        l.forEach(f);
    else {
        const h = Ot(n)
          , p = h && y1(e);
        if (h && e === "length") {
            const m = Number(r);
            l.forEach( (g, b) => {
                (b === "length" || b === cc || !Qs(b) && b >= m) && f(g)
            }
            )
        } else
            switch ((e !== void 0 || l.has(void 0)) && f(l.get(e)),
            p && f(l.get(cc)),
            t) {
            case "add":
                h ? p && f(l.get("length")) : (f(l.get(Sa)),
                Rl(n) && f(l.get(a0)));
                break;
            case "delete":
                h || (f(l.get(Sa)),
                Rl(n) && f(l.get(a0)));
                break;
            case "set":
                Rl(n) && f(l.get(Sa));
                break
            }
    }
    E1()
}
function wR(n, t) {
    const e = oh.get(n);
    return e && e.get(t)
}
function hl(n) {
    const t = cn(n);
    return t === n ? t : (Rr(t, "iterate", cc),
    Ts(n) ? t : t.map(Pr))
}
function Em(n) {
    return Rr(n = cn(n), "iterate", cc),
    n
}
const ER = {
    __proto__: null,
    [Symbol.iterator]() {
        return rv(this, Symbol.iterator, Pr)
    },
    concat(...n) {
        return hl(this).concat(...n.map(t => Ot(t) ? hl(t) : t))
    },
    entries() {
        return rv(this, "entries", n => (n[1] = Pr(n[1]),
        n))
    },
    every(n, t) {
        return Vi(this, "every", n, t, void 0, arguments)
    },
    filter(n, t) {
        return Vi(this, "filter", n, t, e => e.map(Pr), arguments)
    },
    find(n, t) {
        return Vi(this, "find", n, t, Pr, arguments)
    },
    findIndex(n, t) {
        return Vi(this, "findIndex", n, t, void 0, arguments)
    },
    findLast(n, t) {
        return Vi(this, "findLast", n, t, Pr, arguments)
    },
    findLastIndex(n, t) {
        return Vi(this, "findLastIndex", n, t, void 0, arguments)
    },
    forEach(n, t) {
        return Vi(this, "forEach", n, t, void 0, arguments)
    },
    includes(...n) {
        return sv(this, "includes", n)
    },
    indexOf(...n) {
        return sv(this, "indexOf", n)
    },
    join(n) {
        return hl(this).join(n)
    },
    lastIndexOf(...n) {
        return sv(this, "lastIndexOf", n)
    },
    map(n, t) {
        return Vi(this, "map", n, t, void 0, arguments)
    },
    pop() {
        return Iu(this, "pop")
    },
    push(...n) {
        return Iu(this, "push", n)
    },
    reduce(n, ...t) {
        return lw(this, "reduce", n, t)
    },
    reduceRight(n, ...t) {
        return lw(this, "reduceRight", n, t)
    },
    shift() {
        return Iu(this, "shift")
    },
    some(n, t) {
        return Vi(this, "some", n, t, void 0, arguments)
    },
    splice(...n) {
        return Iu(this, "splice", n)
    },
    toReversed() {
        return hl(this).toReversed()
    },
    toSorted(n) {
        return hl(this).toSorted(n)
    },
    toSpliced(...n) {
        return hl(this).toSpliced(...n)
    },
    unshift(...n) {
        return Iu(this, "unshift", n)
    },
    values() {
        return rv(this, "values", Pr)
    }
};
function rv(n, t, e) {
    const r = Em(n)
      , i = r[t]();
    return r !== n && !Ts(n) && (i._next = i.next,
    i.next = () => {
        const a = i._next();
        return a.value && (a.value = e(a.value)),
        a
    }
    ),
    i
}
const _R = Array.prototype;
function Vi(n, t, e, r, i, a) {
    const l = Em(n)
      , f = l !== n && !Ts(n)
      , h = l[t];
    if (h !== _R[t]) {
        const g = h.apply(n, a);
        return f ? Pr(g) : g
    }
    let p = e;
    l !== n && (f ? p = function(g, b) {
        return e.call(this, Pr(g), b, n)
    }
    : e.length > 2 && (p = function(g, b) {
        return e.call(this, g, b, n)
    }
    ));
    const m = h.call(l, p, r);
    return f && i ? i(m) : m
}
function lw(n, t, e, r) {
    const i = Em(n);
    let a = e;
    return i !== n && (Ts(n) ? e.length > 3 && (a = function(l, f, h) {
        return e.call(this, l, f, h, n)
    }
    ) : a = function(l, f, h) {
        return e.call(this, l, Pr(f), h, n)
    }
    ),
    i[t](a, ...r)
}
function sv(n, t, e) {
    const r = cn(n);
    Rr(r, "iterate", cc);
    const i = r[t](...e);
    return (i === -1 || i === !1) && C1(e[0]) ? (e[0] = cn(e[0]),
    r[t](...e)) : i
}
function Iu(n, t, e=[]) {
    Ho(),
    w1();
    const r = cn(n)[t].apply(n, e);
    return E1(),
    Go(),
    r
}
const LR = m1("__proto__,__v_isRef,__isVue")
  , sL = new Set(Object.getOwnPropertyNames(Symbol).filter(n => n !== "arguments" && n !== "caller").map(n => Symbol[n]).filter(Qs));
function SR(n) {
    Qs(n) || (n = String(n));
    const t = cn(this);
    return Rr(t, "has", n),
    t.hasOwnProperty(n)
}
class iL {
    constructor(t=!1, e=!1) {
        this._isReadonly = t,
        this._isShallow = e
    }
    get(t, e, r) {
        if (e === "__v_skip")
            return t.__v_skip;
        const i = this._isReadonly
          , a = this._isShallow;
        if (e === "__v_isReactive")
            return !i;
        if (e === "__v_isReadonly")
            return i;
        if (e === "__v_isShallow")
            return a;
        if (e === "__v_raw")
            return r === (i ? a ? FR : uL : a ? lL : aL).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(r) ? t : void 0;
        const l = Ot(t);
        if (!i) {
            let h;
            if (l && (h = ER[e]))
                return h;
            if (e === "hasOwnProperty")
                return SR
        }
        const f = Reflect.get(t, e, tr(t) ? t : r);
        return (Qs(e) ? sL.has(e) : LR(e)) || (i || Rr(t, "get", e),
        a) ? f : tr(f) ? l && y1(e) ? f : f.value : Nn(f) ? i ? fL(f) : Cr(f) : f
    }
}
class oL extends iL {
    constructor(t=!1) {
        super(!1, t)
    }
    set(t, e, r, i) {
        let a = t[e];
        if (!this._isShallow) {
            const h = xa(a);
            if (!Ts(r) && !xa(r) && (a = cn(a),
            r = cn(r)),
            !Ot(t) && tr(a) && !tr(r))
                return h ? !1 : (a.value = r,
                !0)
        }
        const l = Ot(t) && y1(e) ? Number(e) < t.length : wn(t, e)
          , f = Reflect.set(t, e, r, tr(t) ? t : i);
        return t === cn(i) && (l ? Fo(r, a) && Ki(t, "set", e, r) : Ki(t, "add", e, r)),
        f
    }
    deleteProperty(t, e) {
        const r = wn(t, e);
        t[e];
        const i = Reflect.deleteProperty(t, e);
        return i && r && Ki(t, "delete", e, void 0),
        i
    }
    has(t, e) {
        const r = Reflect.has(t, e);
        return (!Qs(e) || !sL.has(e)) && Rr(t, "has", e),
        r
    }
    ownKeys(t) {
        return Rr(t, "iterate", Ot(t) ? "length" : Sa),
        Reflect.ownKeys(t)
    }
}
class AR extends iL {
    constructor(t=!1) {
        super(!0, t)
    }
    set(t, e) {
        return !0
    }
    deleteProperty(t, e) {
        return !0
    }
}
const CR = new oL
  , $R = new AR
  , MR = new oL(!0);
const l0 = n => n
  , bd = n => Reflect.getPrototypeOf(n);
function OR(n, t, e) {
    return function(...r) {
        const i = this.__v_raw
          , a = cn(i)
          , l = Rl(a)
          , f = n === "entries" || n === Symbol.iterator && l
          , h = n === "keys" && l
          , p = i[n](...r)
          , m = e ? l0 : t ? u0 : Pr;
        return !t && Rr(a, "iterate", h ? a0 : Sa),
        {
            next() {
                const {value: g, done: b} = p.next();
                return b ? {
                    value: g,
                    done: b
                } : {
                    value: f ? [m(g[0]), m(g[1])] : m(g),
                    done: b
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function wd(n) {
    return function(...t) {
        return n === "delete" ? !1 : n === "clear" ? void 0 : this
    }
}
function NR(n, t) {
    const e = {
        get(i) {
            const a = this.__v_raw
              , l = cn(a)
              , f = cn(i);
            n || (Fo(i, f) && Rr(l, "get", i),
            Rr(l, "get", f));
            const {has: h} = bd(l)
              , p = t ? l0 : n ? u0 : Pr;
            if (h.call(l, i))
                return p(a.get(i));
            if (h.call(l, f))
                return p(a.get(f));
            a !== l && a.get(i)
        },
        get size() {
            const i = this.__v_raw;
            return !n && Rr(cn(i), "iterate", Sa),
            Reflect.get(i, "size", i)
        },
        has(i) {
            const a = this.__v_raw
              , l = cn(a)
              , f = cn(i);
            return n || (Fo(i, f) && Rr(l, "has", i),
            Rr(l, "has", f)),
            i === f ? a.has(i) : a.has(i) || a.has(f)
        },
        forEach(i, a) {
            const l = this
              , f = l.__v_raw
              , h = cn(f)
              , p = t ? l0 : n ? u0 : Pr;
            return !n && Rr(h, "iterate", Sa),
            f.forEach( (m, g) => i.call(a, p(m), p(g), l))
        }
    };
    return lr(e, n ? {
        add: wd("add"),
        set: wd("set"),
        delete: wd("delete"),
        clear: wd("clear")
    } : {
        add(i) {
            !t && !Ts(i) && !xa(i) && (i = cn(i));
            const a = cn(this);
            return bd(a).has.call(a, i) || (a.add(i),
            Ki(a, "add", i, i)),
            this
        },
        set(i, a) {
            !t && !Ts(a) && !xa(a) && (a = cn(a));
            const l = cn(this)
              , {has: f, get: h} = bd(l);
            let p = f.call(l, i);
            p || (i = cn(i),
            p = f.call(l, i));
            const m = h.call(l, i);
            return l.set(i, a),
            p ? Fo(a, m) && Ki(l, "set", i, a) : Ki(l, "add", i, a),
            this
        },
        delete(i) {
            const a = cn(this)
              , {has: l, get: f} = bd(a);
            let h = l.call(a, i);
            h || (i = cn(i),
            h = l.call(a, i)),
            f && f.call(a, i);
            const p = a.delete(i);
            return h && Ki(a, "delete", i, void 0),
            p
        },
        clear() {
            const i = cn(this)
              , a = i.size !== 0
              , l = i.clear();
            return a && Ki(i, "clear", void 0, void 0),
            l
        }
    }),
    ["keys", "values", "entries", Symbol.iterator].forEach(i => {
        e[i] = OR(i, n, t)
    }
    ),
    e
}
function S1(n, t) {
    const e = NR(n, t);
    return (r, i, a) => i === "__v_isReactive" ? !n : i === "__v_isReadonly" ? n : i === "__v_raw" ? r : Reflect.get(wn(e, i) && i in r ? e : r, i, a)
}
const TR = {
    get: S1(!1, !1)
}
  , xR = {
    get: S1(!1, !0)
}
  , IR = {
    get: S1(!0, !1)
};
const aL = new WeakMap
  , lL = new WeakMap
  , uL = new WeakMap
  , FR = new WeakMap;
function RR(n) {
    switch (n) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function PR(n) {
    return n.__v_skip || !Object.isExtensible(n) ? 0 : RR(oR(n))
}
function Cr(n) {
    return xa(n) ? n : A1(n, !1, CR, TR, aL)
}
function cL(n) {
    return A1(n, !1, MR, xR, lL)
}
function fL(n) {
    return A1(n, !0, $R, IR, uL)
}
function A1(n, t, e, r, i) {
    if (!Nn(n) || n.__v_raw && !(t && n.__v_isReactive))
        return n;
    const a = i.get(n);
    if (a)
        return a;
    const l = PR(n);
    if (l === 0)
        return n;
    const f = new Proxy(n,l === 2 ? r : e);
    return i.set(n, f),
    f
}
function Ro(n) {
    return xa(n) ? Ro(n.__v_raw) : !!(n && n.__v_isReactive)
}
function xa(n) {
    return !!(n && n.__v_isReadonly)
}
function Ts(n) {
    return !!(n && n.__v_isShallow)
}
function C1(n) {
    return n ? !!n.__v_raw : !1
}
function cn(n) {
    const t = n && n.__v_raw;
    return t ? cn(t) : n
}
function $1(n) {
    return !wn(n, "__v_skip") && Object.isExtensible(n) && U_(n, "__v_skip", !0),
    n
}
const Pr = n => Nn(n) ? Cr(n) : n
  , u0 = n => Nn(n) ? fL(n) : n;
function tr(n) {
    return n ? n.__v_isRef === !0 : !1
}
function te(n) {
    return dL(n, !1)
}
function DR(n) {
    return dL(n, !0)
}
function dL(n, t) {
    return tr(n) ? n : new qR(n,t)
}
class qR {
    constructor(t, e) {
        this.dep = new L1,
        this.__v_isRef = !0,
        this.__v_isShallow = !1,
        this._rawValue = e ? t : cn(t),
        this._value = e ? t : Pr(t),
        this.__v_isShallow = e
    }
    get value() {
        return this.dep.track(),
        this._value
    }
    set value(t) {
        const e = this._rawValue
          , r = this.__v_isShallow || Ts(t) || xa(t);
        t = r ? t : cn(t),
        Fo(t, e) && (this._rawValue = t,
        this._value = r ? t : Pr(t),
        this.dep.trigger())
    }
}
function Ee(n) {
    return tr(n) ? n.value : n
}
const BR = {
    get: (n, t, e) => t === "__v_raw" ? n : Ee(Reflect.get(n, t, e)),
    set: (n, t, e, r) => {
        const i = n[t];
        return tr(i) && !tr(e) ? (i.value = e,
        !0) : Reflect.set(n, t, e, r)
    }
};
function hL(n) {
    return Ro(n) ? n : new Proxy(n,BR)
}
function kR(n) {
    const t = Ot(n) ? new Array(n.length) : {};
    for (const e in n)
        t[e] = VR(n, e);
    return t
}
class zR {
    constructor(t, e, r) {
        this._object = t,
        this._key = e,
        this._defaultValue = r,
        this.__v_isRef = !0,
        this._value = void 0
    }
    get value() {
        const t = this._object[this._key];
        return this._value = t === void 0 ? this._defaultValue : t
    }
    set value(t) {
        this._object[this._key] = t
    }
    get dep() {
        return wR(cn(this._object), this._key)
    }
}
function VR(n, t, e) {
    const r = n[t];
    return tr(r) ? r : new zR(n,t,e)
}
class UR {
    constructor(t, e, r) {
        this.fn = t,
        this.setter = e,
        this._value = void 0,
        this.dep = new L1(this),
        this.__v_isRef = !0,
        this.deps = void 0,
        this.depsTail = void 0,
        this.flags = 16,
        this.globalVersion = uc - 1,
        this.next = void 0,
        this.effect = this,
        this.__v_isReadonly = !e,
        this.isSSR = r
    }
    notify() {
        if (this.flags |= 16,
        !(this.flags & 8) && xn !== this)
            return Q_(this, !0),
            !0
    }
    get value() {
        const t = this.dep.track();
        return tL(this),
        t && (t.version = this.dep.version),
        this._value
    }
    set value(t) {
        this.setter && this.setter(t)
    }
}
function jR(n, t, e=!1) {
    let r, i;
    return Dt(n) ? r = n : (r = n.get,
    i = n.set),
    new UR(r,i,e)
}
const Ed = {}
  , ah = new WeakMap;
let va;
function HR(n, t=!1, e=va) {
    if (e) {
        let r = ah.get(e);
        r || ah.set(e, r = []),
        r.push(n)
    }
}
function GR(n, t, e=Mn) {
    const {immediate: r, deep: i, once: a, scheduler: l, augmentJob: f, call: h} = e
      , p = k => i ? k : Ts(k) || i === !1 || i === 0 ? Zi(k, 1) : Zi(k);
    let m, g, b, E, S = !1, F = !1;
    if (tr(n) ? (g = () => n.value,
    S = Ts(n)) : Ro(n) ? (g = () => p(n),
    S = !0) : Ot(n) ? (F = !0,
    S = n.some(k => Ro(k) || Ts(k)),
    g = () => n.map(k => {
        if (tr(k))
            return k.value;
        if (Ro(k))
            return p(k);
        if (Dt(k))
            return h ? h(k, 2) : k()
    }
    )) : Dt(n) ? t ? g = h ? () => h(n, 2) : n : g = () => {
        if (b) {
            Ho();
            try {
                b()
            } finally {
                Go()
            }
        }
        const k = va;
        va = m;
        try {
            return h ? h(n, 3, [E]) : n(E)
        } finally {
            va = k
        }
    }
    : g = Ks,
    t && i) {
        const k = g
          , z = i === !0 ? 1 / 0 : i;
        g = () => Zi(k(), z)
    }
    const B = K_()
      , Q = () => {
        m.stop(),
        B && B.active && v1(B.effects, m)
    }
    ;
    if (a && t) {
        const k = t;
        t = (...z) => {
            k(...z),
            Q()
        }
    }
    let ae = F ? new Array(n.length).fill(Ed) : Ed;
    const V = k => {
        if (!(!(m.flags & 1) || !m.dirty && !k))
            if (t) {
                const z = m.run();
                if (i || S || (F ? z.some( (Z, re) => Fo(Z, ae[re])) : Fo(z, ae))) {
                    b && b();
                    const Z = va;
                    va = m;
                    try {
                        const re = [z, ae === Ed ? void 0 : F && ae[0] === Ed ? [] : ae, E];
                        h ? h(t, 3, re) : t(...re),
                        ae = z
                    } finally {
                        va = Z
                    }
                }
            } else
                m.run()
    }
    ;
    return f && f(V),
    m = new Z_(g),
    m.scheduler = l ? () => l(V, !1) : V,
    E = k => HR(k, !1, m),
    b = m.onStop = () => {
        const k = ah.get(m);
        if (k) {
            if (h)
                h(k, 4);
            else
                for (const z of k)
                    z();
            ah.delete(m)
        }
    }
    ,
    t ? r ? V(!0) : ae = m.run() : l ? l(V.bind(null, !0), !0) : m.run(),
    Q.pause = m.pause.bind(m),
    Q.resume = m.resume.bind(m),
    Q.stop = Q,
    Q
}
function Zi(n, t=1 / 0, e) {
    if (t <= 0 || !Nn(n) || n.__v_skip || (e = e || new Set,
    e.has(n)))
        return n;
    if (e.add(n),
    t--,
    tr(n))
        Zi(n.value, t, e);
    else if (Ot(n))
        for (let r = 0; r < n.length; r++)
            Zi(n[r], t, e);
    else if (iu(n) || Rl(n))
        n.forEach(r => {
            Zi(r, t, e)
        }
        );
    else if (V_(n)) {
        for (const r in n)
            Zi(n[r], t, e);
        for (const r of Object.getOwnPropertySymbols(n))
            Object.prototype.propertyIsEnumerable.call(n, r) && Zi(n[r], t, e)
    }
    return n
}
/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
function Nf(n, t, e, r) {
    try {
        return r ? n(...r) : n()
    } catch (i) {
        Tf(i, t, e)
    }
}
function Xs(n, t, e, r) {
    if (Dt(n)) {
        const i = Nf(n, t, e, r);
        return i && k_(i) && i.catch(a => {
            Tf(a, t, e)
        }
        ),
        i
    }
    if (Ot(n)) {
        const i = [];
        for (let a = 0; a < n.length; a++)
            i.push(Xs(n[a], t, e, r));
        return i
    }
}
function Tf(n, t, e, r=!0) {
    const i = t ? t.vnode : null
      , {errorHandler: a, throwUnhandledErrorInProduction: l} = t && t.appContext.config || Mn;
    if (t) {
        let f = t.parent;
        const h = t.proxy
          , p = `https://vuejs.org/error-reference/#runtime-${e}`;
        for (; f; ) {
            const m = f.ec;
            if (m) {
                for (let g = 0; g < m.length; g++)
                    if (m[g](n, h, p) === !1)
                        return
            }
            f = f.parent
        }
        if (a) {
            Ho(),
            Nf(a, null, 10, [n, h, p]),
            Go();
            return
        }
    }
    WR(n, e, i, r, l)
}
function WR(n, t, e, r=!0, i=!1) {
    if (i)
        throw n;
    console.error(n)
}
const Yr = [];
let mi = -1;
const Pl = [];
let Co = null
  , Cl = 0;
const pL = Promise.resolve();
let lh = null;
function _m(n) {
    const t = lh || pL;
    return n ? t.then(this ? n.bind(this) : n) : t
}
function JR(n) {
    let t = mi + 1
      , e = Yr.length;
    for (; t < e; ) {
        const r = t + e >>> 1
          , i = Yr[r]
          , a = fc(i);
        a < n || a === n && i.flags & 2 ? t = r + 1 : e = r
    }
    return t
}
function M1(n) {
    if (!(n.flags & 1)) {
        const t = fc(n)
          , e = Yr[Yr.length - 1];
        !e || !(n.flags & 2) && t >= fc(e) ? Yr.push(n) : Yr.splice(JR(t), 0, n),
        n.flags |= 1,
        mL()
    }
}
function mL() {
    lh || (lh = pL.then(vL))
}
function KR(n) {
    Ot(n) ? Pl.push(...n) : Co && n.id === -1 ? Co.splice(Cl + 1, 0, n) : n.flags & 1 || (Pl.push(n),
    n.flags |= 1),
    mL()
}
function uw(n, t, e=mi + 1) {
    for (; e < Yr.length; e++) {
        const r = Yr[e];
        if (r && r.flags & 2) {
            if (n && r.id !== n.uid)
                continue;
            Yr.splice(e, 1),
            e--,
            r.flags & 4 && (r.flags &= -2),
            r(),
            r.flags & 4 || (r.flags &= -2)
        }
    }
}
function gL(n) {
    if (Pl.length) {
        const t = [...new Set(Pl)].sort( (e, r) => fc(e) - fc(r));
        if (Pl.length = 0,
        Co) {
            Co.push(...t);
            return
        }
        for (Co = t,
        Cl = 0; Cl < Co.length; Cl++) {
            const e = Co[Cl];
            e.flags & 4 && (e.flags &= -2),
            e.flags & 8 || e(),
            e.flags &= -2
        }
        Co = null,
        Cl = 0
    }
}
const fc = n => n.id == null ? n.flags & 2 ? -1 : 1 / 0 : n.id;
function vL(n) {
    const t = Ks;
    try {
        for (mi = 0; mi < Yr.length; mi++) {
            const e = Yr[mi];
            e && !(e.flags & 8) && (e.flags & 4 && (e.flags &= -2),
            Nf(e, e.i, e.i ? 15 : 14),
            e.flags & 4 || (e.flags &= -2))
        }
    } finally {
        for (; mi < Yr.length; mi++) {
            const e = Yr[mi];
            e && (e.flags &= -2)
        }
        mi = -1,
        Yr.length = 0,
        gL(),
        lh = null,
        (Yr.length || Pl.length) && vL()
    }
}
let mr = null
  , yL = null;
function uh(n) {
    const t = mr;
    return mr = n,
    yL = n && n.type.__scopeId || null,
    t
}
function Wr(n, t=mr, e) {
    if (!t || n._n)
        return n;
    const r = (...i) => {
        r._d && Lw(-1);
        const a = uh(t);
        let l;
        try {
            l = n(...i)
        } finally {
            uh(a),
            r._d && Lw(1)
        }
        return l
    }
    ;
    return r._n = !0,
    r._c = !0,
    r._d = !0,
    r
}
function So(n, t) {
    if (mr === null)
        return n;
    const e = $m(mr)
      , r = n.dirs || (n.dirs = []);
    for (let i = 0; i < t.length; i++) {
        let[a,l,f,h=Mn] = t[i];
        a && (Dt(a) && (a = {
            mounted: a,
            updated: a
        }),
        a.deep && Zi(l),
        r.push({
            dir: a,
            instance: e,
            value: l,
            oldValue: void 0,
            arg: f,
            modifiers: h
        }))
    }
    return n
}
function fa(n, t, e, r) {
    const i = n.dirs
      , a = t && t.dirs;
    for (let l = 0; l < i.length; l++) {
        const f = i[l];
        a && (f.oldValue = a[l].value);
        let h = f.dir[r];
        h && (Ho(),
        Xs(h, e, 8, [n.el, f, n, t]),
        Go())
    }
}
const bL = Symbol("_vte")
  , wL = n => n.__isTeleport
  , Gu = n => n && (n.disabled || n.disabled === "")
  , cw = n => n && (n.defer || n.defer === "")
  , fw = n => typeof SVGElement < "u" && n instanceof SVGElement
  , dw = n => typeof MathMLElement == "function" && n instanceof MathMLElement
  , c0 = (n, t) => {
    const e = n && n.to;
    return Kn(e) ? t ? t(e) : null : e
}
  , EL = {
    name: "Teleport",
    __isTeleport: !0,
    process(n, t, e, r, i, a, l, f, h, p) {
        const {mc: m, pc: g, pbc: b, o: {insert: E, querySelector: S, createText: F, createComment: B}} = p
          , Q = Gu(t.props);
        let {shapeFlag: ae, children: V, dynamicChildren: k} = t;
        if (n == null) {
            const z = t.el = F("")
              , Z = t.anchor = F("");
            E(z, e, r),
            E(Z, e, r);
            const re = (D, R) => {
                ae & 16 && (i && i.isCE && (i.ce._teleportTarget = D),
                m(V, D, R, i, a, l, f, h))
            }
              , C = () => {
                const D = t.target = c0(t.props, S)
                  , R = _L(D, t, F, E);
                D && (l !== "svg" && fw(D) ? l = "svg" : l !== "mathml" && dw(D) && (l = "mathml"),
                Q || (re(D, R),
                Ud(t, !1)))
            }
            ;
            Q && (re(e, Z),
            Ud(t, !0)),
            cw(t.props) ? Jr( () => {
                C(),
                t.el.__isMounted = !0
            }
            , a) : C()
        } else {
            if (cw(t.props) && !n.el.__isMounted) {
                Jr( () => {
                    EL.process(n, t, e, r, i, a, l, f, h, p),
                    delete n.el.__isMounted
                }
                , a);
                return
            }
            t.el = n.el,
            t.targetStart = n.targetStart;
            const z = t.anchor = n.anchor
              , Z = t.target = n.target
              , re = t.targetAnchor = n.targetAnchor
              , C = Gu(n.props)
              , D = C ? e : Z
              , R = C ? z : re;
            if (l === "svg" || fw(Z) ? l = "svg" : (l === "mathml" || dw(Z)) && (l = "mathml"),
            k ? (b(n.dynamicChildren, k, D, i, a, l, f),
            I1(n, t, !0)) : h || g(n, t, D, R, i, a, l, f, !1),
            Q)
                C ? t.props && n.props && t.props.to !== n.props.to && (t.props.to = n.props.to) : _d(t, e, z, p, 1);
            else if ((t.props && t.props.to) !== (n.props && n.props.to)) {
                const W = t.target = c0(t.props, S);
                W && _d(t, W, null, p, 0)
            } else
                C && _d(t, Z, re, p, 1);
            Ud(t, Q)
        }
    },
    remove(n, t, e, {um: r, o: {remove: i}}, a) {
        const {shapeFlag: l, children: f, anchor: h, targetStart: p, targetAnchor: m, target: g, props: b} = n;
        if (g && (i(p),
        i(m)),
        a && i(h),
        l & 16) {
            const E = a || !Gu(b);
            for (let S = 0; S < f.length; S++) {
                const F = f[S];
                r(F, t, e, E, !!F.dynamicChildren)
            }
        }
    },
    move: _d,
    hydrate: ZR
};
function _d(n, t, e, {o: {insert: r}, m: i}, a=2) {
    a === 0 && r(n.targetAnchor, t, e);
    const {el: l, anchor: f, shapeFlag: h, children: p, props: m} = n
      , g = a === 2;
    if (g && r(l, t, e),
    (!g || Gu(m)) && h & 16)
        for (let b = 0; b < p.length; b++)
            i(p[b], t, e, 2);
    g && r(f, t, e)
}
function ZR(n, t, e, r, i, a, {o: {nextSibling: l, parentNode: f, querySelector: h, insert: p, createText: m}}, g) {
    const b = t.target = c0(t.props, h);
    if (b) {
        const E = Gu(t.props)
          , S = b._lpa || b.firstChild;
        if (t.shapeFlag & 16)
            if (E)
                t.anchor = g(l(n), t, f(n), e, r, i, a),
                t.targetStart = S,
                t.targetAnchor = S && l(S);
            else {
                t.anchor = l(n);
                let F = S;
                for (; F; ) {
                    if (F && F.nodeType === 8) {
                        if (F.data === "teleport start anchor")
                            t.targetStart = F;
                        else if (F.data === "teleport anchor") {
                            t.targetAnchor = F,
                            b._lpa = t.targetAnchor && l(t.targetAnchor);
                            break
                        }
                    }
                    F = l(F)
                }
                t.targetAnchor || _L(b, t, m, p),
                g(S && l(S), t, b, e, r, i, a)
            }
        Ud(t, E)
    }
    return t.anchor && l(t.anchor)
}
const O1 = EL;
function Ud(n, t) {
    const e = n.ctx;
    if (e && e.ut) {
        let r, i;
        for (t ? (r = n.el,
        i = n.anchor) : (r = n.targetStart,
        i = n.targetAnchor); r && r !== i; )
            r.nodeType === 1 && r.setAttribute("data-v-owner", e.uid),
            r = r.nextSibling;
        e.ut()
    }
}
function _L(n, t, e, r) {
    const i = t.targetStart = e("")
      , a = t.targetAnchor = e("");
    return i[bL] = a,
    n && (r(i, n),
    r(a, n)),
    a
}
const $o = Symbol("_leaveCb")
  , Ld = Symbol("_enterCb");
function YR() {
    const n = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return If( () => {
        n.isMounted = !0
    }
    ),
    OL( () => {
        n.isUnmounting = !0
    }
    ),
    n
}
const Cs = [Function, Array]
  , LL = {
    mode: String,
    appear: Boolean,
    persisted: Boolean,
    onBeforeEnter: Cs,
    onEnter: Cs,
    onAfterEnter: Cs,
    onEnterCancelled: Cs,
    onBeforeLeave: Cs,
    onLeave: Cs,
    onAfterLeave: Cs,
    onLeaveCancelled: Cs,
    onBeforeAppear: Cs,
    onAppear: Cs,
    onAfterAppear: Cs,
    onAppearCancelled: Cs
}
  , SL = n => {
    const t = n.subTree;
    return t.component ? SL(t.component) : t
}
  , QR = {
    name: "BaseTransition",
    props: LL,
    setup(n, {slots: t}) {
        const e = K4()
          , r = YR();
        return () => {
            const i = t.default && $L(t.default(), !0);
            if (!i || !i.length)
                return;
            const a = AL(i)
              , l = cn(n)
              , {mode: f} = l;
            if (r.isLeaving)
                return iv(a);
            const h = hw(a);
            if (!h)
                return iv(a);
            let p = f0(h, l, r, e, g => p = g);
            h.type !== Qr && dc(h, p);
            let m = e.subTree && hw(e.subTree);
            if (m && m.type !== Qr && !ba(h, m) && SL(e).type !== Qr) {
                let g = f0(m, l, r, e);
                if (dc(m, g),
                f === "out-in" && h.type !== Qr)
                    return r.isLeaving = !0,
                    g.afterLeave = () => {
                        r.isLeaving = !1,
                        e.job.flags & 8 || e.update(),
                        delete g.afterLeave,
                        m = void 0
                    }
                    ,
                    iv(a);
                f === "in-out" && h.type !== Qr ? g.delayLeave = (b, E, S) => {
                    const F = CL(r, m);
                    F[String(m.key)] = m,
                    b[$o] = () => {
                        E(),
                        b[$o] = void 0,
                        delete p.delayedLeave,
                        m = void 0
                    }
                    ,
                    p.delayedLeave = () => {
                        S(),
                        delete p.delayedLeave,
                        m = void 0
                    }
                }
                : m = void 0
            } else
                m && (m = void 0);
            return a
        }
    }
};
function AL(n) {
    let t = n[0];
    if (n.length > 1) {
        for (const e of n)
            if (e.type !== Qr) {
                t = e;
                break
            }
    }
    return t
}
const XR = QR;
function CL(n, t) {
    const {leavingVNodes: e} = n;
    let r = e.get(t.type);
    return r || (r = Object.create(null),
    e.set(t.type, r)),
    r
}
function f0(n, t, e, r, i) {
    const {appear: a, mode: l, persisted: f=!1, onBeforeEnter: h, onEnter: p, onAfterEnter: m, onEnterCancelled: g, onBeforeLeave: b, onLeave: E, onAfterLeave: S, onLeaveCancelled: F, onBeforeAppear: B, onAppear: Q, onAfterAppear: ae, onAppearCancelled: V} = t
      , k = String(n.key)
      , z = CL(e, n)
      , Z = (D, R) => {
        D && Xs(D, r, 9, R)
    }
      , re = (D, R) => {
        const W = R[1];
        Z(D, R),
        Ot(D) ? D.every(I => I.length <= 1) && W() : D.length <= 1 && W()
    }
      , C = {
        mode: l,
        persisted: f,
        beforeEnter(D) {
            let R = h;
            if (!e.isMounted)
                if (a)
                    R = B || h;
                else
                    return;
            D[$o] && D[$o](!0);
            const W = z[k];
            W && ba(n, W) && W.el[$o] && W.el[$o](),
            Z(R, [D])
        },
        enter(D) {
            let R = p
              , W = m
              , I = g;
            if (!e.isMounted)
                if (a)
                    R = Q || p,
                    W = ae || m,
                    I = V || g;
                else
                    return;
            let N = !1;
            const P = D[Ld] = J => {
                N || (N = !0,
                J ? Z(I, [D]) : Z(W, [D]),
                C.delayedLeave && C.delayedLeave(),
                D[Ld] = void 0)
            }
            ;
            R ? re(R, [D, P]) : P()
        },
        leave(D, R) {
            const W = String(n.key);
            if (D[Ld] && D[Ld](!0),
            e.isUnmounting)
                return R();
            Z(b, [D]);
            let I = !1;
            const N = D[$o] = P => {
                I || (I = !0,
                R(),
                P ? Z(F, [D]) : Z(S, [D]),
                D[$o] = void 0,
                z[W] === n && delete z[W])
            }
            ;
            z[W] = n,
            E ? re(E, [D, N]) : N()
        },
        clone(D) {
            const R = f0(D, t, e, r, i);
            return i && i(R),
            R
        }
    };
    return C
}
function iv(n) {
    if (xf(n))
        return n = ko(n),
        n.children = null,
        n
}
function hw(n) {
    if (!xf(n))
        return wL(n.type) && n.children ? AL(n.children) : n;
    const {shapeFlag: t, children: e} = n;
    if (e) {
        if (t & 16)
            return e[0];
        if (t & 32 && Dt(e.default))
            return e.default()
    }
}
function dc(n, t) {
    n.shapeFlag & 6 && n.component ? (n.transition = t,
    dc(n.component.subTree, t)) : n.shapeFlag & 128 ? (n.ssContent.transition = t.clone(n.ssContent),
    n.ssFallback.transition = t.clone(n.ssFallback)) : n.transition = t
}
function $L(n, t=!1, e) {
    let r = []
      , i = 0;
    for (let a = 0; a < n.length; a++) {
        let l = n[a];
        const f = e == null ? l.key : String(e) + String(l.key != null ? l.key : a);
        l.type === Jn ? (l.patchFlag & 128 && i++,
        r = r.concat($L(l.children, t, f))) : (t || l.type !== Qr) && r.push(f != null ? ko(l, {
            key: f
        }) : l)
    }
    if (i > 1)
        for (let a = 0; a < r.length; a++)
            r[a].patchFlag = -2;
    return r
}
/*! #__NO_SIDE_EFFECTS__ */
function gs(n, t) {
    return Dt(n) ? ( () => lr({
        name: n.name
    }, t, {
        setup: n
    }))() : n
}
function N1(n) {
    n.ids = [n.ids[0] + n.ids[2]++ + "-", 0, 0]
}
function ch(n, t, e, r, i=!1) {
    if (Ot(n)) {
        n.forEach( (S, F) => ch(S, t && (Ot(t) ? t[F] : t), e, r, i));
        return
    }
    if (Dl(r) && !i) {
        r.shapeFlag & 512 && r.type.__asyncResolved && r.component.subTree.component && ch(n, t, e, r.component.subTree);
        return
    }
    const a = r.shapeFlag & 4 ? $m(r.component) : r.el
      , l = i ? null : a
      , {i: f, r: h} = n
      , p = t && t.r
      , m = f.refs === Mn ? f.refs = {} : f.refs
      , g = f.setupState
      , b = cn(g)
      , E = g === Mn ? () => !1 : S => wn(b, S);
    if (p != null && p !== h && (Kn(p) ? (m[p] = null,
    E(p) && (g[p] = null)) : tr(p) && (p.value = null)),
    Dt(h))
        Nf(h, f, 12, [l, m]);
    else {
        const S = Kn(h)
          , F = tr(h);
        if (S || F) {
            const B = () => {
                if (n.f) {
                    const Q = S ? E(h) ? g[h] : m[h] : h.value;
                    i ? Ot(Q) && v1(Q, a) : Ot(Q) ? Q.includes(a) || Q.push(a) : S ? (m[h] = [a],
                    E(h) && (g[h] = m[h])) : (h.value = [a],
                    n.k && (m[n.k] = h.value))
                } else
                    S ? (m[h] = l,
                    E(h) && (g[h] = l)) : F && (h.value = l,
                    n.k && (m[n.k] = l))
            }
            ;
            l ? (B.id = -1,
            Jr(B, e)) : B()
        }
    }
}
const pw = n => n.nodeType === 8;
wm().requestIdleCallback;
wm().cancelIdleCallback;
function e4(n, t) {
    if (pw(n) && n.data === "[") {
        let e = 1
          , r = n.nextSibling;
        for (; r; ) {
            if (r.nodeType === 1) {
                if (t(r) === !1)
                    break
            } else if (pw(r))
                if (r.data === "]") {
                    if (--e === 0)
                        break
                } else
                    r.data === "[" && e++;
            r = r.nextSibling
        }
    } else
        t(n)
}
const Dl = n => !!n.type.__asyncLoader;
/*! #__NO_SIDE_EFFECTS__ */
function un(n) {
    Dt(n) && (n = {
        loader: n
    });
    const {loader: t, loadingComponent: e, errorComponent: r, delay: i=200, hydrate: a, timeout: l, suspensible: f=!0, onError: h} = n;
    let p = null, m, g = 0;
    const b = () => (g++,
    p = null,
    E())
      , E = () => {
        let S;
        return p || (S = p = t().catch(F => {
            if (F = F instanceof Error ? F : new Error(String(F)),
            h)
                return new Promise( (B, Q) => {
                    h(F, () => B(b()), () => Q(F), g + 1)
                }
                );
            throw F
        }
        ).then(F => S !== p && p ? p : (F && (F.__esModule || F[Symbol.toStringTag] === "Module") && (F = F.default),
        m = F,
        F)))
    }
    ;
    return gs({
        name: "AsyncComponentWrapper",
        __asyncLoader: E,
        __asyncHydrate(S, F, B) {
            const Q = a ? () => {
                const ae = a(B, V => e4(S, V));
                ae && (F.bum || (F.bum = [])).push(ae)
            }
            : B;
            m ? Q() : E().then( () => !F.isUnmounted && Q())
        },
        get __asyncResolved() {
            return m
        },
        setup() {
            const S = pr;
            if (N1(S),
            m)
                return () => ov(m, S);
            const F = V => {
                p = null,
                Tf(V, S, 13, !r)
            }
            ;
            if (f && S.suspense || kl)
                return E().then(V => () => ov(V, S)).catch(V => (F(V),
                () => r ? jt(r, {
                    error: V
                }) : null));
            const B = te(!1)
              , Q = te()
              , ae = te(!!i);
            return i && setTimeout( () => {
                ae.value = !1
            }
            , i),
            l != null && setTimeout( () => {
                if (!B.value && !Q.value) {
                    const V = new Error(`Async component timed out after ${l}ms.`);
                    F(V),
                    Q.value = V
                }
            }
            , l),
            E().then( () => {
                B.value = !0,
                S.parent && xf(S.parent.vnode) && S.parent.update()
            }
            ).catch(V => {
                F(V),
                Q.value = V
            }
            ),
            () => {
                if (B.value && m)
                    return ov(m, S);
                if (Q.value && r)
                    return jt(r, {
                        error: Q.value
                    });
                if (e && !ae.value)
                    return jt(e)
            }
        }
    })
}
function ov(n, t) {
    const {ref: e, props: r, children: i, ce: a} = t.vnode
      , l = jt(n, r, i);
    return l.ref = e,
    l.ce = a,
    delete t.vnode.ce,
    l
}
const xf = n => n.type.__isKeepAlive;
function t4(n, t) {
    ML(n, "a", t)
}
function n4(n, t) {
    ML(n, "da", t)
}
function ML(n, t, e=pr) {
    const r = n.__wdc || (n.__wdc = () => {
        let i = e;
        for (; i; ) {
            if (i.isDeactivated)
                return;
            i = i.parent
        }
        return n()
    }
    );
    if (Lm(t, r, e),
    e) {
        let i = e.parent;
        for (; i && i.parent; )
            xf(i.parent.vnode) && r4(r, t, e, i),
            i = i.parent
    }
}
function r4(n, t, e, r) {
    const i = Lm(t, n, r, !0);
    Sm( () => {
        v1(r[t], i)
    }
    , e)
}
function Lm(n, t, e=pr, r=!1) {
    if (e) {
        const i = e[n] || (e[n] = [])
          , a = t.__weh || (t.__weh = (...l) => {
            Ho();
            const f = Ff(e)
              , h = Xs(t, e, n, l);
            return f(),
            Go(),
            h
        }
        );
        return r ? i.unshift(a) : i.push(a),
        a
    }
}
const to = n => (t, e=pr) => {
    (!kl || n === "sp") && Lm(n, (...r) => t(...r), e)
}
  , s4 = to("bm")
  , If = to("m")
  , i4 = to("bu")
  , o4 = to("u")
  , OL = to("bum")
  , Sm = to("um")
  , a4 = to("sp")
  , l4 = to("rtg")
  , u4 = to("rtc");
function c4(n, t=pr) {
    Lm("ec", n, t)
}
const NL = "components";
function EW(n, t) {
    return d4(NL, n, !0, t) || n
}
const f4 = Symbol.for("v-ndc");
function d4(n, t, e=!0, r=!1) {
    const i = mr || pr;
    if (i) {
        const a = i.type;
        if (n === NL) {
            const f = e5(a, !1);
            if (f && (f === t || f === Fs(t) || f === bm(Fs(t))))
                return a
        }
        const l = mw(i[n] || a[n], t) || mw(i.appContext[n], t);
        return !l && r ? a : l
    }
}
function mw(n, t) {
    return n && (n[t] || n[Fs(t)] || n[bm(Fs(t))])
}
function fh(n, t, e, r) {
    let i;
    const a = e && e[r]
      , l = Ot(n);
    if (l || Kn(n)) {
        const f = l && Ro(n);
        let h = !1;
        f && (h = !Ts(n),
        n = Em(n)),
        i = new Array(n.length);
        for (let p = 0, m = n.length; p < m; p++)
            i[p] = t(h ? Pr(n[p]) : n[p], p, void 0, a && a[p])
    } else if (typeof n == "number") {
        i = new Array(n);
        for (let f = 0; f < n; f++)
            i[f] = t(f + 1, f, void 0, a && a[f])
    } else if (Nn(n))
        if (n[Symbol.iterator])
            i = Array.from(n, (f, h) => t(f, h, void 0, a && a[h]));
        else {
            const f = Object.keys(n);
            i = new Array(f.length);
            for (let h = 0, p = f.length; h < p; h++) {
                const m = f[h];
                i[h] = t(n[m], m, h, a && a[h])
            }
        }
    else
        i = [];
    return e && (e[r] = i),
    i
}
function h4(n, t, e={}, r, i) {
    if (mr.ce || mr.parent && Dl(mr.parent) && mr.parent.ce)
        return t !== "default" && (e.name = t),
        gt(),
        Ut(Jn, null, [jt("slot", e, r && r())], 64);
    let a = n[t];
    a && a._c && (a._d = !1),
    gt();
    const l = a && TL(a(e))
      , f = e.key || l && l.key
      , h = Ut(Jn, {
        key: (f && !Qs(f) ? f : `_${t}`) + (!l && r ? "_fb" : "")
    }, l || (r ? r() : []), l && n._ === 1 ? 64 : -2);
    return !i && h.scopeId && (h.slotScopeIds = [h.scopeId + "-s"]),
    a && a._c && (a._d = !0),
    h
}
function TL(n) {
    return n.some(t => pc(t) ? !(t.type === Qr || t.type === Jn && !TL(t.children)) : !0) ? n : null
}
const d0 = n => n ? YL(n) ? $m(n) : d0(n.parent) : null
  , Wu = lr(Object.create(null), {
    $: n => n,
    $el: n => n.vnode.el,
    $data: n => n.data,
    $props: n => n.props,
    $attrs: n => n.attrs,
    $slots: n => n.slots,
    $refs: n => n.refs,
    $parent: n => d0(n.parent),
    $root: n => d0(n.root),
    $host: n => n.ce,
    $emit: n => n.emit,
    $options: n => T1(n),
    $forceUpdate: n => n.f || (n.f = () => {
        M1(n.update)
    }
    ),
    $nextTick: n => n.n || (n.n = _m.bind(n.proxy)),
    $watch: n => R4.bind(n)
})
  , av = (n, t) => n !== Mn && !n.__isScriptSetup && wn(n, t)
  , p4 = {
    get({_: n}, t) {
        if (t === "__v_skip")
            return !0;
        const {ctx: e, setupState: r, data: i, props: a, accessCache: l, type: f, appContext: h} = n;
        let p;
        if (t[0] !== "$") {
            const E = l[t];
            if (E !== void 0)
                switch (E) {
                case 1:
                    return r[t];
                case 2:
                    return i[t];
                case 4:
                    return e[t];
                case 3:
                    return a[t]
                }
            else {
                if (av(r, t))
                    return l[t] = 1,
                    r[t];
                if (i !== Mn && wn(i, t))
                    return l[t] = 2,
                    i[t];
                if ((p = n.propsOptions[0]) && wn(p, t))
                    return l[t] = 3,
                    a[t];
                if (e !== Mn && wn(e, t))
                    return l[t] = 4,
                    e[t];
                h0 && (l[t] = 0)
            }
        }
        const m = Wu[t];
        let g, b;
        if (m)
            return t === "$attrs" && Rr(n.attrs, "get", ""),
            m(n);
        if ((g = f.__cssModules) && (g = g[t]))
            return g;
        if (e !== Mn && wn(e, t))
            return l[t] = 4,
            e[t];
        if (b = h.config.globalProperties,
        wn(b, t))
            return b[t]
    },
    set({_: n}, t, e) {
        const {data: r, setupState: i, ctx: a} = n;
        return av(i, t) ? (i[t] = e,
        !0) : r !== Mn && wn(r, t) ? (r[t] = e,
        !0) : wn(n.props, t) || t[0] === "$" && t.slice(1)in n ? !1 : (a[t] = e,
        !0)
    },
    has({_: {data: n, setupState: t, accessCache: e, ctx: r, appContext: i, propsOptions: a}}, l) {
        let f;
        return !!e[l] || n !== Mn && wn(n, l) || av(t, l) || (f = a[0]) && wn(f, l) || wn(r, l) || wn(Wu, l) || wn(i.config.globalProperties, l)
    },
    defineProperty(n, t, e) {
        return e.get != null ? n._.accessCache[t] = 0 : wn(e, "value") && this.set(n, t, e.value, null),
        Reflect.defineProperty(n, t, e)
    }
};
function gw(n) {
    return Ot(n) ? n.reduce( (t, e) => (t[e] = null,
    t), {}) : n
}
let h0 = !0;
function m4(n) {
    const t = T1(n)
      , e = n.proxy
      , r = n.ctx;
    h0 = !1,
    t.beforeCreate && vw(t.beforeCreate, n, "bc");
    const {data: i, computed: a, methods: l, watch: f, provide: h, inject: p, created: m, beforeMount: g, mounted: b, beforeUpdate: E, updated: S, activated: F, deactivated: B, beforeDestroy: Q, beforeUnmount: ae, destroyed: V, unmounted: k, render: z, renderTracked: Z, renderTriggered: re, errorCaptured: C, serverPrefetch: D, expose: R, inheritAttrs: W, components: I, directives: N, filters: P} = t;
    if (p && g4(p, r, null),
    l)
        for (const ie in l) {
            const ce = l[ie];
            Dt(ce) && (r[ie] = ce.bind(e))
        }
    if (i) {
        const ie = i.call(e, e);
        Nn(ie) && (n.data = Cr(ie))
    }
    if (h0 = !0,
    a)
        for (const ie in a) {
            const ce = a[ie]
              , Le = Dt(ce) ? ce.bind(e, e) : Dt(ce.get) ? ce.get.bind(e, e) : Ks
              , he = !Dt(ce) && Dt(ce.set) ? ce.set.bind(e) : Ks
              , Fe = Ve({
                get: Le,
                set: he
            });
            Object.defineProperty(r, ie, {
                enumerable: !0,
                configurable: !0,
                get: () => Fe.value,
                set: Te => Fe.value = Te
            })
        }
    if (f)
        for (const ie in f)
            xL(f[ie], r, e, ie);
    if (h) {
        const ie = Dt(h) ? h.call(e) : h;
        Reflect.ownKeys(ie).forEach(ce => {
            jd(ce, ie[ce])
        }
        )
    }
    m && vw(m, n, "c");
    function X(ie, ce) {
        Ot(ce) ? ce.forEach(Le => ie(Le.bind(e))) : ce && ie(ce.bind(e))
    }
    if (X(s4, g),
    X(If, b),
    X(i4, E),
    X(o4, S),
    X(t4, F),
    X(n4, B),
    X(c4, C),
    X(u4, Z),
    X(l4, re),
    X(OL, ae),
    X(Sm, k),
    X(a4, D),
    Ot(R))
        if (R.length) {
            const ie = n.exposed || (n.exposed = {});
            R.forEach(ce => {
                Object.defineProperty(ie, ce, {
                    get: () => e[ce],
                    set: Le => e[ce] = Le
                })
            }
            )
        } else
            n.exposed || (n.exposed = {});
    z && n.render === Ks && (n.render = z),
    W != null && (n.inheritAttrs = W),
    I && (n.components = I),
    N && (n.directives = N),
    D && N1(n)
}
function g4(n, t, e=Ks) {
    Ot(n) && (n = p0(n));
    for (const r in n) {
        const i = n[r];
        let a;
        Nn(i) ? "default"in i ? a = xs(i.from || r, i.default, !0) : a = xs(i.from || r) : a = xs(i),
        tr(a) ? Object.defineProperty(t, r, {
            enumerable: !0,
            configurable: !0,
            get: () => a.value,
            set: l => a.value = l
        }) : t[r] = a
    }
}
function vw(n, t, e) {
    Xs(Ot(n) ? n.map(r => r.bind(t.proxy)) : n.bind(t.proxy), t, e)
}
function xL(n, t, e, r) {
    let i = r.includes(".") ? HL(e, r) : () => e[r];
    if (Kn(n)) {
        const a = t[n];
        Dt(a) && Jt(i, a)
    } else if (Dt(n))
        Jt(i, n.bind(e));
    else if (Nn(n))
        if (Ot(n))
            n.forEach(a => xL(a, t, e, r));
        else {
            const a = Dt(n.handler) ? n.handler.bind(e) : t[n.handler];
            Dt(a) && Jt(i, a, n)
        }
}
function T1(n) {
    const t = n.type
      , {mixins: e, extends: r} = t
      , {mixins: i, optionsCache: a, config: {optionMergeStrategies: l}} = n.appContext
      , f = a.get(t);
    let h;
    return f ? h = f : !i.length && !e && !r ? h = t : (h = {},
    i.length && i.forEach(p => dh(h, p, l, !0)),
    dh(h, t, l)),
    Nn(t) && a.set(t, h),
    h
}
function dh(n, t, e, r=!1) {
    const {mixins: i, extends: a} = t;
    a && dh(n, a, e, !0),
    i && i.forEach(l => dh(n, l, e, !0));
    for (const l in t)
        if (!(r && l === "expose")) {
            const f = v4[l] || e && e[l];
            n[l] = f ? f(n[l], t[l]) : t[l]
        }
    return n
}
const v4 = {
    data: yw,
    props: bw,
    emits: bw,
    methods: Vu,
    computed: Vu,
    beforeCreate: Hr,
    created: Hr,
    beforeMount: Hr,
    mounted: Hr,
    beforeUpdate: Hr,
    updated: Hr,
    beforeDestroy: Hr,
    beforeUnmount: Hr,
    destroyed: Hr,
    unmounted: Hr,
    activated: Hr,
    deactivated: Hr,
    errorCaptured: Hr,
    serverPrefetch: Hr,
    components: Vu,
    directives: Vu,
    watch: b4,
    provide: yw,
    inject: y4
};
function yw(n, t) {
    return t ? n ? function() {
        return lr(Dt(n) ? n.call(this, this) : n, Dt(t) ? t.call(this, this) : t)
    }
    : t : n
}
function y4(n, t) {
    return Vu(p0(n), p0(t))
}
function p0(n) {
    if (Ot(n)) {
        const t = {};
        for (let e = 0; e < n.length; e++)
            t[n[e]] = n[e];
        return t
    }
    return n
}
function Hr(n, t) {
    return n ? [...new Set([].concat(n, t))] : t
}
function Vu(n, t) {
    return n ? lr(Object.create(null), n, t) : t
}
function bw(n, t) {
    return n ? Ot(n) && Ot(t) ? [...new Set([...n, ...t])] : lr(Object.create(null), gw(n), gw(t ?? {})) : t
}
function b4(n, t) {
    if (!n)
        return t;
    if (!t)
        return n;
    const e = lr(Object.create(null), n);
    for (const r in t)
        e[r] = Hr(n[r], t[r]);
    return e
}
function IL() {
    return {
        app: null,
        config: {
            isNativeTag: sR,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let w4 = 0;
function E4(n, t) {
    return function(r, i=null) {
        Dt(r) || (r = lr({}, r)),
        i != null && !Nn(i) && (i = null);
        const a = IL()
          , l = new WeakSet
          , f = [];
        let h = !1;
        const p = a.app = {
            _uid: w4++,
            _component: r,
            _props: i,
            _container: null,
            _context: a,
            _instance: null,
            version: n5,
            get config() {
                return a.config
            },
            set config(m) {},
            use(m, ...g) {
                return l.has(m) || (m && Dt(m.install) ? (l.add(m),
                m.install(p, ...g)) : Dt(m) && (l.add(m),
                m(p, ...g))),
                p
            },
            mixin(m) {
                return a.mixins.includes(m) || a.mixins.push(m),
                p
            },
            component(m, g) {
                return g ? (a.components[m] = g,
                p) : a.components[m]
            },
            directive(m, g) {
                return g ? (a.directives[m] = g,
                p) : a.directives[m]
            },
            mount(m, g, b) {
                if (!h) {
                    const E = p._ceVNode || jt(r, i);
                    return E.appContext = a,
                    b === !0 ? b = "svg" : b === !1 && (b = void 0),
                    g && t ? t(E, m) : n(E, m, b),
                    h = !0,
                    p._container = m,
                    m.__vue_app__ = p,
                    $m(E.component)
                }
            },
            onUnmount(m) {
                f.push(m)
            },
            unmount() {
                h && (Xs(f, p._instance, 16),
                n(null, p._container),
                delete p._container.__vue_app__)
            },
            provide(m, g) {
                return a.provides[m] = g,
                p
            },
            runWithContext(m) {
                const g = Aa;
                Aa = p;
                try {
                    return m()
                } finally {
                    Aa = g
                }
            }
        };
        return p
    }
}
let Aa = null;
function jd(n, t) {
    if (pr) {
        let e = pr.provides;
        const r = pr.parent && pr.parent.provides;
        r === e && (e = pr.provides = Object.create(r)),
        e[n] = t
    }
}
function xs(n, t, e=!1) {
    const r = pr || mr;
    if (r || Aa) {
        const i = Aa ? Aa._context.provides : r ? r.parent == null ? r.vnode.appContext && r.vnode.appContext.provides : r.parent.provides : void 0;
        if (i && n in i)
            return i[n];
        if (arguments.length > 1)
            return e && Dt(t) ? t.call(r && r.proxy) : t
    }
}
function _4() {
    return !!(pr || mr || Aa)
}
const FL = {}
  , RL = () => Object.create(FL)
  , PL = n => Object.getPrototypeOf(n) === FL;
function L4(n, t, e, r=!1) {
    const i = {}
      , a = RL();
    n.propsDefaults = Object.create(null),
    DL(n, t, i, a);
    for (const l in n.propsOptions[0])
        l in i || (i[l] = void 0);
    e ? n.props = r ? i : cL(i) : n.type.props ? n.props = i : n.props = a,
    n.attrs = a
}
function S4(n, t, e, r) {
    const {props: i, attrs: a, vnode: {patchFlag: l}} = n
      , f = cn(i)
      , [h] = n.propsOptions;
    let p = !1;
    if ((r || l > 0) && !(l & 16)) {
        if (l & 8) {
            const m = n.vnode.dynamicProps;
            for (let g = 0; g < m.length; g++) {
                let b = m[g];
                if (Am(n.emitsOptions, b))
                    continue;
                const E = t[b];
                if (h)
                    if (wn(a, b))
                        E !== a[b] && (a[b] = E,
                        p = !0);
                    else {
                        const S = Fs(b);
                        i[S] = m0(h, f, S, E, n, !1)
                    }
                else
                    E !== a[b] && (a[b] = E,
                    p = !0)
            }
        }
    } else {
        DL(n, t, i, a) && (p = !0);
        let m;
        for (const g in f)
            (!t || !wn(t, g) && ((m = Da(g)) === g || !wn(t, m))) && (h ? e && (e[g] !== void 0 || e[m] !== void 0) && (i[g] = m0(h, f, g, void 0, n, !0)) : delete i[g]);
        if (a !== f)
            for (const g in a)
                (!t || !wn(t, g)) && (delete a[g],
                p = !0)
    }
    p && Ki(n.attrs, "set", "")
}
function DL(n, t, e, r) {
    const [i,a] = n.propsOptions;
    let l = !1, f;
    if (t)
        for (let h in t) {
            if (Uu(h))
                continue;
            const p = t[h];
            let m;
            i && wn(i, m = Fs(h)) ? !a || !a.includes(m) ? e[m] = p : (f || (f = {}))[m] = p : Am(n.emitsOptions, h) || (!(h in r) || p !== r[h]) && (r[h] = p,
            l = !0)
        }
    if (a) {
        const h = cn(e)
          , p = f || Mn;
        for (let m = 0; m < a.length; m++) {
            const g = a[m];
            e[g] = m0(i, h, g, p[g], n, !wn(p, g))
        }
    }
    return l
}
function m0(n, t, e, r, i, a) {
    const l = n[e];
    if (l != null) {
        const f = wn(l, "default");
        if (f && r === void 0) {
            const h = l.default;
            if (l.type !== Function && !l.skipFactory && Dt(h)) {
                const {propsDefaults: p} = i;
                if (e in p)
                    r = p[e];
                else {
                    const m = Ff(i);
                    r = p[e] = h.call(null, t),
                    m()
                }
            } else
                r = h;
            i.ce && i.ce._setProp(e, r)
        }
        l[0] && (a && !f ? r = !1 : l[1] && (r === "" || r === Da(e)) && (r = !0))
    }
    return r
}
const A4 = new WeakMap;
function qL(n, t, e=!1) {
    const r = e ? A4 : t.propsCache
      , i = r.get(n);
    if (i)
        return i;
    const a = n.props
      , l = {}
      , f = [];
    let h = !1;
    if (!Dt(n)) {
        const m = g => {
            h = !0;
            const [b,E] = qL(g, t, !0);
            lr(l, b),
            E && f.push(...E)
        }
        ;
        !e && t.mixins.length && t.mixins.forEach(m),
        n.extends && m(n.extends),
        n.mixins && n.mixins.forEach(m)
    }
    if (!a && !h)
        return Nn(n) && r.set(n, Fl),
        Fl;
    if (Ot(a))
        for (let m = 0; m < a.length; m++) {
            const g = Fs(a[m]);
            ww(g) && (l[g] = Mn)
        }
    else if (a)
        for (const m in a) {
            const g = Fs(m);
            if (ww(g)) {
                const b = a[m]
                  , E = l[g] = Ot(b) || Dt(b) ? {
                    type: b
                } : lr({}, b)
                  , S = E.type;
                let F = !1
                  , B = !0;
                if (Ot(S))
                    for (let Q = 0; Q < S.length; ++Q) {
                        const ae = S[Q]
                          , V = Dt(ae) && ae.name;
                        if (V === "Boolean") {
                            F = !0;
                            break
                        } else
                            V === "String" && (B = !1)
                    }
                else
                    F = Dt(S) && S.name === "Boolean";
                E[0] = F,
                E[1] = B,
                (F || wn(E, "default")) && f.push(g)
            }
        }
    const p = [l, f];
    return Nn(n) && r.set(n, p),
    p
}
function ww(n) {
    return n[0] !== "$" && !Uu(n)
}
const BL = n => n[0] === "_" || n === "$stable"
  , x1 = n => Ot(n) ? n.map(wi) : [wi(n)]
  , C4 = (n, t, e) => {
    if (t._n)
        return t;
    const r = Wr( (...i) => x1(t(...i)), e);
    return r._c = !1,
    r
}
  , kL = (n, t, e) => {
    const r = n._ctx;
    for (const i in n) {
        if (BL(i))
            continue;
        const a = n[i];
        if (Dt(a))
            t[i] = C4(i, a, r);
        else if (a != null) {
            const l = x1(a);
            t[i] = () => l
        }
    }
}
  , zL = (n, t) => {
    const e = x1(t);
    n.slots.default = () => e
}
  , VL = (n, t, e) => {
    for (const r in t)
        (e || r !== "_") && (n[r] = t[r])
}
  , $4 = (n, t, e) => {
    const r = n.slots = RL();
    if (n.vnode.shapeFlag & 32) {
        const i = t._;
        i ? (VL(r, t, e),
        e && U_(r, "_", i, !0)) : kL(t, r)
    } else
        t && zL(n, t)
}
  , M4 = (n, t, e) => {
    const {vnode: r, slots: i} = n;
    let a = !0
      , l = Mn;
    if (r.shapeFlag & 32) {
        const f = t._;
        f ? e && f === 1 ? a = !1 : VL(i, t, e) : (a = !t.$stable,
        kL(t, i)),
        l = t
    } else
        t && (zL(n, t),
        l = {
            default: 1
        });
    if (a)
        for (const f in i)
            !BL(f) && l[f] == null && delete i[f]
}
  , Jr = V4;
function O4(n) {
    return N4(n)
}
function N4(n, t) {
    const e = wm();
    e.__VUE__ = !0;
    const {insert: r, remove: i, patchProp: a, createElement: l, createText: f, createComment: h, setText: p, setElementText: m, parentNode: g, nextSibling: b, setScopeId: E=Ks, insertStaticContent: S} = n
      , F = (T, j, ge, Me=null, Oe=null, Be=null, ze=void 0, Ye=null, He=!!j.dynamicChildren) => {
        if (T === j)
            return;
        T && !ba(T, j) && (Me = L(T),
        Te(T, Oe, Be, !0),
        T = null),
        j.patchFlag === -2 && (He = !1,
        j.dynamicChildren = null);
        const {type: Ue, ref: at, shapeFlag: rt} = j;
        switch (Ue) {
        case Cm:
            B(T, j, ge, Me);
            break;
        case Qr:
            Q(T, j, ge, Me);
            break;
        case Hd:
            T == null && ae(j, ge, Me, ze);
            break;
        case Jn:
            I(T, j, ge, Me, Oe, Be, ze, Ye, He);
            break;
        default:
            rt & 1 ? z(T, j, ge, Me, Oe, Be, ze, Ye, He) : rt & 6 ? N(T, j, ge, Me, Oe, Be, ze, Ye, He) : (rt & 64 || rt & 128) && Ue.process(T, j, ge, Me, Oe, Be, ze, Ye, He, $e)
        }
        at != null && Oe && ch(at, T && T.ref, Be, j || T, !j)
    }
      , B = (T, j, ge, Me) => {
        if (T == null)
            r(j.el = f(j.children), ge, Me);
        else {
            const Oe = j.el = T.el;
            j.children !== T.children && p(Oe, j.children)
        }
    }
      , Q = (T, j, ge, Me) => {
        T == null ? r(j.el = h(j.children || ""), ge, Me) : j.el = T.el
    }
      , ae = (T, j, ge, Me) => {
        [T.el,T.anchor] = S(T.children, j, ge, Me, T.el, T.anchor)
    }
      , V = ({el: T, anchor: j}, ge, Me) => {
        let Oe;
        for (; T && T !== j; )
            Oe = b(T),
            r(T, ge, Me),
            T = Oe;
        r(j, ge, Me)
    }
      , k = ({el: T, anchor: j}) => {
        let ge;
        for (; T && T !== j; )
            ge = b(T),
            i(T),
            T = ge;
        i(j)
    }
      , z = (T, j, ge, Me, Oe, Be, ze, Ye, He) => {
        j.type === "svg" ? ze = "svg" : j.type === "math" && (ze = "mathml"),
        T == null ? Z(j, ge, Me, Oe, Be, ze, Ye, He) : D(T, j, Oe, Be, ze, Ye, He)
    }
      , Z = (T, j, ge, Me, Oe, Be, ze, Ye) => {
        let He, Ue;
        const {props: at, shapeFlag: rt, transition: _e, dirs: xe} = T;
        if (He = T.el = l(T.type, Be, at && at.is, at),
        rt & 8 ? m(He, T.children) : rt & 16 && C(T.children, He, null, Me, Oe, lv(T, Be), ze, Ye),
        xe && fa(T, null, Me, "created"),
        re(He, T, T.scopeId, ze, Me),
        at) {
            for (const st in at)
                st !== "value" && !Uu(st) && a(He, st, null, at[st], Be, Me);
            "value"in at && a(He, "value", null, at.value, Be),
            (Ue = at.onVnodeBeforeMount) && di(Ue, Me, T)
        }
        xe && fa(T, null, Me, "beforeMount");
        const Ze = T4(Oe, _e);
        Ze && _e.beforeEnter(He),
        r(He, j, ge),
        ((Ue = at && at.onVnodeMounted) || Ze || xe) && Jr( () => {
            Ue && di(Ue, Me, T),
            Ze && _e.enter(He),
            xe && fa(T, null, Me, "mounted")
        }
        , Oe)
    }
      , re = (T, j, ge, Me, Oe) => {
        if (ge && E(T, ge),
        Me)
            for (let Be = 0; Be < Me.length; Be++)
                E(T, Me[Be]);
        if (Oe) {
            let Be = Oe.subTree;
            if (j === Be || WL(Be.type) && (Be.ssContent === j || Be.ssFallback === j)) {
                const ze = Oe.vnode;
                re(T, ze, ze.scopeId, ze.slotScopeIds, Oe.parent)
            }
        }
    }
      , C = (T, j, ge, Me, Oe, Be, ze, Ye, He=0) => {
        for (let Ue = He; Ue < T.length; Ue++) {
            const at = T[Ue] = Ye ? Mo(T[Ue]) : wi(T[Ue]);
            F(null, at, j, ge, Me, Oe, Be, ze, Ye)
        }
    }
      , D = (T, j, ge, Me, Oe, Be, ze) => {
        const Ye = j.el = T.el;
        let {patchFlag: He, dynamicChildren: Ue, dirs: at} = j;
        He |= T.patchFlag & 16;
        const rt = T.props || Mn
          , _e = j.props || Mn;
        let xe;
        if (ge && da(ge, !1),
        (xe = _e.onVnodeBeforeUpdate) && di(xe, ge, j, T),
        at && fa(j, T, ge, "beforeUpdate"),
        ge && da(ge, !0),
        (rt.innerHTML && _e.innerHTML == null || rt.textContent && _e.textContent == null) && m(Ye, ""),
        Ue ? R(T.dynamicChildren, Ue, Ye, ge, Me, lv(j, Oe), Be) : ze || ce(T, j, Ye, null, ge, Me, lv(j, Oe), Be, !1),
        He > 0) {
            if (He & 16)
                W(Ye, rt, _e, ge, Oe);
            else if (He & 2 && rt.class !== _e.class && a(Ye, "class", null, _e.class, Oe),
            He & 4 && a(Ye, "style", rt.style, _e.style, Oe),
            He & 8) {
                const Ze = j.dynamicProps;
                for (let st = 0; st < Ze.length; st++) {
                    const je = Ze[st]
                      , ct = rt[je]
                      , Et = _e[je];
                    (Et !== ct || je === "value") && a(Ye, je, ct, Et, Oe, ge)
                }
            }
            He & 1 && T.children !== j.children && m(Ye, j.children)
        } else
            !ze && Ue == null && W(Ye, rt, _e, ge, Oe);
        ((xe = _e.onVnodeUpdated) || at) && Jr( () => {
            xe && di(xe, ge, j, T),
            at && fa(j, T, ge, "updated")
        }
        , Me)
    }
      , R = (T, j, ge, Me, Oe, Be, ze) => {
        for (let Ye = 0; Ye < j.length; Ye++) {
            const He = T[Ye]
              , Ue = j[Ye]
              , at = He.el && (He.type === Jn || !ba(He, Ue) || He.shapeFlag & 70) ? g(He.el) : ge;
            F(He, Ue, at, null, Me, Oe, Be, ze, !0)
        }
    }
      , W = (T, j, ge, Me, Oe) => {
        if (j !== ge) {
            if (j !== Mn)
                for (const Be in j)
                    !Uu(Be) && !(Be in ge) && a(T, Be, j[Be], null, Oe, Me);
            for (const Be in ge) {
                if (Uu(Be))
                    continue;
                const ze = ge[Be]
                  , Ye = j[Be];
                ze !== Ye && Be !== "value" && a(T, Be, Ye, ze, Oe, Me)
            }
            "value"in ge && a(T, "value", j.value, ge.value, Oe)
        }
    }
      , I = (T, j, ge, Me, Oe, Be, ze, Ye, He) => {
        const Ue = j.el = T ? T.el : f("")
          , at = j.anchor = T ? T.anchor : f("");
        let {patchFlag: rt, dynamicChildren: _e, slotScopeIds: xe} = j;
        xe && (Ye = Ye ? Ye.concat(xe) : xe),
        T == null ? (r(Ue, ge, Me),
        r(at, ge, Me),
        C(j.children || [], ge, at, Oe, Be, ze, Ye, He)) : rt > 0 && rt & 64 && _e && T.dynamicChildren ? (R(T.dynamicChildren, _e, ge, Oe, Be, ze, Ye),
        (j.key != null || Oe && j === Oe.subTree) && I1(T, j, !0)) : ce(T, j, ge, at, Oe, Be, ze, Ye, He)
    }
      , N = (T, j, ge, Me, Oe, Be, ze, Ye, He) => {
        j.slotScopeIds = Ye,
        T == null ? j.shapeFlag & 512 ? Oe.ctx.activate(j, ge, Me, ze, He) : P(j, ge, Me, Oe, Be, ze, He) : J(T, j, He)
    }
      , P = (T, j, ge, Me, Oe, Be, ze) => {
        const Ye = T.component = J4(T, Me, Oe);
        if (xf(T) && (Ye.ctx.renderer = $e),
        Z4(Ye, !1, ze),
        Ye.asyncDep) {
            if (Oe && Oe.registerDep(Ye, X, ze),
            !T.el) {
                const He = Ye.subTree = jt(Qr);
                Q(null, He, j, ge)
            }
        } else
            X(Ye, T, j, ge, Oe, Be, ze)
    }
      , J = (T, j, ge) => {
        const Me = j.component = T.component;
        if (k4(T, j, ge))
            if (Me.asyncDep && !Me.asyncResolved) {
                ie(Me, j, ge);
                return
            } else
                Me.next = j,
                Me.update();
        else
            j.el = T.el,
            Me.vnode = j
    }
      , X = (T, j, ge, Me, Oe, Be, ze) => {
        const Ye = () => {
            if (T.isMounted) {
                let {next: rt, bu: _e, u: xe, parent: Ze, vnode: st} = T;
                {
                    const Bt = UL(T);
                    if (Bt) {
                        rt && (rt.el = st.el,
                        ie(T, rt, ze)),
                        Bt.asyncDep.then( () => {
                            T.isUnmounted || Ye()
                        }
                        );
                        return
                    }
                }
                let je = rt, ct;
                da(T, !1),
                rt ? (rt.el = st.el,
                ie(T, rt, ze)) : rt = st,
                _e && Vd(_e),
                (ct = rt.props && rt.props.onVnodeBeforeUpdate) && di(ct, Ze, rt, st),
                da(T, !0);
                const Et = uv(T)
                  , It = T.subTree;
                T.subTree = Et,
                F(It, Et, g(It.el), L(It), T, Oe, Be),
                rt.el = Et.el,
                je === null && z4(T, Et.el),
                xe && Jr(xe, Oe),
                (ct = rt.props && rt.props.onVnodeUpdated) && Jr( () => di(ct, Ze, rt, st), Oe)
            } else {
                let rt;
                const {el: _e, props: xe} = j
                  , {bm: Ze, m: st, parent: je, root: ct, type: Et} = T
                  , It = Dl(j);
                if (da(T, !1),
                Ze && Vd(Ze),
                !It && (rt = xe && xe.onVnodeBeforeMount) && di(rt, je, j),
                da(T, !0),
                _e && me) {
                    const Bt = () => {
                        T.subTree = uv(T),
                        me(_e, T.subTree, T, Oe, null)
                    }
                    ;
                    It && Et.__asyncHydrate ? Et.__asyncHydrate(_e, T, Bt) : Bt()
                } else {
                    ct.ce && ct.ce._injectChildStyle(Et);
                    const Bt = T.subTree = uv(T);
                    F(null, Bt, ge, Me, T, Oe, Be),
                    j.el = Bt.el
                }
                if (st && Jr(st, Oe),
                !It && (rt = xe && xe.onVnodeMounted)) {
                    const Bt = j;
                    Jr( () => di(rt, je, Bt), Oe)
                }
                (j.shapeFlag & 256 || je && Dl(je.vnode) && je.vnode.shapeFlag & 256) && T.a && Jr(T.a, Oe),
                T.isMounted = !0,
                j = ge = Me = null
            }
        }
        ;
        T.scope.on();
        const He = T.effect = new Z_(Ye);
        T.scope.off();
        const Ue = T.update = He.run.bind(He)
          , at = T.job = He.runIfDirty.bind(He);
        at.i = T,
        at.id = T.uid,
        He.scheduler = () => M1(at),
        da(T, !0),
        Ue()
    }
      , ie = (T, j, ge) => {
        j.component = T;
        const Me = T.vnode.props;
        T.vnode = j,
        T.next = null,
        S4(T, j.props, Me, ge),
        M4(T, j.children, ge),
        Ho(),
        uw(T),
        Go()
    }
      , ce = (T, j, ge, Me, Oe, Be, ze, Ye, He=!1) => {
        const Ue = T && T.children
          , at = T ? T.shapeFlag : 0
          , rt = j.children
          , {patchFlag: _e, shapeFlag: xe} = j;
        if (_e > 0) {
            if (_e & 128) {
                he(Ue, rt, ge, Me, Oe, Be, ze, Ye, He);
                return
            } else if (_e & 256) {
                Le(Ue, rt, ge, Me, Oe, Be, ze, Ye, He);
                return
            }
        }
        xe & 8 ? (at & 16 && Se(Ue, Oe, Be),
        rt !== Ue && m(ge, rt)) : at & 16 ? xe & 16 ? he(Ue, rt, ge, Me, Oe, Be, ze, Ye, He) : Se(Ue, Oe, Be, !0) : (at & 8 && m(ge, ""),
        xe & 16 && C(rt, ge, Me, Oe, Be, ze, Ye, He))
    }
      , Le = (T, j, ge, Me, Oe, Be, ze, Ye, He) => {
        T = T || Fl,
        j = j || Fl;
        const Ue = T.length
          , at = j.length
          , rt = Math.min(Ue, at);
        let _e;
        for (_e = 0; _e < rt; _e++) {
            const xe = j[_e] = He ? Mo(j[_e]) : wi(j[_e]);
            F(T[_e], xe, ge, null, Oe, Be, ze, Ye, He)
        }
        Ue > at ? Se(T, Oe, Be, !0, !1, rt) : C(j, ge, Me, Oe, Be, ze, Ye, He, rt)
    }
      , he = (T, j, ge, Me, Oe, Be, ze, Ye, He) => {
        let Ue = 0;
        const at = j.length;
        let rt = T.length - 1
          , _e = at - 1;
        for (; Ue <= rt && Ue <= _e; ) {
            const xe = T[Ue]
              , Ze = j[Ue] = He ? Mo(j[Ue]) : wi(j[Ue]);
            if (ba(xe, Ze))
                F(xe, Ze, ge, null, Oe, Be, ze, Ye, He);
            else
                break;
            Ue++
        }
        for (; Ue <= rt && Ue <= _e; ) {
            const xe = T[rt]
              , Ze = j[_e] = He ? Mo(j[_e]) : wi(j[_e]);
            if (ba(xe, Ze))
                F(xe, Ze, ge, null, Oe, Be, ze, Ye, He);
            else
                break;
            rt--,
            _e--
        }
        if (Ue > rt) {
            if (Ue <= _e) {
                const xe = _e + 1
                  , Ze = xe < at ? j[xe].el : Me;
                for (; Ue <= _e; )
                    F(null, j[Ue] = He ? Mo(j[Ue]) : wi(j[Ue]), ge, Ze, Oe, Be, ze, Ye, He),
                    Ue++
            }
        } else if (Ue > _e)
            for (; Ue <= rt; )
                Te(T[Ue], Oe, Be, !0),
                Ue++;
        else {
            const xe = Ue
              , Ze = Ue
              , st = new Map;
            for (Ue = Ze; Ue <= _e; Ue++) {
                const Nt = j[Ue] = He ? Mo(j[Ue]) : wi(j[Ue]);
                Nt.key != null && st.set(Nt.key, Ue)
            }
            let je, ct = 0;
            const Et = _e - Ze + 1;
            let It = !1
              , Bt = 0;
            const yn = new Array(Et);
            for (Ue = 0; Ue < Et; Ue++)
                yn[Ue] = 0;
            for (Ue = xe; Ue <= rt; Ue++) {
                const Nt = T[Ue];
                if (ct >= Et) {
                    Te(Nt, Oe, Be, !0);
                    continue
                }
                let xt;
                if (Nt.key != null)
                    xt = st.get(Nt.key);
                else
                    for (je = Ze; je <= _e; je++)
                        if (yn[je - Ze] === 0 && ba(Nt, j[je])) {
                            xt = je;
                            break
                        }
                xt === void 0 ? Te(Nt, Oe, Be, !0) : (yn[xt - Ze] = Ue + 1,
                xt >= Bt ? Bt = xt : It = !0,
                F(Nt, j[xt], ge, null, Oe, Be, ze, Ye, He),
                ct++)
            }
            const qt = It ? x4(yn) : Fl;
            for (je = qt.length - 1,
            Ue = Et - 1; Ue >= 0; Ue--) {
                const Nt = Ze + Ue
                  , xt = j[Nt]
                  , Lt = Nt + 1 < at ? j[Nt + 1].el : Me;
                yn[Ue] === 0 ? F(null, xt, ge, Lt, Oe, Be, ze, Ye, He) : It && (je < 0 || Ue !== qt[je] ? Fe(xt, ge, Lt, 2) : je--)
            }
        }
    }
      , Fe = (T, j, ge, Me, Oe=null) => {
        const {el: Be, type: ze, transition: Ye, children: He, shapeFlag: Ue} = T;
        if (Ue & 6) {
            Fe(T.component.subTree, j, ge, Me);
            return
        }
        if (Ue & 128) {
            T.suspense.move(j, ge, Me);
            return
        }
        if (Ue & 64) {
            ze.move(T, j, ge, $e);
            return
        }
        if (ze === Jn) {
            r(Be, j, ge);
            for (let rt = 0; rt < He.length; rt++)
                Fe(He[rt], j, ge, Me);
            r(T.anchor, j, ge);
            return
        }
        if (ze === Hd) {
            V(T, j, ge);
            return
        }
        if (Me !== 2 && Ue & 1 && Ye)
            if (Me === 0)
                Ye.beforeEnter(Be),
                r(Be, j, ge),
                Jr( () => Ye.enter(Be), Oe);
            else {
                const {leave: rt, delayLeave: _e, afterLeave: xe} = Ye
                  , Ze = () => r(Be, j, ge)
                  , st = () => {
                    rt(Be, () => {
                        Ze(),
                        xe && xe()
                    }
                    )
                }
                ;
                _e ? _e(Be, Ze, st) : st()
            }
        else
            r(Be, j, ge)
    }
      , Te = (T, j, ge, Me=!1, Oe=!1) => {
        const {type: Be, props: ze, ref: Ye, children: He, dynamicChildren: Ue, shapeFlag: at, patchFlag: rt, dirs: _e, cacheIndex: xe} = T;
        if (rt === -2 && (Oe = !1),
        Ye != null && ch(Ye, null, ge, T, !0),
        xe != null && (j.renderCache[xe] = void 0),
        at & 256) {
            j.ctx.deactivate(T);
            return
        }
        const Ze = at & 1 && _e
          , st = !Dl(T);
        let je;
        if (st && (je = ze && ze.onVnodeBeforeUnmount) && di(je, j, T),
        at & 6)
            Ge(T.component, ge, Me);
        else {
            if (at & 128) {
                T.suspense.unmount(ge, Me);
                return
            }
            Ze && fa(T, null, j, "beforeUnmount"),
            at & 64 ? T.type.remove(T, j, ge, $e, Me) : Ue && !Ue.hasOnce && (Be !== Jn || rt > 0 && rt & 64) ? Se(Ue, j, ge, !1, !0) : (Be === Jn && rt & 384 || !Oe && at & 16) && Se(He, j, ge),
            Me && ye(T)
        }
        (st && (je = ze && ze.onVnodeUnmounted) || Ze) && Jr( () => {
            je && di(je, j, T),
            Ze && fa(T, null, j, "unmounted")
        }
        , ge)
    }
      , ye = T => {
        const {type: j, el: ge, anchor: Me, transition: Oe} = T;
        if (j === Jn) {
            qe(ge, Me);
            return
        }
        if (j === Hd) {
            k(T);
            return
        }
        const Be = () => {
            i(ge),
            Oe && !Oe.persisted && Oe.afterLeave && Oe.afterLeave()
        }
        ;
        if (T.shapeFlag & 1 && Oe && !Oe.persisted) {
            const {leave: ze, delayLeave: Ye} = Oe
              , He = () => ze(ge, Be);
            Ye ? Ye(T.el, Be, He) : He()
        } else
            Be()
    }
      , qe = (T, j) => {
        let ge;
        for (; T !== j; )
            ge = b(T),
            i(T),
            T = ge;
        i(j)
    }
      , Ge = (T, j, ge) => {
        const {bum: Me, scope: Oe, job: Be, subTree: ze, um: Ye, m: He, a: Ue} = T;
        Ew(He),
        Ew(Ue),
        Me && Vd(Me),
        Oe.stop(),
        Be && (Be.flags |= 8,
        Te(ze, T, j, ge)),
        Ye && Jr(Ye, j),
        Jr( () => {
            T.isUnmounted = !0
        }
        , j),
        j && j.pendingBranch && !j.isUnmounted && T.asyncDep && !T.asyncResolved && T.suspenseId === j.pendingId && (j.deps--,
        j.deps === 0 && j.resolve())
    }
      , Se = (T, j, ge, Me=!1, Oe=!1, Be=0) => {
        for (let ze = Be; ze < T.length; ze++)
            Te(T[ze], j, ge, Me, Oe)
    }
      , L = T => {
        if (T.shapeFlag & 6)
            return L(T.component.subTree);
        if (T.shapeFlag & 128)
            return T.suspense.next();
        const j = b(T.anchor || T.el)
          , ge = j && j[bL];
        return ge ? b(ge) : j
    }
    ;
    let K = !1;
    const de = (T, j, ge) => {
        T == null ? j._vnode && Te(j._vnode, null, null, !0) : F(j._vnode || null, T, j, null, null, null, ge),
        j._vnode = T,
        K || (K = !0,
        uw(),
        gL(),
        K = !1)
    }
      , $e = {
        p: F,
        um: Te,
        m: Fe,
        r: ye,
        mt: P,
        mc: C,
        pc: ce,
        pbc: R,
        n: L,
        o: n
    };
    let Re, me;
    return t && ([Re,me] = t($e)),
    {
        render: de,
        hydrate: Re,
        createApp: E4(de, Re)
    }
}
function lv({type: n, props: t}, e) {
    return e === "svg" && n === "foreignObject" || e === "mathml" && n === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : e
}
function da({effect: n, job: t}, e) {
    e ? (n.flags |= 32,
    t.flags |= 4) : (n.flags &= -33,
    t.flags &= -5)
}
function T4(n, t) {
    return (!n || n && !n.pendingBranch) && t && !t.persisted
}
function I1(n, t, e=!1) {
    const r = n.children
      , i = t.children;
    if (Ot(r) && Ot(i))
        for (let a = 0; a < r.length; a++) {
            const l = r[a];
            let f = i[a];
            f.shapeFlag & 1 && !f.dynamicChildren && ((f.patchFlag <= 0 || f.patchFlag === 32) && (f = i[a] = Mo(i[a]),
            f.el = l.el),
            !e && f.patchFlag !== -2 && I1(l, f)),
            f.type === Cm && (f.el = l.el)
        }
}
function x4(n) {
    const t = n.slice()
      , e = [0];
    let r, i, a, l, f;
    const h = n.length;
    for (r = 0; r < h; r++) {
        const p = n[r];
        if (p !== 0) {
            if (i = e[e.length - 1],
            n[i] < p) {
                t[r] = i,
                e.push(r);
                continue
            }
            for (a = 0,
            l = e.length - 1; a < l; )
                f = a + l >> 1,
                n[e[f]] < p ? a = f + 1 : l = f;
            p < n[e[a]] && (a > 0 && (t[r] = e[a - 1]),
            e[a] = r)
        }
    }
    for (a = e.length,
    l = e[a - 1]; a-- > 0; )
        e[a] = l,
        l = t[l];
    return e
}
function UL(n) {
    const t = n.subTree.component;
    if (t)
        return t.asyncDep && !t.asyncResolved ? t : UL(t)
}
function Ew(n) {
    if (n)
        for (let t = 0; t < n.length; t++)
            n[t].flags |= 8
}
const I4 = Symbol.for("v-scx")
  , F4 = () => xs(I4);
function Jt(n, t, e) {
    return jL(n, t, e)
}
function jL(n, t, e=Mn) {
    const {immediate: r, deep: i, flush: a, once: l} = e
      , f = lr({}, e)
      , h = t && r || !t && a !== "post";
    let p;
    if (kl) {
        if (a === "sync") {
            const E = F4();
            p = E.__watcherHandles || (E.__watcherHandles = [])
        } else if (!h) {
            const E = () => {}
            ;
            return E.stop = Ks,
            E.resume = Ks,
            E.pause = Ks,
            E
        }
    }
    const m = pr;
    f.call = (E, S, F) => Xs(E, m, S, F);
    let g = !1;
    a === "post" ? f.scheduler = E => {
        Jr(E, m && m.suspense)
    }
    : a !== "sync" && (g = !0,
    f.scheduler = (E, S) => {
        S ? E() : M1(E)
    }
    ),
    f.augmentJob = E => {
        t && (E.flags |= 4),
        g && (E.flags |= 2,
        m && (E.id = m.uid,
        E.i = m))
    }
    ;
    const b = GR(n, t, f);
    return kl && (p ? p.push(b) : h && b()),
    b
}
function R4(n, t, e) {
    const r = this.proxy
      , i = Kn(n) ? n.includes(".") ? HL(r, n) : () => r[n] : n.bind(r, r);
    let a;
    Dt(t) ? a = t : (a = t.handler,
    e = t);
    const l = Ff(this)
      , f = jL(i, a.bind(r), e);
    return l(),
    f
}
function HL(n, t) {
    const e = t.split(".");
    return () => {
        let r = n;
        for (let i = 0; i < e.length && r; i++)
            r = r[e[i]];
        return r
    }
}
const P4 = (n, t) => t === "modelValue" || t === "model-value" ? n.modelModifiers : n[`${t}Modifiers`] || n[`${Fs(t)}Modifiers`] || n[`${Da(t)}Modifiers`];
function D4(n, t, ...e) {
    if (n.isUnmounted)
        return;
    const r = n.vnode.props || Mn;
    let i = e;
    const a = t.startsWith("update:")
      , l = a && P4(r, t.slice(7));
    l && (l.trim && (i = e.map(m => Kn(m) ? m.trim() : m)),
    l.number && (i = e.map(ih)));
    let f, h = r[f = ev(t)] || r[f = ev(Fs(t))];
    !h && a && (h = r[f = ev(Da(t))]),
    h && Xs(h, n, 6, i);
    const p = r[f + "Once"];
    if (p) {
        if (!n.emitted)
            n.emitted = {};
        else if (n.emitted[f])
            return;
        n.emitted[f] = !0,
        Xs(p, n, 6, i)
    }
}
function GL(n, t, e=!1) {
    const r = t.emitsCache
      , i = r.get(n);
    if (i !== void 0)
        return i;
    const a = n.emits;
    let l = {}
      , f = !1;
    if (!Dt(n)) {
        const h = p => {
            const m = GL(p, t, !0);
            m && (f = !0,
            lr(l, m))
        }
        ;
        !e && t.mixins.length && t.mixins.forEach(h),
        n.extends && h(n.extends),
        n.mixins && n.mixins.forEach(h)
    }
    return !a && !f ? (Nn(n) && r.set(n, null),
    null) : (Ot(a) ? a.forEach(h => l[h] = null) : lr(l, a),
    Nn(n) && r.set(n, l),
    l)
}
function Am(n, t) {
    return !n || !vm(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    wn(n, t[0].toLowerCase() + t.slice(1)) || wn(n, Da(t)) || wn(n, t))
}
function uv(n) {
    const {type: t, vnode: e, proxy: r, withProxy: i, propsOptions: [a], slots: l, attrs: f, emit: h, render: p, renderCache: m, props: g, data: b, setupState: E, ctx: S, inheritAttrs: F} = n
      , B = uh(n);
    let Q, ae;
    try {
        if (e.shapeFlag & 4) {
            const k = i || r
              , z = k;
            Q = wi(p.call(z, k, m, g, E, b, S)),
            ae = f
        } else {
            const k = t;
            Q = wi(k.length > 1 ? k(g, {
                attrs: f,
                slots: l,
                emit: h
            }) : k(g, null)),
            ae = t.props ? f : q4(f)
        }
    } catch (k) {
        Ju.length = 0,
        Tf(k, n, 1),
        Q = jt(Qr)
    }
    let V = Q;
    if (ae && F !== !1) {
        const k = Object.keys(ae)
          , {shapeFlag: z} = V;
        k.length && z & 7 && (a && k.some(g1) && (ae = B4(ae, a)),
        V = ko(V, ae, !1, !0))
    }
    return e.dirs && (V = ko(V, null, !1, !0),
    V.dirs = V.dirs ? V.dirs.concat(e.dirs) : e.dirs),
    e.transition && dc(V, e.transition),
    Q = V,
    uh(B),
    Q
}
const q4 = n => {
    let t;
    for (const e in n)
        (e === "class" || e === "style" || vm(e)) && ((t || (t = {}))[e] = n[e]);
    return t
}
  , B4 = (n, t) => {
    const e = {};
    for (const r in n)
        (!g1(r) || !(r.slice(9)in t)) && (e[r] = n[r]);
    return e
}
;
function k4(n, t, e) {
    const {props: r, children: i, component: a} = n
      , {props: l, children: f, patchFlag: h} = t
      , p = a.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (e && h >= 0) {
        if (h & 1024)
            return !0;
        if (h & 16)
            return r ? _w(r, l, p) : !!l;
        if (h & 8) {
            const m = t.dynamicProps;
            for (let g = 0; g < m.length; g++) {
                const b = m[g];
                if (l[b] !== r[b] && !Am(p, b))
                    return !0
            }
        }
    } else
        return (i || f) && (!f || !f.$stable) ? !0 : r === l ? !1 : r ? l ? _w(r, l, p) : !0 : !!l;
    return !1
}
function _w(n, t, e) {
    const r = Object.keys(t);
    if (r.length !== Object.keys(n).length)
        return !0;
    for (let i = 0; i < r.length; i++) {
        const a = r[i];
        if (t[a] !== n[a] && !Am(e, a))
            return !0
    }
    return !1
}
function z4({vnode: n, parent: t}, e) {
    for (; t; ) {
        const r = t.subTree;
        if (r.suspense && r.suspense.activeBranch === n && (r.el = n.el),
        r === n)
            (n = t.vnode).el = e,
            t = t.parent;
        else
            break
    }
}
const WL = n => n.__isSuspense;
function V4(n, t) {
    t && t.pendingBranch ? Ot(n) ? t.effects.push(...n) : t.effects.push(n) : KR(n)
}
const Jn = Symbol.for("v-fgt")
  , Cm = Symbol.for("v-txt")
  , Qr = Symbol.for("v-cmt")
  , Hd = Symbol.for("v-stc")
  , Ju = [];
let ps = null;
function gt(n=!1) {
    Ju.push(ps = n ? null : [])
}
function U4() {
    Ju.pop(),
    ps = Ju[Ju.length - 1] || null
}
let hc = 1;
function Lw(n, t=!1) {
    hc += n,
    n < 0 && ps && t && (ps.hasOnce = !0)
}
function JL(n) {
    return n.dynamicChildren = hc > 0 ? ps || Fl : null,
    U4(),
    hc > 0 && ps && ps.push(n),
    n
}
function Fn(n, t, e, r, i, a) {
    return JL(se(n, t, e, r, i, a, !0))
}
function Ut(n, t, e, r, i) {
    return JL(jt(n, t, e, r, i, !0))
}
function pc(n) {
    return n ? n.__v_isVNode === !0 : !1
}
function ba(n, t) {
    return n.type === t.type && n.key === t.key
}
const KL = ({key: n}) => n ?? null
  , Gd = ({ref: n, ref_key: t, ref_for: e}) => (typeof n == "number" && (n = "" + n),
n != null ? Kn(n) || tr(n) || Dt(n) ? {
    i: mr,
    r: n,
    k: t,
    f: !!e
} : n : null);
function se(n, t=null, e=null, r=0, i=null, a=n === Jn ? 0 : 1, l=!1, f=!1) {
    const h = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n,
        props: t,
        key: t && KL(t),
        ref: t && Gd(t),
        scopeId: yL,
        slotScopeIds: null,
        children: e,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetStart: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: a,
        patchFlag: r,
        dynamicProps: i,
        dynamicChildren: null,
        appContext: null,
        ctx: mr
    };
    return f ? (F1(h, e),
    a & 128 && n.normalize(h)) : e && (h.shapeFlag |= Kn(e) ? 8 : 16),
    hc > 0 && !l && ps && (h.patchFlag > 0 || a & 6) && h.patchFlag !== 32 && ps.push(h),
    h
}
const jt = j4;
function j4(n, t=null, e=null, r=0, i=null, a=!1) {
    if ((!n || n === f4) && (n = Qr),
    pc(n)) {
        const f = ko(n, t, !0);
        return e && F1(f, e),
        hc > 0 && !a && ps && (f.shapeFlag & 6 ? ps[ps.indexOf(n)] = f : ps.push(f)),
        f.patchFlag = -2,
        f
    }
    if (t5(n) && (n = n.__vccOpts),
    t) {
        t = H4(t);
        let {class: f, style: h} = t;
        f && !Kn(f) && (t.class = Of(f)),
        Nn(h) && (C1(h) && !Ot(h) && (h = lr({}, h)),
        t.style = Na(h))
    }
    const l = Kn(n) ? 1 : WL(n) ? 128 : wL(n) ? 64 : Nn(n) ? 4 : Dt(n) ? 2 : 0;
    return se(n, t, e, r, i, l, a, !0)
}
function H4(n) {
    return n ? C1(n) || PL(n) ? lr({}, n) : n : null
}
function ko(n, t, e=!1, r=!1) {
    const {props: i, ref: a, patchFlag: l, children: f, transition: h} = n
      , p = t ? ZL(i || {}, t) : i
      , m = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: n.type,
        props: p,
        key: p && KL(p),
        ref: t && t.ref ? e && a ? Ot(a) ? a.concat(Gd(t)) : [a, Gd(t)] : Gd(t) : a,
        scopeId: n.scopeId,
        slotScopeIds: n.slotScopeIds,
        children: f,
        target: n.target,
        targetStart: n.targetStart,
        targetAnchor: n.targetAnchor,
        staticCount: n.staticCount,
        shapeFlag: n.shapeFlag,
        patchFlag: t && n.type !== Jn ? l === -1 ? 16 : l | 16 : l,
        dynamicProps: n.dynamicProps,
        dynamicChildren: n.dynamicChildren,
        appContext: n.appContext,
        dirs: n.dirs,
        transition: h,
        component: n.component,
        suspense: n.suspense,
        ssContent: n.ssContent && ko(n.ssContent),
        ssFallback: n.ssFallback && ko(n.ssFallback),
        el: n.el,
        anchor: n.anchor,
        ctx: n.ctx,
        ce: n.ce
    };
    return h && r && dc(m, h.clone(m)),
    m
}
function dr(n=" ", t=0) {
    return jt(Cm, null, n, t)
}
function _W(n, t) {
    const e = jt(Hd, null, n);
    return e.staticCount = t,
    e
}
function Kt(n="", t=!1) {
    return t ? (gt(),
    Ut(Qr, null, n)) : jt(Qr, null, n)
}
function wi(n) {
    return n == null || typeof n == "boolean" ? jt(Qr) : Ot(n) ? jt(Jn, null, n.slice()) : pc(n) ? Mo(n) : jt(Cm, null, String(n))
}
function Mo(n) {
    return n.el === null && n.patchFlag !== -1 || n.memo ? n : ko(n)
}
function F1(n, t) {
    let e = 0;
    const {shapeFlag: r} = n;
    if (t == null)
        t = null;
    else if (Ot(t))
        e = 16;
    else if (typeof t == "object")
        if (r & 65) {
            const i = t.default;
            i && (i._c && (i._d = !1),
            F1(n, i()),
            i._c && (i._d = !0));
            return
        } else {
            e = 32;
            const i = t._;
            !i && !PL(t) ? t._ctx = mr : i === 3 && mr && (mr.slots._ === 1 ? t._ = 1 : (t._ = 2,
            n.patchFlag |= 1024))
        }
    else
        Dt(t) ? (t = {
            default: t,
            _ctx: mr
        },
        e = 32) : (t = String(t),
        r & 64 ? (e = 16,
        t = [dr(t)]) : e = 8);
    n.children = t,
    n.shapeFlag |= e
}
function ZL(...n) {
    const t = {};
    for (let e = 0; e < n.length; e++) {
        const r = n[e];
        for (const i in r)
            if (i === "class")
                t.class !== r.class && (t.class = Of([t.class, r.class]));
            else if (i === "style")
                t.style = Na([t.style, r.style]);
            else if (vm(i)) {
                const a = t[i]
                  , l = r[i];
                l && a !== l && !(Ot(a) && a.includes(l)) && (t[i] = a ? [].concat(a, l) : l)
            } else
                i !== "" && (t[i] = r[i])
    }
    return t
}
function di(n, t, e, r=null) {
    Xs(n, t, 7, [e, r])
}
const G4 = IL();
let W4 = 0;
function J4(n, t, e) {
    const r = n.type
      , i = (t ? t.appContext : n.appContext) || G4
      , a = {
        uid: W4++,
        vnode: n,
        type: r,
        parent: t,
        appContext: i,
        root: null,
        next: null,
        subTree: null,
        effect: null,
        update: null,
        job: null,
        scope: new W_(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(i.provides),
        ids: t ? t.ids : ["", 0, 0],
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: qL(r, i),
        emitsOptions: GL(r, i),
        emit: null,
        emitted: null,
        propsDefaults: Mn,
        inheritAttrs: r.inheritAttrs,
        ctx: Mn,
        data: Mn,
        props: Mn,
        attrs: Mn,
        slots: Mn,
        refs: Mn,
        setupState: Mn,
        setupContext: null,
        suspense: e,
        suspenseId: e ? e.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return a.ctx = {
        _: a
    },
    a.root = t ? t.root : a,
    a.emit = D4.bind(null, a),
    n.ce && n.ce(a),
    a
}
let pr = null;
const K4 = () => pr || mr;
let hh, g0;
{
    const n = wm()
      , t = (e, r) => {
        let i;
        return (i = n[e]) || (i = n[e] = []),
        i.push(r),
        a => {
            i.length > 1 ? i.forEach(l => l(a)) : i[0](a)
        }
    }
    ;
    hh = t("__VUE_INSTANCE_SETTERS__", e => pr = e),
    g0 = t("__VUE_SSR_SETTERS__", e => kl = e)
}
const Ff = n => {
    const t = pr;
    return hh(n),
    n.scope.on(),
    () => {
        n.scope.off(),
        hh(t)
    }
}
  , Sw = () => {
    pr && pr.scope.off(),
    hh(null)
}
;
function YL(n) {
    return n.vnode.shapeFlag & 4
}
let kl = !1;
function Z4(n, t=!1, e=!1) {
    t && g0(t);
    const {props: r, children: i} = n.vnode
      , a = YL(n);
    L4(n, r, a, t),
    $4(n, i, e);
    const l = a ? Y4(n, t) : void 0;
    return t && g0(!1),
    l
}
function Y4(n, t) {
    const e = n.type;
    n.accessCache = Object.create(null),
    n.proxy = new Proxy(n.ctx,p4);
    const {setup: r} = e;
    if (r) {
        Ho();
        const i = n.setupContext = r.length > 1 ? X4(n) : null
          , a = Ff(n)
          , l = Nf(r, n, 0, [n.props, i])
          , f = k_(l);
        if (Go(),
        a(),
        (f || n.sp) && !Dl(n) && N1(n),
        f) {
            if (l.then(Sw, Sw),
            t)
                return l.then(h => {
                    Aw(n, h, t)
                }
                ).catch(h => {
                    Tf(h, n, 0)
                }
                );
            n.asyncDep = l
        } else
            Aw(n, l, t)
    } else
        QL(n, t)
}
function Aw(n, t, e) {
    Dt(t) ? n.type.__ssrInlineRender ? n.ssrRender = t : n.render = t : Nn(t) && (n.setupState = hL(t)),
    QL(n, e)
}
let Cw;
function QL(n, t, e) {
    const r = n.type;
    if (!n.render) {
        if (!t && Cw && !r.render) {
            const i = r.template || T1(n).template;
            if (i) {
                const {isCustomElement: a, compilerOptions: l} = n.appContext.config
                  , {delimiters: f, compilerOptions: h} = r
                  , p = lr(lr({
                    isCustomElement: a,
                    delimiters: f
                }, l), h);
                r.render = Cw(i, p)
            }
        }
        n.render = r.render || Ks
    }
    {
        const i = Ff(n);
        Ho();
        try {
            m4(n)
        } finally {
            Go(),
            i()
        }
    }
}
const Q4 = {
    get(n, t) {
        return Rr(n, "get", ""),
        n[t]
    }
};
function X4(n) {
    const t = e => {
        n.exposed = e || {}
    }
    ;
    return {
        attrs: new Proxy(n.attrs,Q4),
        slots: n.slots,
        emit: n.emit,
        expose: t
    }
}
function $m(n) {
    return n.exposed ? n.exposeProxy || (n.exposeProxy = new Proxy(hL($1(n.exposed)),{
        get(t, e) {
            if (e in t)
                return t[e];
            if (e in Wu)
                return Wu[e](n)
        },
        has(t, e) {
            return e in t || e in Wu
        }
    })) : n.proxy
}
function e5(n, t=!0) {
    return Dt(n) ? n.displayName || n.name : n.name || t && n.__name
}
function t5(n) {
    return Dt(n) && "__vccOpts"in n
}
const Ve = (n, t) => jR(n, t, kl);
function R1(n, t, e) {
    const r = arguments.length;
    return r === 2 ? Nn(t) && !Ot(t) ? pc(t) ? jt(n, null, [t]) : jt(n, t) : jt(n, null, t) : (r > 3 ? e = Array.prototype.slice.call(arguments, 2) : r === 3 && pc(e) && (e = [e]),
    jt(n, t, e))
}
const n5 = "3.5.13";
/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/
let v0;
const $w = typeof window < "u" && window.trustedTypes;
if ($w)
    try {
        v0 = $w.createPolicy("vue", {
            createHTML: n => n
        })
    } catch {}
const XL = v0 ? n => v0.createHTML(n) : n => n
  , r5 = "http://www.w3.org/2000/svg"
  , s5 = "http://www.w3.org/1998/Math/MathML"
  , Wi = typeof document < "u" ? document : null
  , Mw = Wi && Wi.createElement("template")
  , i5 = {
    insert: (n, t, e) => {
        t.insertBefore(n, e || null)
    }
    ,
    remove: n => {
        const t = n.parentNode;
        t && t.removeChild(n)
    }
    ,
    createElement: (n, t, e, r) => {
        const i = t === "svg" ? Wi.createElementNS(r5, n) : t === "mathml" ? Wi.createElementNS(s5, n) : e ? Wi.createElement(n, {
            is: e
        }) : Wi.createElement(n);
        return n === "select" && r && r.multiple != null && i.setAttribute("multiple", r.multiple),
        i
    }
    ,
    createText: n => Wi.createTextNode(n),
    createComment: n => Wi.createComment(n),
    setText: (n, t) => {
        n.nodeValue = t
    }
    ,
    setElementText: (n, t) => {
        n.textContent = t
    }
    ,
    parentNode: n => n.parentNode,
    nextSibling: n => n.nextSibling,
    querySelector: n => Wi.querySelector(n),
    setScopeId(n, t) {
        n.setAttribute(t, "")
    },
    insertStaticContent(n, t, e, r, i, a) {
        const l = e ? e.previousSibling : t.lastChild;
        if (i && (i === a || i.nextSibling))
            for (; t.insertBefore(i.cloneNode(!0), e),
            !(i === a || !(i = i.nextSibling)); )
                ;
        else {
            Mw.innerHTML = XL(r === "svg" ? `<svg>${n}</svg>` : r === "mathml" ? `<math>${n}</math>` : n);
            const f = Mw.content;
            if (r === "svg" || r === "mathml") {
                const h = f.firstChild;
                for (; h.firstChild; )
                    f.appendChild(h.firstChild);
                f.removeChild(h)
            }
            t.insertBefore(f, e)
        }
        return [l ? l.nextSibling : t.firstChild, e ? e.previousSibling : t.lastChild]
    }
}
  , bo = "transition"
  , Fu = "animation"
  , mc = Symbol("_vtc")
  , e2 = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
}
  , o5 = lr({}, LL, e2)
  , a5 = n => (n.displayName = "Transition",
n.props = o5,
n)
  , LW = a5( (n, {slots: t}) => R1(XR, l5(n), t))
  , ha = (n, t=[]) => {
    Ot(n) ? n.forEach(e => e(...t)) : n && n(...t)
}
  , Ow = n => n ? Ot(n) ? n.some(t => t.length > 1) : n.length > 1 : !1;
function l5(n) {
    const t = {};
    for (const I in n)
        I in e2 || (t[I] = n[I]);
    if (n.css === !1)
        return t;
    const {name: e="v", type: r, duration: i, enterFromClass: a=`${e}-enter-from`, enterActiveClass: l=`${e}-enter-active`, enterToClass: f=`${e}-enter-to`, appearFromClass: h=a, appearActiveClass: p=l, appearToClass: m=f, leaveFromClass: g=`${e}-leave-from`, leaveActiveClass: b=`${e}-leave-active`, leaveToClass: E=`${e}-leave-to`} = n
      , S = u5(i)
      , F = S && S[0]
      , B = S && S[1]
      , {onBeforeEnter: Q, onEnter: ae, onEnterCancelled: V, onLeave: k, onLeaveCancelled: z, onBeforeAppear: Z=Q, onAppear: re=ae, onAppearCancelled: C=V} = t
      , D = (I, N, P, J) => {
        I._enterCancelled = J,
        pa(I, N ? m : f),
        pa(I, N ? p : l),
        P && P()
    }
      , R = (I, N) => {
        I._isLeaving = !1,
        pa(I, g),
        pa(I, E),
        pa(I, b),
        N && N()
    }
      , W = I => (N, P) => {
        const J = I ? re : ae
          , X = () => D(N, I, P);
        ha(J, [N, X]),
        Nw( () => {
            pa(N, I ? h : a),
            Ui(N, I ? m : f),
            Ow(J) || Tw(N, r, F, X)
        }
        )
    }
    ;
    return lr(t, {
        onBeforeEnter(I) {
            ha(Q, [I]),
            Ui(I, a),
            Ui(I, l)
        },
        onBeforeAppear(I) {
            ha(Z, [I]),
            Ui(I, h),
            Ui(I, p)
        },
        onEnter: W(!1),
        onAppear: W(!0),
        onLeave(I, N) {
            I._isLeaving = !0;
            const P = () => R(I, N);
            Ui(I, g),
            I._enterCancelled ? (Ui(I, b),
            Fw()) : (Fw(),
            Ui(I, b)),
            Nw( () => {
                I._isLeaving && (pa(I, g),
                Ui(I, E),
                Ow(k) || Tw(I, r, B, P))
            }
            ),
            ha(k, [I, P])
        },
        onEnterCancelled(I) {
            D(I, !1, void 0, !0),
            ha(V, [I])
        },
        onAppearCancelled(I) {
            D(I, !0, void 0, !0),
            ha(C, [I])
        },
        onLeaveCancelled(I) {
            R(I),
            ha(z, [I])
        }
    })
}
function u5(n) {
    if (n == null)
        return null;
    if (Nn(n))
        return [cv(n.enter), cv(n.leave)];
    {
        const t = cv(n);
        return [t, t]
    }
}
function cv(n) {
    return uR(n)
}
function Ui(n, t) {
    t.split(/\s+/).forEach(e => e && n.classList.add(e)),
    (n[mc] || (n[mc] = new Set)).add(t)
}
function pa(n, t) {
    t.split(/\s+/).forEach(r => r && n.classList.remove(r));
    const e = n[mc];
    e && (e.delete(t),
    e.size || (n[mc] = void 0))
}
function Nw(n) {
    requestAnimationFrame( () => {
        requestAnimationFrame(n)
    }
    )
}
let c5 = 0;
function Tw(n, t, e, r) {
    const i = n._endId = ++c5
      , a = () => {
        i === n._endId && r()
    }
    ;
    if (e != null)
        return setTimeout(a, e);
    const {type: l, timeout: f, propCount: h} = f5(n, t);
    if (!l)
        return r();
    const p = l + "end";
    let m = 0;
    const g = () => {
        n.removeEventListener(p, b),
        a()
    }
      , b = E => {
        E.target === n && ++m >= h && g()
    }
    ;
    setTimeout( () => {
        m < h && g()
    }
    , f + 1),
    n.addEventListener(p, b)
}
function f5(n, t) {
    const e = window.getComputedStyle(n)
      , r = S => (e[S] || "").split(", ")
      , i = r(`${bo}Delay`)
      , a = r(`${bo}Duration`)
      , l = xw(i, a)
      , f = r(`${Fu}Delay`)
      , h = r(`${Fu}Duration`)
      , p = xw(f, h);
    let m = null
      , g = 0
      , b = 0;
    t === bo ? l > 0 && (m = bo,
    g = l,
    b = a.length) : t === Fu ? p > 0 && (m = Fu,
    g = p,
    b = h.length) : (g = Math.max(l, p),
    m = g > 0 ? l > p ? bo : Fu : null,
    b = m ? m === bo ? a.length : h.length : 0);
    const E = m === bo && /\b(transform|all)(,|$)/.test(r(`${bo}Property`).toString());
    return {
        type: m,
        timeout: g,
        propCount: b,
        hasTransform: E
    }
}
function xw(n, t) {
    for (; n.length < t.length; )
        n = n.concat(n);
    return Math.max(...t.map( (e, r) => Iw(e) + Iw(n[r])))
}
function Iw(n) {
    return n === "auto" ? 0 : Number(n.slice(0, -1).replace(",", ".")) * 1e3
}
function Fw() {
    return document.body.offsetHeight
}
function d5(n, t, e) {
    const r = n[mc];
    r && (t = (t ? [t, ...r] : [...r]).join(" ")),
    t == null ? n.removeAttribute("class") : e ? n.setAttribute("class", t) : n.className = t
}
const ph = Symbol("_vod")
  , t2 = Symbol("_vsh")
  , SW = {
    beforeMount(n, {value: t}, {transition: e}) {
        n[ph] = n.style.display === "none" ? "" : n.style.display,
        e && t ? e.beforeEnter(n) : Ru(n, t)
    },
    mounted(n, {value: t}, {transition: e}) {
        e && t && e.enter(n)
    },
    updated(n, {value: t, oldValue: e}, {transition: r}) {
        !t != !e && (r ? t ? (r.beforeEnter(n),
        Ru(n, !0),
        r.enter(n)) : r.leave(n, () => {
            Ru(n, !1)
        }
        ) : Ru(n, t))
    },
    beforeUnmount(n, {value: t}) {
        Ru(n, t)
    }
};
function Ru(n, t) {
    n.style.display = t ? n[ph] : "none",
    n[t2] = !t
}
const h5 = Symbol("")
  , p5 = /(^|;)\s*display\s*:/;
function m5(n, t, e) {
    const r = n.style
      , i = Kn(e);
    let a = !1;
    if (e && !i) {
        if (t)
            if (Kn(t))
                for (const l of t.split(";")) {
                    const f = l.slice(0, l.indexOf(":")).trim();
                    e[f] == null && Wd(r, f, "")
                }
            else
                for (const l in t)
                    e[l] == null && Wd(r, l, "");
        for (const l in e)
            l === "display" && (a = !0),
            Wd(r, l, e[l])
    } else if (i) {
        if (t !== e) {
            const l = r[h5];
            l && (e += ";" + l),
            r.cssText = e,
            a = p5.test(e)
        }
    } else
        t && n.removeAttribute("style");
    ph in n && (n[ph] = a ? r.display : "",
    n[t2] && (r.display = "none"))
}
const Rw = /\s*!important$/;
function Wd(n, t, e) {
    if (Ot(e))
        e.forEach(r => Wd(n, t, r));
    else if (e == null && (e = ""),
    t.startsWith("--"))
        n.setProperty(t, e);
    else {
        const r = g5(n, t);
        Rw.test(e) ? n.setProperty(Da(r), e.replace(Rw, ""), "important") : n[r] = e
    }
}
const Pw = ["Webkit", "Moz", "ms"]
  , fv = {};
function g5(n, t) {
    const e = fv[t];
    if (e)
        return e;
    let r = Fs(t);
    if (r !== "filter" && r in n)
        return fv[t] = r;
    r = bm(r);
    for (let i = 0; i < Pw.length; i++) {
        const a = Pw[i] + r;
        if (a in n)
            return fv[t] = a
    }
    return t
}
const Dw = "http://www.w3.org/1999/xlink";
function qw(n, t, e, r, i, a=mR(t)) {
    r && t.startsWith("xlink:") ? e == null ? n.removeAttributeNS(Dw, t.slice(6, t.length)) : n.setAttributeNS(Dw, t, e) : e == null || a && !j_(e) ? n.removeAttribute(t) : n.setAttribute(t, a ? "" : Qs(e) ? String(e) : e)
}
function Bw(n, t, e, r, i) {
    if (t === "innerHTML" || t === "textContent") {
        e != null && (n[t] = t === "innerHTML" ? XL(e) : e);
        return
    }
    const a = n.tagName;
    if (t === "value" && a !== "PROGRESS" && !a.includes("-")) {
        const f = a === "OPTION" ? n.getAttribute("value") || "" : n.value
          , h = e == null ? n.type === "checkbox" ? "on" : "" : String(e);
        (f !== h || !("_value"in n)) && (n.value = h),
        e == null && n.removeAttribute(t),
        n._value = e;
        return
    }
    let l = !1;
    if (e === "" || e == null) {
        const f = typeof n[t];
        f === "boolean" ? e = j_(e) : e == null && f === "string" ? (e = "",
        l = !0) : f === "number" && (e = 0,
        l = !0)
    }
    try {
        n[t] = e
    } catch {}
    l && n.removeAttribute(i || t)
}
function Yi(n, t, e, r) {
    n.addEventListener(t, e, r)
}
function v5(n, t, e, r) {
    n.removeEventListener(t, e, r)
}
const kw = Symbol("_vei");
function y5(n, t, e, r, i=null) {
    const a = n[kw] || (n[kw] = {})
      , l = a[t];
    if (r && l)
        l.value = r;
    else {
        const [f,h] = b5(t);
        if (r) {
            const p = a[t] = _5(r, i);
            Yi(n, f, p, h)
        } else
            l && (v5(n, f, l, h),
            a[t] = void 0)
    }
}
const zw = /(?:Once|Passive|Capture)$/;
function b5(n) {
    let t;
    if (zw.test(n)) {
        t = {};
        let r;
        for (; r = n.match(zw); )
            n = n.slice(0, n.length - r[0].length),
            t[r[0].toLowerCase()] = !0
    }
    return [n[2] === ":" ? n.slice(3) : Da(n.slice(2)), t]
}
let dv = 0;
const w5 = Promise.resolve()
  , E5 = () => dv || (w5.then( () => dv = 0),
dv = Date.now());
function _5(n, t) {
    const e = r => {
        if (!r._vts)
            r._vts = Date.now();
        else if (r._vts <= e.attached)
            return;
        Xs(L5(r, e.value), t, 5, [r])
    }
    ;
    return e.value = n,
    e.attached = E5(),
    e
}
function L5(n, t) {
    if (Ot(t)) {
        const e = n.stopImmediatePropagation;
        return n.stopImmediatePropagation = () => {
            e.call(n),
            n._stopped = !0
        }
        ,
        t.map(r => i => !i._stopped && r && r(i))
    } else
        return t
}
const Vw = n => n.charCodeAt(0) === 111 && n.charCodeAt(1) === 110 && n.charCodeAt(2) > 96 && n.charCodeAt(2) < 123
  , S5 = (n, t, e, r, i, a) => {
    const l = i === "svg";
    t === "class" ? d5(n, r, l) : t === "style" ? m5(n, e, r) : vm(t) ? g1(t) || y5(n, t, e, r, a) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : A5(n, t, r, l)) ? (Bw(n, t, r),
    !n.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && qw(n, t, r, l, a, t !== "value")) : n._isVueCE && (/[A-Z]/.test(t) || !Kn(r)) ? Bw(n, Fs(t), r, a, t) : (t === "true-value" ? n._trueValue = r : t === "false-value" && (n._falseValue = r),
    qw(n, t, r, l))
}
;
function A5(n, t, e, r) {
    if (r)
        return !!(t === "innerHTML" || t === "textContent" || t in n && Vw(t) && Dt(e));
    if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && n.tagName === "INPUT" || t === "type" && n.tagName === "TEXTAREA")
        return !1;
    if (t === "width" || t === "height") {
        const i = n.tagName;
        if (i === "IMG" || i === "VIDEO" || i === "CANVAS" || i === "SOURCE")
            return !1
    }
    return Vw(t) && Kn(e) ? !1 : t in n
}
const zo = n => {
    const t = n.props["onUpdate:modelValue"] || !1;
    return Ot(t) ? e => Vd(t, e) : t
}
;
function C5(n) {
    n.target.composing = !0
}
function Uw(n) {
    const t = n.target;
    t.composing && (t.composing = !1,
    t.dispatchEvent(new Event("input")))
}
const Is = Symbol("_assign")
  , Jd = {
    created(n, {modifiers: {lazy: t, trim: e, number: r}}, i) {
        n[Is] = zo(i);
        const a = r || i.props && i.props.type === "number";
        Yi(n, t ? "change" : "input", l => {
            if (l.target.composing)
                return;
            let f = n.value;
            e && (f = f.trim()),
            a && (f = ih(f)),
            n[Is](f)
        }
        ),
        e && Yi(n, "change", () => {
            n.value = n.value.trim()
        }
        ),
        t || (Yi(n, "compositionstart", C5),
        Yi(n, "compositionend", Uw),
        Yi(n, "change", Uw))
    },
    mounted(n, {value: t}) {
        n.value = t ?? ""
    },
    beforeUpdate(n, {value: t, oldValue: e, modifiers: {lazy: r, trim: i, number: a}}, l) {
        if (n[Is] = zo(l),
        n.composing)
            return;
        const f = (a || n.type === "number") && !/^0\d/.test(n.value) ? ih(n.value) : n.value
          , h = t ?? "";
        f !== h && (document.activeElement === n && n.type !== "range" && (r && t === e || i && n.value.trim() === h) || (n.value = h))
    }
}
  , $5 = {
    deep: !0,
    created(n, t, e) {
        n[Is] = zo(e),
        Yi(n, "change", () => {
            const r = n._modelValue
              , i = zl(n)
              , a = n.checked
              , l = n[Is];
            if (Ot(r)) {
                const f = b1(r, i)
                  , h = f !== -1;
                if (a && !h)
                    l(r.concat(i));
                else if (!a && h) {
                    const p = [...r];
                    p.splice(f, 1),
                    l(p)
                }
            } else if (iu(r)) {
                const f = new Set(r);
                a ? f.add(i) : f.delete(i),
                l(f)
            } else
                l(n2(n, a))
        }
        )
    },
    mounted: jw,
    beforeUpdate(n, t, e) {
        n[Is] = zo(e),
        jw(n, t, e)
    }
};
function jw(n, {value: t, oldValue: e}, r) {
    n._modelValue = t;
    let i;
    if (Ot(t))
        i = b1(t, r.props.value) > -1;
    else if (iu(t))
        i = t.has(r.props.value);
    else {
        if (t === e)
            return;
        i = Ta(t, n2(n, !0))
    }
    n.checked !== i && (n.checked = i)
}
const hv = {
    created(n, {value: t}, e) {
        n.checked = Ta(t, e.props.value),
        n[Is] = zo(e),
        Yi(n, "change", () => {
            n[Is](zl(n))
        }
        )
    },
    beforeUpdate(n, {value: t, oldValue: e}, r) {
        n[Is] = zo(r),
        t !== e && (n.checked = Ta(t, r.props.value))
    }
}
  , AW = {
    deep: !0,
    created(n, {value: t, modifiers: {number: e}}, r) {
        const i = iu(t);
        Yi(n, "change", () => {
            const a = Array.prototype.filter.call(n.options, l => l.selected).map(l => e ? ih(zl(l)) : zl(l));
            n[Is](n.multiple ? i ? new Set(a) : a : a[0]),
            n._assigning = !0,
            _m( () => {
                n._assigning = !1
            }
            )
        }
        ),
        n[Is] = zo(r)
    },
    mounted(n, {value: t}) {
        Hw(n, t)
    },
    beforeUpdate(n, t, e) {
        n[Is] = zo(e)
    },
    updated(n, {value: t}) {
        n._assigning || Hw(n, t)
    }
};
function Hw(n, t) {
    const e = n.multiple
      , r = Ot(t);
    if (!(e && !r && !iu(t))) {
        for (let i = 0, a = n.options.length; i < a; i++) {
            const l = n.options[i]
              , f = zl(l);
            if (e)
                if (r) {
                    const h = typeof f;
                    h === "string" || h === "number" ? l.selected = t.some(p => String(p) === String(f)) : l.selected = b1(t, f) > -1
                } else
                    l.selected = t.has(f);
            else if (Ta(zl(l), t)) {
                n.selectedIndex !== i && (n.selectedIndex = i);
                return
            }
        }
        !e && n.selectedIndex !== -1 && (n.selectedIndex = -1)
    }
}
function zl(n) {
    return "_value"in n ? n._value : n.value
}
function n2(n, t) {
    const e = t ? "_trueValue" : "_falseValue";
    return e in n ? n[e] : t
}
const M5 = ["ctrl", "shift", "alt", "meta"]
  , O5 = {
    stop: n => n.stopPropagation(),
    prevent: n => n.preventDefault(),
    self: n => n.target !== n.currentTarget,
    ctrl: n => !n.ctrlKey,
    shift: n => !n.shiftKey,
    alt: n => !n.altKey,
    meta: n => !n.metaKey,
    left: n => "button"in n && n.button !== 0,
    middle: n => "button"in n && n.button !== 1,
    right: n => "button"in n && n.button !== 2,
    exact: (n, t) => M5.some(e => n[`${e}Key`] && !t.includes(e))
}
  , CW = (n, t) => {
    const e = n._withMods || (n._withMods = {})
      , r = t.join(".");
    return e[r] || (e[r] = (i, ...a) => {
        for (let l = 0; l < t.length; l++) {
            const f = O5[t[l]];
            if (f && f(i, t))
                return
        }
        return n(i, ...a)
    }
    )
}
  , N5 = lr({
    patchProp: S5
}, i5);
let Gw;
function T5() {
    return Gw || (Gw = O4(N5))
}
const x5 = (...n) => {
    const t = T5().createApp(...n)
      , {mount: e} = t;
    return t.mount = r => {
        const i = F5(r);
        if (!i)
            return;
        const a = t._component;
        !Dt(a) && !a.render && !a.template && (a.template = i.innerHTML),
        i.nodeType === 1 && (i.textContent = "");
        const l = e(i, !1, I5(i));
        return i instanceof Element && (i.removeAttribute("v-cloak"),
        i.setAttribute("data-v-app", "")),
        l
    }
    ,
    t
}
;
function I5(n) {
    if (n instanceof SVGElement)
        return "svg";
    if (typeof MathMLElement == "function" && n instanceof MathMLElement)
        return "mathml"
}
function F5(n) {
    return Kn(n) ? document.querySelector(n) : n
}
var R5 = !1;
/*!
 * pinia v2.3.0
 * (c) 2024 Eduardo San Martin Morote
 * @license MIT
 */
let r2;
const Mm = n => r2 = n
  , s2 = Symbol();
function y0(n) {
    return n && typeof n == "object" && Object.prototype.toString.call(n) === "[object Object]" && typeof n.toJSON != "function"
}
var Ku;
(function(n) {
    n.direct = "direct",
    n.patchObject = "patch object",
    n.patchFunction = "patch function"
}
)(Ku || (Ku = {}));
function P5() {
    const n = J_(!0)
      , t = n.run( () => te({}));
    let e = []
      , r = [];
    const i = $1({
        install(a) {
            Mm(i),
            i._a = a,
            a.provide(s2, i),
            a.config.globalProperties.$pinia = i,
            r.forEach(l => e.push(l)),
            r = []
        },
        use(a) {
            return !this._a && !R5 ? r.push(a) : e.push(a),
            this
        },
        _p: e,
        _a: null,
        _e: n,
        _s: new Map,
        state: t
    });
    return i
}
const i2 = () => {}
;
function Ww(n, t, e, r=i2) {
    n.push(t);
    const i = () => {
        const a = n.indexOf(t);
        a > -1 && (n.splice(a, 1),
        r())
    }
    ;
    return !e && K_() && vR(i),
    i
}
function pl(n, ...t) {
    n.slice().forEach(e => {
        e(...t)
    }
    )
}
const D5 = n => n()
  , Jw = Symbol()
  , pv = Symbol();
function b0(n, t) {
    n instanceof Map && t instanceof Map ? t.forEach( (e, r) => n.set(r, e)) : n instanceof Set && t instanceof Set && t.forEach(n.add, n);
    for (const e in t) {
        if (!t.hasOwnProperty(e))
            continue;
        const r = t[e]
          , i = n[e];
        y0(i) && y0(r) && n.hasOwnProperty(e) && !tr(r) && !Ro(r) ? n[e] = b0(i, r) : n[e] = r
    }
    return n
}
const q5 = Symbol();
function B5(n) {
    return !y0(n) || !n.hasOwnProperty(q5)
}
const {assign: Ao} = Object;
function k5(n) {
    return !!(tr(n) && n.effect)
}
function z5(n, t, e, r) {
    const {state: i, actions: a, getters: l} = t
      , f = e.state.value[n];
    let h;
    function p() {
        f || (e.state.value[n] = i ? i() : {});
        const m = kR(e.state.value[n]);
        return Ao(m, a, Object.keys(l || {}).reduce( (g, b) => (g[b] = $1(Ve( () => {
            Mm(e);
            const E = e._s.get(n);
            return l[b].call(E, E)
        }
        )),
        g), {}))
    }
    return h = o2(n, p, t, e, r, !0),
    h
}
function o2(n, t, e={}, r, i, a) {
    let l;
    const f = Ao({
        actions: {}
    }, e)
      , h = {
        deep: !0
    };
    let p, m, g = [], b = [], E;
    const S = r.state.value[n];
    !a && !S && (r.state.value[n] = {}),
    te({});
    let F;
    function B(C) {
        let D;
        p = m = !1,
        typeof C == "function" ? (C(r.state.value[n]),
        D = {
            type: Ku.patchFunction,
            storeId: n,
            events: E
        }) : (b0(r.state.value[n], C),
        D = {
            type: Ku.patchObject,
            payload: C,
            storeId: n,
            events: E
        });
        const R = F = Symbol();
        _m().then( () => {
            F === R && (p = !0)
        }
        ),
        m = !0,
        pl(g, D, r.state.value[n])
    }
    const Q = a ? function() {
        const {state: D} = e
          , R = D ? D() : {};
        this.$patch(W => {
            Ao(W, R)
        }
        )
    }
    : i2;
    function ae() {
        l.stop(),
        g = [],
        b = [],
        r._s.delete(n)
    }
    const V = (C, D="") => {
        if (Jw in C)
            return C[pv] = D,
            C;
        const R = function() {
            Mm(r);
            const W = Array.from(arguments)
              , I = []
              , N = [];
            function P(ie) {
                I.push(ie)
            }
            function J(ie) {
                N.push(ie)
            }
            pl(b, {
                args: W,
                name: R[pv],
                store: z,
                after: P,
                onError: J
            });
            let X;
            try {
                X = C.apply(this && this.$id === n ? this : z, W)
            } catch (ie) {
                throw pl(N, ie),
                ie
            }
            return X instanceof Promise ? X.then(ie => (pl(I, ie),
            ie)).catch(ie => (pl(N, ie),
            Promise.reject(ie))) : (pl(I, X),
            X)
        };
        return R[Jw] = !0,
        R[pv] = D,
        R
    }
      , k = {
        _p: r,
        $id: n,
        $onAction: Ww.bind(null, b),
        $patch: B,
        $reset: Q,
        $subscribe(C, D={}) {
            const R = Ww(g, C, D.detached, () => W())
              , W = l.run( () => Jt( () => r.state.value[n], I => {
                (D.flush === "sync" ? m : p) && C({
                    storeId: n,
                    type: Ku.direct,
                    events: E
                }, I)
            }
            , Ao({}, h, D)));
            return R
        },
        $dispose: ae
    }
      , z = Cr(k);
    r._s.set(n, z);
    const re = (r._a && r._a.runWithContext || D5)( () => r._e.run( () => (l = J_()).run( () => t({
        action: V
    }))));
    for (const C in re) {
        const D = re[C];
        if (tr(D) && !k5(D) || Ro(D))
            a || (S && B5(D) && (tr(D) ? D.value = S[C] : b0(D, S[C])),
            r.state.value[n][C] = D);
        else if (typeof D == "function") {
            const R = V(D, C);
            re[C] = R,
            f.actions[C] = D
        }
    }
    return Ao(z, re),
    Ao(cn(z), re),
    Object.defineProperty(z, "$state", {
        get: () => r.state.value[n],
        set: C => {
            B(D => {
                Ao(D, C)
            }
            )
        }
    }),
    r._p.forEach(C => {
        Ao(z, l.run( () => C({
            store: z,
            app: r._a,
            pinia: r,
            options: f
        })))
    }
    ),
    S && a && e.hydrate && e.hydrate(z.$state, S),
    p = !0,
    m = !0,
    z
}
/*! #__NO_SIDE_EFFECTS__ */
function Ti(n, t, e) {
    let r, i;
    const a = typeof t == "function";
    typeof n == "string" ? (r = n,
    i = a ? e : t) : (i = n,
    r = n.id);
    function l(f, h) {
        const p = _4();
        return f = f || (p ? xs(s2, null) : null),
        f && Mm(f),
        f = r2,
        f._s.has(r) || (a ? o2(r, t, i, f) : z5(r, i, f)),
        f._s.get(r)
    }
    return l.$id = r,
    l
}
/*!
  * vue-router v4.5.0
  * (c) 2024 Eduardo San Martin Morote
  * @license MIT
  */
const $l = typeof document < "u";
function a2(n) {
    return typeof n == "object" || "displayName"in n || "props"in n || "__vccOpts"in n
}
function V5(n) {
    return n.__esModule || n[Symbol.toStringTag] === "Module" || n.default && a2(n.default)
}
const bn = Object.assign;
function mv(n, t) {
    const e = {};
    for (const r in t) {
        const i = t[r];
        e[r] = ei(i) ? i.map(n) : n(i)
    }
    return e
}
const Zu = () => {}
  , ei = Array.isArray
  , l2 = /#/g
  , U5 = /&/g
  , j5 = /\//g
  , H5 = /=/g
  , G5 = /\?/g
  , u2 = /\+/g
  , W5 = /%5B/g
  , J5 = /%5D/g
  , c2 = /%5E/g
  , K5 = /%60/g
  , f2 = /%7B/g
  , Z5 = /%7C/g
  , d2 = /%7D/g
  , Y5 = /%20/g;
function P1(n) {
    return encodeURI("" + n).replace(Z5, "|").replace(W5, "[").replace(J5, "]")
}
function Q5(n) {
    return P1(n).replace(f2, "{").replace(d2, "}").replace(c2, "^")
}
function w0(n) {
    return P1(n).replace(u2, "%2B").replace(Y5, "+").replace(l2, "%23").replace(U5, "%26").replace(K5, "`").replace(f2, "{").replace(d2, "}").replace(c2, "^")
}
function X5(n) {
    return w0(n).replace(H5, "%3D")
}
function e7(n) {
    return P1(n).replace(l2, "%23").replace(G5, "%3F")
}
function t7(n) {
    return n == null ? "" : e7(n).replace(j5, "%2F")
}
function gc(n) {
    try {
        return decodeURIComponent("" + n)
    } catch {}
    return "" + n
}
const n7 = /\/$/
  , r7 = n => n.replace(n7, "");
function gv(n, t, e="/") {
    let r, i = {}, a = "", l = "";
    const f = t.indexOf("#");
    let h = t.indexOf("?");
    return f < h && f >= 0 && (h = -1),
    h > -1 && (r = t.slice(0, h),
    a = t.slice(h + 1, f > -1 ? f : t.length),
    i = n(a)),
    f > -1 && (r = r || t.slice(0, f),
    l = t.slice(f, t.length)),
    r = a7(r ?? t, e),
    {
        fullPath: r + (a && "?") + a + l,
        path: r,
        query: i,
        hash: gc(l)
    }
}
function s7(n, t) {
    const e = t.query ? n(t.query) : "";
    return t.path + (e && "?") + e + (t.hash || "")
}
function Kw(n, t) {
    return !t || !n.toLowerCase().startsWith(t.toLowerCase()) ? n : n.slice(t.length) || "/"
}
function i7(n, t, e) {
    const r = t.matched.length - 1
      , i = e.matched.length - 1;
    return r > -1 && r === i && Vl(t.matched[r], e.matched[i]) && h2(t.params, e.params) && n(t.query) === n(e.query) && t.hash === e.hash
}
function Vl(n, t) {
    return (n.aliasOf || n) === (t.aliasOf || t)
}
function h2(n, t) {
    if (Object.keys(n).length !== Object.keys(t).length)
        return !1;
    for (const e in n)
        if (!o7(n[e], t[e]))
            return !1;
    return !0
}
function o7(n, t) {
    return ei(n) ? Zw(n, t) : ei(t) ? Zw(t, n) : n === t
}
function Zw(n, t) {
    return ei(t) ? n.length === t.length && n.every( (e, r) => e === t[r]) : n.length === 1 && n[0] === t
}
function a7(n, t) {
    if (n.startsWith("/"))
        return n;
    if (!n)
        return t;
    const e = t.split("/")
      , r = n.split("/")
      , i = r[r.length - 1];
    (i === ".." || i === ".") && r.push("");
    let a = e.length - 1, l, f;
    for (l = 0; l < r.length; l++)
        if (f = r[l],
        f !== ".")
            if (f === "..")
                a > 1 && a--;
            else
                break;
    return e.slice(0, a).join("/") + "/" + r.slice(l).join("/")
}
const wo = {
    path: "/",
    name: void 0,
    params: {},
    query: {},
    hash: "",
    fullPath: "/",
    matched: [],
    meta: {},
    redirectedFrom: void 0
};
var vc;
(function(n) {
    n.pop = "pop",
    n.push = "push"
}
)(vc || (vc = {}));
var Yu;
(function(n) {
    n.back = "back",
    n.forward = "forward",
    n.unknown = ""
}
)(Yu || (Yu = {}));
function l7(n) {
    if (!n)
        if ($l) {
            const t = document.querySelector("base");
            n = t && t.getAttribute("href") || "/",
            n = n.replace(/^\w+:\/\/[^\/]+/, "")
        } else
            n = "/";
    return n[0] !== "/" && n[0] !== "#" && (n = "/" + n),
    r7(n)
}
const u7 = /^[^#]+#/;
function c7(n, t) {
    return n.replace(u7, "#") + t
}
function f7(n, t) {
    const e = document.documentElement.getBoundingClientRect()
      , r = n.getBoundingClientRect();
    return {
        behavior: t.behavior,
        left: r.left - e.left - (t.left || 0),
        top: r.top - e.top - (t.top || 0)
    }
}
const Om = () => ({
    left: window.scrollX,
    top: window.scrollY
});
function d7(n) {
    let t;
    if ("el"in n) {
        const e = n.el
          , r = typeof e == "string" && e.startsWith("#")
          , i = typeof e == "string" ? r ? document.getElementById(e.slice(1)) : document.querySelector(e) : e;
        if (!i)
            return;
        t = f7(i, n)
    } else
        t = n;
    "scrollBehavior"in document.documentElement.style ? window.scrollTo(t) : window.scrollTo(t.left != null ? t.left : window.scrollX, t.top != null ? t.top : window.scrollY)
}
function Yw(n, t) {
    return (history.state ? history.state.position - t : -1) + n
}
const E0 = new Map;
function h7(n, t) {
    E0.set(n, t)
}
function p7(n) {
    const t = E0.get(n);
    return E0.delete(n),
    t
}
let m7 = () => location.protocol + "//" + location.host;
function p2(n, t) {
    const {pathname: e, search: r, hash: i} = t
      , a = n.indexOf("#");
    if (a > -1) {
        let f = i.includes(n.slice(a)) ? n.slice(a).length : 1
          , h = i.slice(f);
        return h[0] !== "/" && (h = "/" + h),
        Kw(h, "")
    }
    return Kw(e, n) + r + i
}
function g7(n, t, e, r) {
    let i = []
      , a = []
      , l = null;
    const f = ({state: b}) => {
        const E = p2(n, location)
          , S = e.value
          , F = t.value;
        let B = 0;
        if (b) {
            if (e.value = E,
            t.value = b,
            l && l === S) {
                l = null;
                return
            }
            B = F ? b.position - F.position : 0
        } else
            r(E);
        i.forEach(Q => {
            Q(e.value, S, {
                delta: B,
                type: vc.pop,
                direction: B ? B > 0 ? Yu.forward : Yu.back : Yu.unknown
            })
        }
        )
    }
    ;
    function h() {
        l = e.value
    }
    function p(b) {
        i.push(b);
        const E = () => {
            const S = i.indexOf(b);
            S > -1 && i.splice(S, 1)
        }
        ;
        return a.push(E),
        E
    }
    function m() {
        const {history: b} = window;
        b.state && b.replaceState(bn({}, b.state, {
            scroll: Om()
        }), "")
    }
    function g() {
        for (const b of a)
            b();
        a = [],
        window.removeEventListener("popstate", f),
        window.removeEventListener("beforeunload", m)
    }
    return window.addEventListener("popstate", f),
    window.addEventListener("beforeunload", m, {
        passive: !0
    }),
    {
        pauseListeners: h,
        listen: p,
        destroy: g
    }
}
function Qw(n, t, e, r=!1, i=!1) {
    return {
        back: n,
        current: t,
        forward: e,
        replaced: r,
        position: window.history.length,
        scroll: i ? Om() : null
    }
}
function v7(n) {
    const {history: t, location: e} = window
      , r = {
        value: p2(n, e)
    }
      , i = {
        value: t.state
    };
    i.value || a(r.value, {
        back: null,
        current: r.value,
        forward: null,
        position: t.length - 1,
        replaced: !0,
        scroll: null
    }, !0);
    function a(h, p, m) {
        const g = n.indexOf("#")
          , b = g > -1 ? (e.host && document.querySelector("base") ? n : n.slice(g)) + h : m7() + n + h;
        try {
            t[m ? "replaceState" : "pushState"](p, "", b),
            i.value = p
        } catch (E) {
            console.error(E),
            e[m ? "replace" : "assign"](b)
        }
    }
    function l(h, p) {
        const m = bn({}, t.state, Qw(i.value.back, h, i.value.forward, !0), p, {
            position: i.value.position
        });
        a(h, m, !0),
        r.value = h
    }
    function f(h, p) {
        const m = bn({}, i.value, t.state, {
            forward: h,
            scroll: Om()
        });
        a(m.current, m, !0);
        const g = bn({}, Qw(r.value, h, null), {
            position: m.position + 1
        }, p);
        a(h, g, !1),
        r.value = h
    }
    return {
        location: r,
        state: i,
        push: f,
        replace: l
    }
}
function y7(n) {
    n = l7(n);
    const t = v7(n)
      , e = g7(n, t.state, t.location, t.replace);
    function r(a, l=!0) {
        l || e.pauseListeners(),
        history.go(a)
    }
    const i = bn({
        location: "",
        base: n,
        go: r,
        createHref: c7.bind(null, n)
    }, t, e);
    return Object.defineProperty(i, "location", {
        enumerable: !0,
        get: () => t.location.value
    }),
    Object.defineProperty(i, "state", {
        enumerable: !0,
        get: () => t.state.value
    }),
    i
}
function b7(n) {
    return typeof n == "string" || n && typeof n == "object"
}
function m2(n) {
    return typeof n == "string" || typeof n == "symbol"
}
const g2 = Symbol("");
var Xw;
(function(n) {
    n[n.aborted = 4] = "aborted",
    n[n.cancelled = 8] = "cancelled",
    n[n.duplicated = 16] = "duplicated"
}
)(Xw || (Xw = {}));
function Ul(n, t) {
    return bn(new Error, {
        type: n,
        [g2]: !0
    }, t)
}
function ji(n, t) {
    return n instanceof Error && g2 in n && (t == null || !!(n.type & t))
}
const eE = "[^/]+?"
  , w7 = {
    sensitive: !1,
    strict: !1,
    start: !0,
    end: !0
}
  , E7 = /[.+*?^${}()[\]/\\]/g;
function _7(n, t) {
    const e = bn({}, w7, t)
      , r = [];
    let i = e.start ? "^" : "";
    const a = [];
    for (const p of n) {
        const m = p.length ? [] : [90];
        e.strict && !p.length && (i += "/");
        for (let g = 0; g < p.length; g++) {
            const b = p[g];
            let E = 40 + (e.sensitive ? .25 : 0);
            if (b.type === 0)
                g || (i += "/"),
                i += b.value.replace(E7, "\\$&"),
                E += 40;
            else if (b.type === 1) {
                const {value: S, repeatable: F, optional: B, regexp: Q} = b;
                a.push({
                    name: S,
                    repeatable: F,
                    optional: B
                });
                const ae = Q || eE;
                if (ae !== eE) {
                    E += 10;
                    try {
                        new RegExp(`(${ae})`)
                    } catch (k) {
                        throw new Error(`Invalid custom RegExp for param "${S}" (${ae}): ` + k.message)
                    }
                }
                let V = F ? `((?:${ae})(?:/(?:${ae}))*)` : `(${ae})`;
                g || (V = B && p.length < 2 ? `(?:/${V})` : "/" + V),
                B && (V += "?"),
                i += V,
                E += 20,
                B && (E += -8),
                F && (E += -20),
                ae === ".*" && (E += -50)
            }
            m.push(E)
        }
        r.push(m)
    }
    if (e.strict && e.end) {
        const p = r.length - 1;
        r[p][r[p].length - 1] += .7000000000000001
    }
    e.strict || (i += "/?"),
    e.end ? i += "$" : e.strict && !i.endsWith("/") && (i += "(?:/|$)");
    const l = new RegExp(i,e.sensitive ? "" : "i");
    function f(p) {
        const m = p.match(l)
          , g = {};
        if (!m)
            return null;
        for (let b = 1; b < m.length; b++) {
            const E = m[b] || ""
              , S = a[b - 1];
            g[S.name] = E && S.repeatable ? E.split("/") : E
        }
        return g
    }
    function h(p) {
        let m = ""
          , g = !1;
        for (const b of n) {
            (!g || !m.endsWith("/")) && (m += "/"),
            g = !1;
            for (const E of b)
                if (E.type === 0)
                    m += E.value;
                else if (E.type === 1) {
                    const {value: S, repeatable: F, optional: B} = E
                      , Q = S in p ? p[S] : "";
                    if (ei(Q) && !F)
                        throw new Error(`Provided param "${S}" is an array but it is not repeatable (* or + modifiers)`);
                    const ae = ei(Q) ? Q.join("/") : Q;
                    if (!ae)
                        if (B)
                            b.length < 2 && (m.endsWith("/") ? m = m.slice(0, -1) : g = !0);
                        else
                            throw new Error(`Missing required param "${S}"`);
                    m += ae
                }
        }
        return m || "/"
    }
    return {
        re: l,
        score: r,
        keys: a,
        parse: f,
        stringify: h
    }
}
function L7(n, t) {
    let e = 0;
    for (; e < n.length && e < t.length; ) {
        const r = t[e] - n[e];
        if (r)
            return r;
        e++
    }
    return n.length < t.length ? n.length === 1 && n[0] === 40 + 40 ? -1 : 1 : n.length > t.length ? t.length === 1 && t[0] === 40 + 40 ? 1 : -1 : 0
}
function v2(n, t) {
    let e = 0;
    const r = n.score
      , i = t.score;
    for (; e < r.length && e < i.length; ) {
        const a = L7(r[e], i[e]);
        if (a)
            return a;
        e++
    }
    if (Math.abs(i.length - r.length) === 1) {
        if (tE(r))
            return 1;
        if (tE(i))
            return -1
    }
    return i.length - r.length
}
function tE(n) {
    const t = n[n.length - 1];
    return n.length > 0 && t[t.length - 1] < 0
}
const S7 = {
    type: 0,
    value: ""
}
  , A7 = /[a-zA-Z0-9_]/;
function C7(n) {
    if (!n)
        return [[]];
    if (n === "/")
        return [[S7]];
    if (!n.startsWith("/"))
        throw new Error(`Invalid path "${n}"`);
    function t(E) {
        throw new Error(`ERR (${e})/"${p}": ${E}`)
    }
    let e = 0
      , r = e;
    const i = [];
    let a;
    function l() {
        a && i.push(a),
        a = []
    }
    let f = 0, h, p = "", m = "";
    function g() {
        p && (e === 0 ? a.push({
            type: 0,
            value: p
        }) : e === 1 || e === 2 || e === 3 ? (a.length > 1 && (h === "*" || h === "+") && t(`A repeatable param (${p}) must be alone in its segment. eg: '/:ids+.`),
        a.push({
            type: 1,
            value: p,
            regexp: m,
            repeatable: h === "*" || h === "+",
            optional: h === "*" || h === "?"
        })) : t("Invalid state to consume buffer"),
        p = "")
    }
    function b() {
        p += h
    }
    for (; f < n.length; ) {
        if (h = n[f++],
        h === "\\" && e !== 2) {
            r = e,
            e = 4;
            continue
        }
        switch (e) {
        case 0:
            h === "/" ? (p && g(),
            l()) : h === ":" ? (g(),
            e = 1) : b();
            break;
        case 4:
            b(),
            e = r;
            break;
        case 1:
            h === "(" ? e = 2 : A7.test(h) ? b() : (g(),
            e = 0,
            h !== "*" && h !== "?" && h !== "+" && f--);
            break;
        case 2:
            h === ")" ? m[m.length - 1] == "\\" ? m = m.slice(0, -1) + h : e = 3 : m += h;
            break;
        case 3:
            g(),
            e = 0,
            h !== "*" && h !== "?" && h !== "+" && f--,
            m = "";
            break;
        default:
            t("Unknown state");
            break
        }
    }
    return e === 2 && t(`Unfinished custom RegExp for param "${p}"`),
    g(),
    l(),
    i
}
function $7(n, t, e) {
    const r = _7(C7(n.path), e)
      , i = bn(r, {
        record: n,
        parent: t,
        children: [],
        alias: []
    });
    return t && !i.record.aliasOf == !t.record.aliasOf && t.children.push(i),
    i
}
function M7(n, t) {
    const e = []
      , r = new Map;
    t = iE({
        strict: !1,
        end: !0,
        sensitive: !1
    }, t);
    function i(g) {
        return r.get(g)
    }
    function a(g, b, E) {
        const S = !E
          , F = rE(g);
        F.aliasOf = E && E.record;
        const B = iE(t, g)
          , Q = [F];
        if ("alias"in g) {
            const k = typeof g.alias == "string" ? [g.alias] : g.alias;
            for (const z of k)
                Q.push(rE(bn({}, F, {
                    components: E ? E.record.components : F.components,
                    path: z,
                    aliasOf: E ? E.record : F
                })))
        }
        let ae, V;
        for (const k of Q) {
            const {path: z} = k;
            if (b && z[0] !== "/") {
                const Z = b.record.path
                  , re = Z[Z.length - 1] === "/" ? "" : "/";
                k.path = b.record.path + (z && re + z)
            }
            if (ae = $7(k, b, B),
            E ? E.alias.push(ae) : (V = V || ae,
            V !== ae && V.alias.push(ae),
            S && g.name && !sE(ae) && l(g.name)),
            y2(ae) && h(ae),
            F.children) {
                const Z = F.children;
                for (let re = 0; re < Z.length; re++)
                    a(Z[re], ae, E && E.children[re])
            }
            E = E || ae
        }
        return V ? () => {
            l(V)
        }
        : Zu
    }
    function l(g) {
        if (m2(g)) {
            const b = r.get(g);
            b && (r.delete(g),
            e.splice(e.indexOf(b), 1),
            b.children.forEach(l),
            b.alias.forEach(l))
        } else {
            const b = e.indexOf(g);
            b > -1 && (e.splice(b, 1),
            g.record.name && r.delete(g.record.name),
            g.children.forEach(l),
            g.alias.forEach(l))
        }
    }
    function f() {
        return e
    }
    function h(g) {
        const b = T7(g, e);
        e.splice(b, 0, g),
        g.record.name && !sE(g) && r.set(g.record.name, g)
    }
    function p(g, b) {
        let E, S = {}, F, B;
        if ("name"in g && g.name) {
            if (E = r.get(g.name),
            !E)
                throw Ul(1, {
                    location: g
                });
            B = E.record.name,
            S = bn(nE(b.params, E.keys.filter(V => !V.optional).concat(E.parent ? E.parent.keys.filter(V => V.optional) : []).map(V => V.name)), g.params && nE(g.params, E.keys.map(V => V.name))),
            F = E.stringify(S)
        } else if (g.path != null)
            F = g.path,
            E = e.find(V => V.re.test(F)),
            E && (S = E.parse(F),
            B = E.record.name);
        else {
            if (E = b.name ? r.get(b.name) : e.find(V => V.re.test(b.path)),
            !E)
                throw Ul(1, {
                    location: g,
                    currentLocation: b
                });
            B = E.record.name,
            S = bn({}, b.params, g.params),
            F = E.stringify(S)
        }
        const Q = [];
        let ae = E;
        for (; ae; )
            Q.unshift(ae.record),
            ae = ae.parent;
        return {
            name: B,
            path: F,
            params: S,
            matched: Q,
            meta: N7(Q)
        }
    }
    n.forEach(g => a(g));
    function m() {
        e.length = 0,
        r.clear()
    }
    return {
        addRoute: a,
        resolve: p,
        removeRoute: l,
        clearRoutes: m,
        getRoutes: f,
        getRecordMatcher: i
    }
}
function nE(n, t) {
    const e = {};
    for (const r of t)
        r in n && (e[r] = n[r]);
    return e
}
function rE(n) {
    const t = {
        path: n.path,
        redirect: n.redirect,
        name: n.name,
        meta: n.meta || {},
        aliasOf: n.aliasOf,
        beforeEnter: n.beforeEnter,
        props: O7(n),
        children: n.children || [],
        instances: {},
        leaveGuards: new Set,
        updateGuards: new Set,
        enterCallbacks: {},
        components: "components"in n ? n.components || null : n.component && {
            default: n.component
        }
    };
    return Object.defineProperty(t, "mods", {
        value: {}
    }),
    t
}
function O7(n) {
    const t = {}
      , e = n.props || !1;
    if ("component"in n)
        t.default = e;
    else
        for (const r in n.components)
            t[r] = typeof e == "object" ? e[r] : e;
    return t
}
function sE(n) {
    for (; n; ) {
        if (n.record.aliasOf)
            return !0;
        n = n.parent
    }
    return !1
}
function N7(n) {
    return n.reduce( (t, e) => bn(t, e.meta), {})
}
function iE(n, t) {
    const e = {};
    for (const r in n)
        e[r] = r in t ? t[r] : n[r];
    return e
}
function T7(n, t) {
    let e = 0
      , r = t.length;
    for (; e !== r; ) {
        const a = e + r >> 1;
        v2(n, t[a]) < 0 ? r = a : e = a + 1
    }
    const i = x7(n);
    return i && (r = t.lastIndexOf(i, r - 1)),
    r
}
function x7(n) {
    let t = n;
    for (; t = t.parent; )
        if (y2(t) && v2(n, t) === 0)
            return t
}
function y2({record: n}) {
    return !!(n.name || n.components && Object.keys(n.components).length || n.redirect)
}
function I7(n) {
    const t = {};
    if (n === "" || n === "?")
        return t;
    const r = (n[0] === "?" ? n.slice(1) : n).split("&");
    for (let i = 0; i < r.length; ++i) {
        const a = r[i].replace(u2, " ")
          , l = a.indexOf("=")
          , f = gc(l < 0 ? a : a.slice(0, l))
          , h = l < 0 ? null : gc(a.slice(l + 1));
        if (f in t) {
            let p = t[f];
            ei(p) || (p = t[f] = [p]),
            p.push(h)
        } else
            t[f] = h
    }
    return t
}
function oE(n) {
    let t = "";
    for (let e in n) {
        const r = n[e];
        if (e = X5(e),
        r == null) {
            r !== void 0 && (t += (t.length ? "&" : "") + e);
            continue
        }
        (ei(r) ? r.map(a => a && w0(a)) : [r && w0(r)]).forEach(a => {
            a !== void 0 && (t += (t.length ? "&" : "") + e,
            a != null && (t += "=" + a))
        }
        )
    }
    return t
}
function F7(n) {
    const t = {};
    for (const e in n) {
        const r = n[e];
        r !== void 0 && (t[e] = ei(r) ? r.map(i => i == null ? null : "" + i) : r == null ? r : "" + r)
    }
    return t
}
const R7 = Symbol("")
  , aE = Symbol("")
  , Nm = Symbol("")
  , D1 = Symbol("")
  , _0 = Symbol("");
function Pu() {
    let n = [];
    function t(r) {
        return n.push(r),
        () => {
            const i = n.indexOf(r);
            i > -1 && n.splice(i, 1)
        }
    }
    function e() {
        n = []
    }
    return {
        add: t,
        list: () => n.slice(),
        reset: e
    }
}
function Oo(n, t, e, r, i, a=l => l()) {
    const l = r && (r.enterCallbacks[i] = r.enterCallbacks[i] || []);
    return () => new Promise( (f, h) => {
        const p = b => {
            b === !1 ? h(Ul(4, {
                from: e,
                to: t
            })) : b instanceof Error ? h(b) : b7(b) ? h(Ul(2, {
                from: t,
                to: b
            })) : (l && r.enterCallbacks[i] === l && typeof b == "function" && l.push(b),
            f())
        }
          , m = a( () => n.call(r && r.instances[i], t, e, p));
        let g = Promise.resolve(m);
        n.length < 3 && (g = g.then(p)),
        g.catch(b => h(b))
    }
    )
}
function vv(n, t, e, r, i=a => a()) {
    const a = [];
    for (const l of n)
        for (const f in l.components) {
            let h = l.components[f];
            if (!(t !== "beforeRouteEnter" && !l.instances[f]))
                if (a2(h)) {
                    const m = (h.__vccOpts || h)[t];
                    m && a.push(Oo(m, e, r, l, f, i))
                } else {
                    let p = h();
                    a.push( () => p.then(m => {
                        if (!m)
                            throw new Error(`Couldn't resolve component "${f}" at "${l.path}"`);
                        const g = V5(m) ? m.default : m;
                        l.mods[f] = m,
                        l.components[f] = g;
                        const E = (g.__vccOpts || g)[t];
                        return E && Oo(E, e, r, l, f, i)()
                    }
                    ))
                }
        }
    return a
}
function lE(n) {
    const t = xs(Nm)
      , e = xs(D1)
      , r = Ve( () => {
        const h = Ee(n.to);
        return t.resolve(h)
    }
    )
      , i = Ve( () => {
        const {matched: h} = r.value
          , {length: p} = h
          , m = h[p - 1]
          , g = e.matched;
        if (!m || !g.length)
            return -1;
        const b = g.findIndex(Vl.bind(null, m));
        if (b > -1)
            return b;
        const E = uE(h[p - 2]);
        return p > 1 && uE(m) === E && g[g.length - 1].path !== E ? g.findIndex(Vl.bind(null, h[p - 2])) : b
    }
    )
      , a = Ve( () => i.value > -1 && B7(e.params, r.value.params))
      , l = Ve( () => i.value > -1 && i.value === e.matched.length - 1 && h2(e.params, r.value.params));
    function f(h={}) {
        if (q7(h)) {
            const p = t[Ee(n.replace) ? "replace" : "push"](Ee(n.to)).catch(Zu);
            return n.viewTransition && typeof document < "u" && "startViewTransition"in document && document.startViewTransition( () => p),
            p
        }
        return Promise.resolve()
    }
    return {
        route: r,
        href: Ve( () => r.value.href),
        isActive: a,
        isExactActive: l,
        navigate: f
    }
}
function P7(n) {
    return n.length === 1 ? n[0] : n
}
const D7 = gs({
    name: "RouterLink",
    compatConfig: {
        MODE: 3
    },
    props: {
        to: {
            type: [String, Object],
            required: !0
        },
        replace: Boolean,
        activeClass: String,
        exactActiveClass: String,
        custom: Boolean,
        ariaCurrentValue: {
            type: String,
            default: "page"
        }
    },
    useLink: lE,
    setup(n, {slots: t}) {
        const e = Cr(lE(n))
          , {options: r} = xs(Nm)
          , i = Ve( () => ({
            [cE(n.activeClass, r.linkActiveClass, "router-link-active")]: e.isActive,
            [cE(n.exactActiveClass, r.linkExactActiveClass, "router-link-exact-active")]: e.isExactActive
        }));
        return () => {
            const a = t.default && P7(t.default(e));
            return n.custom ? a : R1("a", {
                "aria-current": e.isExactActive ? n.ariaCurrentValue : null,
                href: e.href,
                onClick: e.navigate,
                class: i.value
            }, a)
        }
    }
})
  , cs = D7;
function q7(n) {
    if (!(n.metaKey || n.altKey || n.ctrlKey || n.shiftKey) && !n.defaultPrevented && !(n.button !== void 0 && n.button !== 0)) {
        if (n.currentTarget && n.currentTarget.getAttribute) {
            const t = n.currentTarget.getAttribute("target");
            if (/\b_blank\b/i.test(t))
                return
        }
        return n.preventDefault && n.preventDefault(),
        !0
    }
}
function B7(n, t) {
    for (const e in t) {
        const r = t[e]
          , i = n[e];
        if (typeof r == "string") {
            if (r !== i)
                return !1
        } else if (!ei(i) || i.length !== r.length || r.some( (a, l) => a !== i[l]))
            return !1
    }
    return !0
}
function uE(n) {
    return n ? n.aliasOf ? n.aliasOf.path : n.path : ""
}
const cE = (n, t, e) => n ?? t ?? e
  , k7 = gs({
    name: "RouterView",
    inheritAttrs: !1,
    props: {
        name: {
            type: String,
            default: "default"
        },
        route: Object
    },
    compatConfig: {
        MODE: 3
    },
    setup(n, {attrs: t, slots: e}) {
        const r = xs(_0)
          , i = Ve( () => n.route || r.value)
          , a = xs(aE, 0)
          , l = Ve( () => {
            let p = Ee(a);
            const {matched: m} = i.value;
            let g;
            for (; (g = m[p]) && !g.components; )
                p++;
            return p
        }
        )
          , f = Ve( () => i.value.matched[l.value]);
        jd(aE, Ve( () => l.value + 1)),
        jd(R7, f),
        jd(_0, i);
        const h = te();
        return Jt( () => [h.value, f.value, n.name], ([p,m,g], [b,E,S]) => {
            m && (m.instances[g] = p,
            E && E !== m && p && p === b && (m.leaveGuards.size || (m.leaveGuards = E.leaveGuards),
            m.updateGuards.size || (m.updateGuards = E.updateGuards))),
            p && m && (!E || !Vl(m, E) || !b) && (m.enterCallbacks[g] || []).forEach(F => F(p))
        }
        , {
            flush: "post"
        }),
        () => {
            const p = i.value
              , m = n.name
              , g = f.value
              , b = g && g.components[m];
            if (!b)
                return fE(e.default, {
                    Component: b,
                    route: p
                });
            const E = g.props[m]
              , S = E ? E === !0 ? p.params : typeof E == "function" ? E(p) : E : null
              , B = R1(b, bn({}, S, t, {
                onVnodeUnmounted: Q => {
                    Q.component.isUnmounted && (g.instances[m] = null)
                }
                ,
                ref: h
            }));
            return fE(e.default, {
                Component: B,
                route: p
            }) || B
        }
    }
});
function fE(n, t) {
    if (!n)
        return null;
    const e = n(t);
    return e.length === 1 ? e[0] : e
}
const b2 = k7;
function z7(n) {
    const t = M7(n.routes, n)
      , e = n.parseQuery || I7
      , r = n.stringifyQuery || oE
      , i = n.history
      , a = Pu()
      , l = Pu()
      , f = Pu()
      , h = DR(wo);
    let p = wo;
    $l && n.scrollBehavior && "scrollRestoration"in history && (history.scrollRestoration = "manual");
    const m = mv.bind(null, L => "" + L)
      , g = mv.bind(null, t7)
      , b = mv.bind(null, gc);
    function E(L, K) {
        let de, $e;
        return m2(L) ? (de = t.getRecordMatcher(L),
        $e = K) : $e = L,
        t.addRoute($e, de)
    }
    function S(L) {
        const K = t.getRecordMatcher(L);
        K && t.removeRoute(K)
    }
    function F() {
        return t.getRoutes().map(L => L.record)
    }
    function B(L) {
        return !!t.getRecordMatcher(L)
    }
    function Q(L, K) {
        if (K = bn({}, K || h.value),
        typeof L == "string") {
            const j = gv(e, L, K.path)
              , ge = t.resolve({
                path: j.path
            }, K)
              , Me = i.createHref(j.fullPath);
            return bn(j, ge, {
                params: b(ge.params),
                hash: gc(j.hash),
                redirectedFrom: void 0,
                href: Me
            })
        }
        let de;
        if (L.path != null)
            de = bn({}, L, {
                path: gv(e, L.path, K.path).path
            });
        else {
            const j = bn({}, L.params);
            for (const ge in j)
                j[ge] == null && delete j[ge];
            de = bn({}, L, {
                params: g(j)
            }),
            K.params = g(K.params)
        }
        const $e = t.resolve(de, K)
          , Re = L.hash || "";
        $e.params = m(b($e.params));
        const me = s7(r, bn({}, L, {
            hash: Q5(Re),
            path: $e.path
        }))
          , T = i.createHref(me);
        return bn({
            fullPath: me,
            hash: Re,
            query: r === oE ? F7(L.query) : L.query || {}
        }, $e, {
            redirectedFrom: void 0,
            href: T
        })
    }
    function ae(L) {
        return typeof L == "string" ? gv(e, L, h.value.path) : bn({}, L)
    }
    function V(L, K) {
        if (p !== L)
            return Ul(8, {
                from: K,
                to: L
            })
    }
    function k(L) {
        return re(L)
    }
    function z(L) {
        return k(bn(ae(L), {
            replace: !0
        }))
    }
    function Z(L) {
        const K = L.matched[L.matched.length - 1];
        if (K && K.redirect) {
            const {redirect: de} = K;
            let $e = typeof de == "function" ? de(L) : de;
            return typeof $e == "string" && ($e = $e.includes("?") || $e.includes("#") ? $e = ae($e) : {
                path: $e
            },
            $e.params = {}),
            bn({
                query: L.query,
                hash: L.hash,
                params: $e.path != null ? {} : L.params
            }, $e)
        }
    }
    function re(L, K) {
        const de = p = Q(L)
          , $e = h.value
          , Re = L.state
          , me = L.force
          , T = L.replace === !0
          , j = Z(de);
        if (j)
            return re(bn(ae(j), {
                state: typeof j == "object" ? bn({}, Re, j.state) : Re,
                force: me,
                replace: T
            }), K || de);
        const ge = de;
        ge.redirectedFrom = K;
        let Me;
        return !me && i7(r, $e, de) && (Me = Ul(16, {
            to: ge,
            from: $e
        }),
        Fe($e, $e, !0, !1)),
        (Me ? Promise.resolve(Me) : R(ge, $e)).catch(Oe => ji(Oe) ? ji(Oe, 2) ? Oe : he(Oe) : ce(Oe, ge, $e)).then(Oe => {
            if (Oe) {
                if (ji(Oe, 2))
                    return re(bn({
                        replace: T
                    }, ae(Oe.to), {
                        state: typeof Oe.to == "object" ? bn({}, Re, Oe.to.state) : Re,
                        force: me
                    }), K || ge)
            } else
                Oe = I(ge, $e, !0, T, Re);
            return W(ge, $e, Oe),
            Oe
        }
        )
    }
    function C(L, K) {
        const de = V(L, K);
        return de ? Promise.reject(de) : Promise.resolve()
    }
    function D(L) {
        const K = qe.values().next().value;
        return K && typeof K.runWithContext == "function" ? K.runWithContext(L) : L()
    }
    function R(L, K) {
        let de;
        const [$e,Re,me] = V7(L, K);
        de = vv($e.reverse(), "beforeRouteLeave", L, K);
        for (const j of $e)
            j.leaveGuards.forEach(ge => {
                de.push(Oo(ge, L, K))
            }
            );
        const T = C.bind(null, L, K);
        return de.push(T),
        Se(de).then( () => {
            de = [];
            for (const j of a.list())
                de.push(Oo(j, L, K));
            return de.push(T),
            Se(de)
        }
        ).then( () => {
            de = vv(Re, "beforeRouteUpdate", L, K);
            for (const j of Re)
                j.updateGuards.forEach(ge => {
                    de.push(Oo(ge, L, K))
                }
                );
            return de.push(T),
            Se(de)
        }
        ).then( () => {
            de = [];
            for (const j of me)
                if (j.beforeEnter)
                    if (ei(j.beforeEnter))
                        for (const ge of j.beforeEnter)
                            de.push(Oo(ge, L, K));
                    else
                        de.push(Oo(j.beforeEnter, L, K));
            return de.push(T),
            Se(de)
        }
        ).then( () => (L.matched.forEach(j => j.enterCallbacks = {}),
        de = vv(me, "beforeRouteEnter", L, K, D),
        de.push(T),
        Se(de))).then( () => {
            de = [];
            for (const j of l.list())
                de.push(Oo(j, L, K));
            return de.push(T),
            Se(de)
        }
        ).catch(j => ji(j, 8) ? j : Promise.reject(j))
    }
    function W(L, K, de) {
        f.list().forEach($e => D( () => $e(L, K, de)))
    }
    function I(L, K, de, $e, Re) {
        const me = V(L, K);
        if (me)
            return me;
        const T = K === wo
          , j = $l ? history.state : {};
        de && ($e || T ? i.replace(L.fullPath, bn({
            scroll: T && j && j.scroll
        }, Re)) : i.push(L.fullPath, Re)),
        h.value = L,
        Fe(L, K, de, T),
        he()
    }
    let N;
    function P() {
        N || (N = i.listen( (L, K, de) => {
            if (!Ge.listening)
                return;
            const $e = Q(L)
              , Re = Z($e);
            if (Re) {
                re(bn(Re, {
                    replace: !0,
                    force: !0
                }), $e).catch(Zu);
                return
            }
            p = $e;
            const me = h.value;
            $l && h7(Yw(me.fullPath, de.delta), Om()),
            R($e, me).catch(T => ji(T, 12) ? T : ji(T, 2) ? (re(bn(ae(T.to), {
                force: !0
            }), $e).then(j => {
                ji(j, 20) && !de.delta && de.type === vc.pop && i.go(-1, !1)
            }
            ).catch(Zu),
            Promise.reject()) : (de.delta && i.go(-de.delta, !1),
            ce(T, $e, me))).then(T => {
                T = T || I($e, me, !1),
                T && (de.delta && !ji(T, 8) ? i.go(-de.delta, !1) : de.type === vc.pop && ji(T, 20) && i.go(-1, !1)),
                W($e, me, T)
            }
            ).catch(Zu)
        }
        ))
    }
    let J = Pu(), X = Pu(), ie;
    function ce(L, K, de) {
        he(L);
        const $e = X.list();
        return $e.length ? $e.forEach(Re => Re(L, K, de)) : console.error(L),
        Promise.reject(L)
    }
    function Le() {
        return ie && h.value !== wo ? Promise.resolve() : new Promise( (L, K) => {
            J.add([L, K])
        }
        )
    }
    function he(L) {
        return ie || (ie = !L,
        P(),
        J.list().forEach( ([K,de]) => L ? de(L) : K()),
        J.reset()),
        L
    }
    function Fe(L, K, de, $e) {
        const {scrollBehavior: Re} = n;
        if (!$l || !Re)
            return Promise.resolve();
        const me = !de && p7(Yw(L.fullPath, 0)) || ($e || !de) && history.state && history.state.scroll || null;
        return _m().then( () => Re(L, K, me)).then(T => T && d7(T)).catch(T => ce(T, L, K))
    }
    const Te = L => i.go(L);
    let ye;
    const qe = new Set
      , Ge = {
        currentRoute: h,
        listening: !0,
        addRoute: E,
        removeRoute: S,
        clearRoutes: t.clearRoutes,
        hasRoute: B,
        getRoutes: F,
        resolve: Q,
        options: n,
        push: k,
        replace: z,
        go: Te,
        back: () => Te(-1),
        forward: () => Te(1),
        beforeEach: a.add,
        beforeResolve: l.add,
        afterEach: f.add,
        onError: X.add,
        isReady: Le,
        install(L) {
            const K = this;
            L.component("RouterLink", cs),
            L.component("RouterView", b2),
            L.config.globalProperties.$router = K,
            Object.defineProperty(L.config.globalProperties, "$route", {
                enumerable: !0,
                get: () => Ee(h)
            }),
            $l && !ye && h.value === wo && (ye = !0,
            k(i.location).catch(Re => {}
            ));
            const de = {};
            for (const Re in wo)
                Object.defineProperty(de, Re, {
                    get: () => h.value[Re],
                    enumerable: !0
                });
            L.provide(Nm, K),
            L.provide(D1, cL(de)),
            L.provide(_0, h);
            const $e = L.unmount;
            qe.add(L),
            L.unmount = function() {
                qe.delete(L),
                qe.size < 1 && (p = wo,
                N && N(),
                N = null,
                h.value = wo,
                ye = !1,
                ie = !1),
                $e()
            }
        }
    };
    function Se(L) {
        return L.reduce( (K, de) => K.then( () => D(de)), Promise.resolve())
    }
    return Ge
}
function V7(n, t) {
    const e = []
      , r = []
      , i = []
      , a = Math.max(t.matched.length, n.matched.length);
    for (let l = 0; l < a; l++) {
        const f = t.matched[l];
        f && (n.matched.find(p => Vl(p, f)) ? r.push(f) : e.push(f));
        const h = n.matched[l];
        h && (t.matched.find(p => Vl(p, h)) || i.push(h))
    }
    return [e, r, i]
}
function U7() {
    return xs(Nm)
}
function $W(n) {
    return xs(D1)
}
var Zt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function j7(n) {
    return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n
}
function w2(n) {
    if (n.__esModule)
        return n;
    var t = n.default;
    if (typeof t == "function") {
        var e = function r() {
            return this instanceof r ? Reflect.construct(t, arguments, this.constructor) : t.apply(this, arguments)
        };
        e.prototype = t.prototype
    } else
        e = {};
    return Object.defineProperty(e, "__esModule", {
        value: !0
    }),
    Object.keys(n).forEach(function(r) {
        var i = Object.getOwnPropertyDescriptor(n, r);
        Object.defineProperty(e, r, i.get ? i : {
            enumerable: !0,
            get: function() {
                return n[r]
            }
        })
    }),
    e
}
var ut = {}
  , Rf = {}
  , pt = {}
  , vr = {}
  , Ie = {}
  , Dr = {}
  , sn = {};
Object.defineProperty(sn, "__esModule", {
    value: !0
});
sn.natsToSemitones = sn.semitonesToNats = sn.natsToCents = sn.centsToNats = sn.mtsBytesToHex = sn.mtsBytesToFrequency = sn.mtsBytesToMts = sn.frequencyToMtsBytes = sn.mtsToMtsBytes = sn.ftom = sn.ftomts = sn.mtof = sn.centOffsetToFrequency = sn.frequencyToCentOffset = sn.centsToValue = sn.valueToCents = void 0;
function E2(n) {
    return 1200 * Math.log2(n)
}
sn.valueToCents = E2;
function _2(n) {
    return Math.pow(2, n / 1200)
}
sn.centsToValue = _2;
function H7(n, t=440) {
    return E2(n / t)
}
sn.frequencyToCentOffset = H7;
function G7(n, t=440) {
    return _2(n) * t
}
sn.centOffsetToFrequency = G7;
const q1 = 69;
function L2(n) {
    return 440 * Math.pow(2, (n - q1) / 12)
}
sn.mtof = L2;
function S2(n, t=!1) {
    if (n <= 0)
        return 0;
    if (n > 13289.656616 && !t)
        return 127.999878;
    const e = q1 + 12 * Math.log2(n / 440);
    return Math.round(e * 1e6) / 1e6
}
sn.ftomts = S2;
function W7(n) {
    const t = q1 + 12 * Math.log2(n / 440)
      , e = Math.round(t)
      , r = (t - e) * 100;
    return [e, r]
}
sn.ftom = W7;
function A2(n) {
    if (n <= 0)
        return new Uint8Array([0, 0, 0]);
    if (n > 127.999878)
        return new Uint8Array([127, 127, 126]);
    const t = Math.trunc(n)
      , e = Math.round(16384 * (n - t))
      , r = new Uint8Array(3);
    return r[0] = t,
    r[1] = e >> 7 & 127,
    r[2] = e & 127,
    r
}
sn.mtsToMtsBytes = A2;
function J7(n) {
    const t = S2(n);
    return A2(t)
}
sn.frequencyToMtsBytes = J7;
function C2(n) {
    const t = n[1] > 127 ? 127 : n[1];
    let e = n[2];
    const r = n[0] > 127 ? 127 : n[0];
    r === 127 ? e >= 127 && (e = 126) : e > 127 && (e = 127);
    const i = ((t << 7) + e) / 16384;
    return r + i
}
sn.mtsBytesToMts = C2;
function K7(n) {
    const t = C2(n)
      , e = L2(t);
    return Math.round(e * 1e6) / 1e6
}
sn.mtsBytesToFrequency = K7;
function Z7(n) {
    const t = n[0] > 127 ? 127 : n[0]
      , e = n[1] > 127 ? 127 : n[1]
      , r = n[2] > 127 ? 127 : n[2];
    return t.toString(16).padStart(2, "0") + e.toString(16).padStart(2, "0") + r.toString(16).padStart(2, "0")
}
sn.mtsBytesToHex = Z7;
function Y7(n) {
    return n / 1200 * Math.LN2
}
sn.centsToNats = Y7;
function Q7(n) {
    return n / Math.LN2 * 1200
}
sn.natsToCents = Q7;
function X7(n) {
    return n / 12 * Math.LN2
}
sn.semitonesToNats = X7;
function eP(n) {
    return n / Math.LN2 * 12
}
sn.natsToSemitones = eP;
var jl = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.primeRange = n.primes = n.nthPrime = n.isPrime = n.BIG_INT_PRIMES = n.PRIME_CENTS = n.LOG_PRIMES = n.PRIMES = void 0,
    n.PRIMES = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009, 1013, 1019, 1021, 1031, 1033, 1039, 1049, 1051, 1061, 1063, 1069, 1087, 1091, 1093, 1097, 1103, 1109, 1117, 1123, 1129, 1151, 1153, 1163, 1171, 1181, 1187, 1193, 1201, 1213, 1217, 1223, 1229, 1231, 1237, 1249, 1259, 1277, 1279, 1283, 1289, 1291, 1297, 1301, 1303, 1307, 1319, 1321, 1327, 1361, 1367, 1373, 1381, 1399, 1409, 1423, 1427, 1429, 1433, 1439, 1447, 1451, 1453, 1459, 1471, 1481, 1483, 1487, 1489, 1493, 1499, 1511, 1523, 1531, 1543, 1549, 1553, 1559, 1567, 1571, 1579, 1583, 1597, 1601, 1607, 1609, 1613, 1619, 1621, 1627, 1637, 1657, 1663, 1667, 1669, 1693, 1697, 1699, 1709, 1721, 1723, 1733, 1741, 1747, 1753, 1759, 1777, 1783, 1787, 1789, 1801, 1811, 1823, 1831, 1847, 1861, 1867, 1871, 1873, 1877, 1879, 1889, 1901, 1907, 1913, 1931, 1933, 1949, 1951, 1973, 1979, 1987, 1993, 1997, 1999, 2003, 2011, 2017, 2027, 2029, 2039, 2053, 2063, 2069, 2081, 2083, 2087, 2089, 2099, 2111, 2113, 2129, 2131, 2137, 2141, 2143, 2153, 2161, 2179, 2203, 2207, 2213, 2221, 2237, 2239, 2243, 2251, 2267, 2269, 2273, 2281, 2287, 2293, 2297, 2309, 2311, 2333, 2339, 2341, 2347, 2351, 2357, 2371, 2377, 2381, 2383, 2389, 2393, 2399, 2411, 2417, 2423, 2437, 2441, 2447, 2459, 2467, 2473, 2477, 2503, 2521, 2531, 2539, 2543, 2549, 2551, 2557, 2579, 2591, 2593, 2609, 2617, 2621, 2633, 2647, 2657, 2659, 2663, 2671, 2677, 2683, 2687, 2689, 2693, 2699, 2707, 2711, 2713, 2719, 2729, 2731, 2741, 2749, 2753, 2767, 2777, 2789, 2791, 2797, 2801, 2803, 2819, 2833, 2837, 2843, 2851, 2857, 2861, 2879, 2887, 2897, 2903, 2909, 2917, 2927, 2939, 2953, 2957, 2963, 2969, 2971, 2999, 3001, 3011, 3019, 3023, 3037, 3041, 3049, 3061, 3067, 3079, 3083, 3089, 3109, 3119, 3121, 3137, 3163, 3167, 3169, 3181, 3187, 3191, 3203, 3209, 3217, 3221, 3229, 3251, 3253, 3257, 3259, 3271, 3299, 3301, 3307, 3313, 3319, 3323, 3329, 3331, 3343, 3347, 3359, 3361, 3371, 3373, 3389, 3391, 3407, 3413, 3433, 3449, 3457, 3461, 3463, 3467, 3469, 3491, 3499, 3511, 3517, 3527, 3529, 3533, 3539, 3541, 3547, 3557, 3559, 3571, 3581, 3583, 3593, 3607, 3613, 3617, 3623, 3631, 3637, 3643, 3659, 3671, 3673, 3677, 3691, 3697, 3701, 3709, 3719, 3727, 3733, 3739, 3761, 3767, 3769, 3779, 3793, 3797, 3803, 3821, 3823, 3833, 3847, 3851, 3853, 3863, 3877, 3881, 3889, 3907, 3911, 3917, 3919, 3923, 3929, 3931, 3943, 3947, 3967, 3989, 4001, 4003, 4007, 4013, 4019, 4021, 4027, 4049, 4051, 4057, 4073, 4079, 4091, 4093, 4099, 4111, 4127, 4129, 4133, 4139, 4153, 4157, 4159, 4177, 4201, 4211, 4217, 4219, 4229, 4231, 4241, 4243, 4253, 4259, 4261, 4271, 4273, 4283, 4289, 4297, 4327, 4337, 4339, 4349, 4357, 4363, 4373, 4391, 4397, 4409, 4421, 4423, 4441, 4447, 4451, 4457, 4463, 4481, 4483, 4493, 4507, 4513, 4517, 4519, 4523, 4547, 4549, 4561, 4567, 4583, 4591, 4597, 4603, 4621, 4637, 4639, 4643, 4649, 4651, 4657, 4663, 4673, 4679, 4691, 4703, 4721, 4723, 4729, 4733, 4751, 4759, 4783, 4787, 4789, 4793, 4799, 4801, 4813, 4817, 4831, 4861, 4871, 4877, 4889, 4903, 4909, 4919, 4931, 4933, 4937, 4943, 4951, 4957, 4967, 4969, 4973, 4987, 4993, 4999, 5003, 5009, 5011, 5021, 5023, 5039, 5051, 5059, 5077, 5081, 5087, 5099, 5101, 5107, 5113, 5119, 5147, 5153, 5167, 5171, 5179, 5189, 5197, 5209, 5227, 5231, 5233, 5237, 5261, 5273, 5279, 5281, 5297, 5303, 5309, 5323, 5333, 5347, 5351, 5381, 5387, 5393, 5399, 5407, 5413, 5417, 5419, 5431, 5437, 5441, 5443, 5449, 5471, 5477, 5479, 5483, 5501, 5503, 5507, 5519, 5521, 5527, 5531, 5557, 5563, 5569, 5573, 5581, 5591, 5623, 5639, 5641, 5647, 5651, 5653, 5657, 5659, 5669, 5683, 5689, 5693, 5701, 5711, 5717, 5737, 5741, 5743, 5749, 5779, 5783, 5791, 5801, 5807, 5813, 5821, 5827, 5839, 5843, 5849, 5851, 5857, 5861, 5867, 5869, 5879, 5881, 5897, 5903, 5923, 5927, 5939, 5953, 5981, 5987, 6007, 6011, 6029, 6037, 6043, 6047, 6053, 6067, 6073, 6079, 6089, 6091, 6101, 6113, 6121, 6131, 6133, 6143, 6151, 6163, 6173, 6197, 6199, 6203, 6211, 6217, 6221, 6229, 6247, 6257, 6263, 6269, 6271, 6277, 6287, 6299, 6301, 6311, 6317, 6323, 6329, 6337, 6343, 6353, 6359, 6361, 6367, 6373, 6379, 6389, 6397, 6421, 6427, 6449, 6451, 6469, 6473, 6481, 6491, 6521, 6529, 6547, 6551, 6553, 6563, 6569, 6571, 6577, 6581, 6599, 6607, 6619, 6637, 6653, 6659, 6661, 6673, 6679, 6689, 6691, 6701, 6703, 6709, 6719, 6733, 6737, 6761, 6763, 6779, 6781, 6791, 6793, 6803, 6823, 6827, 6829, 6833, 6841, 6857, 6863, 6869, 6871, 6883, 6899, 6907, 6911, 6917, 6947, 6949, 6959, 6961, 6967, 6971, 6977, 6983, 6991, 6997, 7001, 7013, 7019, 7027, 7039, 7043, 7057, 7069, 7079, 7103, 7109, 7121, 7127, 7129, 7151, 7159, 7177, 7187, 7193, 7207, 7211, 7213, 7219, 7229, 7237, 7243, 7247, 7253, 7283, 7297, 7307, 7309, 7321, 7331, 7333, 7349, 7351, 7369, 7393, 7411, 7417, 7433, 7451, 7457, 7459, 7477, 7481, 7487, 7489, 7499, 7507, 7517, 7523, 7529, 7537, 7541, 7547, 7549, 7559, 7561, 7573, 7577, 7583, 7589, 7591, 7603, 7607, 7621, 7639, 7643, 7649, 7669, 7673, 7681, 7687, 7691, 7699, 7703, 7717, 7723, 7727, 7741, 7753, 7757, 7759, 7789, 7793, 7817, 7823, 7829, 7841, 7853, 7867, 7873, 7877, 7879, 7883, 7901, 7907, 7919],
    n.LOG_PRIMES = n.PRIMES.map(Math.log);
    const t = 1200 / Math.LN2;
    n.PRIME_CENTS = n.LOG_PRIMES.map(l => l * t),
    n.PRIME_CENTS[0] = 1200,
    n.BIG_INT_PRIMES = n.PRIMES.map(BigInt);
    function e(l) {
        if (l < 7927)
            return n.PRIMES.includes(l);
        if (!Number.isInteger(l))
            return !1;
        if (l > 62837328)
            throw new Error("Prime check only implemented up to 62837328");
        for (const f of n.PRIMES) {
            if (f * f > l)
                return !0;
            if (l % f === 0)
                return !1
        }
        return !0
    }
    n.isPrime = e;
    function r(l) {
        if (l < n.PRIMES.length)
            return n.PRIMES[l];
        l -= n.PRIMES.length;
        let f = 7927;
        for (; l; ) {
            if (f += 4,
            l -= Number(e(f)),
            !l)
                return f;
            f += 2,
            l -= Number(e(f))
        }
        return f
    }
    n.nthPrime = r;
    function i(l, f) {
        if (f === void 0 && (f = l,
        l = 2),
        l > f || f < 2)
            return [];
        if (l <= 2) {
            if (f < 3)
                return [2];
            l = 2
        } else
            for (l = Math.ceil((l + 1) * .5) * 2 - 1; !e(l); )
                l += 2;
        for (f = Math.floor((f + 1) * .5) * 2 - 1; !e(f); )
            f -= 2;
        const h = n.PRIMES.indexOf(l)
          , p = n.PRIMES.indexOf(f);
        let m;
        if (p < 0)
            h >= 0 ? (m = n.PRIMES.slice(h),
            l = 7927) : m = [];
        else
            return n.PRIMES.slice(h, p + 1);
        for (let g = l; g <= f; g += 2)
            e(g) && m.push(g);
        return m
    }
    n.primes = i;
    function a(l, f) {
        if (f === void 0 && (f = l,
        l = 0),
        l = Math.round(Math.max(0, l)),
        f = Math.round(f),
        f <= l)
            return [];
        if (f <= n.PRIMES.length)
            return n.PRIMES.slice(l, f);
        const h = n.PRIMES.slice(l);
        l = Math.max(0, l - n.PRIMES.length),
        f -= n.PRIMES.length;
        let p = 7927, m, g = 4, b = 2;
        for (; l; ) {
            if (p += 4,
            m = Number(e(p)),
            l -= m,
            f -= m,
            !l) {
                g = 2,
                b = 4;
                break
            }
            p += 2,
            m = Number(e(p)),
            l -= m,
            f -= m
        }
        for (; f; ) {
            if (e(p) && (h.push(p),
            f--,
            !f))
                return h;
            p += g,
            e(p) && (h.push(p),
            f--),
            p += b
        }
        return h
    }
    n.primeRange = a
}
)(jl);
Object.defineProperty(Dr, "__esModule", {
    value: !0
});
Dr.Fraction = Dr.modc = Dr.mmod = Dr.lcm = Dr.gcd = void 0;
const dE = sn
  , hE = jl
  , tP = 1e3
  , nP = 128;
function Gr(n, t) {
    if (!n)
        return t;
    if (!t)
        return n;
    for (; ; ) {
        if (n %= t,
        !n)
            return t;
        if (t %= n,
        !t)
            return n
    }
}
Dr.gcd = Gr;
function ya(n, t) {
    return n && n / Gr(n, t) * t
}
Dr.lcm = ya;
function Kd(n, t) {
    return (n % t + t) % t
}
Dr.mmod = Kd;
function rP(n, t) {
    return t && ((n % t + t) % t || t)
}
Dr.modc = rP;
class bt {
    constructor(t, e) {
        if (e !== void 0) {
            if (typeof t != "number")
                throw new Error("Numerator must be a number when denominator is given");
            if (isNaN(t) || isNaN(e))
                throw new Error("Cannot represent NaN as a fraction");
            if (this.s = Math.sign(t * e),
            this.n = Math.abs(t),
            this.d = Math.abs(e),
            this.screenInfinity(),
            this.d > Number.MAX_SAFE_INTEGER)
                throw new Error("Denominator above safe limit");
            if (this.n > Number.MAX_SAFE_INTEGER)
                throw isFinite(this.n) ? new Error("Numerator above safe limit") : new Error("Cannot represent Infinity as a fraction");
            if (this.d === 0)
                throw new Error("Division by Zero");
            this.defloat()
        } else if (typeof t == "number") {
            if (isNaN(t))
                throw new Error("Cannot represent NaN as a fraction");
            if (this.s = Math.sign(t),
            this.n = Math.abs(t),
            this.d = 1,
            !isFinite(this.n))
                throw new Error("Cannot represent Infinity as a fraction");
            this.defloat()
        } else if (typeof t == "string") {
            t = t.toLowerCase(),
            this.d = 1;
            let r;
            if (t.includes("e") && ([t,r] = t.split("e", 2)),
            t.includes("/")) {
                if (this.n = 1,
                t.includes("."))
                    throw new Error("Parameters must be integer");
                const [i,a] = t.split("/", 2);
                i === "-" ? this.n *= -1 : this.n *= i ? parseInt(i, 10) : 1,
                this.d *= a ? parseInt(a, 10) : 1,
                this.s = Math.sign(this.n * this.d),
                this.n = Math.abs(this.n),
                this.d = Math.abs(this.d)
            } else if (t.includes(".")) {
                let[i,a] = t.split(".", 2), l;
                if ([a,l] = a.split("'", 2),
                i.startsWith("-") ? (this.s = -1,
                i = i.slice(1)) : this.s = 1,
                i.startsWith("-"))
                    throw new Error("Double sign");
                this.n = 0;
                for (const f of a.split("").reverse()) {
                    if (this.n += this.d * parseInt(f, 10),
                    this.d *= 10,
                    this.d > Number.MAX_SAFE_INTEGER)
                        throw new Error("Decimal string too complex");
                    const h = Gr(this.n, this.d);
                    this.n /= h,
                    this.d /= h
                }
                if (i && (this.n += parseInt(i, 10) * this.d),
                l && (l = l.replace(/'/g, ""),
                l.length)) {
                    const f = parseInt(l, 10);
                    if (f > Number.MAX_SAFE_INTEGER)
                        throw new Error("Cycle too long");
                    const h = (10 ** l.length - 1) * 10 ** a.length
                      , p = Gr(h, this.d);
                    this.d /= p,
                    this.n = this.n * (h / p) + this.d * f,
                    this.d *= h
                }
                this.n || (this.s = 0)
            } else
                this.n = parseInt(t, 10),
                this.s = Math.sign(this.n),
                this.n = Math.abs(this.n);
            if (this.d === 0)
                throw new Error("Division by Zero");
            if (r) {
                const i = parseInt(r, 10);
                i > 0 ? this.n *= 10 ** i : i < 0 && (this.d *= 10 ** -i)
            }
            this.validate(),
            this.reduce()
        } else {
            if (t.d === 0)
                throw new Error("Division by Zero");
            "s"in t ? this.s = Math.sign(t.s) : this.s = 1,
            t.d < 0 && (this.s = -this.s),
            t.n < 0 ? this.s = -this.s : t.n === 0 && (this.s = 0),
            this.n = Math.abs(t.n),
            this.d = Math.abs(t.d),
            this.screenInfinity(),
            this.validate(),
            this.reduce()
        }
    }
    validate() {
        if (isNaN(this.s) || isNaN(this.n) || isNaN(this.d))
            throw new Error("Cannot represent NaN as a fraction");
        if (this.n > Number.MAX_SAFE_INTEGER)
            throw isFinite(this.n) ? new Error("Numerator above safe limit") : new Error("Cannot represent Infinity as a fraction");
        if (this.d > Number.MAX_SAFE_INTEGER)
            throw new Error("Denominator above safe limit")
    }
    defloat() {
        for (; this.n !== Math.floor(this.n) || this.d !== Math.floor(this.d); )
            this.n *= 2,
            this.d *= 2;
        if (this.n > Number.MAX_SAFE_INTEGER || this.d > Number.MAX_SAFE_INTEGER) {
            let t = this.n / this.d;
            const e = [];
            for (let i = 0; i < 20; ++i) {
                const a = Math.floor(t);
                if (a > 1e12 || (e.push(a),
                t === a))
                    break;
                t = 1 / (t - a)
            }
            if (!e.length)
                throw new Error("Numerator above safe limit");
            let r = 1;
            for (; r <= e.length; ) {
                let i = e[e.length - r]
                  , a = 1;
                for (let l = e.length - r - 1; l >= 0; --l)
                    [i,a] = [a + i * e[l], i];
                if (this.n = i,
                this.d = a,
                i <= Number.MAX_SAFE_INTEGER && a <= Number.MAX_SAFE_INTEGER)
                    break;
                r++
            }
        }
        this.reduce()
    }
    reduce() {
        const t = Gr(this.n, this.d);
        this.n /= t,
        this.d /= t
    }
    screenInfinity() {
        if (!isFinite(this.d)) {
            if (!isFinite(this.n))
                throw new Error("Cannot represent NaN as a fraction");
            this.s = 0,
            this.n = 0,
            this.d = 1
        }
    }
    toString() {
        let t = this.s < 0 ? "-" : "";
        const e = Math.floor(this.n / this.d);
        t += e.toString();
        let r = this.abs().sub(e);
        if (r.n === 0)
            return t;
        t += ".";
        let i = "";
        const a = [r];
        for (let l = 0; l < nP; ++l) {
            r = r.mul(10);
            const f = Math.floor(r.n / r.d);
            if (i += f.toString(),
            r = r.sub(f),
            r.n === 0)
                return t + i;
            for (let h = 0; h < a.length; ++h)
                if (r.equals(a[h]))
                    return t + i.slice(0, h) + "'" + i.slice(h) + "'";
            a.push(r)
        }
        return t + i + "..."
    }
    toJSON() {
        return {
            n: this.n * this.s,
            d: this.d
        }
    }
    static reviver(t, e) {
        return typeof e == "object" && e !== null && "n"in e && Number.isInteger(e.n) && "d"in e && Number.isInteger(e.d) && Object.keys(e).length === 2 ? new bt(e) : e
    }
    toContinued() {
        const t = [];
        let e = this.n
          , r = this.d;
        for (let i = 0; i < tP; ++i) {
            const a = Math.floor(e / r);
            if (t.push(a),
            [e,r] = [r, e - a * r],
            e === 1)
                break
        }
        return t
    }
    abs() {
        return new bt({
            s: Math.abs(this.s),
            n: this.n,
            d: this.d
        })
    }
    valueOf() {
        return this.s * this.n / this.d
    }
    inverse() {
        if (this.n === 0)
            throw new Error("Division by Zero");
        return new bt({
            s: this.s,
            n: this.d,
            d: this.n
        })
    }
    neg() {
        return new bt({
            s: -this.s,
            n: this.n,
            d: this.d
        })
    }
    toFraction() {
        const t = this.s * this.n;
        return this.d === 1 ? t.toString() : `${t}/${this.d}`
    }
    clone() {
        return new bt(this)
    }
    simplify(t=.001) {
        const e = this.abs()
          , r = e.toContinued()
          , i = e.valueOf();
        for (let a = 1; a < r.length; a++) {
            let l = new bt({
                s: 1,
                n: r[a - 1],
                d: 1
            });
            for (let f = a - 2; f >= 0; f--)
                l = l.inverse().add(r[f]);
            if (Math.abs(l.valueOf() - i) <= t)
                return new bt({
                    s: this.s,
                    n: l.n,
                    d: l.d
                })
        }
        return this.clone()
    }
    simplifyRelative(t=3.5) {
        const e = this.abs()
          , r = e.toContinued()
          , i = (0,
        dE.valueToCents)(e.valueOf());
        for (let a = 1; a < r.length; a++) {
            let l = new bt({
                s: 1,
                n: r[a - 1],
                d: 1
            });
            for (let f = a - 2; f >= 0; f--)
                l = l.inverse().add(r[f]);
            if (Math.abs((0,
            dE.valueToCents)(l.valueOf()) - i) <= t)
                return new bt({
                    s: this.s,
                    n: l.n,
                    d: l.d
                })
        }
        return this.clone()
    }
    floor() {
        if (this.d > Number.MAX_SAFE_INTEGER)
            return new bt(Math.floor(this.valueOf()));
        const t = this.s * this.n
          , e = Kd(t, this.d);
        return new bt((t - e) / this.d)
    }
    ceil() {
        if (this.d > Number.MAX_SAFE_INTEGER)
            return new bt(Math.ceil(this.valueOf()));
        const t = this.s * this.n
          , e = Kd(t, this.d);
        return e ? new bt(1 + (t - e) / this.d) : this
    }
    round() {
        try {
            return this.add(new bt({
                s: 1,
                n: 1,
                d: 2
            })).floor()
        } catch {
            return new bt(Math.round(this.valueOf()))
        }
    }
    roundTo(t) {
        const {n: e, d: r} = new bt(t);
        return new bt(this.s * Math.round(this.n * r / (this.d * e)) * e,r)
    }
    add(t) {
        const {s: e, n: r, d: i} = new bt(t)
          , a = Gr(this.d, i)
          , l = i / a;
        return new bt(this.s * this.n * l + e * r * (this.d / a),l * this.d)
    }
    sub(t) {
        const {s: e, n: r, d: i} = new bt(t)
          , a = Gr(this.d, i)
          , l = i / a;
        return new bt(this.s * this.n * l - e * r * (this.d / a),l * this.d)
    }
    lensAdd(t) {
        const {s: e, n: r, d: i} = new bt(t);
        if (!r || !this.n)
            return new bt({
                s: 0,
                n: 0,
                d: 1
            });
        const a = ya(this.n, r);
        return new bt(this.s * e * a,a / r * i + a / this.n * this.d)
    }
    lensSub(t) {
        const {s: e, n: r, d: i} = new bt(t);
        if (!r || !this.n)
            return new bt({
                s: 0,
                n: 0,
                d: 1
            });
        const a = ya(this.n, r);
        return new bt(this.s * e * a,a / this.n * this.d - a / r * i)
    }
    mul(t) {
        const {s: e, n: r, d: i} = new bt(t)
          , a = Gr(this.n, i)
          , l = Gr(this.d, r);
        return new bt(this.s * (this.n / a) * e * (r / l),this.d / l * (i / a))
    }
    div(t) {
        const {s: e, n: r, d: i} = new bt(t);
        if (r === 0)
            throw new Error("Division by Zero");
        const a = Gr(this.n, r)
          , l = Gr(this.d, i);
        return new bt(this.s * (this.n / a) * e * (i / l),this.d / l * (r / a))
    }
    mod(t) {
        const {n: e, d: r} = new bt(t)
          , i = ya(this.d, r);
        return new bt(this.s * (i / this.d * this.n) % (e * (i / r)),i)
    }
    mmod(t) {
        const {n: e, d: r} = new bt(t)
          , i = ya(this.d, r);
        return new bt(Kd(this.s * (i / this.d * this.n), e * (i / r)),i)
    }
    sqrt() {
        if (this.s < 0)
            return null;
        const t = Math.round(Math.sqrt(this.n));
        if (t * t !== this.n)
            return null;
        const e = Math.round(Math.sqrt(this.d));
        return e * e !== this.d ? null : new bt(t,e)
    }
    pow(t) {
        const {s: e, n: r, d: i} = new bt(t);
        if (e === 0)
            return new bt(1);
        if (i === 1)
            return e < 0 ? new bt((this.s * this.d) ** r,this.n ** r) : new bt((this.s * this.n) ** r,this.d ** r);
        if (this.s === 0)
            return new bt(0);
        if (this.s < 0 && i % 2 === 0)
            return null;
        if (this.n === 1)
            return this.s > 0 ? new bt(1) : new bt(-1);
        if (r === 1 && i === 2) {
            const m = this.sqrt();
            return m ? e > 0 ? m : m.inverse() : null
        }
        let a = 1
          , l = 1
          , f = 0
          , h = r % 2 ? this.s : 1
          , p = 1;
        do {
            if (f >= hE.PRIMES.length)
                return null;
            let m = -1;
            const g = hE.PRIMES[f]
              , b = g ** i;
            let E;
            do
                E = a,
                a *= b,
                m++;
            while (this.n % a === 0);
            a = E;
            for (let S = 1; S < i; ++S)
                if (E *= g,
                this.n % E === 0)
                    return null;
            if (m) {
                h *= g ** (r * m),
                f++;
                continue
            }
            m = -1;
            do
                E = l,
                l *= b,
                m++;
            while (this.d % l === 0);
            l = E;
            for (let S = 1; S < i; ++S)
                if (E *= g,
                this.d % E === 0)
                    return null;
            p *= g ** (r * m),
            f++
        } while (a !== this.n || l !== this.d);
        return e > 0 ? new bt(h,p) : new bt(p,h)
    }
    compare(t) {
        try {
            const {s: e, n: r, d: i} = new bt(t);
            return this.s * this.n * i - e * r * this.d
        } catch {
            return NaN
        }
    }
    equals(t) {
        try {
            const {s: e, n: r, d: i} = new bt(t);
            return this.s === e && this.n === r && this.d === i
        } catch {
            return !1
        }
    }
    divisible(t) {
        try {
            const {n: e, d: r} = new bt(t)
              , i = Gr(this.n, e)
              , a = Gr(this.d, r);
            return !(!e || this.n / i * (r / a) % (e / i * (this.d / a)))
        } catch {
            return !1
        }
    }
    gcd(t) {
        const {n: e, d: r} = new bt(t);
        return new bt(Gr(e, this.n),ya(this.d, r))
    }
    lcm(t) {
        const {s: e, n: r, d: i} = new bt(t)
          , a = new bt(ya(r, this.n),Gr(i, this.d));
        return a.s = this.s * e,
        a
    }
    geoMod(t) {
        let {s: e, n: r, d: i} = this;
        const {s: a, n: l, d: f} = new bt(t);
        if (l === f)
            throw new Error("Geometric modulo by 1");
        let h = Math.floor(Math.log(r / i) / Math.log(l / f));
        if (isNaN(h) || !isFinite(h))
            throw new Error("Unable to calculate geometric modulo.");
        return h > 0 ? (r *= f ** h,
        i *= l ** h) : h < 0 && (r *= l ** -h,
        i *= f ** -h),
        l > f ? (r * f >= i * l && (h++,
        r *= f,
        i *= l),
        r < i && (h--,
        r *= l,
        i *= f)) : (r * f <= i * l && (h++,
        r *= f,
        i *= l),
        r > i && (h--,
        r *= l,
        i *= f)),
        e *= a ** h,
        new bt({
            s: e,
            n: r,
            d: i
        })
    }
    isUnity() {
        return this.s === 1 && this.n === 1 && this.d === 1
    }
    gabs() {
        return this.n < this.d ? new bt({
            n: this.d,
            d: this.n
        }) : this.abs()
    }
    gcr(t, e=100) {
        let r = this.gabs()
          , i = new bt(t).gabs();
        if (r.isUnity())
            return i;
        if (i.isUnity())
            return r;
        for (let a = 0; a < e; ++a)
            try {
                if (r = r.geoMod(i),
                r.isUnity())
                    return i;
                if (i = i.geoMod(r),
                i.isUnity())
                    return r
            } catch {
                return null
            }
        return null
    }
    log(t, e=100) {
        const r = new bt(t);
        if (r.isUnity())
            return this.isUnity() ? new bt(1) : null;
        const i = this.gcr(r, e);
        if (i === null)
            return null;
        const a = 1 / Math.log(i.n / i.d)
          , l = Math.round(Math.log(this.n / this.d) * a)
          , f = Math.round(Math.log(r.n / r.d) * a);
        if (r.s < 0) {
            if (f % 2 === 0)
                return null;
            if (l % 2) {
                if (this.s > 0)
                    return null
            } else if (this.s < 0)
                return null
        } else if (this.s < 0)
            return null;
        return new bt({
            n: l,
            d: f
        })
    }
    lcr(t, e=100) {
        const r = new bt(t)
          , i = this.gcr(t, e);
        if (i === null)
            return null;
        if (i.isUnity())
            return new bt(1);
        const a = 1 / Math.log(i.n / i.d)
          , l = Math.round(Math.log(this.n / this.d) * a)
          , f = Math.round(Math.log(r.n / r.d) * a);
        return i.pow(l * f)
    }
    geoRoundTo(t) {
        const e = new bt(t);
        let r = Math.log(this.n / this.d) / Math.log(e.n / e.d);
        if (this.s === 0)
            return this.clone();
        if (this.s < 0) {
            if (e.s > 0)
                return null;
            r = Math.round((r + 1) * .5) * 2 - 1
        } else
            e.s < 0 ? r = Math.round(r * .5) * 2 : r = Math.round(r);
        return e.pow(r)
    }
}
Dr.Fraction = bt;
var Tt = {};
Object.defineProperty(Tt, "__esModule", {
    value: !0
});
Tt.primeFactorize = Tt.toMonzoAndResidual = Tt.primeLimit = Tt.monzoToBigNumeratorDenominator = Tt.monzoToBigInt = Tt.monzoToFraction = Tt.toMonzo = Tt.rescale = Tt.decumulate = Tt.accumulate = Tt.unapplyWeights = Tt.applyWeights = Tt.fractionalNorm = Tt.fractionalDot = Tt.fractionalScale = Tt.scale = Tt.fractionalSub = Tt.sub = Tt.fractionalAdd = Tt.add = Tt.fractionalMonzosEqual = Tt.monzosEqual = Tt.bigAbs = void 0;
const ar = Dr
  , Dn = jl
  , B1 = 2 ** 31;
function $2(n) {
    return n < 0n ? -n : n
}
Tt.bigAbs = $2;
function sP(n, t) {
    if (n === t)
        return !0;
    for (let e = Math.min(n.length, t.length) - 1; e >= 0; --e)
        if (n[e] !== t[e])
            return !1;
    if (n.length > t.length) {
        for (let e = t.length; e < n.length; ++e)
            if (n[e])
                return !1
    }
    if (t.length > n.length) {
        for (let e = n.length; e < t.length; ++e)
            if (t[e])
                return !1
    }
    return !0
}
Tt.monzosEqual = sP;
function iP(n, t) {
    if (n === t)
        return !0;
    for (let e = Math.min(n.length, t.length) - 1; e >= 0; --e)
        if (!new ar.Fraction(n[e]).equals(t[e]))
            return !1;
    if (n.length > t.length) {
        for (let e = t.length; e < n.length; ++e)
            if (new ar.Fraction(n[e]).n)
                return !1
    }
    if (t.length > n.length) {
        for (let e = n.length; e < t.length; ++e)
            if (new ar.Fraction(t[e]).n)
                return !1
    }
    return !0
}
Tt.fractionalMonzosEqual = iP;
function oP(n, t) {
    const e = [...n];
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] += t[r];
    return e.push(...t.slice(e.length)),
    e
}
Tt.add = oP;
function aP(n, t) {
    const e = n.map(r => new ar.Fraction(r));
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] = e[r].add(t[r]);
    for (; e.length < t.length; )
        e.push(new ar.Fraction(t[e.length]));
    return e
}
Tt.fractionalAdd = aP;
function M2(n, t) {
    const e = [...n];
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] -= t[r];
    for (; e.length < t.length; )
        e.push(-t[e.length]);
    return e
}
Tt.sub = M2;
function lP(n, t) {
    const e = n.map(r => new ar.Fraction(r));
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] = e[r].sub(t[r]);
    for (; e.length < t.length; )
        e.push(new ar.Fraction(t[e.length]).neg());
    return e
}
Tt.fractionalSub = lP;
function uP(n, t) {
    return n.map(e => e * t)
}
Tt.scale = uP;
function cP(n, t) {
    return n.map(e => new ar.Fraction(e).mul(t))
}
Tt.fractionalScale = cP;
function fP(n, t) {
    let e = new ar.Fraction(0);
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e = e.add(new ar.Fraction(n[r]).mul(t[r]));
    return e
}
Tt.fractionalDot = fP;
function dP(n, t="L2") {
    let e = new ar.Fraction(0);
    for (let r = 0; r < n.length; ++r) {
        const i = new ar.Fraction(n[r]).abs();
        t === "taxicab" ? e = e.add(i) : t === "maximum" ? e.compare(i) < 0 && (e = i) : e = e.add(i.mul(i))
    }
    return e
}
Tt.fractionalNorm = dP;
function hP(n, t) {
    const e = [...n];
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] *= t[r];
    return e
}
Tt.applyWeights = hP;
function pP(n, t) {
    const e = [...n];
    for (let r = Math.min(n.length, t.length) - 1; r >= 0; --r)
        e[r] /= t[r];
    return e
}
Tt.unapplyWeights = pP;
function mP(n, t) {
    for (let e = 0; e < Math.min(n.length, t.length); ++e)
        n[e] += t[e];
    return n
}
Tt.accumulate = mP;
function gP(n, t) {
    for (let e = 0; e < Math.min(n.length, t.length); ++e)
        n[e] -= t[e];
    return n
}
Tt.decumulate = gP;
function vP(n, t) {
    for (let e = 0; e < n.length; ++e)
        n[e] *= t;
    return n
}
Tt.rescale = vP;
function L0(n) {
    if (typeof n == "bigint")
        return yP(n);
    if (typeof n != "number") {
        if (n = new ar.Fraction(n),
        n.s !== 1)
            throw new Error(`Cannot convert fraction ${n.toFraction()} to monzo`);
        return M2(L0(n.n), L0(n.d))
    }
    if (n < 1 || Math.round(n) !== n)
        throw new Error(`Cannot convert number ${n} to monzo`);
    if (n === 1)
        return [];
    const t = [0];
    let e = 1
      , r = 0;
    if (n < B1) {
        if (e = (n ^ n - 1) & n,
        t[0] = Math.log2(e),
        n === e)
            return t;
        t.push(0),
        r = 1
    }
    for (; ; ) {
        const i = e;
        if (e *= Dn.PRIMES[r],
        n % e) {
            if (e = i,
            t.push(0),
            r++,
            r >= Dn.PRIMES.length)
                throw new Error("Out of primes")
        } else {
            if (n === e)
                return t[r]++,
                t;
            t[r]++
        }
    }
}
Tt.toMonzo = L0;
function yP(n) {
    if (n < 1n)
        throw new Error("Cannot convert non-positive big integer to monzo");
    if (n === 1n)
        return [];
    const t = [0];
    let e = 1n
      , r = 0;
    for (; ; ) {
        const i = e;
        if (e *= Dn.BIG_INT_PRIMES[r],
        n % e) {
            if (e = i,
            t.push(0),
            r++,
            r >= Dn.BIG_INT_PRIMES.length)
                throw new Error("Out of primes")
        } else {
            if (n === e)
                return t[r]++,
                t;
            t[r]++
        }
    }
}
function bP(n) {
    let t = 1
      , e = 1
      , r = 0;
    for (const i of n)
        i > 0 && (t *= Dn.PRIMES[r] ** i),
        i < 0 && (e *= Dn.PRIMES[r] ** -i),
        r++;
    return new ar.Fraction(t,e)
}
Tt.monzoToFraction = bP;
function wP(n) {
    let t = 1n
      , e = 0;
    for (const r of n) {
        if (r > 0 && (t *= Dn.BIG_INT_PRIMES[e] ** BigInt(r)),
        r < 0)
            throw new Error("Cannot produce big fractions");
        e++
    }
    return t
}
Tt.monzoToBigInt = wP;
function EP(n) {
    let t = 1n
      , e = 1n
      , r = 0;
    for (const i of n)
        i > 0 && (t *= Dn.BIG_INT_PRIMES[r] ** BigInt(i)),
        i < 0 && (e *= Dn.BIG_INT_PRIMES[r] ** BigInt(-i)),
        r++;
    return {
        numerator: t,
        denominator: e
    }
}
Tt.monzoToBigNumeratorDenominator = EP;
function S0(n, t=!1, e=7919) {
    if (typeof n == "bigint")
        return _P(n, t, e);
    if (typeof n != "number")
        return n = new ar.Fraction(n),
        Math.max(S0(n.n, t, e), S0(n.d, t, e));
    if (n < 1 || Math.round(n) !== n)
        return NaN;
    if (n === 1)
        return t ? 0 : 1;
    let r = 1
      , i = 0;
    if (n < B1) {
        if (r = (n ^ n - 1) & n,
        n === r)
            return t ? 1 : 2;
        i = 1
    }
    for (; ; ) {
        const a = r;
        if (r *= Dn.PRIMES[i],
        n % r) {
            if (r = a,
            i++,
            i >= Dn.PRIMES.length || Dn.PRIMES[i] > e)
                return 1 / 0
        } else if (n === r)
            return t ? i + 1 : Dn.PRIMES[i]
    }
}
Tt.primeLimit = S0;
function _P(n, t, e) {
    if (n < 1n)
        return NaN;
    if (n === 1n)
        return t ? 0 : 1;
    let r = (n ^ n - 1n) & n;
    if (n === r)
        return t ? 1 : 2;
    let i = 1;
    for (; ; ) {
        const a = r;
        if (r *= Dn.BIG_INT_PRIMES[i],
        n % r) {
            if (r = a,
            i++,
            i >= Dn.PRIMES.length || Dn.PRIMES[i] > e)
                return 1 / 0
        } else if (n === r)
            return t ? i + 1 : Dn.PRIMES[i]
    }
}
function LP(n, t) {
    if (typeof n == "bigint")
        return SP(n, t);
    if (n = new ar.Fraction(n),
    !n.n)
        return [Array(t).fill(0), new ar.Fraction(0)];
    let[e,r] = A0(n.n)
      , [i,a] = A0(n.d);
    const l = Array(t).fill(-1);
    l[0] = e[0] - i[0],
    l[1] = e[1] - i[1],
    l[2] = e[2] - i[2],
    l[3] = e[3] - i[3];
    let f = 1
      , h = 1;
    for (let m = 4; m < t; ++m) {
        let g;
        do
            g = f,
            f *= Dn.PRIMES[m],
            l[m]++;
        while (r % f === 0);
        if (f = g,
        !l[m]) {
            l[m] = 1;
            do
                g = h,
                h *= Dn.PRIMES[m],
                l[m]--;
            while (a % h === 0);
            h = g
        }
    }
    for (r /= f,
    a /= h; l.length > t; ) {
        const m = l.pop();
        m > 0 ? r *= Dn.PRIMES[l.length] ** m : m < 0 && (a *= Dn.PRIMES[l.length] ** -m)
    }
    const p = new ar.Fraction(r,a);
    return p.s = n.s,
    [l, p]
}
Tt.toMonzoAndResidual = LP;
function SP(n, t) {
    if (!n)
        return [Array(t).fill(0), 0n];
    let[e,r] = $P($2(n))
      , i = 1n;
    for (let a = 4; a < t; ++a) {
        e.push(-1);
        let l;
        do
            l = i,
            i *= Dn.BIG_INT_PRIMES[a],
            e[a]++;
        while (r % i === 0n);
        i = l
    }
    for (r /= i; e.length > t; ) {
        const a = e.pop();
        r *= Dn.BIG_INT_PRIMES[e.length] ** BigInt(a)
    }
    return [e, n < 0n ? -r : r]
}
const Ae = [0, 0, 0, 0]
  , Ft = [0, 1, 0, 0]
  , nn = [0, 0, 1, 0]
  , kn = [0, 0, 0, 1]
  , zn = [0, 2, 0, 0]
  , $s = [0, 1, 1, 0]
  , Eo = [0, 1, 0, 1]
  , ml = [0, 0, 1, 1]
  , gl = [0, 2, 1, 0]
  , Sd = [0, 2, 0, 1]
  , pE = [0, 1, 1, 1]
  , AP = [0, 2, 1, 1]
  , O2 = [[315, AP], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [5, nn], [3, Ft], [7, kn], [1, Ae], [9, zn], [5, nn], [1, Ae], [3, Ft], [1, Ae], [7, kn], [15, $s], [1, Ae], [1, Ae], [9, zn], [1, Ae], [5, nn], [21, Eo], [1, Ae], [1, Ae], [3, Ft], [5, nn], [1, Ae], [9, zn], [7, kn], [1, Ae], [15, $s], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [35, ml], [9, zn], [1, Ae], [1, Ae], [3, Ft], [5, nn], [1, Ae], [21, Eo], [1, Ae], [1, Ae], [45, gl], [1, Ae], [1, Ae], [3, Ft], [7, kn], [5, nn], [3, Ft], [1, Ae], [1, Ae], [9, zn], [5, nn], [7, kn], [3, Ft], [1, Ae], [1, Ae], [15, $s], [1, Ae], [1, Ae], [63, Sd], [1, Ae], [5, nn], [3, Ft], [1, Ae], [1, Ae], [3, Ft], [35, ml], [1, Ae], [9, zn], [1, Ae], [1, Ae], [15, $s], [1, Ae], [7, kn], [3, Ft], [1, Ae], [5, nn], [9, zn], [1, Ae], [1, Ae], [21, Eo], [5, nn], [1, Ae], [3, Ft], [1, Ae], [1, Ae], [45, gl], [7, kn], [1, Ae], [3, Ft], [1, Ae], [5, nn], [3, Ft], [1, Ae], [7, kn], [9, zn], [5, nn], [1, Ae], [3, Ft], [1, Ae], [1, Ae], [105, pE], [1, Ae], [1, Ae], [9, zn], [1, Ae], [5, nn], [3, Ft], [7, kn], [1, Ae], [3, Ft], [5, nn], [1, Ae], [9, zn], [1, Ae], [7, kn], [15, $s], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [5, nn], [63, Sd], [1, Ae], [1, Ae], [3, Ft], [5, nn], [1, Ae], [3, Ft], [7, kn], [1, Ae], [45, gl], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [35, ml], [3, Ft], [1, Ae], [1, Ae], [9, zn], [5, nn], [1, Ae], [21, Eo], [1, Ae], [1, Ae], [15, $s], [1, Ae], [1, Ae], [9, zn], [7, kn], [5, nn], [3, Ft], [1, Ae], [1, Ae], [3, Ft], [5, nn], [7, kn], [9, zn], [1, Ae], [1, Ae], [15, $s], [1, Ae], [1, Ae], [21, Eo], [1, Ae], [5, nn], [9, zn], [1, Ae], [1, Ae], [3, Ft], [35, ml], [1, Ae], [3, Ft], [1, Ae], [1, Ae], [45, gl], [1, Ae], [7, kn], [3, Ft], [1, Ae], [5, nn], [3, Ft], [1, Ae], [1, Ae], [63, Sd], [5, nn], [1, Ae], [3, Ft], [1, Ae], [1, Ae], [15, $s], [7, kn], [1, Ae], [9, zn], [1, Ae], [5, nn], [3, Ft], [1, Ae], [7, kn], [3, Ft], [5, nn], [1, Ae], [9, zn], [1, Ae], [1, Ae], [105, pE], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [5, nn], [9, zn], [7, kn], [1, Ae], [3, Ft], [5, nn], [1, Ae], [3, Ft], [1, Ae], [7, kn], [45, gl], [1, Ae], [1, Ae], [3, Ft], [1, Ae], [5, nn], [21, Eo], [1, Ae], [1, Ae], [9, zn], [5, nn], [1, Ae], [3, Ft], [7, kn], [1, Ae], [15, $s], [1, Ae], [1, Ae], [9, zn], [1, Ae], [35, ml], [3, Ft], [1, Ae], [1, Ae], [3, Ft], [5, nn], [1, Ae], [63, Sd], [1, Ae], [1, Ae], [15, $s], [1, Ae], [1, Ae], [3, Ft], [7, kn], [5, nn], [9, zn], [1, Ae], [1, Ae], [3, Ft], [5, nn], [7, kn], [3, Ft], [1, Ae], [1, Ae], [45, gl], [1, Ae], [1, Ae], [21, Eo], [1, Ae], [5, nn], [3, Ft], [1, Ae], [1, Ae], [9, zn], [35, ml], [1, Ae], [3, Ft], [1, Ae], [1, Ae], [15, $s], [1, Ae], [7, kn], [9, zn], [1, Ae], [5, nn], [3, Ft], [1, Ae], [1, Ae], [21, Eo], [5, nn], [1, Ae], [9, zn], [1, Ae], [1, Ae], [15, $s], [7, kn], [1, Ae], [3, Ft], [1, Ae], [5, nn], [9, zn], [1, Ae], [7, kn], [3, Ft], [5, nn], [1, Ae], [3, Ft], [1, Ae], [1, Ae]]
  , CP = O2.map(n => [BigInt(n[0]), n[1]]);
function A0(n) {
    const t = [0, 0, 0, 0];
    if (n < B1) {
        const e = (n ^ n - 1) & n;
        n /= e,
        t[0] = Math.log2(e)
    } else
        for (; !(n % 2); )
            t[0]++,
            n /= 2;
    for (; ; ) {
        const [e,r] = O2[n % 315];
        if (e === 1)
            break;
        n /= e,
        t[1] += r[1],
        t[2] += r[2],
        t[3] += r[3]
    }
    return [t, n]
}
function $P(n) {
    const t = [0, 0, 0, 0]
      , e = (n ^ n - 1n) & n;
    if (n /= e,
    t[0] += Math.log2(Number(e)),
    t[0] === 1 / 0) {
        t[0] = 0;
        let r = 1n;
        for (; r < e; )
            t[0]++,
            r <<= 1n
    }
    for (; ; ) {
        const [r,i] = CP[Number(n % 315n)];
        if (r === 1n)
            break;
        n /= r,
        t[1] += i[1],
        t[2] += i[2],
        t[3] += i[3]
    }
    return [t, n]
}
function MP(n, t, e) {
    let r = 0
      , i = n;
    for (; t; )
        t & 1 && (r = (r + i) % e),
        i = (i << 1) % e,
        t >>= 1;
    return r
}
function yv(n, t, e=1) {
    return MP(n, n, t) + e
}
function Du(n, t=2, e=1) {
    let r = t
      , i = r
      , a = 1;
    for (; a === 1; )
        r = yv(r, n, e),
        i = yv(yv(i, n, e), n, e),
        a = (0,
        ar.gcd)(Math.abs(r - i), n);
    return a
}
function bv(n) {
    let t = Du(n);
    return t === n && (t = Du(n, 3),
    t === n && (t = Du(n, 9),
    t === n && (t = Du(n, 4, 2),
    t === n))) ? Du(n, 1, 2) : t
}
function C0(n) {
    if (typeof n != "number" || !Number.isInteger(n)) {
        const {s: i, n: a, d: l} = new ar.Fraction(n)
          , f = C0(i * a)
          , h = C0(l);
        for (const [p,m] of h)
            f.set(p, -m);
        return f
    }
    const t = new Map;
    if (n === 0)
        return t.set(0, 1),
        t;
    if (n < 0 && (t.set(-1, 1),
    n = -n),
    n > Number.MAX_SAFE_INTEGER)
        throw new Error(`Factorization not implemented above ${Number.MAX_SAFE_INTEGER}.`);
    let[e,r] = A0(n);
    if (r > 1073741823)
        throw new Error("Factorization not implemented when 7-limit residual > 1073741823.");
    for (let i = 0; i < e.length; ++i)
        e[i] && t.set(Dn.PRIMES[i], e[i]);
    if (Dn.PRIMES.includes(r))
        return t.set(r, 1),
        t;
    for (; r !== 1; ) {
        let i = bv(r);
        r /= i;
        let a = bv(i);
        if (a === i)
            t.set(i, (t.get(i) ?? 0) + 1);
        else {
            for (; i !== a; )
                a === 901 ? (t.set(17, (t.get(17) ?? 0) + 1),
                t.set(53, (t.get(53) ?? 0) + 1)) : a === 1241 ? (t.set(17, (t.get(17) ?? 0) + 1),
                t.set(73, (t.get(73) ?? 0) + 1)) : a === 1681 ? t.set(41, (t.get(41) ?? 0) + 2) : a === 3149 ? (t.set(47, (t.get(47) ?? 0) + 1),
                t.set(67, (t.get(67) ?? 0) + 1)) : a === 3869 ? (t.set(53, (t.get(53) ?? 0) + 1),
                t.set(73, (t.get(73) ?? 0) + 1)) : a === 65773 ? (t.set(17, (t.get(17) ?? 0) + 1),
                t.set(53, (t.get(53) ?? 0) + 1),
                t.set(73, (t.get(73) ?? 0) + 1)) : t.set(a, (t.get(a) ?? 0) + 1),
                i /= a,
                a = bv(i);
            t.set(i, (t.get(i) ?? 0) + 1)
        }
    }
    return t
}
Tt.primeFactorize = C0;
var Ai = {}
  , Pf = {};
Object.defineProperty(Pf, "__esModule", {
    value: !0
});
Pf.sum = void 0;
const $0 = 17976931348623157e292
  , OP = 17976931348623155e292
  , mE = $0 - OP;
function Ad(n, t) {
    const e = n + t
      , r = t - (e - n);
    return {
        hi: e,
        lo: r
    }
}
function NP(n) {
    const t = [];
    let e = 0;
    const r = n[Symbol.iterator]()
      , i = r.next.bind(r);
    function a(p) {
        for (; ; ) {
            const {done: m, value: g} = i();
            if (m)
                return p;
            Number.isFinite(g) || Object.is(g, p) || (p = NaN)
        }
    }
    for (; ; ) {
        const {done: p, value: m} = i();
        if (p)
            return -0;
        if (!Object.is(m, -0)) {
            if (!Number.isFinite(m))
                return a(m);
            t.push(m);
            break
        }
    }
    for (; ; ) {
        const {done: p, value: m} = i();
        if (p)
            break;
        let g = +m;
        if (!Number.isFinite(g))
            return a(g);
        let b = 0;
        for (let E of t) {
            Math.abs(g) < Math.abs(E) && ([g,E] = [E, g]);
            let {hi: S, lo: F} = Ad(g, E);
            if (Math.abs(S) === 1 / 0) {
                const B = S === 1 / 0 ? 1 : -1;
                if (e += B,
                Math.abs(e) >= 2 ** 53)
                    throw new RangeError("overflow");
                g = g - B * 2 ** 1023 - B * 2 ** 1023,
                Math.abs(g) < Math.abs(E) && ([g,E] = [E, g]),
                {hi: S, lo: F} = Ad(g, E)
            }
            F !== 0 && (t[b] = F,
            ++b),
            g = S
        }
        t.length = b,
        g !== 0 && t.push(g)
    }
    let l = t.length - 1
      , f = 0
      , h = 0;
    if (e !== 0) {
        const p = l >= 0 ? t[l] : 0;
        if (--l,
        Math.abs(e) > 1 || e > 0 && p > 0 || e < 0 && p < 0)
            return e > 0 ? 1 / 0 : -1 / 0;
        if ({hi: f, lo: h} = Ad(e * 2 ** 1023, p / 2),
        h *= 2,
        Math.abs(2 * f) === 1 / 0)
            return f > 0 ? f === 2 ** 1023 && h === -(mE / 2) && l >= 0 && t[l] < 0 ? $0 : 1 / 0 : f === -(2 ** 1023) && h === mE / 2 && l >= 0 && t[l] > 0 ? -$0 : -1 / 0;
        h !== 0 && (t[l + 1] = h,
        ++l,
        h = 0),
        f *= 2
    }
    for (; l >= 0; ) {
        const p = f
          , m = t[l];
        if (--l,
        {hi: f, lo: h} = Ad(p, m),
        h !== 0)
            break
    }
    if (l >= 0 && (h < 0 && t[l] < 0 || h > 0 && t[l] > 0)) {
        const p = h * 2
          , m = f + p
          , g = m - f;
        p === g && (f = m)
    }
    return f
}
Pf.sum = NP;
Object.defineProperty(Ai, "__esModule", {
    value: !0
});
Ai.norm = Ai.dotPrecise = Ai.dot = void 0;
const TP = Pf;
function xP(n, t) {
    const e = Math.min(n.length, t.length);
    let r = 0;
    for (let i = 0; i < e; ++i)
        r += n[i] * t[i];
    return r
}
Ai.dot = xP;
function IP(n, t) {
    const e = Math.min(n.length, t.length);
    function *r() {
        for (let i = 0; i < e; ++i)
            yield n[i] * t[i]
    }
    return (0,
    TP.sum)(r())
}
Ai.dotPrecise = IP;
function FP(n, t="euclidean") {
    let e = 0;
    for (let r = 0; r < n.length; ++r)
        t === "taxicab" ? e += Math.abs(n[r]) : t === "maximum" ? e = Math.max(e, Math.abs(n[r])) : e += n[r] * n[r];
    return t === "euclidean" ? Math.sqrt(e) : e
}
Ai.norm = FP;
var Li = {};
Object.defineProperty(Li, "__esModule", {
    value: !0
});
Li.iterCombinations = Li.iterKCombinations = Li.combinations = Li.kCombinations = void 0;
function k1(n, t) {
    if (t > n.length || t <= 0)
        return [];
    if (t === n.length)
        return [n];
    if (t === 1) {
        const r = [];
        for (let i = 0; i < n.length; i++)
            r.push([n[i]]);
        return r
    }
    const e = [];
    for (let r = 0; r < n.length - t + 1; r++) {
        const i = n.slice(r, r + 1)
          , a = k1(n.slice(r + 1), t - 1);
        for (let l = 0; l < a.length; l++)
            e.push(i.concat(a[l]))
    }
    return e
}
Li.kCombinations = k1;
function RP(n) {
    const t = [];
    for (let e = 1; e <= n.length; e++) {
        const r = k1(n, e);
        for (let i = 0; i < r.length; i++)
            t.push(r[i])
    }
    return t
}
Li.combinations = RP;
function *z1(n, t) {
    if (t > n.length || t <= 0)
        return 0;
    if (t === n.length)
        return yield n,
        1;
    if (t === 1) {
        for (let r = 0; r < n.length; r++)
            yield[n[r]];
        return n.length
    }
    let e = 0;
    for (let r = 0; r < n.length - t + 1; r++) {
        const i = n.slice(r, r + 1);
        for (const a of z1(n.slice(r + 1), t - 1))
            yield i.concat(a),
            e++
    }
    return e
}
Li.iterKCombinations = z1;
function *PP(n) {
    let t = 0;
    for (let e = 1; e <= n.length; e++)
        for (const r of z1(n, e))
            yield r,
            t++;
    return t
}
Li.iterCombinations = PP;
var Fr = {};
Object.defineProperty(Fr, "__esModule", {
    value: !0
});
Fr.approximateRadical = Fr.continuedFraction = Fr.approximatePrimeLimit = Fr.approximatePrimeLimitWithErrors = Fr.approximateOddLimit = Fr.approximateOddLimitWithErrors = Fr.getConvergents = void 0;
const DP = sn
  , ms = Dr
  , Nl = jl;
function qP(n, t, e, r=!1, i=!1) {
    const a = new ms.Fraction(n)
      , l = []
      , f = a.toContinued()
      , h = [];
    for (let p = 0; p < f.length; p++) {
        const m = f[p];
        let g = m
          , b = 1;
        for (let E = p; E > 0; E--)
            [b,g] = [g, b],
            g += b * f[E - 1];
        if (r && p > 0) {
            const E = i ? 1 : Math.ceil(m / 2);
            for (let S = E; S < m; S++) {
                const F = g - (m - S) * l[h[p - 1]].n
                  , B = b - (m - S) * l[h[p - 1]].d;
                if (B > t)
                    break;
                const Q = new ms.Fraction(F,B);
                if (i)
                    l.push(Q);
                else if (2 * S > m)
                    l.push(Q);
                else
                    try {
                        Q.sub(a).abs().compare(l[l.length - 1].sub(a).abs()) < 0 && l.push(Q)
                    } catch {}
                if (l.length >= e)
                    return l
            }
        }
        if (b > t)
            break;
        if (h.push(l.length),
        l.push(new ms.Fraction(g,b)),
        l.length >= e)
            return l
    }
    return l
}
Fr.getConvergents = qP;
const vl = [new ms.Fraction(1), new ms.Fraction(1,3), new ms.Fraction(3)]
  , gE = [0, -Nl.PRIME_CENTS[1], Nl.PRIME_CENTS[1]]
  , Cd = [1, 3]
  , mh = new ms.Fraction(2);
function N2(n, t) {
    const e = (t - 1) / 2;
    for (; Cd.length <= e; ) {
        const i = Cd.length * 2 + 1;
        for (let a = 1; a <= i; a += 2)
            for (let l = 1; l <= i; l += 2) {
                const f = new ms.Fraction(a,l);
                let h = !0;
                for (let p = 0; p < vl.length; ++p)
                    if (f.equals(vl[p])) {
                        h = !1;
                        break
                    }
                h && (vl.push(f),
                gE.push((0,
                DP.valueToCents)(f.valueOf())))
            }
        Cd.push(vl.length)
    }
    const r = [];
    for (let i = 0; i < Cd[e]; ++i) {
        const a = gE[i]
          , l = (0,
        ms.mmod)(n - a, 1200);
        if (l <= 600) {
            const f = Math.round((n - a - l) / 1200)
              , h = l;
            r.push([vl[i].mul(mh.pow(f)), h])
        } else {
            const f = Math.round((n - a - l) / 1200) + 1
              , h = 1200 - l;
            r.push([vl[i].mul(mh.pow(f)), h])
        }
    }
    return r.sort( (i, a) => i[1] - a[1]),
    r
}
Fr.approximateOddLimitWithErrors = N2;
function BP(n, t) {
    return N2(n, t).map(e => e[0])
}
Fr.approximateOddLimit = BP;
function T2(n, t, e, r=600, i=100) {
    if (r > 600)
        throw new Error("Maximum search distance is 600 cents");
    const a = [];
    function l(h, p) {
        if (p.n)
            if (a.length < i)
                a.push([p, h]),
                a.length === i && a.sort( (m, g) => m[1] - g[1]);
            else {
                if (h > a[a.length - 1][1])
                    return;
                for (let m = a.length - 1; ; m--)
                    if (h <= a[m][1]) {
                        a.splice(m, 0, [p, h]);
                        break
                    }
                a.pop()
            }
    }
    function f(h, p, m) {
        if (!(h.n > 1e11 || h.d > 1e11)) {
            if (m > t) {
                const g = (0,
                ms.mmod)(n - p, 1200);
                if (g <= 600) {
                    const b = g;
                    if (b > r)
                        return;
                    const E = Math.round((n - p - g) / 1200);
                    if (Math.abs(E) > 52)
                        return;
                    const S = h.mul(mh.pow(E));
                    l(b, S)
                } else {
                    const b = 1200 - g;
                    if (b > r)
                        return;
                    const E = Math.round((n - p - g) / 1200) + 1;
                    if (Math.abs(E) > 52)
                        return;
                    const S = h.mul(mh.pow(E));
                    l(b, S)
                }
                return
            }
            f(h, p, m + 1);
            for (let g = 1; g <= e; ++g)
                f(h.mul(Nl.PRIMES[m] ** g), p + Nl.PRIME_CENTS[m] * g, m + 1),
                f(h.div(Nl.PRIMES[m] ** g), p - Nl.PRIME_CENTS[m] * g, m + 1)
        }
    }
    return f(new ms.Fraction(1), 0, 1),
    a.sort( (h, p) => h[1] - p[1]),
    a
}
Fr.approximatePrimeLimitWithErrors = T2;
function kP(n, t, e, r=600, i=100) {
    return T2(n, t, e, r, i).map(a => a[0])
}
Fr.approximatePrimeLimit = kP;
function x2(n) {
    const t = [];
    let e = Math.floor(n);
    for (t.push(e),
    n -= e; n && e < 1e12 && t.length < 32; )
        n = 1 / n,
        e = Math.floor(n),
        t.push(e),
        n -= e;
    return t
}
Fr.continuedFraction = x2;
function zP(n, t=5, e=5e4) {
    let r = 1
      , i = new ms.Fraction(1)
      , a = Math.abs(n - 1);
    for (let l = 1; l <= t; ++l) {
        const f = x2(n ** l);
        let h;
        for (let p = 0; p < f.length - 1; ++p) {
            let m = new ms.Fraction(f[p]);
            for (let g = p - 1; g >= 0; --g)
                m = m.inverse().add(f[g]);
            if (m.n * m.d > e)
                break;
            h = m
        }
        if (h !== void 0) {
            const p = Math.abs(h.valueOf() ** (1 / l) - n);
            p < a && (r = l,
            i = h,
            a = p)
        }
    }
    return {
        index: r,
        radicand: i
    }
}
Fr.approximateRadical = zP;
var Mt = {}
  , er = {};
Object.defineProperty(er, "__esModule", {
    value: !0
});
er.preimage = er.cokernel = er.kernel = er.transpose = er.antitranspose = er.integerDet = er.pruneZeroRows = er.hnf = er.padMatrix = void 0;
const VP = Tt;
function vE(n) {
    return typeof n == "number" ? Math.abs(n) : (0,
    VP.bigAbs)(n)
}
function M0(n, t) {
    return typeof n == "number" ? Math.floor(n / t) : n >= 0n != t >= 0n && n % t ? n / t - 1n : n / t
}
function UP(n, t, e) {
    let r, i;
    for (let a = t; a < n.length; ++a)
        n[a][e] && (i === void 0 || vE(n[a][e]) < i) && (r = a,
        i = vE(n[a][e]));
    return r
}
function qa(n) {
    const t = n.length;
    if (!t)
        return {
            height: t,
            width: 0,
            zero: 0,
            one: 1,
            M: []
        };
    let e = 0, r;
    for (const a of n)
        e = Math.max(e, a.length),
        a.length && (r = typeof a[0] == "number" ? 0 : 0n);
    if (n = n.map(a => [...a]),
    r === void 0)
        return {
            height: t,
            width: e,
            zero: 0,
            one: 1,
            M: n
        };
    const i = typeof r == "number" ? 1 : 1n;
    for (const a of n)
        for (; a.length < e; )
            a.push(r);
    return {
        height: t,
        width: e,
        zero: r,
        one: i,
        M: n
    }
}
er.padMatrix = qa;
function V1(n) {
    const {width: t, height: e, zero: r, one: i, M: a} = qa(n);
    let l = 0
      , f = 0;
    const h = -i;
    for (; ; ) {
        if (l === e || f === t)
            return a;
        const p = UP(a, l, f);
        if (p === void 0) {
            f = f + 1;
            continue
        }
        [a[l],a[p]] = [a[p], a[l]];
        for (let g = l + 1; g < e; ++g)
            if (a[g][f]) {
                const b = M0(a[g][f], a[l][f]);
                for (let E = 0; E < t; ++E)
                    a[g][E] -= b * a[l][E]
            }
        let m = !0;
        for (let g = l + 1; g < e; ++g)
            a[g][f] && (m = !1);
        if (m) {
            if (a[l][f] < r)
                for (let g = 0; g < t; ++g)
                    a[l][g] *= h;
            if (a[l][f])
                for (let g = 0; g < l; ++g) {
                    const b = M0(a[g][f], a[l][f]);
                    if (b)
                        for (let E = 0; E < t; ++E)
                            a[g][E] -= b * a[l][E]
                }
            l += 1,
            f += 1
        }
    }
}
er.hnf = V1;
function jP(n) {
    for (let t = 0; t < n.length; ++t)
        n[t].some(Boolean) || (n.splice(t, 1),
        t--)
}
er.pruneZeroRows = jP;
function HP(n) {
    const {width: t, height: e, zero: r, one: i, M: a} = qa(n);
    if (!t || !e || t !== e)
        return r;
    let l = i
      , f = l;
    for (let h = 0; h < t - 1; ++h) {
        if (!a[h][h]) {
            let p;
            for (let m = h + 1; m < e; ++m)
                if (a[m][h]) {
                    p = m;
                    break
                }
            if (p === void 0)
                return r;
            [a[h],a[p]] = [a[p], a[h]],
            l = -l
        }
        for (let p = h + 1; p < e; ++p)
            for (let m = h + 1; m < t; ++m)
                a[p][m] = M0(a[p][m] * a[h][h] - a[p][h] * a[h][m], f);
        f = a[h][h]
    }
    return l * a.pop().pop()
}
er.integerDet = HP;
function GP(n) {
    const {width: t, height: e, M: r} = qa(n)
      , i = [];
    for (let a = t - 1; a >= 0; --a) {
        const l = [];
        for (let f = e - 1; f >= 0; --f)
            l.push(r[f][a]);
        i.push(l)
    }
    return i
}
er.antitranspose = GP;
function Ia(n) {
    const {width: t, height: e, M: r} = qa(n)
      , i = [];
    for (let a = 0; a < t; ++a) {
        const l = [];
        for (let f = 0; f < e; ++f)
            l.push(r[f][a]);
        i.push(l)
    }
    return i
}
er.transpose = Ia;
function I2(n) {
    const {width: t, height: e, zero: r, one: i, M: a} = qa(n);
    for (let f = 0; f < t; ++f) {
        const h = Array(t).fill(r);
        h[f] = i,
        a.push(h)
    }
    const l = Ia(V1(Ia(a)));
    for (let f = 0; f < e; ++f)
        l.shift();
    for (const f of l)
        for (let h = 0; h < e; ++h)
            f.shift();
    return l
}
er.kernel = I2;
function WP(n) {
    return Ia(I2(Ia(n)))
}
er.cokernel = WP;
function JP(n) {
    const {width: t, height: e, zero: r, one: i, M: a} = qa(n)
      , l = Ia(a);
    for (let h = 0; h < t; ++h)
        for (let p = 0; p < t; ++p)
            l[h].push(h === p ? i : r);
    const f = V1(l);
    for (; f.length > e; )
        f.pop();
    for (const h of f)
        for (let p = 0; p < e; ++p)
            h.shift();
    return Ia(f)
}
er.preimage = JP;
Object.defineProperty(Mt, "__esModule", {
    value: !0
});
Mt.solveDiophantine = Mt.respell = Mt.nearestPlane = Mt.canonical = Mt.defactoredHnf = Mt.fractionalMatsub = Mt.fractionalMatadd = Mt.fractionalMatscale = Mt.matsub = Mt.matadd = Mt.matscale = Mt.minor = Mt.fractionalTranspose = Mt.fractionalDet = Mt.det = Mt.fractionalMatmul_ = Mt.fractionalMatmul = Mt.matmul = Mt.fractionalInv = Mt.inv = Mt.fractionalEye = Mt.eye = Mt.fractionalLenstraLenstraLovasz = Mt.lenstraLenstraLovasz = Mt.fractionalGram = Mt.gram = void 0;
const gr = Dr
  , Rn = Tt
  , yc = Ai
  , js = er;
function Qu(n, t=1e-12) {
    const e = []
      , r = []
      , i = [];
    for (let a = 0; a < n.length; ++a) {
        e.push([...n[a]]);
        for (let l = 0; l < a; ++l)
            e[a] = (0,
            Rn.sub)(e[a], (0,
            Rn.scale)(e[l], (0,
            yc.dot)(e[a], i[l])));
        r.push((0,
        yc.dot)(e[a], e[a])),
        r[a] > t ? i.push((0,
        Rn.scale)(e[a], 1 / r[a])) : i.push((0,
        Rn.scale)(e[a], 0))
    }
    return {
        ortho: e,
        squaredLengths: r,
        dual: i
    }
}
Mt.gram = Qu;
function Zd(n) {
    const t = []
      , e = []
      , r = [];
    for (let i = 0; i < n.length; ++i) {
        t.push(n[i].map(a => new gr.Fraction(a)));
        for (let a = 0; a < i; ++a)
            t[i] = (0,
            Rn.fractionalSub)(t[i], (0,
            Rn.fractionalScale)(t[a], (0,
            Rn.fractionalDot)(t[i], r[a])));
        e.push((0,
        Rn.fractionalDot)(t[i], t[i])),
        e[i].n ? r.push((0,
        Rn.fractionalScale)(t[i], e[i].inverse())) : r.push((0,
        Rn.fractionalScale)(t[i], e[i]))
    }
    return {
        ortho: t,
        squaredLengths: e,
        dual: r
    }
}
Mt.fractionalGram = Zd;
function KP(n, t=.75, e=1e-12, r=1e4) {
    n = n.map(h => [...h]);
    let {ortho: i, squaredLengths: a, dual: l} = Qu(n, e)
      , f = 1;
    for (; f < n.length && r--; ) {
        for (let p = f - 1; p >= 0; --p) {
            const m = (0,
            yc.dot)(n[f], l[p]);
            Math.abs(m) > .5 && (n[f] = (0,
            Rn.sub)(n[f], (0,
            Rn.scale)(n[p], Math.round(m))),
            {ortho: i, squaredLengths: a, dual: l} = Qu(n, e))
        }
        const h = (0,
        yc.dot)(n[f], l[f - 1]);
        if (a[f] > (t - h * h) * a[f - 1] || !a[f - 1])
            f++;
        else {
            const p = n[f];
            n[f] = n[f - 1],
            n[f - 1] = p,
            {ortho: i, squaredLengths: a, dual: l} = Qu(n, e),
            f = Math.max(f - 1, 1)
        }
    }
    return {
        basis: n,
        gram: {
            ortho: i,
            squaredLengths: a,
            dual: l
        }
    }
}
Mt.lenstraLenstraLovasz = KP;
const ZP = new gr.Fraction(1,2);
function YP(n, t="3/4", e=1e4) {
    const r = n.map(p => p.map(m => new gr.Fraction(m)))
      , i = new gr.Fraction(t);
    let {ortho: a, squaredLengths: l, dual: f} = Zd(r)
      , h = 1;
    for (; h < r.length && e--; ) {
        for (let m = h - 1; m >= 0; --m) {
            const g = (0,
            Rn.fractionalDot)(r[h], f[m]);
            g.abs().compare(ZP) > 0 && (r[h] = (0,
            Rn.fractionalSub)(r[h], (0,
            Rn.fractionalScale)(r[m], g.round())),
            {ortho: a, squaredLengths: l, dual: f} = Zd(r))
        }
        const p = (0,
        Rn.fractionalDot)(r[h], f[h - 1]);
        if (l[h].compare(i.sub(p.mul(p)).mul(l[h - 1])) > 0 || !l[h - 1].n)
            h++;
        else {
            const m = r[h];
            r[h] = r[h - 1],
            r[h - 1] = m,
            {ortho: a, squaredLengths: l, dual: f} = Zd(r),
            h = Math.max(h - 1, 1)
        }
    }
    return {
        basis: r,
        gram: {
            ortho: a,
            squaredLengths: l,
            dual: f
        }
    }
}
Mt.fractionalLenstraLenstraLovasz = YP;
function QP(n, t, e=0) {
    t ?? (t = n);
    const r = [];
    for (let i = 0; i < n; ++i)
        r.push(Array(t).fill(0)),
        i >= e && i + e < t && (r[i][i + e] = 1);
    return r
}
Mt.eye = QP;
function XP(n, t, e=0) {
    t ?? (t = n);
    const r = [];
    for (let i = 0; i < n; ++i) {
        const a = [];
        for (let l = 0; l < t; ++l)
            l === i + e ? a.push(new gr.Fraction(1)) : a.push(new gr.Fraction(0));
        r.push(a)
    }
    return r
}
Mt.fractionalEye = XP;
function U1(n) {
    let t = 0;
    const e = n.length;
    for (const i of n)
        t = Math.max(t, i.length);
    if (t !== e)
        throw new Error("Non-square matrix");
    const r = [];
    for (let i = 0; i < e; ++i)
        r.push(Array(t).fill(0)),
        r[i][i] = 1;
    n = n.map(i => [...i]);
    for (let i = 0; i < e; ++i)
        for (let a = n[i].length; a < t; ++a)
            n[i][a] = 0;
    for (let i = 0; i < t; ++i) {
        let a, l = 0;
        for (let f = i; f < e; ++f)
            Math.abs(n[f][i]) > Math.abs(l) && (a = f,
            l = n[f][i]);
        if (a === void 0)
            throw new Error("Matrix is singular");
        if (i !== a) {
            let f = n[a];
            n[a] = n[i],
            n[i] = f,
            f = r[a],
            r[a] = r[i],
            r[i] = f
        }
        l !== 1 && (l = 1 / l,
        n[i] = n[i].map(f => f * l),
        r[i] = r[i].map(f => f * l));
        for (let f = i + 1; f < e; ++f)
            if (l = n[f][i],
            l) {
                r[f] = r[f].map( (h, p) => h - l * r[i][p]);
                for (let h = i + 1; h < t; ++h)
                    n[f][h] -= l * n[i][h]
            }
    }
    for (let i = t - 1; i > 0; --i)
        for (let a = i - 1; a >= 0; --a) {
            const l = n[a][i];
            l && (r[a] = r[a].map( (f, h) => f - l * r[i][h]))
        }
    return r
}
Mt.inv = U1;
function e6(n) {
    let t = 0;
    const e = n.length;
    for (const a of n)
        t = Math.max(t, a.length);
    if (t !== e)
        throw new Error("Non-square matrix");
    const r = [];
    for (let a = 0; a < e; ++a) {
        const l = [];
        for (let f = 0; f < t; ++f)
            a === f ? l.push(new gr.Fraction(1)) : l.push(new gr.Fraction(0));
        r.push(l)
    }
    const i = n.map(a => a.map(l => new gr.Fraction(l)));
    for (let a = 0; a < e; ++a)
        for (let l = i[a].length; l < t; ++l)
            i[a][l] = new gr.Fraction(0);
    for (let a = 0; a < t; ++a) {
        let l = i[a][a];
        if (!l.n) {
            for (let f = a + 1; f < e; ++f)
                if (i[f][a].n) {
                    let h = i[f];
                    i[f] = i[a],
                    i[a] = h,
                    h = r[f],
                    r[f] = r[a],
                    r[a] = h;
                    break
                }
            if (l = i[a][a],
            !l.n)
                throw new Error("Matrix is singular")
        }
        l.isUnity() || (i[a] = i[a].map(f => f.div(l)),
        r[a] = r[a].map(f => f.div(l)));
        for (let f = a + 1; f < e; ++f)
            if (l = i[f][a],
            l.n) {
                r[f] = r[f].map( (h, p) => h.sub(l.mul(r[a][p])));
                for (let h = a + 1; h < t; ++h)
                    i[f][h] = i[f][h].sub(l.mul(i[a][h]))
            }
    }
    for (let a = t - 1; a > 0; --a)
        for (let l = a - 1; l >= 0; --l) {
            const f = i[l][a];
            f.n && (r[l] = r[l].map( (h, p) => h.sub(f.mul(r[a][p]))))
        }
    return r
}
Mt.fractionalInv = e6;
function gh(n, t) {
    let e = 0;
    Array.isArray(n[0]) || (n = [n],
    e++),
    Array.isArray(t[0]) || (t = t.map(i => [i]),
    e++);
    const r = t6(n, t);
    return e === 1 ? r.flat() : e === 2 ? r[0][0] : r
}
Mt.matmul = gh;
function t6(n, t) {
    const e = n.length;
    let r = 0;
    for (const l of t)
        r = Math.max(r, l.length);
    let i = 0;
    for (const l of n)
        i = Math.max(i, l.length);
    for (t = [...t]; t.length < i; )
        t.push([]);
    const a = [];
    for (let l = 0; l < e; ++l) {
        const f = Array(r).fill(0)
          , h = n[l];
        for (let p = 0; p < r; ++p)
            for (let m = 0; m < h.length; ++m)
                f[p] += h[m] * (t[m][p] ?? 0);
        a.push(f)
    }
    return a
}
function n6(n, t) {
    let e = 0;
    Array.isArray(n[0]) || (n = [n],
    e++),
    Array.isArray(t[0]) || (t = t.map(i => [i]),
    e++);
    const r = F2(n, t);
    return e === 1 ? r.flat() : e === 2 ? r[0][0] : r
}
Mt.fractionalMatmul = n6;
function F2(n, t) {
    const e = n.length;
    let r = 0;
    for (const f of t)
        r = Math.max(r, f.length);
    let i = 0;
    for (const f of n)
        i = Math.max(i, f.length);
    const a = t.map(f => f.map(h => new gr.Fraction(h)));
    for (; a.length < i; )
        a.push([]);
    for (const f of a)
        for (; f.length < r; )
            f.push(new gr.Fraction(0));
    const l = [];
    for (let f = 0; f < e; ++f) {
        const h = [];
        for (; h.length < r; )
            h.push(new gr.Fraction(0));
        const p = n[f].map(m => new gr.Fraction(m));
        for (let m = 0; m < r; ++m)
            for (let g = 0; g < p.length; ++g)
                h[m] = h[m].add(p[g].mul(a[g][m]));
        l.push(h)
    }
    return l
}
Mt.fractionalMatmul_ = F2;
function r6(n) {
    let t = 0;
    const e = n.length;
    for (const i of n)
        t = Math.max(t, i.length);
    if (t !== e)
        throw new Error("Non-square matrix");
    n = n.map(i => [...i]);
    let r = 1;
    for (let i = 0; i < t; ++i) {
        let a, l = 0;
        for (let f = i; f < e; ++f)
            Math.abs(n[f][i]) > Math.abs(l) && (a = f,
            l = n[f][i]);
        if (a === void 0)
            return 0;
        if (i !== a) {
            const f = n[a];
            n[a] = n[i],
            n[i] = f,
            r = -r
        }
        r *= l,
        l = 1 / l;
        for (let f = i + 1; f < e; ++f) {
            const h = n[f]
              , p = h[i] * l;
            if (p) {
                const m = n[i];
                for (let g = i + 1; g < m.length; ++g)
                    h[g] -= p * m[g]
            }
        }
    }
    return r
}
Mt.det = r6;
function s6(n) {
    let t = 0;
    const e = n.length;
    for (const a of n)
        t = Math.max(t, a.length);
    if (t !== e)
        throw new Error("Non-square matrix");
    const r = n.map(a => a.map(l => new gr.Fraction(l)));
    for (const a of r)
        for (; a.length < t; )
            a.push(new gr.Fraction(0));
    let i = new gr.Fraction(1);
    for (let a = 0; a < t; ++a) {
        let l = r[a][a];
        if (!l.n) {
            for (let f = a + 1; f < e; ++f)
                if (r[f][a].n) {
                    const h = r[f];
                    r[f] = r[a],
                    r[a] = h,
                    i = i.neg();
                    break
                }
            if (l = r[a][a],
            !l.n)
                return new gr.Fraction(0)
        }
        i = i.mul(l);
        for (let f = a + 1; f < e; ++f) {
            const h = r[f]
              , p = h[a].div(l);
            if (p.n) {
                const m = r[a];
                for (let g = a + 1; g < t; ++g)
                    h[g] = h[g].sub(p.mul(m[g]))
            }
        }
    }
    return i
}
Mt.fractionalDet = s6;
function i6(n) {
    let t = 0;
    for (const r of n)
        t = Math.max(r.length, t);
    const e = [];
    for (let r = 0; r < t; ++r) {
        const i = [];
        for (let a = 0; a < n.length; ++a)
            i.push(new gr.Fraction(n[a][r] ?? 0));
        e.push(i)
    }
    return e
}
Mt.fractionalTranspose = i6;
function o6(n, t, e) {
    n = n.map(r => [...r]),
    n.splice(t, 1);
    for (const r of n)
        r.splice(e, 1);
    return n
}
Mt.minor = o6;
function a6(n, t) {
    return n.map(e => (0,
    Rn.scale)(e, t))
}
Mt.matscale = a6;
function l6(n, t) {
    const e = []
      , r = Math.max(n.length, t.length);
    for (let i = 0; i < r; ++i)
        e.push((0,
        Rn.add)(n[i] ?? [], t[i] ?? []));
    return e
}
Mt.matadd = l6;
function u6(n, t) {
    const e = []
      , r = Math.max(n.length, t.length);
    for (let i = 0; i < r; ++i)
        e.push((0,
        Rn.sub)(n[i] ?? [], t[i] ?? []));
    return e
}
Mt.matsub = u6;
function c6(n, t) {
    return n.map(e => (0,
    Rn.fractionalScale)(e, t))
}
Mt.fractionalMatscale = c6;
function f6(n, t) {
    const e = []
      , r = Math.max(n.length, t.length);
    for (let i = 0; i < r; ++i)
        e.push((0,
        Rn.fractionalAdd)(n[i] ?? [], t[i] ?? []));
    return e
}
Mt.fractionalMatadd = f6;
function d6(n, t) {
    const e = []
      , r = Math.max(n.length, t.length);
    for (let i = 0; i < r; ++i)
        e.push((0,
        Rn.fractionalSub)(n[i] ?? [], t[i] ?? []));
    return e
}
Mt.fractionalMatsub = d6;
function O0(n) {
    const t = n.map(l => l.map(BigInt))
      , e = (0,
    js.hnf)((0,
    js.transpose)(t));
    for (; e.length > n.length; )
        e.pop();
    if ((0,
    js.integerDet)(e) === 1n)
        return (0,
        js.hnf)(t).map(l => l.map(Number));
    const i = U1((0,
    js.transpose)(e).map(l => l.map(Number)))
      , a = gh(i, n).map(l => l.map(Math.round));
    return (0,
    js.hnf)(a)
}
Mt.defactoredHnf = O0;
function h6(n) {
    for (const t of n)
        if (t.length < n.length)
            return (0,
            js.antitranspose)(O0((0,
            js.antitranspose)(n)));
    return O0(n)
}
Mt.canonical = h6;
function p6(n, t, e) {
    return (0,
    Rn.sub)(n, R2(n, t, e))
}
Mt.nearestPlane = p6;
function R2(n, t, e) {
    e === void 0 && (e = Qu(t).dual),
    n = [...n];
    for (let r = e.length - 1; r >= 0; --r) {
        const i = (0,
        yc.dot)(n, e[r]);
        n = (0,
        Rn.sub)(n, (0,
        Rn.scale)(t[r], Math.round(i)))
    }
    return n
}
Mt.respell = R2;
function m6(n, t) {
    const e = Array.isArray(t[0])
      , r = e ? (0,
    js.padMatrix)(t).M : t.map(b => [b])
      , {width: i, height: a, M: l} = (0,
    js.padMatrix)(n.map(b => b.map(BigInt)));
    for (let b = 0; b < a; ++b)
        l[b].push(...r[b].map(BigInt));
    const f = (0,
    js.hnf)(l);
    for (; f.length > i; )
        f.pop();
    const h = [];
    for (const b of f)
        h.push(b.splice(i, b.length - i).map(Number));
    const p = U1(f.map(b => b.map(Number)))
      , m = gh(p, h).map(b => b.map(Math.round))
      , g = gh(n, m);
    for (let b = 0; b < r.length; ++b)
        if (!(0,
        Rn.monzosEqual)(r[b], g[b]))
            throw new Error("Could not solve system");
    return e ? m : m.map(b => b[0])
}
Mt.solveDiophantine = m6;
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(N, P, J, X) {
        X === void 0 && (X = J);
        var ie = Object.getOwnPropertyDescriptor(P, J);
        (!ie || ("get"in ie ? !P.__esModule : ie.writable || ie.configurable)) && (ie = {
            enumerable: !0,
            get: function() {
                return P[J]
            }
        }),
        Object.defineProperty(N, X, ie)
    }
    : function(N, P, J, X) {
        X === void 0 && (X = J),
        N[X] = P[J]
    }
    )
      , e = Zt && Zt.__exportStar || function(N, P) {
        for (var J in N)
            J !== "default" && !Object.prototype.hasOwnProperty.call(P, J) && t(P, N, J)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.wilsonHeight = n.tenneyHeight = n.monzoToCents = n.hasMarginConstantStructure = n.falsifyConstantStructure = n.fareyInterior = n.fareySequence = n.ceilPow2 = n.circleDistance = n.circleDifference = n.clamp = n.binomial = n.FractionSet = n.modInv = n.iteratedEuclid = n.extendedEuclid = n.div = n.arraysEqual = n.sum = void 0;
    const r = Dr
      , i = Tt
      , a = Ai
      , l = jl;
    e(Dr, n),
    e(jl, n),
    e(sn, n),
    e(Li, n),
    e(Tt, n),
    e(Fr, n),
    e(Ai, n),
    e(Mt, n),
    e(er, n);
    var f = Pf;
    Object.defineProperty(n, "sum", {
        enumerable: !0,
        get: function() {
            return f.sum
        }
    });
    function h(N, P) {
        if (N === P)
            return !0;
        if (N.length !== P.length)
            return !1;
        for (let J = 0; J < N.length; ++J)
            if (N[J] !== P[J])
                return !1;
        return !0
    }
    n.arraysEqual = h;
    function p(N, P) {
        return Math.floor(N / P)
    }
    n.div = p;
    function m(N, P) {
        if (isNaN(N) || isNaN(P))
            throw new Error("Invalid input");
        let[J,X] = [N, P]
          , [ie,ce] = [1, 0]
          , [Le,he] = [0, 1];
        for (; X !== 0; ) {
            const Fe = p(J, X);
            [J,X] = [X, J - Fe * X],
            [ie,ce] = [ce, ie - Fe * ce],
            [Le,he] = [he, Le - Fe * he]
        }
        return {
            coefA: ie,
            coefB: Le,
            gcd: J,
            quotientA: he,
            quotientB: Math.abs(ce)
        }
    }
    n.extendedEuclid = m;
    function g(N) {
        const P = [];
        let J;
        for (const X of N) {
            if (J === void 0) {
                J = X,
                P.push(1);
                continue
            }
            const ie = m(J, X);
            for (let ce = 0; ce < P.length; ++ce)
                P[ce] *= ie.coefA;
            J = ie.gcd,
            P.push(ie.coefB)
        }
        return P
    }
    n.iteratedEuclid = g;
    function b(N, P, J=!0) {
        const {gcd: X, coefA: ie} = m(N, P);
        if (J && X !== 1)
            throw new Error(`${N} does not have a modular inverse modulo ${P} since they're not coprime`);
        return (0,
        r.mmod)(ie, P)
    }
    n.modInv = b;
    class E extends Set {
        has(P) {
            for (const J of this)
                if (J.equals(P))
                    return !0;
            return !1
        }
        add(P) {
            return this.has(P) ? this : (super.add(P),
            this)
        }
        delete(P) {
            for (const J of this)
                if (J.equals(P))
                    return super.delete(J);
            return !1
        }
    }
    n.FractionSet = E;
    const S = [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1], [1, 5, 10, 10, 5, 1], [1, 6, 15, 20, 15, 6, 1], [1, 7, 21, 35, 35, 21, 7, 1], [1, 8, 28, 56, 70, 56, 28, 8, 1]];
    function F(N, P) {
        for (; N >= S.length; ) {
            const J = S.length
              , X = S[J - 1]
              , ie = [1];
            for (let ce = 1; ce < J; ce++)
                ie.push(X[ce - 1] + X[ce]);
            ie.push(1),
            S.push(ie)
        }
        return S[N][P]
    }
    n.binomial = F;
    function B(N, P, J) {
        return J < N ? N : J > P ? P : J
    }
    n.clamp = B;
    function Q(N, P, J=1200) {
        const X = .5 * J;
        return (0,
        r.mmod)(N - P + X, J) - X
    }
    n.circleDifference = Q;
    function ae(N, P, J=1200) {
        return Math.abs(Q(N, P, J))
    }
    n.circleDistance = ae;
    function V(N) {
        return N >= 1 && N < 1073741824 ? 1 << 32 - Math.clz32(N - 1) : N <= 0 ? 0 : 2 ** Math.ceil(Math.log2(N))
    }
    n.ceilPow2 = V;
    function *k(N) {
        let P = 0
          , J = 1
          , X = 1
          , ie = N;
        for (yield new r.Fraction(P,J); 0 <= X && X <= N; ) {
            const ce = Math.floor((N + J) / ie);
            [P,J,X,ie] = [X, ie, ce * X - P, ce * ie - J],
            yield new r.Fraction(P,J)
        }
    }
    n.fareySequence = k;
    function *z(N) {
        if (N < 2)
            return;
        let P = 1
          , J = N
          , X = 1
          , ie = N - 1;
        for (yield new r.Fraction(P,J); ie > 1; ) {
            const ce = Math.floor((N + J) / ie);
            [P,J,X,ie] = [X, ie, ce * X - P, ce * ie - J],
            yield new r.Fraction(P,J)
        }
    }
    n.fareyInterior = z;
    function Z(N) {
        const P = N.length;
        if (!P)
            return null;
        const J = N[P - 1]
          , X = [...N];
        for (const ce of N)
            X.push(J + ce);
        const ie = new Map;
        for (let ce = 0; ce < P; ce++) {
            if (ie.has(X[ce]))
                return [ie.get(X[ce]), [-1, ce + 1]];
            ie.set(X[ce], [-1, ce + 1])
        }
        for (let ce = 0; ce < P - 1; ++ce)
            for (let Le = 1; Le < P; ++Le) {
                const he = X[ce + Le] - X[ce];
                if (ie.has(he)) {
                    const [Fe,Te] = ie.get(he);
                    if (Le !== Te)
                        return [[Fe, Fe + Te], [ce, ce + Le]]
                }
                ie.set(he, [ce, Le])
            }
        return null
    }
    n.falsifyConstantStructure = Z;
    function re(N, P) {
        const J = N.length;
        if (!J)
            return !0;
        const X = N[J - 1]
          , ie = [...N];
        for (const Le of N)
            ie.push(X + Le);
        const ce = new Map;
        for (let Le = 0; Le < J; Le++) {
            for (const he of ce.keys())
                if (Math.abs(he - ie[Le]) <= P)
                    return !1;
            ce.set(ie[Le], Le + 1)
        }
        for (let Le = 0; Le < J - 1; ++Le)
            for (let he = 1; he < J; ++he) {
                const Fe = ie[Le + he] - ie[Le];
                if (ce.has(Fe) && ce.get(Fe) !== he)
                    return !1;
                for (const [Te,ye] of ce.entries())
                    if (ye !== he && Math.abs(Te - Fe) <= P)
                        return !1;
                ce.set(Fe, he)
            }
        return !0
    }
    n.hasMarginConstantStructure = re;
    const C = 1200 / Math.LN2
      , D = 2n ** 1024n;
    function R(N) {
        const P = (0,
        a.dotPrecise)(N, l.PRIME_CENTS);
        if (Math.abs(P) > 10)
            return P;
        for (const ce of N)
            if (!Number.isInteger(ce))
                return P;
        let {numerator: J, denominator: X} = (0,
        i.monzoToBigNumeratorDenominator)(N)
          , ie = J - X;
        for (; X >= D; )
            ie >>= 1n,
            X >>= 1n;
        return Math.log1p(Number(ie) / Number(X)) * C
    }
    n.monzoToCents = R;
    function W(N) {
        if (Array.isArray(N))
            return (0,
            a.dotPrecise)(N.map(ie => Math.abs(ie)), l.LOG_PRIMES);
        const {s: P, n: J, d: X} = new r.Fraction(N);
        return P ? Math.log(J) + Math.log(X) : 1 / 0
    }
    n.tenneyHeight = W;
    function I(N) {
        if (Array.isArray(N))
            return (0,
            a.dot)(N.map(J => Math.abs(J)), l.PRIMES);
        if (N instanceof Map || (N = (0,
        i.primeFactorize)(N)),
        N.has(0))
            return 1 / 0;
        N.delete(-1);
        let P = 0;
        for (const [J,X] of N)
            P += Math.abs(X) * J;
        return P
    }
    n.wilsonHeight = I
}
)(Ie);
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.hasOwn = n.setUnion = n.validateBigInt = n.ABSURD_EXPONENT = n.countUpsAndLifts = n.binaryExponent = n.metricExponent = n.ELEVEN = n.SEVEN = n.FIVE = n.THREE = n.TWO = n.FRACTION_PRIMES = n.HALF = n.NEGATIVE_ONE = n.ONE = n.ZERO = n.F = n.NUM_INTERCHANGE_COMPONENTS = void 0;
    const t = Ie;
    n.NUM_INTERCHANGE_COMPONENTS = 9;
    function e(g, b) {
        return Object.freeze(new t.Fraction(g,b))
    }
    n.F = e,
    n.ZERO = e(0),
    n.ONE = e(1),
    n.NEGATIVE_ONE = e(-1),
    n.HALF = e(1, 2),
    n.FRACTION_PRIMES = [];
    for (const g of t.PRIMES)
        n.FRACTION_PRIMES.push(e(g));
    n.TWO = n.FRACTION_PRIMES[0],
    n.THREE = n.FRACTION_PRIMES[1],
    n.FIVE = n.FRACTION_PRIMES[2],
    n.SEVEN = n.FRACTION_PRIMES[3],
    n.ELEVEN = n.FRACTION_PRIMES[4];
    function r(g) {
        switch (g) {
        case "Q":
            return 30;
        case "R":
            return 27;
        case "Y":
            return 24;
        case "Z":
            return 21;
        case "E":
            return 18;
        case "P":
            return 15;
        case "T":
            return 12;
        case "G":
            return 9;
        case "M":
            return 6;
        case "k":
            return 3;
        case "h":
            return 2;
        case "da":
            return 1;
        case "":
            return 0;
        case "d":
            return -1;
        case "c":
            return -2;
        case "m":
            return -3;
        case "":
            return -6;
        case "n":
            return -9;
        case "p":
            return -12;
        case "f":
            return -15;
        case "a":
            return -18;
        case "z":
            return -21;
        case "y":
            return -24;
        case "r":
            return -27;
        case "q":
            return -30;
        default:
            throw new Error(`Unrecognized prefix ${g}.`)
        }
    }
    n.metricExponent = r;
    function i(g) {
        switch (g) {
        case "Ki":
            return 1;
        case "Mi":
            return 2;
        case "Gi":
            return 3;
        case "Ti":
            return 4;
        case "Pi":
            return 5;
        case "Ei":
            return 6;
        case "Zi":
            return 7;
        case "Yi":
            return 8;
        case "Ri":
            return 9;
        case "Qi":
            return 10;
        default:
            throw new Error(`Unrecognized prefix ${g}.`)
        }
    }
    n.binaryExponent = i;
    function a(g, b, E) {
        let S, F;
        if (!Number.isInteger(g))
            throw new Error("Unable to notate fractional steps.");
        b <= 0 || E <= 0 ? (S = 0,
        F = 0) : E > b ? (S = Math.round(g / E),
        g -= S * E,
        F = Math.round(g / b),
        g -= F * b) : (F = Math.round(g / b),
        g -= F * b,
        S = Math.round(g / E),
        g -= S * E);
        let B;
        S >= 0 ? B = "/".repeat(S) : B = "\\".repeat(-S),
        F >= 0 ? B += "^".repeat(F) : B += "v".repeat(-F);
        const Q = g;
        let ae = "";
        return Q && (ae += ` ${Q > 0 ? "+" : "-"} ${Math.abs(Q)}\\`),
        {
            ups: F,
            lifts: S,
            steps: Q,
            prefix: B,
            postfix: ae
        }
    }
    n.countUpsAndLifts = a;
    const l = BigInt("1" + "0".repeat(1e3));
    n.ABSURD_EXPONENT = 3322n;
    function f(g) {
        if (g > l || -g > l)
            throw new Error("Integer overflow.")
    }
    n.validateBigInt = f;
    function h(g, b) {
        const E = new Set;
        for (const S of g)
            E.add(S);
        for (const S of b)
            E.add(S);
        return E
    }
    function p(g, b) {
        return g.union(b)
    }
    n.setUnion = "union"in Set.prototype ? p : h;
    function m(g, b) {
        return "hasOwn"in Object ? Object.hasOwn(g, b) : Object.prototype.hasOwnProperty.call(g, b)
    }
    n.hasOwn = m
}
)(vr);
Object.defineProperty(pt, "__esModule", {
    value: !0
});
pt.intervalLiteralFromJSON = pt.literalToJSON = pt.integerToVectorComponent = pt.fractionToVectorComponent = pt.numberToDecimalLiteral = pt.literalToString = pt.formatComponent = pt.formatAbsoluteFJS = pt.pitchRoundToNodes = pt.lensSubNodes = pt.lensAddNodes = pt.logNodes = pt.ipowNodes = pt.powNodes = pt.projectNodes = pt.mulNodes = pt.divNodes = pt.roundToNodes = pt.modNodes = pt.subNodes = pt.addNodes = pt.sqrtNode = pt.pitchAbsNode = pt.absNode = pt.invertNode = pt.negNode = pt.uniformInvertNode = pt.inferFJSFlavor = pt.validateNode = void 0;
const wa = vr
  , Ci = Ie;
function g6(n) {
    n && (n.type === "IntegerLiteral" ? (0,
    wa.validateBigInt)(n.value) : n.type === "FractionLiteral" ? ((0,
    wa.validateBigInt)(n.numerator),
    (0,
    wa.validateBigInt)(n.denominator)) : (n.type === "DecimalLiteral" || n.type === "CentsLiteral") && (0,
    wa.validateBigInt)(n.whole))
}
pt.validateNode = g6;
function qr(n, t) {
    let e;
    if (n.type === "FJS" || n.type === "AbsoluteFJS") {
        for (const [r,i] of n.superscripts.concat(n.subscripts))
            if (e === void 0)
                e = i;
            else if (e !== i)
                return ""
    } else
        e = n.flavor;
    if (t === void 0)
        return e ?? "";
    if (t.type === "FJS" || t.type === "AbsoluteFJS") {
        for (const [r,i] of t.superscripts.concat(t.subscripts))
            if (e === void 0)
                e = i;
            else if (e !== i)
                return ""
    } else if (e === void 0)
        e = t.flavor;
    else if (e !== t.flavor)
        return "";
    return e ?? ""
}
pt.inferFJSFlavor = qr;
function P2(n) {
    if (n)
        switch (n.type) {
        case "IntegerLiteral":
            return {
                type: "FractionLiteral",
                numerator: 1n,
                denominator: n.value
            };
        case "FractionLiteral":
            return {
                type: "FractionLiteral",
                numerator: n.denominator,
                denominator: n.numerator
            };
        case "NedjiLiteral":
            return {
                ...n,
                numerator: -n.numerator
            }
        }
}
pt.uniformInvertNode = P2;
const wv = {
    "": "-",
    "+": "-",
    "-": ""
};
function v6(n) {
    if (n)
        switch (n.type) {
        case "IntegerLiteral":
            return {
                ...n,
                value: -n.value
            };
        case "DecimalLiteral":
            return {
                ...n,
                sign: wv[n.sign]
            };
        case "FractionLiteral":
            return {
                ...n,
                numerator: -n.numerator
            };
        case "CentsLiteral":
            return {
                ...n,
                sign: wv[n.sign]
            };
        case "StepLiteral":
            return {
                ...n,
                count: -n.count
            };
        case "NedjiLiteral":
            return {
                ...n,
                numerator: -n.numerator
            };
        case "FJS":
        case "AspiringFJS":
            return {
                type: "AspiringFJS",
                flavor: qr(n)
            };
        case "AbsoluteFJS":
        case "AspiringAbsoluteFJS":
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n)
            };
        case "MonzoLiteral":
            return {
                ...n,
                ups: -n.ups,
                lifts: -n.lifts,
                components: n.components.map(t => ({
                    ...t,
                    sign: wv[t.sign]
                }))
            }
        }
}
pt.negNode = v6;
function y6(n) {
    if (n && (n.type === "IntegerLiteral" || n.type === "FractionLiteral"))
        return P2(n)
}
pt.invertNode = y6;
function b6(n) {
    if (n)
        switch (n.type) {
        case "IntegerLiteral":
            return {
                type: "IntegerLiteral",
                value: (0,
                Ci.bigAbs)(n.value)
            };
        case "FractionLiteral":
            return {
                type: "FractionLiteral",
                numerator: (0,
                Ci.bigAbs)(n.numerator),
                denominator: (0,
                Ci.bigAbs)(n.denominator)
            };
        case "DecimalLiteral":
            return {
                ...n,
                sign: ""
            };
        case "StepLiteral":
            return {
                ...n,
                count: Math.abs(n.count)
            };
        case "CentsLiteral":
            return {
                ...n,
                sign: ""
            };
        case "FJS":
        case "AspiringFJS":
            return {
                type: "AspiringFJS",
                flavor: qr(n)
            };
        case "AbsoluteFJS":
        case "AspiringAbsoluteFJS":
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n)
            };
        case "NedjiLiteral":
            return {
                ...n,
                numerator: Math.abs(n.numerator),
                denominator: Math.abs(n.denominator)
            }
        }
}
pt.absNode = b6;
function w6(n) {
    if (n) {
        if (n.type === "IntegerLiteral")
            return n.value === 0n ? void 0 : {
                type: "IntegerLiteral",
                value: (0,
                Ci.bigAbs)(n.value)
            };
        if (n.type === "FractionLiteral") {
            let t = (0,
            Ci.bigAbs)(n.numerator)
              , e = (0,
            Ci.bigAbs)(n.denominator);
            return e > t && ([t,e] = [e, t]),
            {
                type: "FractionLiteral",
                numerator: t,
                denominator: e
            }
        }
    }
}
pt.pitchAbsNode = w6;
function E6(n) {
    if (n)
        switch (n.type) {
        case "StepLiteral":
            return n.count % 2 ? void 0 : {
                ...n,
                count: n.count / 2
            };
        case "NedjiLiteral":
            return {
                ...n,
                numerator: n.numerator % 2 ? n.numerator : n.numerator / 2,
                denominator: n.numerator % 2 ? n.denominator * 2 : n.denominator
            };
        case "FJS":
        case "AspiringFJS":
            return {
                type: "AspiringFJS",
                flavor: qr(n)
            };
        case "AbsoluteFJS":
        case "AspiringAbsoluteFJS":
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n)
            }
        }
}
pt.sqrtNode = E6;
function D2(n, t) {
    if (n.type === "AbsoluteFJS" || n.type === "AspiringAbsoluteFJS") {
        if (t.type === "FJS" || t.type === "AspiringFJS")
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n, t)
            };
        if (t.type === "SquareSuperparticular")
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n)
            }
    }
    if (n.type === "FJS" || n.type === "AspiringFJS") {
        if (t.type === "AbsoluteFJS" || t.type === "AspiringAbsoluteFJS")
            return {
                type: "AspiringAbsoluteFJS",
                flavor: qr(n, t)
            };
        if (t.type === "FJS" || t.type === "AspiringFJS")
            return {
                type: "AspiringFJS",
                flavor: qr(n, t)
            };
        if (t.type === "SquareSuperparticular")
            return {
                type: "AspiringFJS",
                flavor: qr(n)
            }
    }
}
function q2(n, t) {
    if (!(!n || !t)) {
        if (n.type === "IntegerLiteral" && t.type === "IntegerLiteral")
            return {
                type: n.type,
                value: n.value + t.value
            };
        if (n.type === "NedjiLiteral" && t.type === "NedjiLiteral") {
            if (n.equaveNumerator !== t.equaveNumerator || n.equaveDenominator !== t.equaveDenominator)
                return;
            const e = (0,
            Ci.lcm)(n.denominator, t.denominator);
            return {
                type: n.type,
                numerator: e / n.denominator * n.numerator + e / t.denominator * t.numerator,
                denominator: e,
                equaveNumerator: n.equaveNumerator,
                equaveDenominator: n.equaveDenominator
            }
        }
        return n.type === "StepLiteral" && t.type === "StepLiteral" ? {
            type: n.type,
            count: n.count + t.count
        } : D2(n, t)
    }
}
pt.addNodes = q2;
function _6(n, t) {
    if (!(!n || !t)) {
        if (n.type === "IntegerLiteral" && t.type === "IntegerLiteral")
            return {
                type: n.type,
                value: n.value - t.value
            };
        if (n.type === "NedjiLiteral" && t.type === "NedjiLiteral") {
            const e = {
                ...t
            };
            return e.numerator = -t.numerator,
            q2(n, e)
        }
        return (n.type === "AbsoluteFJS" || n.type === "AspiringAbsoluteFJS") && (t.type === "AbsoluteFJS" || t.type === "AspiringAbsoluteFJS") ? {
            type: "AspiringFJS",
            flavor: qr(n, t)
        } : n.type === "StepLiteral" && t.type === "StepLiteral" ? {
            type: n.type,
            count: n.count - t.count
        } : D2(n, t)
    }
}
pt.subNodes = _6;
function L6(n, t) {
    if (!(!n || !t) && (n.type === "FJS" || n.type === "AspiringFJS") && (t.type === "FJS" || t.type === "AspiringFJS"))
        return {
            type: "AspiringFJS",
            flavor: qr(n, t)
        }
}
pt.modNodes = L6;
function S6(n, t) {
    if (!(!n || !t) && (n.type === "FJS" || n.type === "AspiringFJS") && (t.type === "FJS" || t.type === "AspiringFJS"))
        return {
            type: "AspiringFJS",
            flavor: qr(n, t)
        }
}
pt.roundToNodes = S6;
function A6(n, t) {
    if (!(!n || !t) && n.type === "IntegerLiteral" && t.type === "IntegerLiteral")
        return {
            type: "FractionLiteral",
            numerator: n.value,
            denominator: t.value
        }
}
pt.divNodes = A6;
function B2(n, t) {
    if (!(!n || !t)) {
        if (n.type === "IntegerLiteral")
            return t.type === "NedjiLiteral" ? {
                type: "NedjiLiteral",
                numerator: Number(n.value) * t.numerator,
                denominator: t.denominator,
                equaveNumerator: t.equaveNumerator,
                equaveDenominator: t.equaveDenominator
            } : t.type === "FJS" || t.type === "AspiringFJS" ? {
                type: "AspiringFJS",
                flavor: qr(t)
            } : t.type === "CentLiteral" ? {
                type: "CentsLiteral",
                sign: n.value < 0n ? "-" : "",
                whole: (0,
                Ci.bigAbs)(n.value),
                fractional: "",
                exponent: null,
                real: t.real
            } : t.type === "StepLiteral" ? {
                type: "StepLiteral",
                count: Number(n.value) * t.count
            } : void 0;
        if (n.type === "DecimalLiteral")
            return n.flavor === "z" ? void 0 : t.type === "CentLiteral" ? {
                type: "CentsLiteral",
                sign: n.sign,
                whole: n.whole,
                fractional: n.fractional,
                exponent: n.exponent,
                real: t.real || n.flavor === "r"
            } : void 0;
        if (t.type === "IntegerLiteral" || t.type === "DecimalLiteral")
            return B2(t, n)
    }
}
pt.mulNodes = B2;
function C6(n, t) {
    if (!(!n || !t) && n.type === "NedjiLiteral" && n.equaveNumerator === null) {
        if (t.type === "IntegerLiteral")
            return {
                ...n,
                equaveNumerator: Number(t.value)
            };
        if (t.type === "FractionLiteral")
            return {
                ...n,
                equaveNumerator: Number(t.numerator),
                equaveDenominator: Number(t.denominator)
            }
    }
}
pt.projectNodes = C6;
function $6(n, t) {
    if (!(!n || !t) && t.type === "IntegerLiteral") {
        const e = t.value;
        if (e >= 0n) {
            if (e > wa.ABSURD_EXPONENT)
                return;
            if (n.type === "IntegerLiteral")
                return {
                    type: "IntegerLiteral",
                    value: n.value ** e
                };
            if (n.type === "FractionLiteral")
                return {
                    type: "FractionLiteral",
                    numerator: n.numerator ** e,
                    denominator: n.denominator ** e
                }
        } else {
            if (-e > wa.ABSURD_EXPONENT)
                return;
            if (n.type === "IntegerLiteral")
                return {
                    type: "FractionLiteral",
                    numerator: 1n,
                    denominator: n.value ** -e
                };
            if (n.type === "FractionLiteral")
                return {
                    type: "FractionLiteral",
                    numerator: n.denominator ** -e,
                    denominator: n.numerator ** -e
                }
        }
    }
}
pt.powNodes = $6;
function M6(n, t) {}
pt.ipowNodes = M6;
function O6(n, t) {}
pt.logNodes = O6;
function N6(n, t) {}
pt.lensAddNodes = N6;
function T6(n, t) {}
pt.lensSubNodes = T6;
function x6(n, t) {}
pt.pitchRoundToNodes = x6;
function Tm(n) {
    let t;
    return n.lifts < 0 ? t = "\\".repeat(-n.lifts) : t = "/".repeat(n.lifts),
    n.ups < 0 ? t += "v".repeat(-n.ups) : t += "^".repeat(n.ups),
    t
}
function vh(n) {
    let t = "";
    return n.superscripts.length && (t += "^" + n.superscripts.map(e => e.join("")).join(",")),
    n.subscripts.length && (t += "_" + n.subscripts.map(e => e.join("")).join(",")),
    t
}
function I6(n) {
    const t = Tm(n)
      , e = n.pythagorean.degree
      , r = n.pythagorean.quality
      , i = (n.pythagorean.augmentations ?? []).join("");
    return `${t}${r.fraction}${r.quality}${i}${e.negative ? "-" : ""}${e.base + 7 * e.octaves}${vh(n)}`
}
function F6(n) {
    const t = Tm(n)
      , e = n.mosStep
      , r = e.quality
      , i = (e.augmentations ?? []).join("");
    return `${t}${r.fraction}${r.quality}${i}${e.degree}ms${vh(n)}`
}
function k2(n, t=!0) {
    const e = Tm(n)
      , r = n.pitch
      , i = r.accidentals.map(a => `${a.fraction}${a.accidental}`).join("");
    return t ? `${e}${r.nominal}${i}${r.octave}${vh(n)}` : `${e}${r.nominal}${i}${vh(n)}`
}
pt.formatAbsoluteFJS = k2;
function R6(n) {
    let t = n.sign + n.whole.toString();
    n.fractional && (t += "." + n.fractional);
    const e = n.exponent !== null ? "e" + n.exponent.toString() : n.flavor ? "" : "e";
    return `${t}${e}${n.flavor}`
}
function P6(n) {
    const t = n.sign + n.whole.toString() + "." + n.fractional
      , e = n.exponent !== null ? "e" + n.exponent.toString() : "";
    return n.real ? `${t}${e}r` : e ? `${t}${e}` : t
}
function z2(n) {
    const {sign: t, left: e, separator: r, right: i, exponent: a} = n
      , l = a ? `e${a}` : "";
    return `${t === "-" ? "-" : ""}${e}${r ?? ""}${i}${l}`
}
pt.formatComponent = z2;
function V2(n) {
    return n.map(z2).join(" ")
}
function D6(n) {
    if (n.equaveNumerator === null)
        return `${n.numerator}\\${n.denominator}`;
    let t = n.equaveNumerator.toString();
    return n.equaveDenominator !== null && (t += "/" + n.equaveDenominator.toString()),
    `${n.numerator}\\${n.denominator}<${t}>`
}
function N0(n) {
    const t = n.radical ? "" : "";
    return n.denominator ? `${t}${n.numerator}/${n.denominator}` : `${t}${n.numerator}`
}
function bc(n) {
    if (!Array.isArray(n))
        throw new Error("Unexpected unpruned identifier.");
    return n.map(t => typeof t == "string" ? t : N0(t)).join(".")
}
function q6(n) {
    return n.tweak > 0 ? "^".repeat(n.tweak) + N0(n.element) : "v".repeat(-n.tweak) + N0(n.element)
}
function B6(n) {
    let t = "";
    return n.equave && (t += "[" + n.equave + "]"),
    t += n.divisions.toString(),
    n.tweaks && (t += "[" + n.tweaks.map(q6).join(",") + "]"),
    t + "@" + bc(n.basis)
}
function k6(n) {
    if (!Array.isArray(n.basis))
        throw new Error("Unexpected unpruned identifier.");
    let t = `${Tm(n)}[${V2(n.components)}>`;
    return n.basis.length && (t += `@${bc(n.basis)}`),
    t
}
function z6(n) {
    let t = `<${V2(n.components)}]`;
    if (!Array.isArray(n.basis))
        throw new Error("Unexpected unpruned identifier.");
    return n.basis.length && (t += `@${bc(n.basis)}`),
    t
}
function V6(n) {
    return n.end ? `S${n.start}..${n.end}` : `S${n.start}`
}
function U6(n) {
    switch (n.type) {
    case "NedjiLiteral":
        return D6(n);
    case "StepLiteral":
        return `${n.count}`;
    case "FractionLiteral":
        return `${n.numerator}/${n.denominator}`;
    case "RadicalLiteral":
        return `${n.argument.toFraction()}^${n.exponent.toFraction()}`;
    case "DecimalLiteral":
        return R6(n);
    case "CentsLiteral":
        return P6(n);
    case "CentLiteral":
        return `${n.real ? "r" : ""}`;
    case "ReciprocalCentLiteral":
        return "";
    case "ReciprocalLogarithmicHertzLiteral":
        return "";
    case "NotANumberLiteral":
        return "nan";
    case "InfinityLiteral":
        return "inf";
    case "FJS":
        return I6(n);
    case "AbsoluteFJS":
        return k2(n);
    case "WartsLiteral":
        return `${n.equave}${n.divisions}${n.warts.join("")}@${bc(n.basis)}`;
    case "SparseOffsetVal":
        return B6(n);
    case "HertzLiteral":
        return `${n.prefix}Hz`;
    case "SecondLiteral":
        return `${n.prefix}s`;
    case "MonzoLiteral":
        return k6(n);
    case "ValLiteral":
        return z6(n);
    case "IntegerLiteral":
        return n.value.toString();
    case "SquareSuperparticular":
        return V6(n);
    case "MosStepLiteral":
        return F6(n);
    case "ValBasisLiteral":
        return "@" + bc(n.basis);
    default:
        throw new Error(`Cannot format ${n.type}.`)
    }
}
pt.literalToString = U6;
function j6(n, t) {
    let[e,r] = n.toString().split(".")
      , i = ""
      , a = BigInt(e)
      , l = null;
    if (r ?? (r = ""),
    a < 0n && (i = "-",
    a = -a),
    r.includes("e")) {
        let f;
        [r,f] = r.split("e"),
        l = parseInt(f, 10)
    }
    return {
        type: "DecimalLiteral",
        flavor: t,
        sign: i,
        whole: a,
        fractional: r,
        exponent: l
    }
}
pt.numberToDecimalLiteral = j6;
function H6(n) {
    const t = n.d === 1 ? "" : n.d.toString()
      , e = n.d === 1 ? void 0 : "/";
    return {
        sign: n.s < 0 ? "-" : "",
        left: n.n,
        right: t,
        separator: e,
        exponent: null
    }
}
pt.fractionToVectorComponent = H6;
function G6(n) {
    return {
        sign: n < 0 ? "-" : "",
        left: Math.abs(n),
        right: "",
        exponent: null
    }
}
pt.integerToVectorComponent = G6;
function W6(n) {
    if (!n)
        return;
    const t = n.type;
    switch (n.type) {
    case "IntegerLiteral":
        return {
            type: "i",
            v: n.value.toString()
        };
    case "FractionLiteral":
        return {
            type: "f",
            n: n.numerator.toString(),
            d: n.denominator.toString()
        };
    case "CentsLiteral":
        return {
            type: "c",
            s: n.sign,
            w: n.whole.toString(),
            f: n.fractional,
            e: n.exponent,
            r: n.real
        };
    case "NedjiLiteral":
        return {
            type: "n",
            n: n.numerator,
            d: n.denominator,
            p: n.equaveNumerator,
            q: n.equaveDenominator
        };
    case "DecimalLiteral":
        return {
            ...n,
            whole: n.whole.toString()
        };
    case "RadicalLiteral":
        return {
            type: t,
            argument: n.argument.toJSON(),
            exponent: n.exponent.toJSON()
        };
    case "SquareSuperparticular":
        return {
            type: t,
            start: n.start.toString(),
            end: n.end && n.end.toString()
        };
    case "StepLiteral":
    case "CentLiteral":
    case "ReciprocalCentLiteral":
    case "NotANumberLiteral":
    case "InfinityLiteral":
    case "FJS":
    case "AspiringFJS":
    case "AbsoluteFJS":
    case "AspiringAbsoluteFJS":
    case "MosStepLiteral":
    case "HertzLiteral":
    case "SecondLiteral":
    case "ReciprocalLogarithmicHertzLiteral":
    case "MonzoLiteral":
    case "ValLiteral":
    case "SparseOffsetVal":
    case "WartsLiteral":
    case "ValBasisLiteral":
        return n
    }
}
pt.literalToJSON = W6;
function J6(n) {
    if (n === void 0)
        return;
    const t = n.type;
    switch (t) {
    case "i":
        return {
            type: "IntegerLiteral",
            value: BigInt(n.v)
        };
    case "f":
        return {
            type: "FractionLiteral",
            numerator: BigInt(n.n),
            denominator: BigInt(n.d)
        };
    case "c":
        return {
            type: "CentsLiteral",
            sign: n.s,
            whole: BigInt(n.w),
            fractional: n.f,
            exponent: n.e,
            real: n.r
        };
    case "n":
        return {
            type: "NedjiLiteral",
            numerator: n.n,
            denominator: n.d,
            equaveNumerator: n.p,
            equaveDenominator: n.q
        };
    case "DecimalLiteral":
        return {
            ...n,
            whole: BigInt(n.whole)
        };
    case "RadicalLiteral":
        return {
            type: t,
            argument: Ci.Fraction.reviver("argument", n.argument),
            exponent: Ci.Fraction.reviver("exponent", n.exponent)
        };
    case "SquareSuperparticular":
        return {
            type: t,
            start: BigInt(n.start),
            end: n.end && BigInt(n.end)
        };
    case "StepLiteral":
    case "CentLiteral":
    case "NotANumberLiteral":
    case "InfinityLiteral":
    case "FJS":
    case "AspiringFJS":
    case "AbsoluteFJS":
    case "AspiringAbsoluteFJS":
    case "MosStepLiteral":
    case "HertzLiteral":
    case "SecondLiteral":
    case "MonzoLiteral":
        return n;
    case "IntegerLiteral":
    case "FractionLiteral":
    case "NedjiLiteral":
    case "CentsLiteral":
        throw new Error("Unexpected uncompressed literal.")
    }
}
pt.intervalLiteralFromJSON = J6;
Object.defineProperty(Rf, "__esModule", {
    value: !0
});
Rf.expressionToString = void 0;
const K6 = pt;
function Z6(n) {
    switch (n.type) {
    case "IntegerLiteral":
    case "DecimalLiteral":
    case "FractionLiteral":
    case "RadicalLiteral":
    case "StepLiteral":
    case "NedjiLiteral":
    case "CentsLiteral":
    case "CentLiteral":
    case "ReciprocalCentLiteral":
    case "ReciprocalLogarithmicHertzLiteral":
    case "FJS":
    case "AspiringFJS":
    case "AbsoluteFJS":
    case "AspiringAbsoluteFJS":
    case "HertzLiteral":
    case "SecondLiteral":
    case "MonzoLiteral":
    case "ValLiteral":
    case "SparseOffsetVal":
    case "WartsLiteral":
    case "SquareSuperparticular":
        return (0,
        K6.literalToString)(n);
    case "TrueLiteral":
        return "true";
    case "FalseLiteral":
        return "false";
    case "NoneLiteral":
        return "niente";
    case "Identifier":
        return n.id;
    case "PopScale":
        return n.parent ? "" : "";
    case "TemplateArgument":
        return `${n.index}`;
    case "StringLiteral":
        return JSON.stringify(n.value)
    }
    throw new Error(`Cannot convert ${n.type} to string.`)
}
Rf.expressionToString = Z6;
var Df = {}
  , In = {}
  , hn = {}
  , An = {};
Object.defineProperty(An, "__esModule", {
    value: !0
});
An.TimeMonzo = An.TimeReal = An.getNumberOfComponents = An.setNumberOfComponents = void 0;
const et = Ie
  , Cn = vr
  , or = pt;
let Ea = Cn.NUM_INTERCHANGE_COMPONENTS;
function Y6(n) {
    Ea = n
}
An.setNumberOfComponents = Y6;
function Q6() {
    return Ea
}
An.getNumberOfComponents = Q6;
function U2(n, t) {
    if (n === t)
        return !0;
    if (n.length > t.length)
        return U2(t, n);
    for (let e = 0; e < n.length; ++e)
        if (!n[e].equals(t[e]))
            return !1;
    for (let e = n.length; e < t.length; ++e)
        if (t[e].n !== 0)
            return !1;
    return !0
}
function yE(n) {
    return n >= 1 && n < 4294967296 ? n && !(n & n - 1) : Math.log2(n) % 1 === 0
}
function bE(n) {
    let t = n.d;
    for (; t % 2 === 0; )
        t /= 2;
    for (; t % 5 === 0; )
        t /= 5;
    return t === 1
}
function wE(n, t) {
    return n.compare(t) < 0 ? t : n
}
function EE(n, t) {
    return n.compare(t) > 0 ? t : n
}
function $d(n, t) {
    const e = (0,
    et.gcd)(n, t);
    if (e === 1)
        return 0;
    n /= e,
    t /= e;
    let r = 0;
    for (const [i,a] of (0,
    et.primeFactorize)(e)) {
        let l = a;
        for (; !(n % i); )
            ++l,
            n /= i;
        let f = a;
        for (; !(t % i); )
            ++f,
            t /= i;
        r += l * f
    }
    return r
}
class dt {
    constructor(t, e) {
        if (e || (t = 0),
        !isFinite(t))
            throw new Error("Time exponent must be finite.");
        this.timeExponent = t,
        this.value = e
    }
    static fromValue(t) {
        return new dt(0,t)
    }
    static fromCents(t) {
        return new dt(0,(0,
        et.centsToValue)(t))
    }
    static fromFrequency(t) {
        return new dt(-1,t)
    }
    static reviver(t, e) {
        if (typeof e == "object" && e !== null && e.type === "TimeReal") {
            let r = e.v;
            return r === "nan" ? r = NaN : r === "inf" ? r = 1 / 0 : r === "-inf" && (r = -1 / 0),
            new dt(e.t,r)
        }
        return e
    }
    toJSON() {
        let t = this.value;
        return isNaN(t) ? t = "nan" : (t === 1 / 0 || t === -1 / 0) && (t = "inf"),
        {
            type: "TimeReal",
            t: this.timeExponent,
            v: t
        }
    }
    clone() {
        return new dt(this.timeExponent,this.value)
    }
    toCents(t=!1) {
        if (this.timeExponent)
            throw new Error("Unable to convert a non-scalar to cents.");
        return this.totalCents(t)
    }
    totalCents(t=!1) {
        return t ? (0,
        et.valueToCents)(Math.abs(this.value)) : (0,
        et.valueToCents)(this.value)
    }
    isScalar() {
        return this.timeExponent === 0
    }
    neg() {
        return new dt(this.timeExponent,-this.value)
    }
    inverse() {
        return new dt(-this.timeExponent,1 / this.value)
    }
    sqrt() {
        return new dt(this.timeExponent / 2,Math.sqrt(this.value))
    }
    abs() {
        if (this.timeExponent)
            throw new Error("Absolute value is undefined in the absolute echelon.");
        return new dt(this.timeExponent,Math.abs(this.value))
    }
    pitchAbs() {
        if (this.timeExponent)
            throw new Error("Geometric absolute value is undefined in the absolute echelon.");
        const t = Math.abs(this.value);
        return t < 1 ? new dt(this.timeExponent,1 / t) : new dt(this.timeExponent,t)
    }
    valueOf() {
        return this.value
    }
    equals(t) {
        return this.value === t.valueOf()
    }
    strictEquals(t) {
        return t instanceof Rt ? !1 : this.timeExponent === t.timeExponent && this.value === t.value
    }
    compare(t) {
        return this.value - t.valueOf()
    }
    pow(t) {
        if (t instanceof Rt || t instanceof dt) {
            if (t.timeExponent.valueOf())
                throw new Error("Cannot raise to a non-scalar power.");
            const r = t.valueOf();
            return new dt(this.timeExponent * r,this.value ** r)
        }
        if (typeof t == "number")
            return t === 0 ? new Rt(Cn.ZERO,[]) : new dt(this.timeExponent * t,this.value ** t);
        const e = new et.Fraction(t).valueOf();
        return e ? new dt(this.timeExponent * e,this.value ** e) : new Rt(Cn.ZERO,[])
    }
    tenneyHeight() {
        return this.value < 0 ? NaN : 1 / 0
    }
    lpow(t) {
        if (this.timeExponent)
            throw new Error("Cannot raise to a non-scalar power.");
        return new dt(t.timeExponent.valueOf() * this.value,t.valueOf() ** this.value)
    }
    log(t) {
        if (this.timeExponent) {
            if (t instanceof Rt || t instanceof dt) {
                if (t.timeExponent.valueOf() === 0)
                    throw new Error("Cannot take a scalar logarithm of a value with time units.")
            } else
                throw new Error("Cannot take a scalar logarithm of a value with time units.");
            const e = this.timeExponent / t.timeExponent.valueOf()
              , r = this.totalCents() / t.totalCents();
            if (e !== r)
                throw new Error("Logarithm doesn't exist.");
            return e
        }
        return t instanceof Rt || t instanceof dt ? this.totalCents() / t.totalCents() : typeof t == "number" ? this.totalCents() / (0,
        et.valueToCents)(t) : (t = new et.Fraction(t),
        this.totalCents() / (0,
        et.valueToCents)(t.valueOf()))
    }
    add(t) {
        if (this.value === 0)
            return t.clone();
        const e = t.valueOf();
        if (e === 0)
            return this.clone();
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in addition.");
        return new dt(this.timeExponent,this.value + e)
    }
    sub(t) {
        if (this.value === 0)
            return t.neg();
        const e = t.valueOf();
        if (e === 0)
            return this.clone();
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in subtraction.");
        return new dt(this.timeExponent,this.value - e)
    }
    lsub(t) {
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in addition.");
        return new dt(this.timeExponent,t.valueOf() - this.value)
    }
    lensAdd(t) {
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in addition.");
        if (this.value) {
            const e = t.valueOf();
            return new dt(this.timeExponent,this.value * e / (this.value + e))
        }
        return new dt(this.timeExponent,0)
    }
    lensSub(t) {
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in subtraction.");
        if (this.value) {
            const e = t.valueOf();
            return new dt(this.timeExponent,this.value * e / (e - this.value))
        }
        return new dt(this.timeExponent,0)
    }
    leftLensSub(t) {
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in subtraction.");
        if (this.value) {
            const e = t.valueOf();
            return new dt(this.timeExponent,this.value * e / (this.value - e))
        }
        return new dt(this.timeExponent,0)
    }
    mul(t) {
        return new dt(this.timeExponent + t.timeExponent.valueOf(),this.value * t.valueOf())
    }
    div(t) {
        return new dt(this.timeExponent - t.timeExponent.valueOf(),this.value / t.valueOf())
    }
    ldiv(t) {
        return new dt(t.timeExponent.valueOf() - this.timeExponent,t.valueOf() / this.value)
    }
    roundTo(t) {
        const e = Math.round(this.div(t).valueOf());
        return t.mul(Rt.fromFraction(e))
    }
    pitchRoundTo(t) {
        const e = Math.round(this.totalCents() / t.totalCents());
        return t.pow(e)
    }
    mmod(t, e=!1) {
        if (this.value === 0)
            return e ? t.clone() : this.clone();
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in modulo.");
        const r = t.valueOf();
        return e ? new dt(this.timeExponent,(0,
        et.modc)(this.value, r)) : new dt(this.timeExponent,(0,
        et.mmod)(this.value, r))
    }
    lmmod(t, e=!1) {
        if (t.timeExponent.valueOf() !== this.timeExponent)
            throw new Error("Time exponents must match in modulo.");
        return e ? new dt(this.timeExponent,(0,
        et.mmod)(t.valueOf(), this.value) || this.value) : new dt(this.timeExponent,(0,
        et.mmod)(t.valueOf(), this.value))
    }
    reduce(t, e=!1) {
        const r = this.log(t);
        let i;
        return e && (i = t.pow(1 - Math.ceil(r))),
        i = t.pow(-Math.floor(r)),
        i instanceof Rt ? this.mul(i) : new dt(this.timeExponent + i.timeExponent,this.value * i.value)
    }
    dot(t) {
        const e = new et.Fraction(this.timeExponent).simplify(1e-8);
        return t instanceof dt ? e.mul(new et.Fraction(t.timeExponent).simplify(1e-8)) : e.mul(t.timeExponent)
    }
    asDecimalLiteral() {
        if (!this.timeExponent && !(isNaN(this.value) || !isFinite(this.value)))
            return (0,
            or.numberToDecimalLiteral)(this.valueOf(), "r")
    }
    asCentsLiteral() {
        if (this.timeExponent)
            return;
        const t = this.totalCents();
        if (isNaN(t) || !isFinite(t))
            return;
        const {sign: e, whole: r, fractional: i, exponent: a} = (0,
        or.numberToDecimalLiteral)(t, "r");
        return {
            type: "CentsLiteral",
            sign: e,
            whole: r,
            fractional: i,
            exponent: a,
            real: !0
        }
    }
    asMonzoLiteral(t=!1) {
        const e = []
          , r = [];
        if (isNaN(this.value))
            return r.push({
                numerator: 0,
                denominator: null,
                radical: !1
            }),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            }),
            r.push("inf"),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            }),
            {
                type: "MonzoLiteral",
                components: e,
                ups: 0,
                lifts: 0,
                basis: r
            };
        if (t) {
            if (this.timeExponent) {
                r.push("Hz");
                const {sign: h, whole: p, fractional: m, exponent: g} = (0,
                or.numberToDecimalLiteral)(-this.timeExponent, "r");
                e.push({
                    sign: h,
                    left: Number(p),
                    separator: ".",
                    right: m,
                    exponent: g
                })
            }
        } else if (this.timeExponent === -1)
            r.push("Hz"),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            });
        else if (this.timeExponent) {
            r.push("s");
            const {sign: h, whole: p, fractional: m, exponent: g} = (0,
            or.numberToDecimalLiteral)(this.timeExponent, "r");
            e.push({
                sign: h,
                left: Number(p),
                separator: ".",
                right: m,
                exponent: g
            })
        }
        if (this.value < 0)
            r.push({
                numerator: -1,
                denominator: null,
                radical: !1
            }),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            });
        else if (this.value === 0)
            return r.push("inf"),
            e.push({
                sign: "-",
                left: 1,
                right: "",
                exponent: null
            }),
            {
                type: "MonzoLiteral",
                components: e,
                ups: 0,
                lifts: 0,
                basis: r
            };
        if (!isFinite(this.value))
            return r.push("inf"),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            }),
            {
                type: "MonzoLiteral",
                components: e,
                ups: 0,
                lifts: 0,
                basis: r
            };
        r.push("rc");
        const {sign: i, whole: a, fractional: l, exponent: f} = (0,
        or.numberToDecimalLiteral)(this.totalCents(!0), "r");
        return e.push({
            sign: i,
            left: Number(a),
            separator: ".",
            right: l,
            exponent: f
        }),
        {
            type: "MonzoLiteral",
            components: e,
            ups: 0,
            lifts: 0,
            basis: r
        }
    }
    asInterchangeLiteral() {
        return this.asMonzoLiteral(!0)
    }
    formatTimeExponent() {
        return this.timeExponent ? this.timeExponent === -1 ? "Hz" : this.timeExponent === 1 ? "s" : `s^${(0,
        or.literalToString)((0,
        or.numberToDecimalLiteral)(this.timeExponent, "r"))}` : ""
    }
    toString(t="linear") {
        if (t === "cologarithmic")
            throw new Error("Real numbers don't have a co-domain.");
        if (isNaN(this.value))
            switch (t) {
            case "linear":
                return "nan";
            case "logarithmic":
                return "logarithmic(nan)"
            }
        if (!isFinite(this.value)) {
            let r = this.value < 0 ? "-inf" : "inf";
            switch (this.timeExponent && (r = `${r} * 1${this.formatTimeExponent()}`),
            t) {
            case "linear":
                return r;
            case "logarithmic":
                return `logarithmic(${r})`
            }
        }
        if (t === "linear") {
            const r = this.clone();
            return r.timeExponent = 0,
            `${(0,
            or.literalToString)(r.asDecimalLiteral())}${this.formatTimeExponent()}`
        }
        if (!this.timeExponent) {
            const r = this.asCentsLiteral();
            if (r)
                return (0,
                or.literalToString)(r)
        }
        const e = this.asMonzoLiteral();
        if (!e)
            throw new Error("Unable to represent real quantity as a string.");
        return (0,
        or.literalToString)(e)
    }
    approximateHarmonic(t) {
        const e = Math.round(this.valueOf() * t);
        return Rt.fromFraction(new et.Fraction(e,t))
    }
    approximateSubharmonic(t) {
        const e = Math.round(t / this.valueOf());
        return Rt.fromFraction(new et.Fraction(t,e))
    }
    approximateSimple(t) {
        const e = new et.Fraction(this.valueOf()).simplify(t);
        return Rt.fromFraction(e)
    }
    toContinued() {
        return new et.Fraction(this.valueOf()).toContinued()
    }
    getConvergent(t) {
        const e = this.toContinued().slice(0, t + 1);
        let r = new et.Fraction(e[e.length - 1]);
        for (let i = e.length - 2; i >= 0; i--)
            r = r.inverse().add(e[i]);
        return Rt.fromFraction(r)
    }
    isIntegral() {
        return !1
    }
    isFractional() {
        return !1
    }
    isSqrt() {
        return !1
    }
    isEqualTemperament() {
        return !1
    }
    isUnity() {
        return !1
    }
    isDecimal() {
        return !1
    }
    isPowerOfTwo() {
        return !1
    }
    toBigInteger() {
        throw new Error("Cannot convert irrational value to integer.")
    }
    toFraction() {
        throw new Error("Cannot convert irrational value to a fraction.")
    }
    toBigNumeratorDenominator() {
        throw new Error("Cannot convert irrational value to a fraction.")
    }
    toIntegerMonzo() {
        throw new Error("Cannot convert irrational value to a monzo with integer components.")
    }
    toMonzo() {
        throw new Error("Cannot convert irrational value to an array of numbers.")
    }
    toEqualTemperament() {
        throw new Error("Cannot convert real value to equal temperament.")
    }
    tail() {
        return this.clone()
    }
    gcd(t) {
        return new dt(Math.min(this.timeExponent, t.timeExponent.valueOf()),1)
    }
    lcm(t) {
        return new dt(Math.max(this.timeExponent, t.timeExponent.valueOf()),this.value * t.valueOf())
    }
    get octaves() {
        return new et.Fraction(0)
    }
    project() {
        return new Rt(Cn.ZERO,[])
    }
    divisors() {
        throw new Error("Can only calculate the divisors of a natural number.")
    }
    factorize() {
        throw new Error("Can only factorize radicals.")
    }
    asIntegerLiteral() {}
    asFractionLiteral() {}
    asNedjiLiteral() {}
    asRadicalLiteral() {}
}
An.TimeReal = dt;
class Rt {
    constructor(t, e, r) {
        r === void 0 && (r = new et.Fraction(1)),
        r.n || (t = new et.Fraction(0),
        e = e.map(i => new et.Fraction(0))),
        this.timeExponent = t,
        this.primeExponents = e,
        this.residual = r
    }
    static fromFraction(t, e) {
        const [r,i] = (0,
        et.toMonzoAndResidual)(t, e ?? Ea);
        return new Rt(new et.Fraction(0),r.map(a => new et.Fraction(a)),i)
    }
    static fromEqualTemperament(t, e, r) {
        if (e === void 0 && (e = Cn.TWO),
        r === void 0)
            r = Math.max((0,
            et.primeLimit)(e, !0), Ea);
        else if ((0,
        et.primeLimit)(e, !0) > r)
            throw new Error(`Not enough components to represent equave ${e}.`);
        const [i,a] = (0,
        et.toMonzoAndResidual)(e, r);
        if (!a.isUnity())
            throw new Error("Unable to convert equave to monzo.");
        const l = new et.Fraction(t)
          , f = i.map(h => l.mul(h));
        return new Rt(new et.Fraction(0),f)
    }
    static fromFractionalFrequency(t, e) {
        const r = Rt.fromFraction(t, e);
        return r.timeExponent = new et.Fraction(-1),
        r
    }
    static fromBigInt(t, e) {
        const [r,i] = (0,
        et.toMonzoAndResidual)(t, e ?? Ea)
          , a = Number(i);
        if (Math.abs(a) > Number.MAX_SAFE_INTEGER)
            throw new Error("Residual exceeds safe limit.");
        return new Rt(Cn.ZERO,r.map(l => new et.Fraction(l)),new et.Fraction(a))
    }
    static fromBigNumeratorDenominator(t, e, r) {
        if (e === 0n)
            throw new Error("Division by zero.");
        r ?? (r = Ea);
        const [i,a] = (0,
        et.toMonzoAndResidual)(t, r)
          , [l,f] = (0,
        et.toMonzoAndResidual)(e, r)
          , h = (0,
        et.gcd)(a, f)
          , p = new et.Fraction(Number(a / h),Number(f / h));
        return new Rt(Cn.ZERO,i.map( (m, g) => new et.Fraction(m - l[g])),p)
    }
    static fromFractionalCents(t, e) {
        if (e ?? (e = Ea),
        e < 1)
            throw new Error("Too few components to represent cents.");
        const r = [new et.Fraction(t).div(1200)];
        for (; r.length < e; )
            r.push(new et.Fraction(0));
        return new Rt(Cn.ZERO,r)
    }
    static fromArray(t) {
        return new Rt(new et.Fraction(0),t.map(e => new et.Fraction(e)))
    }
    static reviver(t, e) {
        if (typeof e == "object" && e !== null && e.type === "TimeMonzo") {
            const r = et.Fraction.reviver("t", e.t)
              , i = [];
            for (let l = 0; l < e.p.length; l += 2)
                i.push(new et.Fraction(e.p[l],e.p[l + 1]));
            const a = et.Fraction.reviver("r", e.r);
            return new Rt(r,i,a)
        }
        return e
    }
    toJSON() {
        return {
            type: "TimeMonzo",
            t: this.timeExponent.toJSON(),
            p: this.primeExponents.map(t => [t.s * t.n, t.d]).flat(),
            r: this.residual.toJSON()
        }
    }
    get numberOfComponents() {
        return this.primeExponents.length
    }
    set numberOfComponents(t) {
        for (; this.primeExponents.length > t; ) {
            const e = this.primeExponents.length - 1
              , r = this.primeExponents.pop();
            if (r.d === 1)
                this.residual = this.residual.mul(Cn.FRACTION_PRIMES[e].pow(r));
            else
                throw new Error("Cannot truncate fractional monzo.")
        }
        if (this.primeExponents.length < t) {
            const [e,r] = (0,
            et.toMonzoAndResidual)(this.residual, t);
            for (; this.primeExponents.length < t; )
                this.primeExponents.push(new et.Fraction(e[this.primeExponents.length]));
            this.residual = r
        }
    }
    get octaves() {
        if (this.numberOfComponents > 0)
            return this.primeExponents[0];
        let t = new et.Fraction(0)
          , e = this.residual.n;
        for (; e % 2; )
            e /= 2,
            t = t.add(1);
        let r = this.residual.d;
        for (; r % 2; )
            r /= 2,
            t = t.sub(1);
        return t
    }
    clone() {
        const t = [...this.primeExponents.map(e => e.clone())];
        return new Rt(this.timeExponent.clone(),t,this.residual.clone())
    }
    toFraction() {
        if (!this.primeExponents.length)
            return this.residual.clone();
        let t = this.residual;
        return this.primeExponents.forEach( (e, r) => {
            const i = Cn.FRACTION_PRIMES[r].pow(e);
            if (i === null)
                throw new Error("Unable to convert irrational number to fraction.");
            t = t.mul(i)
        }
        ),
        t
    }
    toBigNumeratorDenominator() {
        let t = BigInt(this.residual.n * this.residual.s)
          , e = BigInt(this.residual.d);
        return this.primeExponents.forEach( (r, i) => {
            if (r.d !== 1)
                throw new Error("Unable to convert irrational number to fraction.");
            const a = BigInt(r.n);
            if (a > Cn.ABSURD_EXPONENT)
                throw new Error("Integer overflow.");
            r.s > 0 ? t *= et.BIG_INT_PRIMES[i] ** a : r.s < 0 && (e *= et.BIG_INT_PRIMES[i] ** a)
        }
        ),
        (0,
        Cn.validateBigInt)(t),
        (0,
        Cn.validateBigInt)(e),
        {
            numerator: t,
            denominator: e
        }
    }
    toBigInteger() {
        if (this.residual.d !== 1)
            throw new Error("Unable to convert fractional number to integer.");
        let t = BigInt(this.residual.n * this.residual.s);
        return this.primeExponents.forEach( (e, r) => {
            if (e.d !== 1)
                throw new Error("Unable to convert irrational number to integer.");
            if (e.s < 0)
                throw new Error("Unable to convert fractional number to integer.");
            const i = BigInt(e.n);
            if (i > 3322n)
                throw new Error("Integer overflow.");
            t *= et.BIG_INT_PRIMES[r] ** i
        }
        ),
        (0,
        Cn.validateBigInt)(t),
        t
    }
    toCents(t=!1) {
        if (this.timeExponent.n)
            throw new Error("Unable to convert a non-scalar to cents.");
        return this.totalCents(t)
    }
    toEqualTemperament(t=!1) {
        if (!this.residual.isUnity())
            throw new Error("Unable to convert non-representable fraction to equal temperament.");
        if (this.primeExponents.length === 0)
            return {
                fractionOfEquave: new et.Fraction(0),
                equave: new et.Fraction(1)
            };
        if (this.primeExponents.slice(1).every(f => !f.n))
            return {
                fractionOfEquave: this.primeExponents[0].clone(),
                equave: new et.Fraction(2)
            };
        let e = 1;
        for (const f of this.primeExponents)
            e = (0,
            et.lcm)(e, f.d);
        let r = 0;
        for (const f of this.primeExponents)
            r = (0,
            et.gcd)(r, f.mul(e).n);
        if (r === 0)
            return {
                fractionOfEquave: new et.Fraction(0),
                equave: new et.Fraction(1)
            };
        let i = new et.Fraction(r,e);
        const a = this.pow(i.inverse());
        if (!(a instanceof Rt && a.isFractional()))
            throw new Error("Equal temperament conversion failed.");
        let l = a.toFraction();
        return l.compare(Cn.ONE) < 0 && (i = i.neg(),
        l = l.inverse()),
        t && i.s < 0 && l.d !== 1 && (i = i.neg(),
        l = l.inverse()),
        {
            fractionOfEquave: i,
            equave: l
        }
    }
    toIntegerMonzo(t) {
        if (!this.residual.isUnity())
            throw new Error("Cannot convert monzo with residual to integers.");
        const e = [];
        for (const r of this.primeExponents) {
            if (r.d !== 1)
                throw new Error("Cannot convert fractional monzo to integers.");
            e.push(r.valueOf())
        }
        for (; t && e.length && !e[e.length - 1]; )
            e.pop();
        return e
    }
    toMonzo(t) {
        if (!this.residual.isUnity())
            throw new Error("Cannot convert time monzo with residual to an array of numbers.");
        const e = [];
        for (const r of this.primeExponents)
            e.push(r.valueOf());
        for (; t && e.length && !e[e.length - 1]; )
            e.pop();
        return e
    }
    isUnity() {
        if (!this.residual.isUnity())
            return !1;
        for (const t of this.primeExponents)
            if (t.n)
                return !1;
        return !0
    }
    isScalar() {
        return this.timeExponent.n === 0
    }
    isIntegral() {
        if (this.residual.d !== 1)
            return !1;
        for (const t of this.primeExponents)
            if (t.s < 0 || t.d !== 1)
                return !1;
        return !0
    }
    isDecimal() {
        if (!bE(this.residual))
            return !1;
        for (const t of this.primeExponents)
            if (t.d !== 1)
                return !1;
        if (this.primeExponents.length < 2)
            return !0;
        if (this.primeExponents[1].s < 0)
            return !1;
        for (let t = 3; t < this.primeExponents.length; ++t)
            if (this.primeExponents[t].s < 0)
                return !1;
        return !0
    }
    isFractional() {
        for (const t of this.primeExponents)
            if (t.d !== 1)
                return !1;
        return !0
    }
    isSqrt() {
        if (this.residual.s < 0)
            return !1;
        for (const t of this.primeExponents)
            if (t.d > 2)
                return !1;
        return !0
    }
    isEqualTemperament() {
        return this.residual.isUnity()
    }
    isPowerOfTwo() {
        if (!this.primeExponents.length)
            return yE(this.residual.n) && yE(this.residual.d);
        if (!this.residual.isUnity())
            return !1;
        for (let t = 1; t < this.primeExponents.length; ++t)
            if (this.primeExponents[t].n)
                return !1;
        return !0
    }
    neg() {
        const t = this.clone();
        return t.residual = this.residual.neg(),
        t
    }
    inverse() {
        const t = this.timeExponent.neg()
          , e = this.primeExponents.map(i => i.neg())
          , r = this.residual.inverse();
        return new Rt(t,e,r)
    }
    sqrt() {
        const t = this.residual.sqrt();
        return t ? new Rt(this.timeExponent.mul(Cn.HALF),this.primeExponents.map(e => e.mul(Cn.HALF)),t) : new dt(this.timeExponent.valueOf(),this.valueOf()).sqrt()
    }
    add(t) {
        if (t instanceof dt)
            return t.add(this);
        if (!this.residual.n)
            return t.clone();
        if (!t.residual.n)
            return this.clone();
        if (!this.timeExponent.equals(t.timeExponent))
            throw new Error(`Cannot add time monzos with disparate units. Have s^${this.timeExponent.toFraction()} + s^${t.timeExponent.toFraction()}.`);
        if (this.isFractional() && t.isFractional()) {
            const e = Rt.fromFraction(this.toFraction().add(t.toFraction()), Math.max(this.numberOfComponents, t.numberOfComponents));
            return e.timeExponent = this.timeExponent.clone(),
            e
        }
        return new dt(this.timeExponent.valueOf(),this.valueOf() + t.valueOf())
    }
    sub(t) {
        if (t instanceof dt)
            return t.lsub(this);
        if (!this.residual.n)
            return t.neg();
        if (!t.residual.n)
            return this.clone();
        if (this.timeExponent.compare(t.timeExponent))
            throw new Error(`Cannot subtract time monzos with disparate units. Have s^${this.timeExponent.toFraction()} + s^${t.timeExponent.toFraction()}.`);
        if (this.isFractional() && t.isFractional()) {
            const e = Rt.fromFraction(this.toFraction().sub(t.toFraction()), Math.max(this.numberOfComponents, t.numberOfComponents));
            return e.timeExponent = this.timeExponent.clone(),
            e
        }
        return new dt(this.timeExponent.valueOf(),this.valueOf() - t.valueOf())
    }
    lensAdd(t) {
        if (t instanceof dt)
            return t.lensAdd(this);
        if (this.timeExponent.compare(t.timeExponent))
            throw new Error(`Cannot lens add time monzos with disparate units. Have s^${this.timeExponent.toFraction()} + s^${t.timeExponent.toFraction()}.`);
        if (this.isFractional() && t.isFractional()) {
            const r = Rt.fromFraction(this.toFraction().lensAdd(t.toFraction()), Math.max(this.numberOfComponents, t.numberOfComponents));
            return r.timeExponent = this.timeExponent.clone(),
            r
        }
        const e = this.valueOf();
        if (e) {
            const r = t.valueOf();
            return new dt(this.timeExponent.valueOf(),e * r / (e + r))
        } else
            return new dt(this.timeExponent.valueOf(),0)
    }
    lensSub(t) {
        if (t instanceof dt)
            return t.leftLensSub(this);
        if (this.timeExponent.compare(t.timeExponent))
            throw new Error(`Cannot lens subtract time monzos with disparate units. Have s^${this.timeExponent.toFraction()} + s^${t.timeExponent.toFraction()}.`);
        if (this.isFractional() && t.isFractional()) {
            const r = Rt.fromFraction(this.toFraction().lensSub(t.toFraction()), Math.max(this.numberOfComponents, t.numberOfComponents));
            return r.timeExponent = this.timeExponent.clone(),
            r
        }
        const e = this.valueOf();
        if (e) {
            const r = t.valueOf();
            return new dt(this.timeExponent.valueOf(),e * r / (r - e))
        } else
            return new dt(this.timeExponent.valueOf(),0)
    }
    mul(t) {
        if (t instanceof dt)
            return t.mul(this);
        if (this.primeExponents.length < t.primeExponents.length)
            return t.mul(this);
        t.primeExponents.length < this.primeExponents.length && (t = t.clone(),
        t.numberOfComponents = this.primeExponents.length);
        const e = [];
        for (let r = 0; r < t.primeExponents.length; ++r)
            try {
                e.push(this.primeExponents[r].add(t.primeExponents[r]))
            } catch {
                return new dt(this.timeExponent.valueOf() + t.timeExponent.valueOf(),this.valueOf() * t.valueOf())
            }
        try {
            const r = this.residual.mul(t.residual);
            return new Rt(this.timeExponent.add(t.timeExponent),e,r)
        } catch {
            return new dt(this.timeExponent.valueOf() + t.timeExponent.valueOf(),this.valueOf() * t.valueOf())
        }
    }
    gcd(t) {
        if (t instanceof dt)
            return t.gcd(this);
        if (this.primeExponents.length < t.primeExponents.length)
            return t.gcd(this);
        if (!this.residual.n)
            return t.clone();
        if (!t.residual.n)
            return this.clone();
        t.primeExponents.length < this.primeExponents.length && (t = t.clone(),
        t.numberOfComponents = this.primeExponents.length);
        const e = [];
        for (let i = 0; i < t.primeExponents.length; ++i)
            e.push(EE(this.primeExponents[i], t.primeExponents[i]));
        const r = this.residual.gcd(t.residual);
        return new Rt(EE(this.timeExponent, t.timeExponent),e,r)
    }
    lcm(t) {
        if (t instanceof dt)
            return t.lcm(this);
        if (this.primeExponents.length < t.primeExponents.length)
            return t.lcm(this);
        t.primeExponents.length < this.primeExponents.length && (t = t.clone(),
        t.numberOfComponents = this.primeExponents.length);
        const e = [];
        for (let i = 0; i < t.primeExponents.length; ++i)
            e.push(wE(this.primeExponents[i], t.primeExponents[i]));
        const r = this.residual.lcm(t.residual);
        return new Rt(wE(this.timeExponent, t.timeExponent),e,r)
    }
    div(t) {
        if (t instanceof dt)
            return t.ldiv(this);
        if (!t.residual.n)
            throw new Error("Division by zero.");
        let e = this;
        e.primeExponents.length < t.primeExponents.length && (e = e.clone(),
        e.numberOfComponents = t.primeExponents.length),
        t.primeExponents.length < e.primeExponents.length && (t = t.clone(),
        t.numberOfComponents = e.primeExponents.length);
        const r = [];
        for (let i = 0; i < t.primeExponents.length; ++i)
            try {
                r.push(e.primeExponents[i].sub(t.primeExponents[i]))
            } catch {
                return new dt(e.timeExponent.valueOf() - t.timeExponent.valueOf(),e.valueOf() / t.valueOf())
            }
        try {
            const i = e.residual.div(t.residual);
            return new Rt(e.timeExponent.sub(t.timeExponent),r,i)
        } catch {
            return new dt(this.timeExponent.valueOf() - t.timeExponent.valueOf(),this.valueOf() / t.valueOf())
        }
    }
    pow(t) {
        if (t instanceof dt)
            return t.lpow(this);
        if (t instanceof Rt) {
            if (t.timeExponent.n !== 0)
                throw new Error("Can only raise to a scalar power.");
            try {
                t = t.toFraction()
            } catch {
                const e = t.valueOf();
                return new dt(this.timeExponent.valueOf() * e,this.valueOf() ** e)
            }
        }
        try {
            const e = new et.Fraction(t);
            try {
                const i = this.primeExponents.map(l => l.mul(e))
                  , a = this.residual.pow(e);
                if (a !== null)
                    return new Rt(this.timeExponent.mul(e),i,a)
            } catch {}
            const r = e.valueOf();
            return new dt(this.timeExponent.valueOf() * r,this.valueOf() ** r)
        } catch (e) {
            if (typeof t == "number")
                return new dt(this.timeExponent.valueOf() * t,this.valueOf() ** t);
            throw e
        }
    }
    log(t) {
        if (t instanceof dt)
            return 1 / t.log(this);
        if (this.timeExponent.n !== 0) {
            if (t instanceof Rt) {
                if (t.timeExponent.n === 0)
                    throw new Error("Cannot take a scalar logarithm of a value with time units.")
            } else
                throw new Error("Cannot take a scalar logarithm of a value with time units.");
            const e = this.timeExponent.div(t.timeExponent)
              , r = this.numberOfComponents
              , i = t.numberOfComponents;
            for (let l = 0; l < Math.min(r, i); ++l)
                if (!this.primeExponents[l].equals(t.primeExponents[l].mul(e)))
                    throw new Error("Logarithm doesn't exist.");
            if (r < i) {
                for (let l = r; l < i; ++l)
                    if (t.primeExponents[l].n)
                        throw new Error("Logarithm doesn't exist.")
            } else if (r > i) {
                for (let l = i; l < r; ++l)
                    if (this.primeExponents[l].n)
                        throw new Error("Logarithm doesn't exist.")
            }
            const a = t.residual.pow(e);
            if (!a || a.compare(this.residual))
                throw new Error("Logarithm doesn't exist.");
            return e
        }
        if (t instanceof Rt) {
            let e = this;
            e.numberOfComponents < t.numberOfComponents && (e = this.clone(),
            e.numberOfComponents = t.numberOfComponents),
            t.numberOfComponents < e.numberOfComponents && (t = t.clone(),
            t.numberOfComponents = e.numberOfComponents);
            let r;
            for (let a = 0; a < e.numberOfComponents; ++a)
                if (r === void 0) {
                    if (t.primeExponents[a].n)
                        r = e.primeExponents[a].div(t.primeExponents[a]);
                    else if (e.primeExponents[a].n)
                        return e.totalCents() / t.totalCents()
                } else if (r !== void 0 && !e.primeExponents[a].equals(t.primeExponents[a].mul(r)))
                    return e.totalCents() / t.totalCents();
            if (r === void 0) {
                const a = e.residual.log(t.residual);
                return a === null ? e.totalCents() / t.totalCents() : a
            }
            const i = t.residual.pow(r);
            return i === null || !i.equals(e.residual) ? e.totalCents() / t.totalCents() : r
        }
        if (typeof t == "number")
            return this.totalCents() / (0,
            et.valueToCents)(t);
        if (t = new et.Fraction(t),
        this.isFractional()) {
            const e = this.toFraction().log(t);
            return e === null ? this.totalCents() / (0,
            et.valueToCents)(t.valueOf()) : e
        }
        return this.totalCents() / (0,
        et.valueToCents)(t.valueOf())
    }
    dot(t) {
        if (t instanceof dt)
            return t.dot(this);
        if (this.numberOfComponents < t.numberOfComponents)
            return t.dot(this);
        if (t.numberOfComponents < this.numberOfComponents && (t = t.clone(),
        t.numberOfComponents = this.numberOfComponents),
        this.residual.isUnity() || t.residual.isUnity()) {
            let h = this.timeExponent.mul(t.timeExponent);
            for (let p = 0; p < this.primeExponents.length; ++p)
                h = h.add(this.primeExponents[p].mul(t.primeExponents[p]));
            return h
        }
        if (!this.residual.s && !t.residual.s)
            throw new Error("Dot product of 0 is ambiguous.");
        if (this.residual.s < 0 && t.residual.s < 0)
            throw new Error("Dot product of -1 is ambiguous.");
        const {n: e, d: r} = this.residual
          , {n: i, d: a} = t.residual
          , l = $d(e, i) - $d(e, a) - $d(r, i) + $d(r, a);
        let f = this.timeExponent.mul(t.timeExponent).add(l);
        for (let h = 0; h < this.primeExponents.length; ++h)
            f = f.add(this.primeExponents[h].mul(t.primeExponents[h]));
        return f
    }
    geometricInverse() {
        const t = this.dot(this);
        if (t.n === 0)
            throw new Error("No geometric inverse exists.");
        const e = this.pow(t.inverse());
        if (e instanceof Rt)
            return e;
        throw new Error("Failed to compute geometric inverse.")
    }
    abs() {
        if (this.timeExponent.n)
            throw new Error("Absolute value is undefined in the absolute echelon.");
        return this.residual.s < 0 ? this.neg() : this.clone()
    }
    pitchAbs() {
        if (this.timeExponent.n)
            throw new Error("Geometric absolute value is undefined in the absolute echelon.");
        const t = this.clone();
        return t.residual.n ? (t.residual.s = 1,
        t.totalCents() < 0 ? t.inverse() : t) : t
    }
    mmod(t, e=!1) {
        if (t instanceof dt)
            return t.lmmod(this, e);
        if (!this.residual.n)
            return e ? t.clone() : this.clone();
        if (!this.timeExponent.equals(t.timeExponent))
            throw new Error(`Cannot mod time monzos with disparate units. Have s^${this.timeExponent.toFraction()} mod s^${t.timeExponent.toFraction()}.`);
        if (this.isFractional() && t.isFractional()) {
            const a = Rt.fromFraction(this.toFraction().mmod(t.toFraction()), Math.max(this.numberOfComponents, t.numberOfComponents));
            return e && !a.residual.n ? t.clone() : (a.timeExponent = this.timeExponent.clone(),
            a)
        }
        const r = t.valueOf()
          , i = e ? (0,
        et.modc)(this.valueOf(), r) : (0,
        et.mmod)(this.valueOf(), r);
        return new dt(this.timeExponent.valueOf(),i)
    }
    reduce(t, e=!1) {
        const r = this.log(t);
        let i;
        return typeof r == "number" ? e ? i = t.pow(1 - Math.ceil(r)) : i = t.pow(-Math.floor(r)) : e ? i = t.pow(Cn.ONE.sub(r.ceil())) : i = t.pow(-r.floor()),
        i instanceof Rt ? this.mul(i) : new dt(this.timeExponent.valueOf() + i.timeExponent,this.valueOf() * i.value)
    }
    project(t) {
        return t.pow(this.octaves)
    }
    strictEquals(t) {
        return t instanceof dt ? !1 : this.numberOfComponents < t.numberOfComponents ? t.strictEquals(this) : (this.numberOfComponents > t.numberOfComponents && (t = t.clone(),
        t.numberOfComponents = this.numberOfComponents),
        this.timeExponent.equals(t.timeExponent) && U2(this.primeExponents, t.primeExponents) && this.residual.equals(t.residual))
    }
    totalCents(t=!1) {
        let e = this.residual.valueOf();
        if (t && (e = Math.abs(e)),
        e === 1)
            return (0,
            et.monzoToCents)(this.primeExponents.map(i => i.valueOf()));
        const r = [];
        r.push((0,
        et.valueToCents)(e));
        for (let i = 0; i < this.primeExponents.length; ++i)
            r.push(this.primeExponents[i].valueOf() * et.PRIME_CENTS[i]);
        return (0,
        et.sum)(r)
    }
    tenneyHeight() {
        if (this.residual.s < 0)
            return NaN;
        if (this.residual.s === 0)
            return 1 / 0;
        let t = Math.log(this.residual.n) + Math.log(this.residual.d);
        for (let e = 0; e < this.primeExponents.length; ++e)
            t += Math.abs(this.primeExponents[e].valueOf()) * et.LOG_PRIMES[e];
        return t
    }
    valueOf() {
        return this.residual.n ? this.residual.s < 0 ? -(0,
        et.centsToValue)(this.totalCents(!0)) : (0,
        et.centsToValue)(this.totalCents()) : 0
    }
    toContinued() {
        return this.isFractional() ? this.toFraction().toContinued() : new et.Fraction(this.valueOf()).toContinued()
    }
    equals(t) {
        return this.valueOf() === t.valueOf()
    }
    compare(t) {
        return t instanceof dt || this.residual.s * t.residual.s !== 1 ? this.valueOf() - t.valueOf() : this.div(t).totalCents() * t.residual.s
    }
    roundTo(t) {
        const e = Math.round(this.div(t).valueOf());
        return t.mul(Rt.fromFraction(e))
    }
    pitchRoundTo(t) {
        const e = Math.round(this.totalCents() / t.totalCents());
        return t.pow(e)
    }
    approximateHarmonic(t) {
        const e = Math.round(this.valueOf() * t);
        return Rt.fromFraction(new et.Fraction(e,t), this.numberOfComponents)
    }
    approximateSubharmonic(t) {
        const e = Math.round(t / this.valueOf());
        return Rt.fromFraction(new et.Fraction(t,e), this.numberOfComponents)
    }
    approximateSimple(t) {
        const e = new et.Fraction(this.valueOf()).simplify(t);
        return Rt.fromFraction(e, this.numberOfComponents)
    }
    getConvergent(t) {
        const e = this.toContinued().slice(0, t + 1);
        let r = new et.Fraction(e[e.length - 1]);
        for (let i = e.length - 2; i >= 0; i--)
            r = r.inverse().add(e[i]);
        return Rt.fromFraction(r, this.numberOfComponents)
    }
    tail(t) {
        const e = this.clone();
        e.numberOfComponents = Math.max(e.numberOfComponents, t);
        for (let r = 0; r < t; ++r)
            e.primeExponents[r] = Cn.ZERO;
        return e
    }
    divisors() {
        if (!this.isIntegral())
            throw new Error("Can only calculate the divisors of an integer.");
        if (this.residual.s !== 1)
            throw new Error("Can only calculate the divisors of a positive integer.");
        const t = [1];
        let e = this.residual.valueOf()
          , r = this.primeExponents.length;
        for (; e !== 1 && r < et.PRIMES.length; ) {
            const i = et.PRIMES[r++];
            let a = 0;
            for (; e % i === 0; )
                e /= i,
                a++;
            const l = t.length;
            let f = i;
            for (; a--; ) {
                for (let h = 0; h < l; ++h)
                    t.push(t[h] * f);
                f *= i
            }
        }
        e !== 1 && t.push(e);
        for (let i = 0; i < this.primeExponents.length; ++i)
            if (this.primeExponents[i].n) {
                const a = et.PRIMES[i];
                let l = this.primeExponents[i].valueOf();
                const f = t.length;
                let h = a;
                for (; l--; ) {
                    for (let p = 0; p < f; ++p)
                        t.push(t[p] * h);
                    h *= a
                }
            }
        return t.sort( (i, a) => i - a),
        t
    }
    factorize() {
        if (this.timeExponent.n)
            throw new Error("Time exponent prevents factorization over integers.");
        const t = (0,
        et.primeFactorize)(this.residual);
        for (const [e,r] of t)
            t.set(e, new et.Fraction(r));
        for (let e = 0; e < this.primeExponents.length; ++e)
            this.primeExponents[e].n && t.set(et.PRIMES[e], this.primeExponents[e]);
        return t
    }
    asDecimalLiteral() {
        if (this.isScalar())
            return this.isDecimal() ? (0,
            or.numberToDecimalLiteral)(this.toFraction(), "e") : (0,
            or.numberToDecimalLiteral)(this.valueOf(), "r")
    }
    asRadicalLiteral() {
        if (this.isEqualTemperament())
            try {
                const {fractionOfEquave: t, equave: e} = this.toEqualTemperament(!0);
                return {
                    type: "RadicalLiteral",
                    argument: e,
                    exponent: t
                }
            } catch {
                return
            }
    }
    asCentsLiteral() {
        if (this.isScalar() && this.isPowerOfTwo()) {
            let t;
            try {
                t = this.octaves.mul(1200)
            } catch {
                return
            }
            if (bE(t)) {
                const {sign: e, whole: r, fractional: i, exponent: a} = (0,
                or.numberToDecimalLiteral)(t, "e");
                return {
                    type: "CentsLiteral",
                    sign: e,
                    whole: r,
                    fractional: i,
                    exponent: a,
                    real: !1
                }
            }
        }
    }
    asIntegerLiteral() {
        if (this.isIntegral())
            return {
                type: "IntegerLiteral",
                value: this.toBigInteger()
            }
    }
    asFractionLiteral(t) {
        if (this.isFractional()) {
            const {numerator: e, denominator: r} = this.toBigNumeratorDenominator();
            if (t === void 0)
                return {
                    type: "FractionLiteral",
                    numerator: e,
                    denominator: r
                };
            if (t.denominator % r === 0n) {
                const i = t.denominator / r;
                return {
                    ...t,
                    numerator: e * i,
                    denominator: r * i
                }
            }
            return {
                type: "FractionLiteral",
                numerator: e,
                denominator: r
            }
        }
    }
    asNedjiLiteral(t) {
        if (this.isEqualTemperament())
            try {
                const {fractionOfEquave: e, equave: r} = this.toEqualTemperament();
                let {s: i, n: a, d: l} = e;
                if (a *= i,
                !t)
                    return r.equals(Cn.TWO) ? {
                        type: "NedjiLiteral",
                        numerator: a,
                        denominator: l,
                        equaveNumerator: null,
                        equaveDenominator: null
                    } : {
                        type: "NedjiLiteral",
                        numerator: a,
                        denominator: l,
                        equaveNumerator: r.s * r.n,
                        equaveDenominator: r.d
                    };
                if (t.equaveNumerator === null) {
                    if (!r.equals(Cn.TWO))
                        return
                } else if (r.n * (t.equaveDenominator ?? 1) !== r.d * t.equaveNumerator)
                    return;
                const f = (0,
                et.lcm)(l, t.denominator);
                return f === t.denominator ? {
                    ...t,
                    numerator: f / l * a
                } : {
                    ...t,
                    numerator: a,
                    denominator: l
                }
            } catch {
                return
            }
    }
    asMonzoLiteral(t=!0) {
        const e = []
          , r = [];
        if (this.timeExponent.equals(Cn.NEGATIVE_ONE) ? (r.push("Hz"),
        e.push({
            sign: "",
            left: 1,
            right: "",
            exponent: null
        })) : this.timeExponent.n && (r.push("s"),
        e.push((0,
        or.fractionToVectorComponent)(this.timeExponent))),
        !this.residual.isUnity()) {
            const {s: a, n: l, d: f} = this.residual;
            f === 1 ? (r.push({
                numerator: a * l,
                denominator: null,
                radical: !1
            }),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            })) : l === 1 ? (r.push({
                numerator: a * f,
                denominator: null,
                radical: !1
            }),
            e.push({
                sign: "-",
                left: 1,
                right: "",
                exponent: null
            })) : (r.push({
                numerator: a * l,
                denominator: f,
                radical: !1
            }),
            e.push({
                sign: "",
                left: 1,
                right: "",
                exponent: null
            }))
        }
        const i = [...this.primeExponents];
        if (t)
            for (; i.length && !i[i.length - 1].n; )
                i.pop();
        if (i.length && r.length) {
            let a = 0;
            for (; i.length && !i[0].n; )
                i.shift(),
                a++;
            i.length && r.push({
                numerator: et.PRIMES[a],
                denominator: null,
                radical: !1
            }),
            i.length > 1 && (r.push(""),
            r.push(""));
            for (const l of i)
                e.push((0,
                or.fractionToVectorComponent)(l))
        } else
            for (const a of i)
                e.push((0,
                or.fractionToVectorComponent)(a));
        return {
            type: "MonzoLiteral",
            components: e,
            ups: 0,
            lifts: 0,
            basis: r
        }
    }
    asInterchangeLiteral() {
        const t = []
          , e = [];
        this.timeExponent.n && (e.push("Hz"),
        t.push((0,
        or.fractionToVectorComponent)(this.timeExponent.inverse().neg()))),
        this.residual.s < 0 ? (e.push({
            numerator: -1,
            denominator: null,
            radical: !1
        }),
        t.push({
            sign: "",
            left: 1,
            right: "",
            exponent: null
        })) : this.residual.s || (e.push({
            numerator: 0,
            denominator: null,
            radical: !1
        }),
        t.push({
            sign: "",
            left: 1,
            right: "",
            exponent: null
        }));
        for (let r = 0; r < this.primeExponents.length; ++r) {
            const i = this.primeExponents[r];
            i.n && (e.push({
                numerator: et.PRIMES[r],
                denominator: null,
                radical: !1
            }),
            t.push((0,
            or.fractionToVectorComponent)(i)))
        }
        return this.residual.n > 1 && (e.push({
            numerator: this.residual.n,
            denominator: null,
            radical: !1
        }),
        t.push({
            sign: "",
            left: 1,
            right: "",
            exponent: null
        })),
        this.residual.d > 1 && (e.push({
            numerator: this.residual.d,
            denominator: null,
            radical: !1
        }),
        t.push({
            sign: "-",
            left: 1,
            right: "",
            exponent: null
        }),
        this.residual.n > this.residual.d && (e.push(e.pop(), e.pop()),
        t.push(t.pop(), t.pop()))),
        {
            type: "MonzoLiteral",
            components: t,
            ups: 0,
            lifts: 0,
            basis: e
        }
    }
    asValLiteral() {
        return {
            ...this.asMonzoLiteral(!1),
            type: "ValLiteral"
        }
    }
    toString(t="linear") {
        if (t === "linear") {
            if (this.isScalar()) {
                if (this.isIntegral())
                    try {
                        return this.toBigInteger().toString()
                    } catch {}
                else if (this.isFractional())
                    try {
                        const {numerator: r, denominator: i} = this.toBigNumeratorDenominator();
                        return `${r}/${i}`
                    } catch {}
                else if (this.isEqualTemperament())
                    try {
                        const {fractionOfEquave: r, equave: i} = this.toEqualTemperament(!0);
                        return `${i.toFraction()}^${r.toFraction()}`
                    } catch {}
            } else if (this.timeExponent.equals(Cn.NEGATIVE_ONE)) {
                if (this.isDecimal())
                    try {
                        return `${this.toFraction().toString()} Hz`
                    } catch {}
                else if (this.isFractional())
                    try {
                        const {numerator: r, denominator: i} = this.toBigNumeratorDenominator();
                        return `${r}/${i} Hz`
                    } catch {}
                else if (this.isEqualTemperament())
                    try {
                        const {fractionOfEquave: r, equave: i} = this.toEqualTemperament(!0);
                        return `${i.toFraction()}^${r.toFraction()} * 1Hz`
                    } catch {}
            }
            const e = [];
            for (let r = 0; r < this.primeExponents.length; ++r) {
                const i = this.primeExponents[r];
                i.equals(Cn.ONE) ? e.push(`${et.PRIMES[r]}`) : i.n && e.push(`${et.PRIMES[r]}^${i.toFraction()}`)
            }
            return this.residual.compare(Cn.ONE) && e.push(this.residual.toFraction()),
            this.timeExponent.equals(Cn.NEGATIVE_ONE) ? e.push("1Hz") : this.timeExponent.n && e.push(`(1s)^${this.timeExponent.toFraction()}`),
            e.join("*")
        } else if (t === "logarithmic") {
            if (this.isScalar()) {
                if (this.isEqualTemperament())
                    try {
                        const {fractionOfEquave: e, equave: r} = this.toEqualTemperament();
                        let i = e.toFraction().replace("/", "\\");
                        return i.includes("\\") || (i += "\\1"),
                        r.compare(Cn.TWO) ? `${i}<${r.toFraction()}>` : i
                    } catch {}
                else if (this.residual.equals(Cn.ONE) && this.primeExponents.every(e => !e.n))
                    return "0c"
            }
            return (0,
            or.literalToString)(this.asMonzoLiteral())
        }
        return (0,
        or.literalToString)(this.asValLiteral())
    }
}
An.TimeMonzo = Rt;
var Gn = {}
  , xm = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.absoluteToNode = n.monzoToNode = n.absoluteMonzo = n.pythagoreanMonzo = n.VULGAR_FRACTIONS = n.ACCIDENTAL_VECTORS = void 0;
    const t = Ie
      , e = An
      , r = vr
      , i = Object.freeze(new t.Fraction(100))
      , a = (0,
    r.F)(1, 4)
      , l = (0,
    r.F)(3, 4)
      , f = (0,
    r.F)(-1, 2)
      , h = (0,
    r.F)(3, 2)
      , p = (0,
    r.F)(-3, 2)
      , m = Object.freeze(r.TWO.neg())
      , g = Object.freeze(r.THREE.neg())
      , b = Object.freeze(r.SEVEN.neg())
      , E = (0,
    r.F)(4, 1)
      , S = Object.freeze(r.ELEVEN.neg())
      , F = (0,
    r.F)(14, 1)
      , B = (0,
    r.F)(5, 2)
      , Q = (0,
    r.F)(-5, 2)
      , ae = (0,
    r.F)(7, 2)
      , V = (0,
    r.F)(9, 2)
      , k = (0,
    r.F)(11, 2)
      , z = [[r.ZERO, r.ZERO], [B, p], [f, r.HALF], [r.TWO, r.NEGATIVE_ONE], [r.NEGATIVE_ONE, r.ONE], [h, f], [p, h]]
      , Z = [(0,
    r.F)(-7, 2), B]
      , re = [V, Q]
      , C = [E, Q]
      , D = [g, B]
      , R = [[p, r.ONE], [r.ONE, f], [m, h], [r.HALF, r.ZERO], [r.THREE, p], [r.ZERO, r.HALF], [B, r.NEGATIVE_ONE]]
      , W = new Map([["F", [r.TWO, r.NEGATIVE_ONE]], ["C", [r.ZERO, r.ZERO]], ["G", [r.NEGATIVE_ONE, r.ONE]], ["D", [(0,
    r.F)(-3, 1), r.TWO]], ["A", [(0,
    r.F)(-4, 1), r.THREE]], ["E", [(0,
    r.F)(-6, 1), E]], ["B", [(0,
    r.F)(-7, 1), r.FIVE]], ["zet", [B, r.NEGATIVE_ONE]], ["", [B, r.NEGATIVE_ONE]], ["gam", [r.HALF, r.ZERO]], ["", [r.HALF, r.ZERO]], ["eta", [p, r.ONE]], ["", [p, r.ONE]], ["del", [(0,
    r.F)(-5, 2), r.TWO]], ["", [(0,
    r.F)(-5, 2), r.TWO]], ["alp", [(0,
    r.F)(-9, 2), r.THREE]], ["", [(0,
    r.F)(-9, 2), r.THREE]], ["eps", [(0,
    r.F)(-11, 2), E]], ["", [(0,
    r.F)(-11, 2), E]], ["bet", [(0,
    r.F)(-15, 2), r.FIVE]], ["", [(0,
    r.F)(-15, 2), r.FIVE]], ["phi", [r.ONE, f]], ["", [r.ONE, f]], ["chi", [m, h]], ["", [m, h]], ["psi", [r.ZERO, r.HALF]], ["", [r.ZERO, r.HALF]], ["ome", [g, B]], ["", [g, B]]]);
    n.ACCIDENTAL_VECTORS = new Map([["", [r.ZERO, r.ZERO, r.ZERO]], ["_", [r.ZERO, r.ZERO, r.ZERO]], ["", [S, r.SEVEN, r.ZERO]], ["#", [S, r.SEVEN, r.ZERO]], ["", [r.ELEVEN, (0,
    r.F)(-7, 1), r.ZERO]], ["b", [r.ELEVEN, (0,
    r.F)(-7, 1), r.ZERO]], ["", [(0,
    r.F)(-22, 1), F, r.ZERO]], ["x", [(0,
    r.F)(-22, 1), F, r.ZERO]], ["", [(0,
    r.F)(22, 1), (0,
    r.F)(-14, 1), r.ZERO]], ["", [(0,
    r.F)(-11, 2), ae, r.ZERO]], ["", [(0,
    r.F)(-11, 2), ae, r.ZERO]], ["t", [(0,
    r.F)(-11, 2), ae, r.ZERO]], ["", [k, (0,
    r.F)(-7, 2), r.ZERO]], ["d", [k, (0,
    r.F)(-7, 2), r.ZERO]], ["", [r.SEVEN, g, r.NEGATIVE_ONE]], ["", [(0,
    r.F)(15, 1), S, r.ONE]], ["", [(0,
    r.F)(-4, 1), E, r.NEGATIVE_ONE]], ["", [E, (0,
    r.F)(-4, 1), r.ONE]], ["", [(0,
    r.F)(-15, 1), r.ELEVEN, r.NEGATIVE_ONE]], ["", [b, r.THREE, r.ONE]]]),
    n.VULGAR_FRACTIONS = new Map([["", r.ONE], ["s", r.HALF], ["", r.HALF], ["", a], ["q", a], ["", l], ["Q", l], ["", (0,
    r.F)(1, 7)], ["", (0,
    r.F)(1, 9)], ["", (0,
    r.F)(1, 10)], ["", (0,
    r.F)(1, 3)], ["", (0,
    r.F)(2, 3)], ["", (0,
    r.F)(1, 5)], ["", (0,
    r.F)(2, 5)], ["", (0,
    r.F)(3, 5)], ["", (0,
    r.F)(4, 5)], ["", (0,
    r.F)(1, 6)], ["", (0,
    r.F)(5, 6)], ["", (0,
    r.F)(1, 8)], ["", (0,
    r.F)(3, 8)], ["", (0,
    r.F)(5, 8)], ["", (0,
    r.F)(7, 8)]]);
    const I = [S, r.SEVEN]
      , N = [r.ELEVEN, b]
      , P = [Object.freeze(S.div(2)), Object.freeze(r.SEVEN.div(2))]
      , J = [Object.freeze(r.ELEVEN.div(2)), Object.freeze(b.div(2))];
    function X(Se) {
        const L = Se.degree.base;
        let K;
        Number.isInteger(L) ? K = [...z[L - 1]] : K = [...R[L - 1.5]];
        const de = Se.quality.quality;
        Se.degree.imperfect ? de === "a" || de === "" || de === "aug" || de === "Aug" ? (K[0] = K[0].sub(k),
        K[1] = K[1].add(ae)) : (de === "d" || de === "dim") && (K[0] = K[0].add(k),
        K[1] = K[1].sub(ae)) : (de === "n" || de === "neu") && (L === 4 ? K = [...Z] : L === 5 ? K = [...re] : L === 1.5 ? K = [...C] : L === 7.5 && (K = [...D])),
        K[0] = K[0].add(Se.degree.octaves);
        let $e = [r.ZERO, r.ZERO];
        if (de === "a" || de === "" || de === "aug" || de === "Aug" ? $e = [...I] : de === "d" || de === "dim" ? $e = [...N] : de === "M" || de === "maj" || de === "Maj" ? $e = [...P] : (de === "m" || de === "min") && ($e = [...J]),
        Se.quality.fraction !== "") {
            const me = n.VULGAR_FRACTIONS.get(Se.quality.fraction);
            $e = [$e[0].mul(me), $e[1].mul(me)]
        }
        for (const me of Se.augmentations ?? [])
            me === "d" || me === "dim" ? ($e[0] = $e[0].add(N[0]),
            $e[1] = $e[1].add(N[1])) : ($e[0] = $e[0].add(I[0]),
            $e[1] = $e[1].add(I[1]));
        const Re = new e.TimeMonzo(r.ZERO,[$e[0].add(K[0]), $e[1].add(K[1])]);
        return Se.degree.negative ? Re.inverse() : Re
    }
    n.pythagoreanMonzo = X;
    function ie(Se) {
        if (!W.has(Se.nominal))
            throw new Error(`Nominal ${Se.nominal} is unassigned.`);
        const L = [...W.get(Se.nominal)];
        for (const K of Se.accidentals) {
            const de = n.VULGAR_FRACTIONS.get(K.fraction);
            if (!n.ACCIDENTAL_VECTORS.has(K.accidental))
                throw new Error(`Accidental ${K.accidental} is unassigned.`);
            const $e = n.ACCIDENTAL_VECTORS.get(K.accidental);
            L[0] = L[0].add($e[0].mul(de)),
            L[1] = L[1].add($e[1].mul(de)),
            L[2] = (L[2] ?? r.ZERO).add($e[2].mul(de))
        }
        return L[0] = L[0].add(Se.octave - 4),
        new e.TimeMonzo(r.ZERO,L)
    }
    n.absoluteMonzo = ie;
    const ce = new Map([["3/2", {
        fraction: "",
        quality: "a"
    }], ["1/2", {
        fraction: "",
        quality: "M"
    }], ["0", {
        fraction: "",
        quality: "n"
    }], ["-1/2", {
        fraction: "",
        quality: "m"
    }], ["-3/2", {
        fraction: "",
        quality: "d"
    }]])
      , Le = new Map([["1", {
        fraction: "",
        quality: "a"
    }], ["0", {
        fraction: "",
        quality: "P"
    }], ["-1", {
        fraction: "",
        quality: "d"
    }]]);
    for (const [Se,L] of n.VULGAR_FRACTIONS.entries())
        Se === "q" || Se === "Q" || Se === "s" || (ce.set(L.add(r.HALF).toFraction(), {
            fraction: Se,
            quality: "a"
        }),
        ce.set(L.div(r.TWO).toFraction(), {
            fraction: Se,
            quality: "M"
        }),
        ce.set(L.div(m).toFraction(), {
            fraction: Se,
            quality: "m"
        }),
        ce.set(f.sub(L).toFraction(), {
            fraction: Se,
            quality: "d"
        }),
        Le.set(L.toFraction(), {
            fraction: Se,
            quality: "a"
        }),
        Le.set(L.neg().toFraction(), {
            fraction: Se,
            quality: "d"
        }));
    function he(Se) {
        let L = Se.primeExponents[0]
          , K = Se.primeExponents[1]
          , de = L.mul(r.SEVEN).add(K.mul(r.ELEVEN)).valueOf();
        const $e = de < 0;
        $e && (de = -de,
        L = L.neg(),
        K = K.neg());
        const Re = (0,
        t.mmod)(de, 7) + 1
          , me = Math.floor(de / 7);
        let T;
        if (Number.isInteger(de))
            T = K.sub(z[Re - 1][1]).div(r.SEVEN);
        else if ((0,
        t.mmod)(de, 1) === .5)
            T = K.sub(R[Re - 1.5][1]).div(r.SEVEN);
        else
            return;
        if (T.abs().compare(i) > 0)
            return;
        const j = ![1, 4, 5, 1.5, 4.5, 7.5].includes(Re);
        let ge;
        const Me = [];
        if (j) {
            for (; T.compare(p) < 0; )
                Me.push("d"),
                T = T.add(r.ONE);
            for (; T.compare(h) > 0; )
                Me.push("a"),
                T = T.sub(r.ONE);
            ge = ce.get(T.toFraction())
        } else {
            for (; T.compare(r.NEGATIVE_ONE) < 0; )
                Me.push("d"),
                T = T.add(r.ONE);
            for (; T.compare(r.ONE) > 0; )
                Me.push("a"),
                T = T.sub(r.ONE);
            ge = Le.get(T.toFraction())
        }
        if (ge)
            return {
                type: "Pythagorean",
                quality: ge,
                augmentations: Me,
                degree: {
                    base: Re,
                    negative: $e,
                    octaves: me,
                    imperfect: j
                }
            }
    }
    n.monzoToNode = he;
    const Fe = ["C", "D", "E", "F", "G", "A", "B"]
      , Te = ["", "", "", "", "", "", ""]
      , ye = new Map
      , qe = [];
    for (const Se of ["", "", "", "d"]) {
        const [L,K] = n.ACCIDENTAL_VECTORS.get(Se)
          , de = new t.Fraction(K).div(r.SEVEN);
        ye.set(de.toFraction(), {
            fraction: "",
            accidental: Se
        }),
        qe.push([de, Se])
    }
    for (const [Se,L] of qe)
        for (const [K,de] of n.VULGAR_FRACTIONS.entries()) {
            if (K === "q" || K === "Q" || K === "s")
                continue;
            const $e = Se.mul(de).toFraction();
            ye.has($e) || ye.set($e, {
                fraction: K,
                accidental: L
            })
        }
    function Ge(Se) {
        const L = Se.primeExponents[0]
          , K = Se.primeExponents[1]
          , de = L.mul(r.SEVEN).add(K.mul(r.ELEVEN)).valueOf()
          , $e = Math.floor(de / 7) + 4
          , Re = (0,
        t.mmod)(de, 1);
        let me;
        if (Re === 0)
            me = Fe[(0,
            t.mmod)(de, 7)];
        else if (Re === .5)
            me = Te[(0,
            t.mmod)(de - .5, 7)];
        else
            return;
        let T = K.sub(W.get(me)[1]).div(r.SEVEN);
        if (T.abs().compare(i) > 0)
            return;
        const j = [];
        for (; T.compare(m) <= 0; )
            j.push({
                fraction: "",
                accidental: ""
            }),
            T = T.add(r.TWO);
        for (; T.compare(r.TWO) >= 0; )
            j.push({
                fraction: "",
                accidental: ""
            }),
            T = T.sub(r.TWO);
        if (T.compare(r.NEGATIVE_ONE) < 0 ? (j.unshift({
            fraction: "",
            accidental: ""
        }),
        T = T.add(r.ONE)) : T.compare(r.ONE) > 0 && (j.unshift({
            fraction: "",
            accidental: ""
        }),
        T = T.sub(r.ONE)),
        T.n) {
            const ge = T.toFraction();
            if (!ye.has(ge))
                return;
            j.unshift(ye.get(ge))
        } else
            j.length || j.unshift({
                fraction: "",
                accidental: ""
            });
        return {
            type: "AbsolutePitch",
            nominal: me,
            accidentals: j,
            octave: $e
        }
    }
    n.absoluteToNode = Ge
}
)(xm);
var j2 = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.getHEWM53 = n.HEWM53_SWAPS = n.getHelmholtzEllis = n.HEJI_SWAPS = n.getLumisComma = n.getSyntonicRastmic = void 0;
    const t = Ie
      , e = An
      , r = vr
      , i = {
        1: ["-1/2", "5/2", "0", "0", "-1"],
        2: ["-1", "5", "0", "0", "-2"],
        4: ["-2", "10", "0", "0", "-4"],
        8: ["-4", "20", "0", "0", "-8"],
        3: ["-2", "2", "-1/2"],
        6: ["-4", "4", "-1"],
        9: ["-6", "6", "-3/2"]
    }
      , a = {
        0: ["-25/4", "17/4", "1", "-1"],
        1: ["3/4", "1/4", "1", "0", "-1"],
        2: ["-11/2", "7/2"],
        3: ["1", "-3/2", "-1", "0", "0", "1"],
        4: ["-9/2", "4", "-2", "1"],
        5: ["1/2", "0", "1", "-1"],
        6: ["1/3", "-5/3", "1"],
        7: ["5/3", "-1/3", "1", "0", "-1"],
        8: ["5/2", "-1", "0", "1", "0", "-1"],
        9: ["9/5", "-13/5", "1"]
    }
      , l = {
        5: "81/80",
        7: "64/63",
        11: "33/32",
        13: "27/26",
        17: "2187/2176",
        19: "513/512",
        23: "736/729",
        29: "261/256",
        31: "32/31",
        37: "37/36",
        41: "82/81",
        43: "129/128",
        47: "752/729",
        53: "54/53",
        59: "243/236",
        61: "244/243",
        67: "2187/2144",
        71: "72/71",
        73: "73/72",
        79: "81/79",
        83: "256/249",
        89: "729/712"
    }
      , f = {
        5: "81/80",
        7: "64/63",
        11: "33/32",
        13: "27/26",
        17: "18/17",
        19: "19/18",
        23: "24/23",
        29: "261/256",
        31: "32/31",
        37: "37/36",
        41: "82/81",
        43: "129/128",
        47: "48/47",
        53: "54/53"
    }
      , h = e.TimeMonzo.fromFraction(1)
      , p = new Map;
    for (const [Q,ae] of Object.entries(i)) {
        const V = new e.TimeMonzo(r.ZERO,ae.map(k => new t.Fraction(k)));
        V.numberOfComponents = (0,
        e.getNumberOfComponents)(),
        p.set(Q, V)
    }
    function m(Q) {
        let ae = h;
        for (const V of Q.toString())
            p.has(V) && (ae = ae.mul(p.get(V)));
        return ae
    }
    n.getSyntonicRastmic = m;
    const g = new Map;
    for (const [Q,ae] of Object.entries(a)) {
        const V = new e.TimeMonzo(r.ZERO,ae.map(k => new t.Fraction(k)));
        V.numberOfComponents = (0,
        e.getNumberOfComponents)(),
        g.set(Q, V)
    }
    function b(Q) {
        let ae = h;
        for (const V of Q.toString())
            g.has(V) && (ae = ae.mul(g.get(V)));
        return ae
    }
    n.getLumisComma = b;
    const E = [h, h];
    n.HEJI_SWAPS = [!1, !1];
    for (const [Q,ae] of Object.entries(l)) {
        const V = t.PRIMES.indexOf(parseInt(Q, 10))
          , k = e.TimeMonzo.fromFraction(ae);
        E[V] = k;
        const z = k.clone();
        z.numberOfComponents = V + 1;
        for (const Z of z.primeExponents.slice(2))
            if (Z.s) {
                n.HEJI_SWAPS[V] = Z.s < 0;
                break
            }
    }
    function S(Q) {
        return Q < E.length ? E[Q] : h
    }
    n.getHelmholtzEllis = S;
    const F = [h, h];
    n.HEWM53_SWAPS = [!1, !1];
    for (const [Q,ae] of Object.entries(f)) {
        const V = t.PRIMES.indexOf(parseInt(Q, 10))
          , k = e.TimeMonzo.fromFraction(ae);
        F[V] = k;
        const z = k.clone();
        z.numberOfComponents = V + 1;
        for (const Z of z.primeExponents.slice(2))
            if (Z.s) {
                n.HEWM53_SWAPS[V] = Z.s < 0;
                break
            }
    }
    function B(Q) {
        return Q < F.length ? F[Q] : h
    }
    n.getHEWM53 = B
}
)(j2);
Object.defineProperty(Gn, "__esModule", {
    value: !0
});
Gn.asAbsoluteFJS = Gn.asFJS = Gn.uninflect = Gn.inflect = Gn.getInflection = Gn.getToneSplitterComma = Gn.getSemiquartalComma = Gn.getNeutralComma = Gn.getFloraComma = Gn.getFormalComma = void 0;
const on = Ie
  , es = An
  , H2 = xm
  , gi = j2
  , X6 = vr
  , eD = Object.freeze(new on.Fraction(100))
  , tD = (0,
on.valueToCents)(65 / 63)
  , nD = .5 * (0,
on.valueToCents)(2187 / 2048) + 1e-6;
13.5 * on.PRIME_CENTS[0] - 8.5 * on.PRIME_CENTS[1];
const _E = 92.1
  , yh = 137.2
  , bh = on.PRIME_CENTS[1] - on.PRIME_CENTS[0]
  , LE = 2 * on.PRIME_CENTS[0] - on.PRIME_CENTS[1]
  , rD = on.PRIME_CENTS[0];
function G2(n, t=tD) {
    let e = 0
      , r = 0;
    if ((0,
    on.circleDistance)(n, e) < t)
        return [r, -r];
    for (; ; ) {
        if (e += bh,
        r++,
        (0,
        on.circleDistance)(n, e) < t)
            return [r, -r];
        if ((0,
        on.circleDistance)(n, -e) < t)
            return [-r, r]
    }
}
function sD(n) {
    let t = .5 * bh
      , e = .5;
    for (; ; ) {
        if ((0,
        on.circleDistance)(n, t) < _E)
            return [e, -e];
        if ((0,
        on.circleDistance)(n, -t) < _E)
            return [-e, e];
        t += bh,
        e++
    }
}
function iD(n) {
    let t = .5 * LE
      , e = .5;
    for (; ; ) {
        if ((0,
        on.circleDistance)(n, t) < yh)
            return [-e - .5, e];
        if ((0,
        on.circleDistance)(n, -t) < yh)
            return [e + .5, -e];
        t += LE,
        e++
    }
}
function oD(n) {
    let t = .5 * rD
      , e = .5;
    for (; ; ) {
        if ((0,
        on.circleDistance)(n, t) < yh)
            return [e, .5 - e];
        if ((0,
        on.circleDistance)(n, -t) < yh)
            return [-e, e - .5];
        t += bh,
        e++
    }
}
function *qf(n) {
    let t = 2;
    for (; t < on.PRIME_CENTS.length; ) {
        let[e,r] = n(on.PRIME_CENTS[t])
          , i = on.PRIME_CENTS[t] + e * on.PRIME_CENTS[0] + r * on.PRIME_CENTS[1];
        for (; i > 600; )
            i -= on.PRIME_CENTS[0],
            e--;
        for (; i < -600; )
            i += on.PRIME_CENTS[0],
            e++;
        yield new es.TimeMonzo(X6.ZERO,[new on.Fraction(e), new on.Fraction(r)]).mul(es.TimeMonzo.fromFraction(on.PRIMES[t])),
        t++
    }
}
const Ev = [es.TimeMonzo.fromFraction(1), es.TimeMonzo.fromFraction(1)]
  , _v = [es.TimeMonzo.fromFraction(1), es.TimeMonzo.fromFraction(1)]
  , Lv = [es.TimeMonzo.fromFraction(1), es.TimeMonzo.fromFraction(1)]
  , Sv = [es.TimeMonzo.fromFraction(1), es.TimeMonzo.fromFraction(1)]
  , Av = [es.TimeMonzo.fromFraction(1), es.TimeMonzo.fromFraction(1)]
  , aD = qf(G2)
  , lD = qf(n => G2(n, nD))
  , uD = qf(sD)
  , cD = qf(iD)
  , fD = qf(oD);
function T0(n) {
    for (; n >= Ev.length; ) {
        const t = aD.next();
        if (t.done)
            throw new Error("Out of primes.");
        Ev.push(t.value)
    }
    return Ev[n]
}
Gn.getFormalComma = T0;
function x0(n) {
    for (; n >= _v.length; ) {
        const t = lD.next();
        if (t.done)
            throw new Error("Out of primes.");
        _v.push(t.value)
    }
    return _v[n]
}
Gn.getFloraComma = x0;
function I0(n) {
    for (; n >= Lv.length; ) {
        const t = uD.next();
        if (t.done)
            throw new Error("Out of primes.");
        Lv.push(t.value)
    }
    return Lv[n]
}
Gn.getNeutralComma = I0;
function F0(n) {
    for (; n >= Sv.length; ) {
        const t = cD.next();
        if (t.done)
            throw new Error("Out of primes.");
        Sv.push(t.value)
    }
    return Sv[n]
}
Gn.getSemiquartalComma = F0;
function R0(n) {
    for (; n >= Av.length; ) {
        const t = fD.next();
        if (t.done)
            throw new Error("Out of primes.");
        Av.push(t.value)
    }
    return Av[n]
}
Gn.getToneSplitterComma = R0;
function j1(n, t) {
    let e = es.TimeMonzo.fromFraction(1);
    for (const [r,i] of n) {
        if (i === "l") {
            e = e.mul((0,
            gi.getLumisComma)(r));
            continue
        } else if (i === "s") {
            e = e.mul((0,
            gi.getSyntonicRastmic)(r));
            continue
        }
        const a = (0,
        on.toMonzo)(r);
        for (let l = 0; l < a.length; ++l)
            i === "c" ? e = e.mul(T0(l).pow(a[l])) : i === "n" ? e = e.mul(I0(l).pow(a[l])) : i === "q" ? e = e.mul(F0(l).pow(a[l])) : i === "t" ? e = e.mul(R0(l).pow(a[l])) : i === "" || i === "f" ? e = e.mul(x0(l).pow(a[l])) : i === "h" ? e = e.mul((0,
            gi.getHelmholtzEllis)(l).pow(a[l])) : i === "m" && (e = e.mul((0,
            gi.getHEWM53)(l).pow(a[l])))
    }
    for (const [r,i] of t) {
        if (i === "l") {
            e = e.div((0,
            gi.getLumisComma)(r));
            continue
        } else if (i === "s") {
            e = e.div((0,
            gi.getSyntonicRastmic)(r));
            continue
        }
        const a = (0,
        on.toMonzo)(r);
        for (let l = 0; l < a.length; ++l)
            i === "c" ? e = e.div(T0(l).pow(a[l])) : i === "" || i === "f" ? e = e.div(x0(l).pow(a[l])) : i === "n" ? e = e.div(I0(l).pow(a[l])) : i === "q" ? e = e.div(F0(l).pow(a[l])) : i === "t" ? e = e.div(R0(l).pow(a[l])) : i === "h" ? e = e.div((0,
            gi.getHelmholtzEllis)(l).pow(a[l])) : i === "m" && (e = e.div((0,
            gi.getHEWM53)(l).pow(a[l])))
    }
    if (e instanceof es.TimeReal)
        throw new Error("FJS inflection failed.");
    return e
}
Gn.getInflection = j1;
function dD(n, t, e) {
    return j1(t, e).mul(n)
}
Gn.inflect = dD;
function H1(n, t) {
    if (t === "l" || t === "s")
        throw new Error("Uninflection not implement in non-prime basis.");
    let e = [];
    t === "h" ? e = gi.HEJI_SWAPS : t === "m" && (e = gi.HEWM53_SWAPS);
    const r = []
      , i = []
      , a = n.primeExponents;
    for (let f = 2; f < a.length; ++f) {
        if (a[f].abs().compare(eD) > 0)
            return;
        let h = r
          , p = i;
        e[f] && ([h,p] = [p, h]);
        for (let m = 0; a[f].compare(m) > 0; ++m)
            h.push([on.PRIMES[f], t]);
        for (let m = 0; a[f].compare(-m) < 0; ++m)
            p.push([on.PRIMES[f], t])
    }
    try {
        const f = (0,
        on.toMonzo)(n.residual);
        for (let h = 2; h < f.length; ++h) {
            let p = r
              , m = i;
            e[h] && ([p,m] = [m, p]);
            for (let g = 0; g < f[h]; ++g)
                p.push([on.PRIMES[h], t]);
            for (let g = 0; g > f[h]; --g)
                m.push([on.PRIMES[h], t])
        }
    } catch {}
    const l = n.div(j1(r, i));
    if (l instanceof es.TimeReal)
        throw new Error("FJS uninflection failed.");
    return {
        pythagoreanMonzo: l,
        superscripts: r,
        subscripts: i
    }
}
Gn.uninflect = H1;
function hD(n, t) {
    if (n.residual.s !== 1 || !n.isScalar())
        return;
    const e = n.primeExponents;
    for (let h = 2; h < e.length; ++h)
        if (e[h].d > 1)
            return;
    const r = H1(n, t);
    if (!r)
        return;
    const {pythagoreanMonzo: i, superscripts: a, subscripts: l} = r
      , f = (0,
    H2.monzoToNode)(i);
    if (f)
        return {
            type: "FJS",
            ups: 0,
            lifts: 0,
            pythagorean: f,
            superscripts: a,
            subscripts: l
        }
}
Gn.asFJS = hD;
function pD(n, t) {
    if (n.residual.s !== 1)
        return;
    const e = n.primeExponents;
    for (let h = 2; h < e.length; ++h)
        if (e[h].d > 1)
            return;
    const r = H1(n, t);
    if (!r)
        return;
    const {pythagoreanMonzo: i, superscripts: a, subscripts: l} = r
      , f = (0,
    H2.absoluteToNode)(i);
    if (f)
        return {
            type: "AbsoluteFJS",
            ups: 0,
            lifts: 0,
            pitch: f,
            superscripts: a,
            subscripts: l
        }
}
Gn.asAbsoluteFJS = pD;
var $i = {};
Object.defineProperty($i, "__esModule", {
    value: !0
});
$i.intCombineTuningMaps = $i.vanishCommas = $i.combineTuningMaps = void 0;
const hr = Ie;
function mD(n, t) {
    const e = (0,
    hr.transpose)(t)
      , r = (0,
    hr.matmul)(e, (0,
    hr.inv)((0,
    hr.matmul)(t, e)));
    return (0,
    hr.matmul)((0,
    hr.matmul)(r, t), n)
}
$i.combineTuningMaps = mD;
function gD(n, t) {
    const e = (0,
    hr.transpose)(t)
      , r = (0,
    hr.matmul)(e, (0,
    hr.inv)((0,
    hr.matmul)(t, e)))
      , i = (0,
    hr.matmul)(r, t);
    return (0,
    hr.sub)(n, (0,
    hr.matmul)(i, n))
}
$i.vanishCommas = gD;
function vD(n, t, e) {
    if (!t.length)
        return [];
    if (t.length === 1)
        return [1];
    let r = 1 / 0
      , i = [];
    function a(l) {
        if (l.length < t.length)
            for (let f = -e; f <= e; ++f) {
                const h = [...l];
                h.push(f),
                a(h)
            }
        else {
            if (Math.abs(l.reduce(hr.gcd)) !== 1)
                return;
            let f = (0,
            hr.scale)(t[0], l[0]);
            for (let m = 1; m < l.length; ++m)
                f = (0,
                hr.add)(f, (0,
                hr.scale)(t[m], l[m]));
            if (!f[0])
                return;
            const h = f.map(m => m / f[0] * n[0])
              , p = (0,
            hr.norm)((0,
            hr.sub)(n, h), "L2");
            p < r && (r = p,
            i = l)
        }
    }
    for (let l = 0; l <= e; ++l)
        a([l]);
    return i
}
$i.intCombineTuningMaps = vD;
Object.defineProperty(hn, "__esModule", {
    value: !0
});
hn.intervalValueAs = hn.Temperament = hn.Val = hn.ValBasis = hn.Interval = hn.log = hn.infect = hn.Color = void 0;
const gn = pt
  , Ct = An
  , Cv = Gn
  , wr = vr
  , mt = Ie
  , yD = $i;
class W2 {
    constructor(t) {
        this.value = t
    }
    toString() {
        return this.value
    }
    strictEquals(t) {
        return this.value === t.value
    }
}
hn.Color = W2;
const J2 = new Ct.TimeMonzo(wr.ZERO,[wr.ONE]);
function SE(n, t, e, r) {
    var l, f;
    if (t.steps)
        throw new Error("Cannot multiply with a stepful scalar.");
    let i = 0;
    if (n.steps && (i = n.steps * t.valueOf(),
    !Number.isInteger(i)))
        throw new Error("Cannot create fractional steps.");
    if (t.value instanceof Ct.TimeReal) {
        const h = n.totalCents();
        return new wt(Ct.TimeReal.fromCents(h * t.value.valueOf()),n.domain,i,e,r)
    }
    const a = n.value.pow(t.value);
    return (((l = n.node) == null ? void 0 : l.type) === "FJS" || ((f = n.node) == null ? void 0 : f.type) === "AspiringFJS") && (e = {
        type: "AspiringFJS",
        flavor: ""
    }),
    new wt(a,n.domain,i,e,r)
}
function Lr(n, t) {
    return Md.color = n.color ?? t.color,
    Md.label = n.label || t.label,
    Md.trackingIds = (0,
    wr.setUnion)(n.trackingIds, t.trackingIds),
    Md
}
hn.infect = Lr;
function P0(n, t) {
    const e = n.value.log(t.value);
    if (typeof e == "number") {
        if (n.steps || t.steps)
            throw new Error("Steps do not match in logarithm.");
        return Ct.TimeReal.fromValue(e)
    } else {
        if (!e.mul(t.steps).equals(n.steps))
            throw new Error("Steps do not match in logarithm.");
        return Ct.TimeMonzo.fromFraction(e)
    }
}
hn.log = P0;
class wt {
    constructor(t, e, r=0, i, a) {
        if ((0,
        gn.validateNode)(i),
        this.value = t,
        this.domain = e,
        this.steps = r,
        this.node = i,
        this.trackingIds = new Set,
        a !== void 0) {
            this.color = a.color,
            this.label = a.label;
            for (const l of a.trackingIds)
                this.trackingIds.add(l)
        } else
            this.label = ""
    }
    static fromInteger(t, e) {
        t = BigInt(t);
        const r = Ct.TimeMonzo.fromBigInt(t);
        return new wt(r,"linear",0,{
            type: "IntegerLiteral",
            value: t
        },e)
    }
    static fromFraction(t, e) {
        const r = Ct.TimeMonzo.fromFraction(t)
          , {numerator: i, denominator: a} = r.toBigNumeratorDenominator();
        return new wt(r,"linear",0,{
            type: "FractionLiteral",
            numerator: i,
            denominator: a
        },e)
    }
    static fromValue(t, e) {
        const r = Ct.TimeReal.fromValue(t);
        return new wt(r,"linear",0,r.asDecimalLiteral(),e)
    }
    static reviver(t, e) {
        if (typeof e == "object" && e !== null && e.type === "Interval") {
            let r;
            e.v.type === "TimeMonzo" ? r = Ct.TimeMonzo.reviver("value", e.v) : r = Ct.TimeReal.reviver("value", e.v);
            const i = new wt(r,e.d ? "logarithmic" : "linear",e.s,(0,
            gn.intervalLiteralFromJSON)(e.n));
            return i.label = e.l,
            i.color = e.c && new W2(e.c),
            i.trackingIds = new Set(e.t),
            i
        }
        return e
    }
    toJSON() {
        return {
            type: "Interval",
            v: this.value.toJSON(),
            d: this.domain === "linear" ? 0 : 1,
            s: this.steps,
            l: this.label,
            c: this.color && this.color.value,
            n: (0,
            gn.literalToJSON)(this.node),
            t: Array.from(this.trackingIds)
        }
    }
    shallowClone() {
        return new wt(this.value,this.domain,this.steps,this.node,this)
    }
    clone() {
        return new wt(this.value.clone(),this.domain,this.steps,{
            ...this.node
        },this)
    }
    toInteger() {
        return this.value instanceof Ct.TimeReal && Number.isInteger(this.value.value) ? this.value.value : Number(this.value.toBigInteger())
    }
    toFraction() {
        return this.value.toFraction()
    }
    isRelative() {
        return !this.value.timeExponent.valueOf()
    }
    isAbsolute() {
        return !!this.value.timeExponent.valueOf()
    }
    totalCents(t=!1) {
        return this.value.totalCents(t)
    }
    neg() {
        const t = (0,
        gn.negNode)(this.node);
        return this.domain === "linear" ? new wt(this.value.neg(),this.domain,this.steps,t,this) : new wt(this.value.inverse(),this.domain,-this.steps,t,this)
    }
    inverse() {
        const t = (0,
        gn.invertNode)(this.node);
        if (this.domain === "linear")
            return new wt(this.value.inverse(),this.domain,-this.steps,t,this);
        if (this.value instanceof Ct.TimeReal)
            throw new Error("Unable to convert irrational number to val.");
        return new Ar(this.value.geometricInverse(),new Gs([this.value.clone()]),void 0)
    }
    abs() {
        if (this.steps)
            throw new Error("Steps are ambiguous in abs.");
        const t = (0,
        gn.absNode)(this.node);
        return this.domain === "linear" ? new wt(this.value.abs(),this.domain,0,t,this) : new wt(this.value.pitchAbs(),this.domain,0,t,this)
    }
    pitchAbs() {
        if (this.domain === "logarithmic")
            throw new Error("Logarithmic absolute value not implemented in the already-logarithmic domain.");
        if (this.steps)
            throw new Error("Steps are ambiguous in labs.");
        const t = (0,
        gn.pitchAbsNode)(this.node);
        return new wt(this.value.pitchAbs(),this.domain,0,t,this)
    }
    sqrt() {
        if (this.steps % 2)
            throw new Error("Cannot split steps using .");
        const t = (0,
        gn.sqrtNode)(this.node);
        return new wt(this.value.sqrt(),this.domain,this.steps / 2,t,this)
    }
    project(t) {
        const e = this.value.octaves.mul(t.steps);
        if (e.d !== 1)
            throw new Error("Cannot create fractional steps.");
        let r;
        return e.n || (r = (0,
        gn.projectNodes)(this.node, t.node)),
        new wt(this.value.project(t.value),"logarithmic",e.valueOf(),r,Lr(this, t))
    }
    add(t) {
        var a, l;
        if (this.domain !== t.domain)
            throw new Error("Domains must match in addition.");
        if (this.domain === "linear" && (this.steps || t.steps))
            throw new Error("Linear addition of steps is not allowed.");
        let e = (0,
        gn.addNodes)(this.node, t.node);
        const r = this.domain === "linear" ? this.value.add(t.value) : this.value.mul(t.value);
        !e && ((a = this.node) == null ? void 0 : a.type) === ((l = t.node) == null ? void 0 : l.type) && (e = wh(r, this.node, !0));
        const i = Lr(this, t);
        return new wt(r,this.domain,this.steps + t.steps,e,i)
    }
    sub(t) {
        var a, l;
        if (this.domain !== t.domain)
            throw new Error("Domains must match in subtraction.");
        if (this.domain === "linear" && (this.steps || t.steps))
            throw new Error("Linear subtraction of steps is not allowed.");
        let e = (0,
        gn.subNodes)(this.node, t.node);
        const r = this.domain === "linear" ? this.value.sub(t.value) : this.value.div(t.value);
        !e && ((a = this.node) == null ? void 0 : a.type) === ((l = t.node) == null ? void 0 : l.type) && (e = wh(r, this.node, !0));
        const i = Lr(this, t);
        return new wt(r,this.domain,this.steps - t.steps,e,i)
    }
    lsub(t) {
        const e = t.sub(this);
        return e.color = this.color ?? t.color,
        e.label = this.label || t.label,
        e
    }
    lensAdd(t) {
        if (this.domain !== t.domain)
            throw new Error("Domains must match in harmonic addition");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in harmonic addition.");
        const e = (0,
        gn.lensAddNodes)(this.node, t.node)
          , r = Lr(this, t);
        if (this.domain === "linear")
            return new wt(this.value.lensAdd(t.value),this.domain,0,e,r);
        if (this.value instanceof Ct.TimeReal || t.value instanceof Ct.TimeReal)
            throw new Error("Irrational logarithmic lens addition not implemented.");
        const i = this.value.dot(this.value);
        if (!i.n)
            return new wt(this.value.clone(),this.domain,0,e,r);
        const a = t.value.dot(t.value);
        if (!a.n)
            return new wt(t.value.clone(),this.domain,0,e,r);
        const l = this.value.pow(i.inverse()).mul(t.value.pow(a.inverse()));
        if (l instanceof Ct.TimeReal)
            throw new Error("Logarithmic lens addition failed.");
        return new wt(l.geometricInverse(),this.domain,0,e,r)
    }
    lensSub(t) {
        if (this.domain !== t.domain)
            throw new Error("Domains must match in harmonic subtraction.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in harmonic subtraction.");
        const e = (0,
        gn.lensSubNodes)(this.node, t.node)
          , r = Lr(this, t);
        if (this.domain === "linear")
            return new wt(this.value.lensSub(t.value),this.domain,0,e,r);
        if (this.value instanceof Ct.TimeReal || t.value instanceof Ct.TimeReal)
            throw new Error("Irrational logarithmic lens subtraction not implemented.");
        const i = this.value.dot(this.value);
        if (!i.n)
            return new wt(this.value.clone(),this.domain,0,e,r);
        const a = t.value.dot(t.value);
        if (!a.n)
            return new wt(t.value.clone(),this.domain,0,e,r);
        const l = this.value.pow(i.inverse()).div(t.value.pow(a.inverse()));
        if (l instanceof Ct.TimeReal)
            throw new Error("Logarithmic lens subtraction failed.");
        return new wt(l.geometricInverse(),this.domain,0,e,r)
    }
    roundTo(t) {
        if (this.domain !== t.domain)
            throw new Error("Domains must match in rounding.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in rounding.");
        const e = (0,
        gn.roundToNodes)(this.node, t.node)
          , r = Lr(this, t);
        return this.domain === "linear" ? new wt(this.value.roundTo(t.value),this.domain,0,e,r) : new wt(this.value.pitchRoundTo(t.value),this.domain,0,e,r)
    }
    mmod(t, e=!1) {
        if (this.domain !== t.domain)
            throw new Error("Domains must match in modulo.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in modulo.");
        const r = (0,
        gn.modNodes)(this.node, t.node)
          , i = Lr(this, t);
        return this.domain === "linear" ? new wt(this.value.mmod(t.value, e),this.domain,0,r,i) : new wt(this.value.reduce(t.value, e),this.domain,0,r,i)
    }
    pitchRoundTo(t) {
        if (this.domain === "logarithmic" || t.domain === "logarithmic")
            throw new Error("Exponential rounding not implemented in logarithmic domain.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in pitch rounding.");
        if (!t.value.isScalar())
            throw new Error("Only scalar exponential rounding implemented.");
        const e = (0,
        gn.pitchRoundToNodes)(this.node, t.node);
        return new wt(this.value.pitchRoundTo(t.value),this.domain,0,e,Lr(this, t))
    }
    mul(t) {
        if (this.domain !== "linear" && t.domain !== "linear")
            throw new Error("At least one domain must be linear in multiplication.");
        if (t.domain === "cologarithmic")
            return t.mul(this);
        const e = (0,
        gn.mulNodes)(this.node, t.node)
          , r = Lr(this, t);
        return t.domain === "logarithmic" ? SE(t, this, e, r) : this.domain === "logarithmic" ? SE(this, t, e, r) : new wt(this.value.mul(t.value),this.domain,this.steps + t.steps,e,r)
    }
    div(t) {
        var i, a;
        let e = (0,
        gn.divNodes)(this.node, t.node);
        const r = Lr(this, t);
        if (t.domain === "logarithmic") {
            if (this.domain !== "logarithmic")
                throw new Error("Domains must match in non-scalar division.");
            const l = this.steps / (t.steps || 1);
            return new wt(P0(this, t),"linear",l,e,r)
        }
        if (this.domain === "logarithmic") {
            let l = 0;
            if (this.steps && (l = this.steps / t.valueOf(),
            !Number.isInteger(l)))
                throw new Error("Cannot create fractional steps.");
            const f = this.value.pow(t.value.inverse());
            return (((i = this.node) == null ? void 0 : i.type) === "FJS" || ((a = this.node) == null ? void 0 : a.type) === "AspiringFJS") && (e = {
                type: "AspiringFJS",
                flavor: ""
            }),
            new wt(f,this.domain,l,e,r)
        }
        return new wt(this.value.div(t.value),this.domain,this.steps - t.steps,e,r)
    }
    ldiv(t) {
        const e = t.div(this);
        return e.color = this.color ?? t.color,
        e.label = this.label || t.label,
        e
    }
    dot(t) {
        let e;
        t.domain === "cologarithmic" ? e = this.value.dot(t.value).add(this.steps) : e = this.value.dot(t.value).add(this.steps * t.steps);
        const r = t instanceof wt ? Lr(this, t) : this;
        if (e.d === 1) {
            const i = BigInt(e.s * e.n);
            return new wt(Ct.TimeMonzo.fromBigInt(i),"linear",0,{
                type: "IntegerLiteral",
                value: i
            },r)
        }
        return new wt(Ct.TimeMonzo.fromFraction(e),"linear",0,{
            type: "FractionLiteral",
            numerator: BigInt(e.s * e.n),
            denominator: BigInt(e.d)
        },r)
    }
    pow(t) {
        if (this.domain === "logarithmic" || t.domain === "logarithmic")
            throw new Error("Exponentiation not implemented in logarithmic domain.");
        if (!t.value.isScalar() || t.steps)
            throw new Error("Only scalar exponentiation implemented.");
        const e = (0,
        gn.powNodes)(this.node, t.node);
        let r = 0;
        if (this.steps && (r = this.steps * t.valueOf(),
        !Number.isInteger(r)))
            throw new Error("Cannot create fractional steps.");
        return new wt(this.value.pow(t.value),this.domain,r,e,Lr(this, t))
    }
    ipow(t) {
        if (this.domain === "logarithmic" || t.domain === "logarithmic")
            throw new Error("Inverse exponentiation not implemented in logarithmic domain.");
        if (!t.value.isScalar() || t.steps)
            throw new Error("Only scalar inverse exponentiation implemented.");
        const e = (0,
        gn.ipowNodes)(this.node, t.node)
          , r = t.value.inverse();
        let i = 0;
        if (this.steps && (i = this.steps * r.valueOf(),
        !Number.isInteger(i)))
            throw new Error("Cannot create fractional steps.");
        return new wt(this.value.pow(r),this.domain,i,e,Lr(this, t))
    }
    log(t) {
        if (this.domain === "logarithmic" || t.domain === "logarithmic")
            throw new Error("Logarithm not implemented in the (already) logarithmic domain.");
        const e = this.steps / (t.steps || 1)
          , r = (0,
        gn.logNodes)(this.node, t.node);
        return new wt(P0(this, t),this.domain,e,r,Lr(this, t))
    }
    reduce(t, e=!1) {
        var a, l, f, h, p;
        if (this.domain === "logarithmic" || t.domain === "logarithmic")
            throw new Error("Reduction not implemented in logarithmic domain.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in reduction.");
        const r = this.value.reduce(t.value, e);
        let i;
        return ((a = t.node) == null ? void 0 : a.type) === "FractionLiteral" && (((l = this.node) == null ? void 0 : l.type) === "IntegerLiteral" || ((f = this.node) == null ? void 0 : f.type) === "FractionLiteral") && (i = r.asFractionLiteral()),
        ((h = this.node) == null ? void 0 : h.type) === "FractionLiteral" && ((p = t.node) == null ? void 0 : p.type) === "IntegerLiteral" && (i = r.asFractionLiteral()),
        new wt(r,this.domain,0,i,Lr(this, t))
    }
    backslash(t) {
        if (!this.value.isScalar() || !t.value.isScalar())
            throw new Error("Only scalars can be backslashed.");
        if (this.domain !== "linear" || t.domain !== "linear")
            throw new Error("Only linear backslashing implemented.");
        if (this.steps || t.steps)
            throw new Error("Steps not supported in backslashing.");
        const e = J2.pow(this.value.div(t.value));
        let r;
        return this.value.isIntegral() && t.value.isIntegral() && (r = {
            type: "NedjiLiteral",
            numerator: this.toInteger(),
            denominator: t.toInteger(),
            equaveNumerator: null,
            equaveDenominator: null
        }),
        new wt(e,"logarithmic",0,r,Lr(this, t))
    }
    compare(t) {
        return this.value.compare(t.value)
    }
    equals(t) {
        return this.value.equals(t.value)
    }
    strictEquals(t) {
        return this.domain === t.domain && this.steps === t.steps && this.value.strictEquals(t.value)
    }
    isPureSteps() {
        return this.value.isScalar() && this.value.isUnity()
    }
    realizeNode(t) {
        if (!this.node)
            return this.node;
        if (this.node.type === "AspiringAbsoluteFJS") {
            let e = 0
              , r = 0
              , i = 0;
            if (t.up.isPureSteps() && t.lift.isPureSteps() && ({ups: e, lifts: r, steps: i} = (0,
            wr.countUpsAndLifts)(this.steps, t.up.steps, t.lift.steps),
            i))
                return;
            const a = t.C4
              , l = this.value.div(a);
            if (l instanceof Ct.TimeReal || !l.isScalar())
                return;
            const f = (0,
            Cv.asAbsoluteFJS)(l, this.node.flavor);
            return f ? (f.ups = e,
            f.lifts = r,
            f) : void 0
        }
        if (this.node.type === "AspiringFJS") {
            if (this.value instanceof Ct.TimeReal)
                return;
            let e = 0
              , r = 0
              , i = 0;
            if (t.up.isPureSteps() && t.lift.isPureSteps() && ({ups: e, lifts: r, steps: i} = (0,
            wr.countUpsAndLifts)(this.steps, t.up.steps, t.lift.steps),
            i))
                return;
            const a = (0,
            Cv.asFJS)(this.value, this.node.flavor);
            return a ? (a.ups = e,
            a.lifts = r,
            a) : void 0
        }
        return this.node
    }
    asMonzoLiteral(t=!1) {
        let e;
        if (t && this.value instanceof Ct.TimeMonzo && !this.value.residual.isUnity()) {
            const r = this.value.clone();
            r.numberOfComponents = wr.NUM_INTERCHANGE_COMPONENTS,
            e = r.asMonzoLiteral()
        } else
            e = this.value.asMonzoLiteral();
        if (!Array.isArray(e.basis))
            throw new Error("Unexpexted unpruned basis.");
        if (t && (e.basis.length || e.components.length > wr.NUM_INTERCHANGE_COMPONENTS || this.steps) && (e = this.value.asInterchangeLiteral(),
        !Array.isArray(e.basis)))
            throw new Error("Unexpexted unpruned basis.");
        return this.steps && (!e.basis.length && e.components.length && (e.basis.push({
            numerator: 2,
            denominator: null,
            radical: !1
        }),
        e.components.length > 1 && (e.basis.push(""),
        e.basis.push(""))),
        e.basis.unshift("1"),
        e.components.unshift((0,
        gn.integerToVectorComponent)(this.steps))),
        e
    }
    simpleStr() {
        if (this.steps) {
            let t;
            if (this.isPureSteps())
                t = `${this.steps}`;
            else {
                const e = this.asMonzoLiteral();
                t = (0,
                gn.literalToString)(e)
            }
            return this.domain === "linear" ? `linear(${t})` : t
        }
        return this.value.toString(this.domain)
    }
    str(t) {
        if (this.node) {
            let e = this.node;
            if (this.node.type === "AspiringAbsoluteFJS") {
                if (!t)
                    return this.simpleStr();
                if (e = this.realizeNode(t),
                !e)
                    return this.simpleStr()
            }
            if (this.node.type === "AspiringFJS") {
                if (t)
                    e = this.realizeNode(t);
                else {
                    if (this.steps)
                        return this.simpleStr();
                    if (this.value instanceof Ct.TimeMonzo)
                        e = (0,
                        Cv.asFJS)(this.value, this.node.flavor);
                    else
                        return this.simpleStr()
                }
                if (!e)
                    return this.simpleStr()
            }
            return (0,
            gn.literalToString)(e)
        }
        return this.simpleStr()
    }
    toString(t, e=!1) {
        const r = this.str(t)
          , i = this.color ? this.color.toString() : "";
        if (e)
            return `${r} ${JSON.stringify(this.label)} ${i || "niente"}`;
        if (i || this.label) {
            let a = "(" + r;
            return this.label && (a += " " + JSON.stringify(this.label)),
            i && (a += " " + i),
            a + ")"
        }
        return r
    }
    valueOf() {
        return this.value.isIntegral() ? Number(this.value.toBigInteger()) : this.value.valueOf()
    }
    up(t) {
        var i, a, l;
        const e = this.value.mul(t.up.value)
          , r = this.steps + t.up.steps;
        if (((i = this.node) == null ? void 0 : i.type) === "FJS" || ((a = this.node) == null ? void 0 : a.type) === "AbsoluteFJS" || ((l = this.node) == null ? void 0 : l.type) === "MonzoLiteral") {
            const f = {
                ...this.node
            };
            f.ups++;
            const h = new wt(e,this.domain,r,f,this);
            return t.fragiles.push(h),
            h
        }
        return new wt(e,this.domain,r,void 0,this)
    }
    down(t, e=1) {
        var a, l, f;
        const r = this.value.div(t.up.value.pow(e))
          , i = this.steps - t.up.steps * e;
        if (((a = this.node) == null ? void 0 : a.type) === "FJS" || ((l = this.node) == null ? void 0 : l.type) === "AbsoluteFJS" || ((f = this.node) == null ? void 0 : f.type) === "MonzoLiteral") {
            const h = {
                ...this.node
            };
            h.ups -= e;
            const p = new wt(r,this.domain,i,h,this);
            return t.fragiles.push(p),
            p
        }
        return new wt(r,this.domain,i,void 0,this)
    }
    lift(t) {
        var i, a, l;
        const e = this.value.mul(t.lift.value)
          , r = this.steps + t.lift.steps;
        if (((i = this.node) == null ? void 0 : i.type) === "FJS" || ((a = this.node) == null ? void 0 : a.type) === "AbsoluteFJS" || ((l = this.node) == null ? void 0 : l.type) === "MonzoLiteral") {
            const f = {
                ...this.node
            };
            f.lifts++;
            const h = new wt(e,this.domain,r,f,this);
            return t.fragiles.push(h),
            h
        }
        return new wt(e,this.domain,r,void 0,this)
    }
    drop(t) {
        var i, a, l;
        const e = this.value.div(t.lift.value)
          , r = this.steps - t.lift.steps;
        if (((i = this.node) == null ? void 0 : i.type) === "FJS" || ((a = this.node) == null ? void 0 : a.type) === "AbsoluteFJS" || ((l = this.node) == null ? void 0 : l.type) === "MonzoLiteral") {
            const f = {
                ...this.node
            };
            f.lifts--;
            const h = new wt(e,this.domain,r,f,this);
            return t.fragiles.push(h),
            h
        }
        return new wt(e,this.domain,r,void 0,this)
    }
    break(t=!1) {
        var e, r, i, a;
        ((e = this.node) == null ? void 0 : e.type) === "FJS" && (this.node = {
            type: "AspiringFJS",
            flavor: (0,
            gn.inferFJSFlavor)(this.node)
        }),
        ((r = this.node) == null ? void 0 : r.type) === "AbsoluteFJS" && (/[J-Z]/.test(this.node.pitch.nominal) ? this.node = void 0 : this.node = {
            type: "AspiringAbsoluteFJS",
            flavor: (0,
            gn.inferFJSFlavor)(this.node)
        }),
        (((i = this.node) == null ? void 0 : i.type) === "MonzoLiteral" || ((a = this.node) == null ? void 0 : a.type) === "MosStepLiteral" || t) && (this.node = void 0)
    }
}
hn.Interval = wt;
const Md = new wt(J2,"logarithmic");
class Gs {
    constructor(t, e) {
        if (this.node = e,
        typeof t == "number") {
            const i = t;
            this.value = mt.PRIMES.slice(0, i).map(a => Ct.TimeMonzo.fromFraction(a, i)),
            this.ortho_ = this.value,
            this.dual_ = this.value;
            return
        }
        t = [...t];
        let r = 0;
        for (const i of t)
            if (i.residual.isUnity()) {
                const a = [...i.primeExponents];
                for (; a.length && !a[a.length - 1].n; )
                    a.pop();
                r = Math.max(a.length, r)
            } else {
                if (i.residual.s !== 1)
                    throw new Error("Only positive elements supported in val subgroups.");
                r = Math.max((0,
                mt.primeLimit)(i.residual.n, !0), (0,
                mt.primeLimit)(i.residual.d, !0), r)
            }
        if (isNaN(r))
            throw new Error("Unable to determine val basis prime limit.");
        for (let i = 0; i < t.length; ++i)
            t[i].numberOfComponents !== r && (t[i] = t[i].clone(),
            t[i].numberOfComponents = r);
        this.value = t
    }
    get size() {
        return this.value.length
    }
    get numberOfComponents() {
        return this.value[0].numberOfComponents
    }
    get nonPrimes() {
        const t = [];
        for (const e of this.value)
            e.isIntegral() && mt.PRIMES.includes(e.valueOf()) || t.push(e);
        return t
    }
    get tenneyValue() {
        return this.tenneyValue_ === void 0 && (this.tenneyValue_ = this.value.map(t => (0,
        mt.applyWeights)(t.toMonzo(), mt.LOG_PRIMES))),
        this.tenneyValue_
    }
    get tenneyGram() {
        return this.tenneyGram_ === void 0 && (this.tenneyGram_ = (0,
        mt.gram)(this.tenneyValue)),
        this.tenneyGram_
    }
    isPrimewise() {
        for (const t of this.value) {
            if (t.timeExponent.n)
                return !1;
            let e = 0;
            for (const r of t.primeExponents)
                r.n && e++;
            if (e > 1)
                return !1;
            for (const r of (0,
            mt.primeFactorize)(t.residual).keys()) {
                if (r <= 0)
                    return !1;
                e++
            }
            if (e !== 1)
                return !1
        }
        return !0
    }
    superBasis() {
        const t = new Set;
        for (const r of this.value) {
            if (r.timeExponent.n)
                throw new Error("Absolute basis does not have a prime super-basis.");
            for (const i of r.factorize().keys()) {
                if (i <= 0)
                    throw new Error("Negative or zero basis does not have a prime super-basis.");
                t.add(i)
            }
        }
        const e = Array.from(t);
        return e.sort( (r, i) => r - i),
        new Gs(e.map(r => Ct.TimeMonzo.fromFraction(r)))
    }
    hypercube(t, e=!1) {
        const r = [new Ct.TimeMonzo(wr.ZERO,[])];
        for (let i = 0; i < this.size; ++i) {
            const a = this.value[i]
              , l = [...r];
            let f;
            for (let h = 0; h < t; ++h) {
                f === void 0 ? f = a : f = f.mul(a);
                for (const p of l) {
                    let m = p.mul(f);
                    if (m instanceof Ct.TimeReal)
                        throw new Error("Hyper-cube spanning failed.");
                    if (r.push(m),
                    m = p.div(f),
                    m instanceof Ct.TimeReal)
                        throw new Error("Hyper-cube spanning failed.");
                    r.push(m)
                }
            }
        }
        return e && r.shift(),
        r
    }
    get ortho() {
        return this.ortho_ === void 0 && this.performGramProcess(),
        this.ortho_
    }
    get dual() {
        return this.dual_ === void 0 && this.performGramProcess(),
        this.dual_
    }
    performGramProcess() {
        if (this.ortho_ === void 0) {
            this.ortho_ = [...this.value],
            this.dual_ = [];
            for (let t = 0; t < this.ortho_.length; ++t) {
                for (let e = 0; e < t; ++e) {
                    const r = this.ortho_[t].div(this.ortho_[e].pow(this.dual_[e].dot(this.ortho_[t])));
                    if (r instanceof Ct.TimeReal)
                        throw new Error("Basis orthogonalization failed.");
                    this.ortho_[t] = r
                }
                this.dual_.push(this.ortho_[t].geometricInverse())
            }
        }
    }
    toArray() {
        return this.value.map(t => new wt(t,"linear"))
    }
    lll(t) {
        for (const i of this.value)
            if (!i.isScalar())
                throw new Error("LLL reduction is only implemented in the relative echelon.");
        if (t === "none")
            try {
                const i = this.value.map(l => l.primeExponents)
                  , a = (0,
                mt.fractionalLenstraLenstraLovasz)(i);
                return new Gs(a.basis.map(l => new Ct.TimeMonzo(wr.ZERO,l).pitchAbs()))
            } catch {}
        let e = this.value.map(i => i.toMonzo());
        t === "tenney" && (e = this.tenneyValue);
        const r = (0,
        mt.lenstraLenstraLovasz)(e);
        return t === "tenney" && (r.basis = r.basis.map(i => (0,
        mt.unapplyWeights)(i, mt.LOG_PRIMES))),
        new Gs(r.basis.map(i => new Ct.TimeMonzo(wr.ZERO,i.map(a => new mt.Fraction(Math.round(a)))).pitchAbs()))
    }
    respell(t, e) {
        if (e === "none") {
            for (let l = this.size - 1; l >= 0; --l) {
                const f = this.dual[l].dot(t);
                if (t = t.div(this.value[l].pow(f.round())),
                t instanceof Ct.TimeReal)
                    throw new Error("Respelling failed.")
            }
            return t
        }
        let r = (0,
        mt.applyWeights)(t.toMonzo(), mt.LOG_PRIMES);
        const i = this.tenneyValue
          , a = this.tenneyGram.dual;
        for (let l = this.size - 1; l >= 0; --l) {
            const f = (0,
            mt.dot)(a[l], r);
            r = (0,
            mt.sub)(r, (0,
            mt.scale)(i[l], Math.round(f)))
        }
        return r = (0,
        mt.unapplyWeights)(r, mt.LOG_PRIMES).map(Math.round),
        new Ct.TimeMonzo(wr.ZERO,r.map(l => new mt.Fraction(l)))
    }
    equals(t) {
        if (this.size !== t.size)
            return !1;
        for (let e = 0; e < this.value.length; ++e)
            if (!this.value[e].equals(t.value[e]))
                return !1;
        return !0
    }
    strictEquals(t) {
        if (this.size !== t.size)
            return !1;
        for (let e = 0; e < this.value.length; ++e)
            if (!this.value[e].strictEquals(t.value[e]))
                return !1;
        return !0
    }
    isStandard(t=!1) {
        if (!t && this.size !== (0,
        Ct.getNumberOfComponents)())
            return !1;
        for (let e = 0; e < this.value.length; ++e)
            if (!this.value[e].isIntegral() || this.value[e].toBigInteger() !== mt.BIG_INT_PRIMES[e])
                return !1;
        return !0
    }
    standardFix(t) {
        let e = mt.PRIME_CENTS.slice(0, this.numberOfComponents);
        const r = this.value.map(a => a.toMonzo())
          , i = this.ortho.map(a => a.toMonzo());
        for (let a = 0; a < r.length; ++a) {
            const l = (0,
            mt.dot)(r[a], e);
            e = (0,
            mt.add)(e, (0,
            mt.scale)(i[a], (t[a] - l) / (0,
            mt.dot)(r[a], i[a])))
        }
        return e
    }
    toSubgroupMonzo(t) {
        const e = [];
        for (let r = 0; r < this.size; ++r) {
            const i = this.dual[r].dot(t);
            if (i.d !== 1)
                throw new Error("Monzo is fractional inside subgroup.");
            if (e.push(i.valueOf()),
            t = t.div(this.ortho[r].pow(i)),
            t instanceof Ct.TimeReal)
                throw new Error("Subgroup conversion failed.")
        }
        if (!(t.isScalar() && t.isUnity()))
            throw new Error("Monzo outside subgroup.");
        return e
    }
    toSmonzoAndResidual(t) {
        const e = [];
        for (let r = 0; r < this.size; ++r) {
            const i = this.dual[r].dot(t);
            if (e.push(i),
            t = t.div(this.ortho[r].pow(i)),
            t instanceof Ct.TimeReal)
                throw new Error("Subgroup conversion failed.")
        }
        return [e, t]
    }
    dot(t) {
        if (!t.length)
            return new Ct.TimeMonzo(wr.ZERO,[]);
        let e = this.value[0].pow(t[0]);
        for (let r = Math.min(this.size, t.length) - 1; r > 0; --r)
            e = e.mul(this.value[r].pow(t[r]));
        if (e instanceof Ct.TimeReal)
            throw new Error("Smonzo conversion failed.");
        return e
    }
    intrinsicCall(t) {
        if (t instanceof wt) {
            let e;
            return t.value instanceof Ct.TimeReal ? e = new Ct.TimeMonzo(wr.ZERO,[]) : e = this.dot(t.value.primeExponents),
            new wt(e,t.domain,0,wh(e, t.node, !0),t)
        }
        return t instanceof Ar ? Ar.fromBasisMap(t.sval, this) : t
    }
    toWartBasis() {
        if (this.isStandard())
            return [""];
        const t = [];
        for (let e of this.value)
            if (e.isScalar() && e.isSqrt()) {
                let r = !1;
                e.isFractional() || (r = !0,
                e = e.pow(2));
                const {s: i, n: a, d: l} = e.toFraction();
                if (i <= 0)
                    throw new Error("Invalid basis.");
                t.push({
                    radical: r,
                    numerator: a,
                    denominator: l === 1 ? null : l
                })
            } else
                throw new Error("Basis is incompatible with warts and SOV.");
        return t
    }
    toString() {
        if (this.node)
            return (0,
            gn.literalToString)(this.node);
        if (!this.size)
            return "basis()";
        const t = {
            type: "ValBasisLiteral",
            basis: []
        }
          , e = () => `basis(${this.value.map(r => r.toString()).join(", ")})`;
        for (let r of this.value)
            if (r.isUnity())
                if (r.timeExponent.equals(-1))
                    t.basis.push("Hz");
                else if (r.timeExponent.equals(1))
                    t.basis.push("s");
                else
                    return e();
            else if (r.isSqrt()) {
                let i = !1;
                r.isFractional() || (i = !0,
                r = r.pow(2));
                const {s: a, n: l, d: f} = r.toFraction();
                if (a <= 0)
                    throw new Error("Invalid basis.");
                t.basis.push({
                    radical: i,
                    numerator: l,
                    denominator: f === 1 ? null : f
                })
            } else
                return e();
        return (0,
        gn.literalToString)(t)
    }
}
hn.ValBasis = Gs;
class Ar {
    constructor(t, e, r) {
        this.domain = "cologarithmic",
        this.value = t,
        this.basis = e,
        this.node = r
    }
    static fromArray(t, e, r) {
        return e || (e = new Gs(t.length)),
        new Ar(Ct.TimeMonzo.fromArray(t),e,r)
    }
    static fromBasisMap(t, e, r) {
        let i = new Ct.TimeMonzo(wr.ZERO,Array(e.numberOfComponents).fill(wr.ZERO));
        for (let a = 0; a < e.value.length; ++a) {
            const f = i.dot(e.value[a]).sub(t[a]);
            i = i.div(e.ortho[a].pow(f.div(e.value[a].dot(e.ortho[a]))))
        }
        if (!(i instanceof Ct.TimeMonzo))
            throw new Error("Val construction failed.");
        return new Ar(i,e,r)
    }
    get equave() {
        return this.basis.value[0]
    }
    get divisions() {
        return this.value.dot(this.equave)
    }
    get sval() {
        return this.basis.value.map(t => this.value.dot(t))
    }
    neg() {
        return new Ar(this.value.inverse(),this.basis)
    }
    inverse() {
        return new wt(this.value.geometricInverse(),"logarithmic")
    }
    abs() {
        return this.divisions.s < 0 ? new Ar(this.value.inverse(),this.basis) : new Ar(this.value.clone(),this.basis)
    }
    sqrt() {
        const t = this.value.sqrt();
        if (t instanceof Ct.TimeMonzo)
            return new Ar(t,this.basis);
        throw new Error("Val square root operation failed.")
    }
    equals(t) {
        return this.value.equals(t.value) && this.basis.equals(t.basis)
    }
    strictEquals(t) {
        return this.value.strictEquals(t.value) && this.basis.strictEquals(t.basis)
    }
    add(t) {
        if (!this.basis.strictEquals(t.basis))
            throw new Error("Val basis must match in addition.");
        const e = this.value.mul(t.value);
        if (e instanceof Ct.TimeReal)
            throw new Error("Val addition failed.");
        return new Ar(e,this.basis)
    }
    sub(t) {
        if (!this.basis.strictEquals(t.basis))
            throw new Error("Val basis must match in subtraction.");
        const e = this.value.div(t.value);
        if (e instanceof Ct.TimeReal)
            throw new Error("Val subtraction failed.");
        return new Ar(e,this.basis)
    }
    mul(t) {
        if (t.domain !== "linear" || t.value.timeExponent.valueOf())
            throw new Error("Only scalar multiplication implemented for vals.");
        if (t.value instanceof Ct.TimeReal)
            throw new Error("Cannot multiply val by an irrational scalar.");
        const e = this.value.pow(t.value);
        if (e instanceof Ct.TimeReal)
            throw new Error("Val scalar multiplication failed.");
        return new Ar(e,this.basis)
    }
    div(t) {
        if (t.domain !== "linear" || t.value.timeExponent.valueOf())
            throw new Error("Only scalar multiplication implemented for vals.");
        const e = this.value.pow(t.value.inverse());
        if (e instanceof Ct.TimeReal)
            throw new Error("Val scalar multiplication failed.");
        return new Ar(e,this.basis)
    }
    dot(t) {
        if (t instanceof wt)
            return t.dot(this);
        const e = this.value.dot(t.value);
        return e.d === 1 ? wt.fromInteger(e.s * e.n) : wt.fromFraction(e)
    }
    errorTE(t, e=!1) {
        const r = this.basis.value.map(p => p.totalCents());
        if (!this.divisions.valueOf()) {
            if (this.sval.some(g => g.n))
                return 1 / 0;
            const m = (0,
            mt.dotPrecise)(t, t);
            return e ? m : Math.sqrt(m / this.basis.numberOfComponents) * r[0]
        }
        const a = r[0] / this.divisions.valueOf()
          , l = this.sval.map(p => p.valueOf() * a)
          , f = (0,
        mt.sub)(t, (0,
        mt.applyWeights)((0,
        mt.unapplyWeights)(l, r), t))
          , h = (0,
        mt.dotPrecise)(f, f);
        return e ? h : Math.sqrt(h / this.basis.numberOfComponents) * r[0]
    }
    nextGPV(t) {
        const e = this.basis.value.map(f => f.totalCents())
          , r = this.basis.value.map(f => this.value.dot(f));
        if (!this.divisions.n)
            return r[0] = r[0].add(wr.ONE),
            Ar.fromBasisMap(r, this.basis);
        const i = r.map(f => f.valueOf());
        let a = 1 / 0
          , l = -1;
        for (let f = 0; f < this.basis.size; ++f) {
            const h = [...i];
            h[f] += 1;
            const p = e[0] / h[0]
              , m = (0,
            mt.sub)(t, (0,
            mt.applyWeights)((0,
            mt.unapplyWeights)((0,
            mt.scale)(h, p), e), t))
              , g = (0,
            mt.dotPrecise)(m, m);
            g < a && (a = g,
            l = f)
        }
        return r[l] = r[l].add(wr.ONE),
        Ar.fromBasisMap(r, this.basis)
    }
    toString() {
        if (this.node)
            return (0,
            gn.literalToString)(this.node);
        const t = this.value.toString("cologarithmic");
        return t.includes("@") || !this.basis.isStandard(!0) ? `withBasis(${t}, ${this.basis.toString()})` : t
    }
}
hn.Val = Ar;
class Tl {
    constructor(t, e, r, i=!1, a="subgroup") {
        if (!t.length)
            throw new Error("Constructing the trivial temperament is not supported.");
        for (e || (e = new Gs(t[0].length)),
        this.basis = e,
        this.canonicalMapping = (0,
        mt.defactoredHnf)(t),
        r === void 0 ? r = [] : r = [...r]; r.length < e.size; )
            r.push(1);
        for (; r.length > e.size; )
            r.pop();
        this.weights = r,
        this.pureEquaves = i,
        this.metric = a;
        const l = (0,
        mt.transpose)((0,
        mt.kernel)(this.canonicalMapping));
        this.commaBasis = new Gs(l.map(p => e.dot(p))).lll("tenney"),
        this.sgens = (0,
        mt.transpose)((0,
        mt.preimage)(this.canonicalMapping));
        const f = this.sgens.map(p => e.dot(p));
        this.preimage = new Gs(f.map(p => this.commaBasis.respell(p, "tenney")));
        const h = this.preimage.value;
        for (let p = 0; p < h.length; ++p)
            h[p].totalCents() < 0 && (h[p] = h[p].inverse(),
            this.sgens[p] = this.sgens[p].map(m => -m),
            this.canonicalMapping[p] = this.canonicalMapping[p].map(m => -m))
    }
    static fromVals(t, e, r=!1, i="subgroup") {
        if (!t.length)
            throw new Error("At least one val is required when constructing a temperament.");
        const a = t[0].basis;
        for (const f of t.slice(1))
            if (!f.basis.equals(a))
                throw new Error("Bases must match when constructing a temperament.");
        let l = t.map(f => f.sval.map(h => BigInt(h.valueOf())));
        return l = (0,
        mt.hnf)(l),
        (0,
        mt.pruneZeroRows)(l),
        new Tl(l.map(f => f.map(Number)),a,e,r,i)
    }
    static fromCommas(t, e, r, i=!1, a="subgroup", l=!1) {
        if (!t.length) {
            if (e === void 0)
                throw new Error("An explicit subgroup is required with an empty comma list.");
            return new Tl((0,
            mt.eye)(e.size),e,r,i,a)
        }
        let f = [];
        if (e)
            f.push(...t.map(h => e.toSubgroupMonzo(h).map(BigInt)));
        else {
            for (const g of t)
                if (!(g.isScalar() && g.isFractional()))
                    throw new Error("Only relative rational commas supported.");
            const h = t.map(g => g.factorize())
              , p = new Set;
            for (const g of h)
                for (const b of g.keys()) {
                    if (b === 0)
                        throw new Error("Zero cannot be tempered out.");
                    if (b < 0)
                        throw new Error("Negative values cannot be tempered out.");
                    p.add(b)
                }
            let m = Array.from(p);
            if (m.sort( (g, b) => g - b),
            l) {
                const g = mt.PRIMES.indexOf(m.pop()) + 1;
                m = mt.PRIMES.slice(0, g)
            }
            e = new Gs(m.map(g => Ct.TimeMonzo.fromFraction(g)));
            for (const g of h)
                f.push(m.map(b => BigInt((g.get(b) ?? 0).valueOf())))
        }
        return f = (0,
        mt.hnf)(f),
        (0,
        mt.pruneZeroRows)(f),
        new Tl((0,
        mt.cokernel)((0,
        mt.transpose)(f)).map(h => h.map(Number)),e,r,i,a)
    }
    get subgroupMapping() {
        if (this.subgroupMapping_ !== void 0)
            return this.subgroupMapping_;
        if (this.metric === "subgroup" && !this.basis.isPrimewise()) {
            const i = this.basis.superBasis();
            let a = Array(i.size).fill(0);
            for (let f = 0; f < this.basis.size; ++f) {
                const h = i.toSubgroupMonzo(this.basis.value[f]);
                a = (0,
                mt.add)(a, (0,
                mt.scale)(h, this.weights[f]).map(Math.abs))
            }
            const l = Tl.fromCommas(this.commaBasis.value, this.basis.superBasis(), a, this.pureEquaves, "inharmonic");
            return this.subgroupMapping_ = this.basis.value.map(f => l.temper(f).totalCents()),
            this.subgroupMapping_
        }
        const t = this.basis.value.map(i => i.totalCents())
          , e = [];
        for (let i = 0; i < this.basis.size; ++i) {
            const a = this.metric === "Tenney-Pakkanen" ? this.basis.value[i].tenneyHeight() : this.basis.value[i].totalCents();
            e.push(this.weights[i] / a)
        }
        const r = (0,
        yD.combineTuningMaps)((0,
        mt.applyWeights)(t, e), this.canonicalMapping.map(i => (0,
        mt.applyWeights)(i, e)));
        if (this.subgroupMapping_ = (0,
        mt.unapplyWeights)(r, e),
        this.pureEquaves) {
            const i = t[0] / this.subgroupMapping_[0];
            this.subgroupMapping_ = this.subgroupMapping_.map(a => a * i)
        }
        return this.subgroupMapping_
    }
    get rank() {
        return this.canonicalMapping.length
    }
    get generators() {
        return this.sgens.map(t => (0,
        mt.dotPrecise)(this.subgroupMapping, t))
    }
    get numberOfPeriods() {
        return this.canonicalMapping[0][0]
    }
    respell(t) {
        const [e,r] = this.basis.toSmonzoAndResidual(t);
        t = new Ct.TimeMonzo(wr.ZERO,[]);
        const i = this.preimage.value;
        for (let l = 0; l < i.length; ++l)
            t = t.mul(i[l].pow((0,
            mt.fractionalDot)(this.canonicalMapping[l], e)));
        const a = this.commaBasis.respell(t, "tenney").mul(r);
        if (a instanceof Ct.TimeReal)
            throw new Error("Respelling failed.");
        return a
    }
    temper(t) {
        if (t instanceof Ct.TimeReal)
            return t;
        const [e,r] = this.basis.toSmonzoAndResidual(t);
        return Ct.TimeReal.fromCents((0,
        mt.dot)(e.map(i => i.valueOf()), this.subgroupMapping)).mul(r)
    }
    dot(t) {
        if (t.value instanceof Ct.TimeReal)
            return this.canonicalMapping.map( () => wt.fromInteger(0));
        const [e] = this.basis.toSmonzoAndResidual(t.value);
        return this.canonicalMapping.map(i => (0,
        mt.fractionalDot)(i, e)).map(i => wt.fromFraction(i))
    }
    errorTE() {
        const t = this.basis.value.map(r => r.totalCents())
          , e = (0,
        mt.sub)(this.weights, (0,
        mt.applyWeights)(this.weights, (0,
        mt.unapplyWeights)(this.subgroupMapping, t)));
        return Math.sqrt((0,
        mt.dotPrecise)(e, e) / t.length) * t[0]
    }
    equals(t) {
        if (this.canonicalMapping.length !== t.canonicalMapping.length)
            return !1;
        for (let e = 0; e < this.canonicalMapping.length; ++e)
            for (let r = 0; r < this.canonicalMapping[e].length; ++r)
                if (this.canonicalMapping[e][r] !== t.canonicalMapping[e][r])
                    return !1;
        return !(0,
        mt.arraysEqual)(this.weights, t.weights) || !this.basis.equals(t.basis) ? !1 : this.pureEquaves === t.pureEquaves
    }
    strictEquals(t) {
        if (this.canonicalMapping.length !== t.canonicalMapping.length)
            return !1;
        for (let e = 0; e < this.canonicalMapping.length; ++e)
            for (let r = 0; r < this.canonicalMapping[e].length; ++r)
                if (this.canonicalMapping[e][r] !== t.canonicalMapping[e][r])
                    return !1;
        return !(0,
        mt.arraysEqual)(this.weights, t.weights) || !this.basis.strictEquals(t.basis) ? !1 : this.pureEquaves === t.pureEquaves
    }
    toString() {
        let t = "Temperament([";
        return t += this.canonicalMapping.map(e => "" + e.join(" ") + "]").join(", "),
        t += "]",
        this.basis.isStandard(!0) || (t += ` ${this.basis}`),
        this.weights.every(e => e === 1) ? this.pureEquaves && (t += ", niente, true") : (t += ", [" + this.weights.map(e => `${e}r`).join(", ") + "]",
        this.pureEquaves && (t += ", true")),
        t + ")"
    }
}
hn.Temperament = Tl;
function wh(n, t, e=!1) {
    if (t)
        switch (t.type) {
        case "IntegerLiteral":
            return n.asIntegerLiteral();
        case "FractionLiteral":
            return n.asFractionLiteral(e ? void 0 : t);
        case "NedjiLiteral":
            return n.asNedjiLiteral(e ? void 0 : t);
        case "CentsLiteral":
            return n.asCentsLiteral();
        case "MonzoLiteral":
            return n.asMonzoLiteral();
        case "FJS":
        case "AspiringFJS":
            return {
                type: "AspiringFJS",
                flavor: (0,
                gn.inferFJSFlavor)(t)
            };
        case "AbsoluteFJS":
        case "AspiringAbsoluteFJS":
            return {
                type: "AspiringAbsoluteFJS",
                flavor: (0,
                gn.inferFJSFlavor)(t)
            };
        default:
            return
        }
}
hn.intervalValueAs = wh;
Object.defineProperty(In, "__esModule", {
    value: !0
});
In.ternaryBroadcast = In.binaryBroadcast = In.unaryBroadcast = In.isArrayOrRecord = In.requireParameters = In.builtinNode = In.linearOne = In.sonicTruth = In.upcastBool = In.fromInteger = void 0;
const Qt = hn
  , G1 = An
  , D0 = vr;
new G1.TimeMonzo(D0.ZERO,[],D0.ZERO);
new G1.TimeMonzo(D0.ZERO,[]);
const wc = [...Array(100).keys()].map(n => Qt.Interval.fromInteger(n));
function bD(n) {
    return n >= 0 && n < wc.length ? wc[n].shallowClone() : Qt.Interval.fromInteger(n)
}
In.fromInteger = bD;
function wD(n) {
    if (n instanceof Qt.Interval)
        return n;
    if (n === !0)
        return wc[1].shallowClone();
    if (n === !1)
        return wc[0].shallowClone();
    throw new Error("An interval or boolean is required.")
}
In.upcastBool = wD;
function ED(n) {
    return n instanceof Qt.Interval ? n.value instanceof G1.TimeReal ? !!n.value.value : !!n.value.residual.n : Array.isArray(n) ? !!n.length : n instanceof Qt.Val || n instanceof Qt.Color ? !0 : n instanceof Qt.ValBasis ? !!n.size : n instanceof Qt.Temperament ? !0 : typeof n == "object" ? !!Object.keys(n).length : !!n
}
In.sonicTruth = ED;
function _D() {
    return wc[1]
}
In.linearOne = _D;
function LD(n, t) {
    const e = n.toString().split("(", 2)[1].split(")", 2)[0].split(",").map(r => r.trim()).filter(r => r.length).map(r => ({
        type: "Parameter",
        id: r,
        defaultValue: null
    }));
    for (const r of e) {
        if (r.id.includes("=")) {
            let[i,a] = r.id.split("=");
            r.id = i.trim(),
            a = a.trim().replace(/'/g, '"'),
            a.includes('"') ? r.defaultValue = {
                type: "StringLiteral",
                value: JSON.parse(a)
            } : a === "true" ? r.defaultValue = {
                type: "TrueLiteral"
            } : a === "false" && (r.defaultValue = {
                type: "FalseLiteral"
            })
        } else
            r.id === "scale" && (r.defaultValue = {
                type: "PopScale",
                parent: !0
            });
        t && r.id in t && (r.defaultValue = t[r.id])
    }
    return {
        type: "FunctionDeclaration",
        name: {
            type: "Identifier",
            id: n.name
        },
        parameters: {
            type: "Parameters",
            parameters: e,
            defaultValue: null
        },
        body: [],
        text: `riff ${n.name} { [native riff] }`
    }
}
In.builtinNode = LD;
function SD(n) {
    for (const t of Object.keys(n))
        if (n[t] === void 0)
            throw new Error(`Parameter '${t}' is required.`)
}
In.requireParameters = SD;
function AD(n) {
    return Array.isArray(n) ? !0 : typeof n != "object" ? !1 : !(n instanceof Qt.Interval || n instanceof Qt.Color || n instanceof Qt.Val || n instanceof Qt.ValBasis || n instanceof Qt.Temperament)
}
In.isArrayOrRecord = AD;
function CD(n, t) {
    if (Array.isArray(n))
        return this.spendGas(n.length),
        n.map(t);
    if (typeof n != "object")
        throw new Error("Invalid container to map over.");
    if (n instanceof Qt.Color || n instanceof Qt.Val || n instanceof Qt.Interval || n instanceof Qt.ValBasis)
        throw new Error("Invalid container to map over.");
    const e = Object.entries(n);
    return this.spendGas(e.length),
    Object.fromEntries(e.map( ([r,i]) => [r, t(i)]))
}
In.unaryBroadcast = CD;
function $D(n, t, e) {
    if (Array.isArray(n)) {
        if (Array.isArray(t)) {
            if (n.length !== t.length)
                throw new Error(`Unable to broadcast arrays together with lengths ${n.length} and ${t.length}.`);
            return this.spendGas(n.length),
            n.map( (i, a) => e(i, t[a]))
        }
        if (typeof t == "object" && !(t instanceof Qt.Color || t instanceof Qt.Interval || t instanceof Qt.Val || t instanceof Qt.ValBasis || t instanceof Qt.Temperament))
            throw new Error("Unable to broadcast an array and record together.");
        return this.spendGas(n.length),
        n.map(i => e(i, t))
    }
    if (typeof n == "object" && !(n instanceof Qt.Color || n instanceof Qt.Interval || n instanceof Qt.Val || n instanceof Qt.ValBasis || n instanceof Qt.Temperament)) {
        if (Array.isArray(t))
            throw new Error("Unable to broadcast an array and record together.");
        const i = Object.entries(n);
        if (typeof t == "object" && !(t instanceof Qt.Color || t instanceof Qt.Interval || t instanceof Qt.Val || t instanceof Qt.ValBasis || t instanceof Qt.Temperament)) {
            for (const l in t)
                if (!(l in n))
                    throw new Error(`Unable broadcast records together on key ${l}.`);
            const a = [];
            for (const [l,f] of i) {
                if (!(l in t))
                    throw new Error(`Unable broadcast records together on key ${l}.`);
                this.spendGas(),
                a.push([l, e(f, t[l])])
            }
            return Object.fromEntries(a)
        }
        return this.spendGas(i.length),
        Object.fromEntries(i.map( ([a,l]) => [a, e(l, t)]))
    }
    if (Array.isArray(t))
        return this.spendGas(t.length),
        t.map(i => e(n, i));
    if (typeof t != "object" || t instanceof Qt.Color || t instanceof Qt.Interval || t instanceof Qt.Val || t instanceof Qt.ValBasis || t instanceof Qt.Temperament)
        throw new Error("Invalid container broadcast.");
    const r = Object.entries(t);
    return this.spendGas(r.length),
    Object.fromEntries(r.map( ([i,a]) => [i, e(n, a)]))
}
In.binaryBroadcast = $D;
function MD(n, t, e, r) {
    if (Array.isArray(n)) {
        if (this.spendGas(n.length),
        Array.isArray(t)) {
            if (Array.isArray(e)) {
                if (n.length !== t.length || t.length !== e.length)
                    throw new Error(`Unable to broadcast arrays together with lengths ${t.length}, ${n.length} and ${e.length}.`);
                return n.map( (i, a) => r(i, t[a], e[a]))
            }
            if (n.length !== t.length)
                throw new Error(`Unable to broadcast arrays together with lengths ${t.length}, ${n.length} and *.`);
            return n.map( (i, a) => r(i, t[a], e))
        }
        if (Array.isArray(e)) {
            if (n.length !== e.length)
                throw new Error(`Unable to broadcast arrays together with lengths *, ${n.length} and ${e.length}.`);
            return n.map( (i, a) => r(i, t, e[a]))
        }
        return n.map(i => r(i, t, e))
    }
    if (Array.isArray(t)) {
        if (this.spendGas(t.length),
        Array.isArray(e)) {
            if (t.length !== e.length)
                throw new Error(`Unable to broadcast arrays together with lengths ${t.length}, * and ${e.length}.`);
            return t.map( (i, a) => r(n, i, e[a]))
        }
        return t.map(i => r(n, i, e))
    }
    return Array.isArray(e) ? (this.spendGas(e.length),
    e.map(i => r(n, t, i))) : r(n, t, e)
}
In.ternaryBroadcast = MD;
var Wt = {};
Object.defineProperty(Wt, "__esModule", {
    value: !0
});
Wt.temper = Wt.factorColor = Wt.centsColor = Wt.lstr = Wt.str = Wt.repr = Wt.sortInPlace = Wt.track = Wt.wilsonHeight = Wt.tenneyHeight = Wt.relative = Wt.absolute = Wt.logarithmic = Wt.linear = Wt.bleach = Wt.simplify = Wt.compare = void 0;
const q0 = Ie
  , En = hn
  , W1 = vr
  , Ni = In
  , xo = An;
function K2(n, t) {
    if (typeof n == "string") {
        if (typeof t != "string")
            throw new Error("Only strings can be compared with other strings.");
        return n < t ? -1 : n > t ? 1 : 0
    }
    if (typeof n == "boolean" && (n = (0,
    Ni.upcastBool)(n)),
    typeof t == "boolean" && (t = (0,
    Ni.upcastBool)(t)),
    !(n instanceof En.Interval && t instanceof En.Interval))
        throw new Error("Only strings or intervals can be compared.");
    if (n.isRelative() && t.isRelative())
        return n.compare(t);
    if (n.isAbsolute() && t.isAbsolute()) {
        const r = J1.bind(this);
        return r(n).compare(r(t))
    }
    const e = ou.bind(this);
    return e(n).compare(e(t))
}
Wt.compare = K2;
function OD(n) {
    if (n instanceof En.Val)
        return new En.Val(n.value.clone(),n.basis);
    if (typeof n == "boolean")
        return (0,
        Ni.upcastBool)(n);
    if (n instanceof En.Interval)
        return new En.Interval(n.value.clone(),n.domain,n.steps,void 0,n);
    throw new Error("An interval, val or boolean is required.")
}
Wt.simplify = OD;
function ND(n) {
    return n = (0,
    Ni.upcastBool)(n),
    new En.Interval(n.value.clone(),n.domain,n.steps,n.node)
}
Wt.bleach = ND;
function TD(n) {
    return n = (0,
    Ni.upcastBool)(n),
    n.domain === "linear" ? n.shallowClone() : new En.Interval(n.value.clone(),"linear",n.steps,void 0,n)
}
Wt.linear = TD;
function xD(n) {
    return n = (0,
    Ni.upcastBool)(n),
    n.domain === "logarithmic" ? n.shallowClone() : new En.Interval(n.value.clone(),"logarithmic",n.steps,void 0,n)
}
Wt.logarithmic = xD;
function J1(n) {
    var t;
    if (n = (0,
    Ni.upcastBool)(n),
    n.isAbsolute()) {
        const e = n.value.timeExponent;
        return W1.NEGATIVE_ONE.equals(e) ? n.shallowClone() : new En.Interval(n.value.pow(e instanceof q0.Fraction ? e.inverse().neg() : -1 / e),n.domain,n.steps,void 0,n)
    }
    if (((t = this.rootContext) == null ? void 0 : t.unisonFrequency) === void 0)
        throw new Error("Reference frequency must be set for relative -> absolute conversion. Try 1/1 = 440 Hz.");
    return new En.Interval(n.value.mul(this.rootContext.unisonFrequency),n.domain,n.steps,void 0,n)
}
Wt.absolute = J1;
function ou(n) {
    var e;
    if (n = (0,
    Ni.upcastBool)(n),
    n.isRelative())
        return n.shallowClone();
    if (((e = this.rootContext) == null ? void 0 : e.unisonFrequency) === void 0)
        throw new Error("Reference frequency must be set for absolute -> relative conversion. Try 1/1 = 440 Hz.");
    const t = J1.bind(this)(n);
    return new En.Interval(t.value.div(this.rootContext.unisonFrequency),n.domain,n.steps,void 0,n)
}
Wt.relative = ou;
function ID(n) {
    return new En.Interval(xo.TimeReal.fromValue((0,
    Ni.upcastBool)(n).value.tenneyHeight()),"linear")
}
Wt.tenneyHeight = ID;
function FD(n) {
    const t = ou.bind(this)((0,
    Ni.upcastBool)(n)).value;
    if (t instanceof xo.TimeReal)
        return new En.Interval(xo.TimeReal.fromValue(1 / 0),"linear");
    const e = (0,
    q0.wilsonHeight)(t.residual);
    if (e === 1 / 0)
        return new En.Interval(xo.TimeReal.fromValue(1 / 0),"linear");
    let r = new q0.Fraction(e);
    const i = t.primeExponents;
    for (let a = 0; a < i.length; ++a)
        r = r.add(i[a].abs().mul(W1.FRACTION_PRIMES[a]));
    return new En.Interval(xo.TimeMonzo.fromFraction(r),"linear")
}
Wt.wilsonHeight = FD;
function RD(n) {
    if (!this.rootContext)
        throw new Error("Root context required for tracking.");
    const t = n.shallowClone();
    return t.trackingIds.add(this.rootContext.nextTrackingId()),
    t
}
Wt.track = RD;
function PD(n, t) {
    if (n ?? (n = this.currentScale),
    !Array.isArray(n))
        throw new Error("Only arrays can be sorted.");
    t === void 0 ? n.sort(K2.bind(this)) : n.sort( (e, r) => t.bind(this)(e, r).value.valueOf())
}
Wt.sortInPlace = PD;
function Ec(n, t=2) {
    if (n === null)
        return "";
    if (n === void 0)
        return "niente";
    if (n instanceof En.Interval)
        return n.toString(this.rootContext);
    if (Array.isArray(n)) {
        if (t < 0)
            return "[Array]";
        const e = Ec.bind(this);
        return "[" + n.map(r => e(r, t - 1)).join(", ") + "]"
    }
    if (typeof n == "function")
        return n.__node__.text;
    if (typeof n == "string")
        return JSON.stringify(n);
    if (n instanceof En.Color || n instanceof En.Val || n instanceof En.ValBasis || n instanceof En.Temperament)
        return n.toString();
    if (typeof n == "object") {
        const e = Ec.bind(this);
        return "#{" + Object.entries(n).map( ([r,i]) => `${e(r)}: ${e(i)}`).join(", ") + "}"
    }
    return `${n}`
}
function DD(n) {
    return Ec.bind(this)(n)
}
Wt.repr = DD;
function qD(n) {
    return n instanceof En.Interval ? n.str(this.rootContext) : Ec.bind(this)(n)
}
Wt.str = qD;
function BD(n, t) {
    if (n instanceof En.Interval) {
        let e = n.str(this.rootContext);
        if (e.length <= t)
            return e;
        if (n.steps)
            return n.simpleStr();
        const r = n.value;
        if (e = r.toString(n.domain),
        e.length <= t)
            return e;
        if (r instanceof xo.TimeReal) {
            if (isNaN(r.value) || !isFinite(r.value))
                return e;
            if (n.domain === "linear") {
                let h = "r";
                r.timeExponent === -1 ? h = h + "Hz" : r.timeExponent === 1 ? h = h + "s" : r.timeExponent && (h = h + "s^*");
                for (let p = t - 1; p >= 2; --p)
                    if (e = r.value.toPrecision(p) + h,
                    e.length <= t)
                        return e;
                return r.value.toPrecision(1) + h
            }
            if (r.timeExponent || r.value <= 0)
                return n.simpleStr();
            const l = r.totalCents()
              , f = "r";
            for (let h = t - 2; h >= 2; --h)
                if (e = l.toPrecision(h) + f,
                e.length <= t)
                    return e;
            return l.toPrecision(1) + f
        }
        const i = r.valueOf();
        if (n.domain === "linear") {
            if (!r.timeExponent.n) {
                for (let h = t - 1; h >= 2; --h)
                    if (e = i.toPrecision(h),
                    e.includes("e") || (e += "e"),
                    e.length <= t)
                        return e;
                return e = i.toPrecision(1),
                e.includes("e") || (e += "e"),
                e
            }
            let l = "s^*";
            const f = r.timeExponent.valueOf();
            f === 1 ? l = "s" : f === -1 && (l = "Hz");
            for (let h = t - 1; h >= 2; --h)
                if (e = i.toPrecision(h) + l,
                e.length <= t)
                    return e;
            return i.toPrecision(1) + l
        }
        if (r.timeExponent.n || r.residual.s !== 1)
            return n.simpleStr();
        const a = r.totalCents();
        if (e = a.toString(),
        (e.includes("e") || !e.includes(".")) && (e += ""),
        e.length <= t)
            return e;
        for (let l = t - 1; l >= 2; --l)
            if (e = a.toPrecision(l),
            (e.includes("e") || !e.includes(".")) && (e += ""),
            e.length <= t)
                return e;
        return e = a.toPrecision(1),
        (e.includes("e") || !e.includes(".")) && (e += ""),
        e
    }
    return Ec.bind(this)(n)
}
Wt.lstr = BD;
function kD(n) {
    const t = ou.bind(this)(n).totalCents() / 1200
      , e = t * 360
      , r = Math.tanh(1 - t * .5) * 50 + 50
      , i = Math.tanh(t * .2) * 50 + 50;
    return new En.Color(`hsl(${e.toFixed(3)}deg ${r.toFixed(3)}% ${i.toFixed(3)}%)`)
}
Wt.centsColor = kD;
const $v = [[[0, 0, 0], [0, 0, 0]], [[60, 60, 60], [-60, -60, -60]], [[255, 255, 0], [0, 255, 0]], [[0, 0, 255], [255, 0, 0]], [[180, 190, 250], [250, 180, 190]], [[255, -100, 255], [-100, 255, 255]]];
function Mv(n) {
    return (127.5 * Math.tanh(n / 300 - .75) + 127.5).toFixed(3)
}
function zD(n) {
    n = ou.bind(this)(n);
    let t = 0
      , e = 0
      , r = 0;
    if (n.value instanceof xo.TimeMonzo) {
        const i = n.value.primeExponents.map(a => a.valueOf());
        for (let a = 0; a < Math.min(i.length, $v.length); ++a) {
            const l = i[a] > 0 ? $v[a][0] : $v[a][1]
              , f = Math.abs(i[a]);
            t += l[0] * f,
            e += l[1] * f,
            r += l[2] * f
        }
    }
    return new En.Color(`rgb(${Mv(t)} ${Mv(e)} ${Mv(r)})`)
}
Wt.factorColor = zD;
function VD(n, t) {
    const e = n.divisions;
    let r;
    if (e.n)
        try {
            const h = n.equave.toFraction();
            let p = null
              , m = null;
            h.compare(W1.TWO) && (p = h.n,
            h.d !== 1 && (m = h.d)),
            r = new En.Interval(xo.TimeMonzo.fromFraction(h).pow(e.inverse()),"logarithmic",0,{
                type: "NedjiLiteral",
                numerator: e.d,
                denominator: e.n,
                equaveNumerator: p,
                equaveDenominator: m
            })
        } catch {
            r = new En.Interval(n.equave.pow(e.inverse()),"logarithmic")
        }
    else
        r = new En.Interval(n.equave.pow(0),"logarithmic");
    const i = ou.bind(this);
    if (Array.isArray(t))
        return t.map(h => {
            h = i(h);
            const p = h.value.tail(n.value.numberOfComponents)
              , m = h.dot(n);
            if (!e.n && m.valueOf())
                throw new Error("Non-unitary tempering by zero divisions of an equave.");
            const g = m.mul(r);
            return p.totalCents(!0) ? new En.Interval(p,"logarithmic").add(g) : g
        }
        );
    t = i(t);
    const a = t.value.tail(n.value.numberOfComponents)
      , l = t.dot(n);
    if (!e.n && l.valueOf())
        throw new Error("Non-unitary tempering by zero divisions of an equave.");
    const f = l.mul(r);
    return a.totalCents(!0) ? new En.Interval(a,"logarithmic").add(f) : f
}
Wt.temper = VD;
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(r, i, a, l) {
        l === void 0 && (l = a);
        var f = Object.getOwnPropertyDescriptor(i, a);
        (!f || ("get"in f ? !i.__esModule : f.writable || f.configurable)) && (f = {
            enumerable: !0,
            get: function() {
                return i[a]
            }
        }),
        Object.defineProperty(r, l, f)
    }
    : function(r, i, a, l) {
        l === void 0 && (l = a),
        r[l] = i[a]
    }
    )
      , e = Zt && Zt.__exportStar || function(r, i) {
        for (var a in r)
            a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, r, a)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    e(In, n),
    e(Wt, n)
}
)(Df);
var K1 = {}
  , ss = {};
const UD = /\p{Zs}/u
  , jD = /\p{ID_Start}/u
  , HD = /\p{ID_Continue}/u;
function GD(n, t) {
    function e() {
        this.constructor = n
    }
    e.prototype = t.prototype,
    n.prototype = new e
}
function Po(n, t, e, r) {
    var i = Error.call(this, n);
    return Object.setPrototypeOf && Object.setPrototypeOf(i, Po.prototype),
    i.expected = t,
    i.found = e,
    i.location = r,
    i.name = "SyntaxError",
    i
}
GD(Po, Error);
function Ov(n, t, e) {
    return e = e || " ",
    n.length > t ? n : (t -= n.length,
    e += e.repeat(t),
    n + e.slice(0, t))
}
Po.prototype.format = function(n) {
    var t = "Error: " + this.message;
    if (this.location) {
        var e = null, r;
        for (r = 0; r < n.length; r++)
            if (n[r].source === this.location.source) {
                e = n[r].text.split(/\r\n|\n|\r/g);
                break
            }
        var i = this.location.start
          , a = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i
          , l = this.location.source + ":" + a.line + ":" + a.column;
        if (e) {
            var f = this.location.end
              , h = Ov("", a.line.toString().length, " ")
              , p = e[i.line - 1]
              , m = i.line === f.line ? f.column : p.length + 1
              , g = m - i.column || 1;
            t += `
 --> ` + l + `
` + h + ` |
` + a.line + " | " + p + `
` + h + " | " + Ov("", i.column - 1, " ") + Ov("", g, "^")
        } else
            t += `
 at ` + l
    }
    return t
}
;
Po.buildMessage = function(n, t) {
    var e = {
        literal: function(p) {
            return '"' + i(p.text) + '"'
        },
        class: function(p) {
            var m = p.parts.map(function(g) {
                return Array.isArray(g) ? a(g[0]) + "-" + a(g[1]) : a(g)
            });
            return "[" + (p.inverted ? "^" : "") + m.join("") + "]"
        },
        any: function() {
            return "any character"
        },
        end: function() {
            return "end of input"
        },
        other: function(p) {
            return p.description
        }
    };
    function r(p) {
        return p.charCodeAt(0).toString(16).toUpperCase()
    }
    function i(p) {
        return p.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function a(p) {
        return p.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function l(p) {
        return e[p.type](p)
    }
    function f(p) {
        var m = p.map(l), g, b;
        if (m.sort(),
        m.length > 0) {
            for (g = 1,
            b = 1; g < m.length; g++)
                m[g - 1] !== m[g] && (m[b] = m[g],
                b++);
            m.length = b
        }
        switch (m.length) {
        case 1:
            return m[0];
        case 2:
            return m[0] + " or " + m[1];
        default:
            return m.slice(0, -1).join(", ") + ", or " + m[m.length - 1]
        }
    }
    function h(p) {
        return p ? '"' + i(p) + '"' : "end of input"
    }
    return "Expected " + f(n) + " but " + h(t) + " found."
}
;
function WD(n, t) {
    t = t !== void 0 ? t : {};
    var e = {}, r = t.grammarSource, i = {
        Start: Ba
    }, a = Ba, l = "[", f = "@", h = "]", p = "(", m = ")", g = "0", b = "e", E = ".", S = `
`, F = "\r", B = `\r
`, Q = "(*", ae = "*)", V = "/", k = ",", z = "", Z = "deg", re = "Hz", C = "hz", D = "rc", R = "s", W = "r", I = "inf", N = "1", P = /^[|&:;,]/, J = /^[<|&:;,]/, X = /^[>\u27E9]/, ie = /^[<\u27E8]/, ce = /^[_0-9]/, Le = /^[0-9]/, he = /^[1-9]/, Fe = /^[+\-]/, Te = /^[\u2028-\u2029]/, ye = /^[$_]/, qe = /^[$\u200C-\u200D]/, Ge = /^[\t\v-\f \xA0\uFEFF]/, Se = /^[\0-\uD7FF\uE000-\uFFFF]/, L = /^[\uD800-\uDBFF]/, K = /^[\uDC00-\uDFFF]/, de = /^[\uD800-\uDFFF]/, $e = fn(["|", "&", ":", ";", ","], !1, !1), Re = fn(["<", "|", "&", ":", ";", ","], !1, !1), me = an("[", !1), T = fn([">", ""], !1, !1), j = an("@", !1), ge = fn(["<", ""], !1, !1), Me = an("]", !1), Oe = an("(", !1), Be = an(")", !1), ze = fn(["_", ["0", "9"]], !1, !1), Ye = fn([["0", "9"]], !1, !1), He = fn([["1", "9"]], !1, !1), Ue = an("0", !1), at = fn(["+", "-"], !1, !1), rt = an("e", !0), _e = an(".", !1), xe = fn([["\u2028", "\u2029"]], !1, !1), Ze = fn(["$", "_"], !1, !1), st = fn(["$", ["", ""]], !1, !1), je = Es("whitespace"), ct = lo(), Et = fn(["	", ["\v", "\f"], " ", "", "\uFEFF"], !1, !1), It = Es("line terminator"), Bt = an(`
`, !1), yn = an("\r", !1), qt = an(`\r
`, !1), Nt = Es("any character"), xt = fn([["\0", ""], ["", ""]], !1, !1), Lt = fn([["\uD800", "\uDBFF"]], !1, !1), pe = fn([["\uDC00", "\uDFFF"]], !1, !1), Pe = fn([["\uD800", "\uDFFF"]], !1, !1), Xe = an("(*", !1), ft = an("*)", !1), Ht = an("/", !1), Yt = an(",", !1), $r = an("", !1), Ds = an("deg", !1), xi = an("Hz", !1), vs = an("hz", !1), ys = an("rc", !1), as = an("s", !1), ri = an("r", !1), Ii = an("inf", !1), qs = an("1", !1), Fi = function(O, U, ee) {
        return _n()
    }, Jo = function(O, U, ee) {
        return _n()
    }, Ri = function() {
        return _n()
    }, Ko = function() {
        return _n()
    }, ro = function() {
        return _n()
    }, Zo = function() {
        return _n()
    }, Mr = function(O) {
        return O.endsWith("_") && ws("Numeric separators are not allowed at the end of numeric literals."),
        O.replace(/_/g, "")
    }, bs = function(O) {
        return O
    }, so = function(O) {
        return parseInt(O, 10)
    }, Bs = function(O) {
        return parseInt(O, 10)
    }, io = function(O) {
        return UD.test(O)
    }, oo = function(O) {
        return jD.test(O)
    }, ks = function(O) {
        return HD.test(O)
    }, Pi = function(O, U, ee, oe) {
        return {
            sign: O,
            left: U,
            separator: ee,
            right: oe,
            exponent: null
        }
    }, ls = function(O, U, ee, oe, ve) {
        return {
            sign: O,
            left: U,
            separator: ee,
            right: oe,
            exponent: ve
        }
    }, ao = function(O, U, ee) {
        return {
            sign: O,
            left: U,
            separator: "",
            right: "",
            exponent: ee
        }
    }, ts = function(O, U, ee) {
        return {
            radical: !!O,
            numerator: U,
            denominator: ee
        }
    }, x = t.peg$currPos | 0, De = x, zt = [{
        line: 1,
        column: 1
    }], kt = x, Zn = t.peg$maxFailExpected || [], be = t.peg$silentFails | 0, jn;
    if (t.startRule) {
        if (!(t.startRule in i))
            throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
        a = i[t.startRule]
    }
    function _n() {
        return n.substring(De, x)
    }
    function ws(O, U) {
        throw U = U !== void 0 ? U : ii(De, x),
        uo(O, U)
    }
    function an(O, U) {
        return {
            type: "literal",
            text: O,
            ignoreCase: U
        }
    }
    function fn(O, U, ee) {
        return {
            type: "class",
            parts: O,
            inverted: U,
            ignoreCase: ee
        }
    }
    function lo() {
        return {
            type: "any"
        }
    }
    function si() {
        return {
            type: "end"
        }
    }
    function Es(O) {
        return {
            type: "other",
            description: O
        }
    }
    function Di(O) {
        var U = zt[O], ee;
        if (U)
            return U;
        if (O >= zt.length)
            ee = zt.length - 1;
        else
            for (ee = O; !zt[--ee]; )
                ;
        for (U = zt[ee],
        U = {
            line: U.line,
            column: U.column
        }; ee < O; )
            n.charCodeAt(ee) === 10 ? (U.line++,
            U.column = 1) : U.column++,
            ee++;
        return zt[O] = U,
        U
    }
    function ii(O, U, ee) {
        var oe = Di(O)
          , ve = Di(U)
          , Ne = {
            source: r,
            start: {
                offset: O,
                line: oe.line,
                column: oe.column
            },
            end: {
                offset: U,
                line: ve.line,
                column: ve.column
            }
        };
        return ee && r && typeof r.offset == "function" && (Ne.start = r.offset(Ne.start),
        Ne.end = r.offset(Ne.end)),
        Ne
    }
    function it(O) {
        x < kt || (x > kt && (kt = x,
        Zn = []),
        Zn.push(O))
    }
    function uo(O, U) {
        return new Po(O,null,null,U)
    }
    function cu(O, U, ee) {
        return new Po(Po.buildMessage(O, U),O,U,ee)
    }
    function Ba() {
        var O, U, ee, oe;
        for (O = x,
        kr(),
        U = [],
        ee = en(),
        ee === e && (ee = _s(),
        ee === e && (ee = Or(),
        ee === e && (ee = oi(),
        ee === e && (ee = we(),
        ee === e && (ee = Ls()))))); ee !== e; )
            U.push(ee),
            ee = x,
            oe = ka(),
            oe = en(),
            oe === e && (oe = _s(),
            oe === e && (oe = Or(),
            oe === e && (oe = oi(),
            oe === e && (oe = we(),
            oe === e && (oe = Ls()))))),
            oe === e ? (x = ee,
            ee = e) : ee = oe;
        return ee = kr(),
        oe = Qo(),
        oe !== e ? O = U : (x = O,
        O = e),
        O
    }
    function ka() {
        var O, U, ee, oe;
        return O = x,
        U = kr(),
        ee = n.charAt(x),
        P.test(ee) ? x++ : (ee = e,
        be === 0 && it($e)),
        ee === e && (ee = null),
        oe = kr(),
        U = [U, ee, oe],
        O = U,
        O
    }
    function $() {
        var O, U, ee, oe, ve, Ne;
        for (O = [],
        U = x,
        ee = x,
        be++,
        oe = Er(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? (oe = x,
        be++,
        ve = n.charAt(x),
        J.test(ve) ? x++ : (ve = e,
        be === 0 && it(Re)),
        be--,
        ve === e ? oe = void 0 : (x = oe,
        oe = e),
        oe !== e ? (ve = x,
        be++,
        n.charCodeAt(x) === 91 ? (Ne = l,
        x++) : (Ne = e,
        be === 0 && it(me)),
        be--,
        Ne === e ? ve = void 0 : (x = ve,
        ve = e),
        ve !== e ? (Ne = rr(),
        Ne !== e ? (ee = [ee, oe, ve, Ne],
        U = ee) : (x = U,
        U = e)) : (x = U,
        U = e)) : (x = U,
        U = e)) : (x = U,
        U = e); U !== e; )
            O.push(U),
            U = x,
            ee = x,
            be++,
            oe = Er(),
            be--,
            oe === e ? ee = void 0 : (x = ee,
            ee = e),
            ee !== e ? (oe = x,
            be++,
            ve = n.charAt(x),
            J.test(ve) ? x++ : (ve = e,
            be === 0 && it(Re)),
            be--,
            ve === e ? oe = void 0 : (x = oe,
            oe = e),
            oe !== e ? (ve = x,
            be++,
            n.charCodeAt(x) === 91 ? (Ne = l,
            x++) : (Ne = e,
            be === 0 && it(me)),
            be--,
            Ne === e ? ve = void 0 : (x = ve,
            ve = e),
            ve !== e ? (Ne = rr(),
            Ne !== e ? (ee = [ee, oe, ve, Ne],
            U = ee) : (x = U,
            U = e)) : (x = U,
            U = e)) : (x = U,
            U = e)) : (x = U,
            U = e);
        return O
    }
    function en() {
        var O, U, ee, oe, ve, Ne;
        return O = x,
        $(),
        n.charCodeAt(x) === 91 ? (U = l,
        x++) : (U = e,
        be === 0 && it(me)),
        U !== e ? (kr(),
        Bi(),
        kr(),
        ee = n.charAt(x),
        X.test(ee) ? x++ : (ee = e,
        be === 0 && it(T)),
        ee !== e ? (oe = x,
        n.charCodeAt(x) === 64 ? (ve = f,
        x++) : (ve = e,
        be === 0 && it(j)),
        ve !== e ? (Ne = Za(),
        oe = Ne) : (x = oe,
        oe = e),
        oe === e && (oe = null),
        De = O,
        O = Fi()) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function _s() {
        var O, U, ee, oe, ve, Ne;
        return O = x,
        $(),
        U = n.charAt(x),
        ie.test(U) ? x++ : (U = e,
        be === 0 && it(ge)),
        U !== e ? (kr(),
        Bi(),
        kr(),
        n.charCodeAt(x) === 93 ? (ee = h,
        x++) : (ee = e,
        be === 0 && it(Me)),
        ee !== e ? (oe = x,
        n.charCodeAt(x) === 64 ? (ve = f,
        x++) : (ve = e,
        be === 0 && it(j)),
        ve !== e ? (Ne = ra(),
        oe = Ne) : (x = oe,
        oe = e),
        oe === e && (oe = null),
        De = O,
        O = Jo()) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function Or() {
        var O, U, ee, oe, ve, Ne, Tn;
        if (O = x,
        U = Yo(),
        U !== e)
            if (n.charCodeAt(x) === 40 ? (ee = p,
            x++) : (ee = e,
            be === 0 && it(Oe)),
            ee !== e) {
                for (oe = [],
                ve = x,
                Ne = x,
                be++,
                n.charCodeAt(x) === 41 ? (Tn = m,
                x++) : (Tn = e,
                be === 0 && it(Be)),
                be--,
                Tn === e ? Ne = void 0 : (x = Ne,
                Ne = e),
                Ne !== e ? (Tn = rr(),
                Tn !== e ? (Ne = [Ne, Tn],
                ve = Ne) : (x = ve,
                ve = e)) : (x = ve,
                ve = e); ve !== e; )
                    oe.push(ve),
                    ve = x,
                    Ne = x,
                    be++,
                    n.charCodeAt(x) === 41 ? (Tn = m,
                    x++) : (Tn = e,
                    be === 0 && it(Be)),
                    be--,
                    Tn === e ? Ne = void 0 : (x = Ne,
                    Ne = e),
                    Ne !== e ? (Tn = rr(),
                    Tn !== e ? (Ne = [Ne, Tn],
                    ve = Ne) : (x = ve,
                    ve = e)) : (x = ve,
                    ve = e);
                n.charCodeAt(x) === 41 ? (ve = m,
                x++) : (ve = e,
                be === 0 && it(Be)),
                ve !== e ? (De = O,
                O = Ri()) : (x = O,
                O = e)
            } else
                x = O,
                O = e;
        else
            x = O,
            O = e;
        return O
    }
    function oi() {
        var O, U, ee, oe, ve, Ne;
        if (O = x,
        n.charCodeAt(x) === 40 ? (U = p,
        x++) : (U = e,
        be === 0 && it(Oe)),
        U !== e) {
            for (ee = [],
            oe = x,
            ve = x,
            be++,
            n.charCodeAt(x) === 41 ? (Ne = m,
            x++) : (Ne = e,
            be === 0 && it(Be)),
            be--,
            Ne === e ? ve = void 0 : (x = ve,
            ve = e),
            ve !== e ? (Ne = rr(),
            Ne !== e ? (ve = [ve, Ne],
            oe = ve) : (x = oe,
            oe = e)) : (x = oe,
            oe = e); oe !== e; )
                ee.push(oe),
                oe = x,
                ve = x,
                be++,
                n.charCodeAt(x) === 41 ? (Ne = m,
                x++) : (Ne = e,
                be === 0 && it(Be)),
                be--,
                Ne === e ? ve = void 0 : (x = ve,
                ve = e),
                ve !== e ? (Ne = rr(),
                Ne !== e ? (ve = [ve, Ne],
                oe = ve) : (x = oe,
                oe = e)) : (x = oe,
                oe = e);
            n.charCodeAt(x) === 41 ? (oe = m,
            x++) : (oe = e,
            be === 0 && it(Be)),
            oe !== e ? (De = O,
            O = Ko()) : (x = O,
            O = e)
        } else
            x = O,
            O = e;
        return O
    }
    function we() {
        var O, U, ee, oe, ve, Ne;
        if (O = x,
        n.charCodeAt(x) === 91 ? (U = l,
        x++) : (U = e,
        be === 0 && it(me)),
        U !== e) {
            for (ee = [],
            oe = x,
            ve = x,
            be++,
            n.charCodeAt(x) === 93 ? (Ne = h,
            x++) : (Ne = e,
            be === 0 && it(Me)),
            be--,
            Ne === e ? ve = void 0 : (x = ve,
            ve = e),
            ve !== e ? (Ne = rr(),
            Ne !== e ? (ve = [ve, Ne],
            oe = ve) : (x = oe,
            oe = e)) : (x = oe,
            oe = e); oe !== e; )
                ee.push(oe),
                oe = x,
                ve = x,
                be++,
                n.charCodeAt(x) === 93 ? (Ne = h,
                x++) : (Ne = e,
                be === 0 && it(Me)),
                be--,
                Ne === e ? ve = void 0 : (x = ve,
                ve = e),
                ve !== e ? (Ne = rr(),
                Ne !== e ? (ve = [ve, Ne],
                oe = ve) : (x = oe,
                oe = e)) : (x = oe,
                oe = e);
            n.charCodeAt(x) === 93 ? (oe = h,
            x++) : (oe = e,
            be === 0 && it(Me)),
            oe !== e ? (De = O,
            O = ro()) : (x = O,
            O = e)
        } else
            x = O,
            O = e;
        return O
    }
    function Ls() {
        var O, U, ee, oe, ve, Ne;
        if (O = x,
        U = [],
        ee = x,
        oe = x,
        be++,
        ve = Er(),
        be--,
        ve === e ? oe = void 0 : (x = oe,
        oe = e),
        oe !== e ? (ve = x,
        be++,
        Ne = n.charAt(x),
        P.test(Ne) ? x++ : (Ne = e,
        be === 0 && it($e)),
        be--,
        Ne === e ? ve = void 0 : (x = ve,
        ve = e),
        ve !== e ? (Ne = rr(),
        Ne !== e ? (oe = [oe, ve, Ne],
        ee = oe) : (x = ee,
        ee = e)) : (x = ee,
        ee = e)) : (x = ee,
        ee = e),
        ee !== e)
            for (; ee !== e; )
                U.push(ee),
                ee = x,
                oe = x,
                be++,
                ve = Er(),
                be--,
                ve === e ? oe = void 0 : (x = oe,
                oe = e),
                oe !== e ? (ve = x,
                be++,
                Ne = n.charAt(x),
                P.test(Ne) ? x++ : (Ne = e,
                be === 0 && it($e)),
                be--,
                Ne === e ? ve = void 0 : (x = ve,
                ve = e),
                ve !== e ? (Ne = rr(),
                Ne !== e ? (oe = [oe, ve, Ne],
                ee = oe) : (x = ee,
                ee = e)) : (x = ee,
                ee = e)) : (x = ee,
                ee = e);
        else
            U = e;
        return U !== e && (De = O,
        U = Zo()),
        O = U,
        O
    }
    function fu() {
        var O, U, ee, oe;
        for (O = x,
        U = x,
        ee = [],
        oe = n.charAt(x),
        ce.test(oe) ? x++ : (oe = e,
        be === 0 && it(ze)); oe !== e; )
            ee.push(oe),
            oe = n.charAt(x),
            ce.test(oe) ? x++ : (oe = e,
            be === 0 && it(ze));
        return U = n.substring(U, x),
        De = O,
        U = Mr(U),
        O = U,
        O
    }
    function co() {
        var O, U;
        return O = x,
        U = n.charAt(x),
        Fe.test(U) ? x++ : (U = e,
        be === 0 && it(at)),
        U === e && (U = null),
        O = n.substring(O, x),
        O
    }
    function tn() {
        var O;
        return O = n.charAt(x),
        O.toLowerCase() === b ? x++ : (O = e,
        be === 0 && it(rt)),
        O
    }
    function qn() {
        var O, U, ee;
        return O = x,
        U = tn(),
        U !== e ? (ee = ai(),
        ee !== e ? (De = O,
        O = bs(ee)) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function qi() {
        var O, U, ee, oe, ve, Ne;
        if (O = x,
        U = x,
        n.charCodeAt(x) === 48 ? (ee = g,
        x++) : (ee = e,
        be === 0 && it(Ue)),
        ee === e)
            if (ee = x,
            oe = n.charAt(x),
            he.test(oe) ? x++ : (oe = e,
            be === 0 && it(He)),
            oe !== e) {
                for (ve = [],
                Ne = us(); Ne !== e; )
                    ve.push(Ne),
                    Ne = us();
                oe = [oe, ve],
                ee = oe
            } else
                x = ee,
                ee = e;
        return ee !== e ? U = n.substring(U, x) : U = ee,
        U !== e && (De = O,
        U = so(U)),
        O = U,
        O
    }
    function za() {
        var O, U, ee, oe, ve;
        if (O = x,
        U = x,
        ee = n.charAt(x),
        he.test(ee) ? x++ : (ee = e,
        be === 0 && it(He)),
        ee !== e) {
            for (oe = [],
            ve = us(); ve !== e; )
                oe.push(ve),
                ve = us();
            ee = [ee, oe],
            U = ee
        } else
            x = U,
            U = e;
        return U !== e ? O = n.substring(O, x) : O = U,
        O
    }
    function ai() {
        var O, U, ee, oe, ve, Ne, Tn, dn;
        if (O = x,
        U = x,
        ee = x,
        oe = n.charAt(x),
        Fe.test(oe) ? x++ : (oe = e,
        be === 0 && it(at)),
        oe === e && (oe = null),
        n.charCodeAt(x) === 48 ? (ve = g,
        x++) : (ve = e,
        be === 0 && it(Ue)),
        ve === e)
            if (ve = x,
            Ne = n.charAt(x),
            he.test(Ne) ? x++ : (Ne = e,
            be === 0 && it(He)),
            Ne !== e) {
                for (Tn = [],
                dn = us(); dn !== e; )
                    Tn.push(dn),
                    dn = us();
                Ne = [Ne, Tn],
                ve = Ne
            } else
                x = ve,
                ve = e;
        return ve !== e ? (oe = [oe, ve],
        ee = oe) : (x = ee,
        ee = e),
        ee !== e ? U = n.substring(U, x) : U = ee,
        U !== e && (De = O,
        U = Bs(U)),
        O = U,
        O
    }
    function Yo() {
        var O, U, ee, oe, ve;
        if (O = x,
        U = x,
        ee = tt(),
        ee !== e) {
            for (oe = [],
            ve = Ss(); ve !== e; )
                oe.push(ve),
                ve = Ss();
            ee = [ee, oe],
            U = ee
        } else
            x = U,
            U = e;
        return U !== e ? O = n.substring(O, x) : O = U,
        O
    }
    function us() {
        var O;
        return O = n.charAt(x),
        Le.test(O) ? x++ : (O = e,
        be === 0 && it(Ye)),
        O
    }
    function tt() {
        var O;
        return O = Ha(),
        O === e && (O = n.charAt(x),
        ye.test(O) ? x++ : (O = e,
        be === 0 && it(Ze))),
        O
    }
    function Ss() {
        var O;
        return O = Ga(),
        O === e && (O = n.charAt(x),
        qe.test(O) ? x++ : (O = e,
        be === 0 && it(st))),
        O
    }
    function kr() {
        var O, U;
        for (be++,
        O = [],
        U = Er(),
        U === e && (U = Xo(),
        U === e && (U = li())); U !== e; )
            O.push(U),
            U = Er(),
            U === e && (U = Xo(),
            U === e && (U = li()));
        return be--,
        U = e,
        be === 0 && it(je),
        O
    }
    function Qo() {
        var O, U;
        return O = x,
        be++,
        n.length > x ? (U = n.charAt(x),
        x++) : (U = e,
        be === 0 && it(ct)),
        be--,
        U === e ? O = void 0 : (x = O,
        O = e),
        O
    }
    function Er() {
        var O;
        return O = n.charAt(x),
        Ge.test(O) ? x++ : (O = e,
        be === 0 && it(Et)),
        O === e && (O = Va()),
        O
    }
    function Xo() {
        var O, U, ee, oe;
        return be++,
        n.charCodeAt(x) === 10 ? (O = S,
        x++) : (O = e,
        be === 0 && it(Bt)),
        O === e && (O = x,
        n.charCodeAt(x) === 13 ? (U = F,
        x++) : (U = e,
        be === 0 && it(yn)),
        U !== e ? (ee = x,
        be++,
        n.charCodeAt(x) === 10 ? (oe = S,
        x++) : (oe = e,
        be === 0 && it(Bt)),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? (U = [U, ee],
        O = U) : (x = O,
        O = e)) : (x = O,
        O = e),
        O === e && (O = n.charAt(x),
        Te.test(O) ? x++ : (O = e,
        be === 0 && it(xe)),
        O === e && (n.substr(x, 2) === B ? (O = B,
        x += 2) : (O = e,
        be === 0 && it(qt))))),
        be--,
        O === e && (U = e,
        be === 0 && it(It)),
        O
    }
    function Va() {
        var O, U, ee;
        return O = x,
        U = rr(),
        U !== e ? (De = x,
        ee = io(U),
        ee ? ee = void 0 : ee = e,
        ee !== e ? (U = [U, ee],
        O = U) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function rr() {
        var O;
        return be++,
        O = Ua(),
        O === e && (O = ja()),
        be--,
        O === e && be === 0 && it(Nt),
        O
    }
    function Ua() {
        var O;
        return O = n.charAt(x),
        Se.test(O) ? x++ : (O = e,
        be === 0 && it(xt)),
        O
    }
    function ja() {
        var O, U, ee, oe;
        return O = x,
        U = x,
        ee = n.charAt(x),
        L.test(ee) ? x++ : (ee = e,
        be === 0 && it(Lt)),
        ee !== e ? (oe = n.charAt(x),
        K.test(oe) ? x++ : (oe = e,
        be === 0 && it(pe)),
        oe !== e ? (ee = [ee, oe],
        U = ee) : (x = U,
        U = e)) : (x = U,
        U = e),
        U !== e ? O = n.substring(O, x) : O = U,
        O === e && (O = n.charAt(x),
        de.test(O) ? x++ : (O = e,
        be === 0 && it(Pe))),
        O
    }
    function Ha() {
        var O, U, ee;
        return O = x,
        U = rr(),
        U !== e ? (De = x,
        ee = oo(U),
        ee ? ee = void 0 : ee = e,
        ee !== e ? (U = [U, ee],
        O = U) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function Ga() {
        var O, U, ee;
        return O = x,
        U = rr(),
        U !== e ? (De = x,
        ee = ks(U),
        ee ? ee = void 0 : ee = e,
        ee !== e ? (U = [U, ee],
        O = U) : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function li() {
        var O, U, ee, oe, ve, Ne;
        if (O = x,
        n.substr(x, 2) === Q ? (U = Q,
        x += 2) : (U = e,
        be === 0 && it(Xe)),
        U !== e) {
            for (ee = [],
            oe = x,
            ve = x,
            be++,
            n.substr(x, 2) === Q ? (Ne = Q,
            x += 2) : (Ne = e,
            be === 0 && it(Xe)),
            Ne === e && (n.substr(x, 2) === ae ? (Ne = ae,
            x += 2) : (Ne = e,
            be === 0 && it(ft))),
            be--,
            Ne === e ? ve = void 0 : (x = ve,
            ve = e),
            ve !== e ? (Ne = rr(),
            Ne !== e ? (ve = [ve, Ne],
            oe = ve) : (x = oe,
            oe = e)) : (x = oe,
            oe = e),
            oe === e && (oe = li()); oe !== e; )
                ee.push(oe),
                oe = x,
                ve = x,
                be++,
                n.substr(x, 2) === Q ? (Ne = Q,
                x += 2) : (Ne = e,
                be === 0 && it(Xe)),
                Ne === e && (n.substr(x, 2) === ae ? (Ne = ae,
                x += 2) : (Ne = e,
                be === 0 && it(ft))),
                be--,
                Ne === e ? ve = void 0 : (x = ve,
                ve = e),
                ve !== e ? (Ne = rr(),
                Ne !== e ? (ve = [ve, Ne],
                oe = ve) : (x = oe,
                oe = e)) : (x = oe,
                oe = e),
                oe === e && (oe = li());
            n.substr(x, 2) === ae ? (oe = ae,
            x += 2) : (oe = e,
            be === 0 && it(ft)),
            oe !== e ? (U = [U, ee, oe],
            O = U) : (x = O,
            O = e)
        } else
            x = O,
            O = e;
        return O
    }
    function ea() {
        var O, U, ee, oe, ve, Ne;
        return O = x,
        U = co(),
        ee = qi(),
        ee !== e ? (n.charCodeAt(x) === 47 ? (oe = V,
        x++) : (oe = e,
        be === 0 && it(Ht)),
        oe !== e ? (ve = za(),
        ve !== e ? (De = O,
        O = Pi(U, ee, oe, ve)) : (x = O,
        O = e)) : (x = O,
        O = e)) : (x = O,
        O = e),
        O === e && (O = x,
        U = co(),
        ee = qi(),
        ee !== e ? (n.charCodeAt(x) === 46 ? (oe = E,
        x++) : (oe = e,
        be === 0 && it(_e)),
        oe !== e ? (ve = fu(),
        Ne = qn(),
        Ne === e && (Ne = null),
        De = O,
        O = ls(U, ee, oe, ve, Ne)) : (x = O,
        O = e)) : (x = O,
        O = e),
        O === e && (O = x,
        U = co(),
        ee = qi(),
        ee !== e ? (oe = qn(),
        oe === e && (oe = null),
        De = O,
        O = ao(U, ee, oe)) : (x = O,
        O = e))),
        O
    }
    function Bi() {
        var O, U, ee, oe, ve, Ne;
        for (O = [],
        U = ea(); U !== e; )
            O.push(U),
            U = x,
            ee = x,
            oe = kr(),
            n.charCodeAt(x) === 44 ? (ve = k,
            x++) : (ve = e,
            be === 0 && it(Yt)),
            ve === e && (ve = null),
            Ne = kr(),
            oe = [oe, ve, Ne],
            ee = oe,
            ee = ea(),
            ee === e ? (x = U,
            U = e) : U = ee;
        return O
    }
    function Wa() {
        var O, U, ee, oe, ve, Ne;
        return O = x,
        n.charCodeAt(x) === 8730 ? (U = z,
        x++) : (U = e,
        be === 0 && it($r)),
        U === e && (U = null),
        ee = ai(),
        ee !== e ? (oe = x,
        n.charCodeAt(x) === 47 ? (ve = V,
        x++) : (ve = e,
        be === 0 && it(Ht)),
        ve !== e ? (Ne = qi(),
        Ne !== e ? oe = Ne : (x = oe,
        oe = e)) : (x = oe,
        oe = e),
        oe === e && (oe = null),
        De = O,
        O = ts(U, ee, oe)) : (x = O,
        O = e),
        O
    }
    function ta() {
        var O, U, ee, oe;
        return O = x,
        n.substr(x, 3) === Z ? (U = Z,
        x += 3) : (U = e,
        be === 0 && it(Ds)),
        U !== e ? (ee = x,
        be++,
        oe = Ss(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? O = U : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function fo() {
        var O, U, ee, oe;
        return O = x,
        n.substr(x, 2) === re ? (U = re,
        x += 2) : (U = e,
        be === 0 && it(xi)),
        U !== e ? (ee = x,
        be++,
        oe = Ss(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? O = U : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function Ja() {
        var O, U, ee, oe;
        return O = x,
        n.substr(x, 2) === C ? (U = C,
        x += 2) : (U = e,
        be === 0 && it(vs)),
        U !== e ? (ee = x,
        be++,
        oe = Ss(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? O = U : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function Ka() {
        var O, U, ee, oe;
        return O = x,
        n.substr(x, 2) === D ? (U = D,
        x += 2) : (U = e,
        be === 0 && it(ys)),
        U !== e ? (ee = x,
        be++,
        oe = Ss(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? O = U : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function na() {
        var O, U, ee, oe;
        return O = x,
        n.charCodeAt(x) === 115 ? (U = R,
        x++) : (U = e,
        be === 0 && it(as)),
        U !== e ? (ee = x,
        be++,
        oe = Ss(),
        be--,
        oe === e ? ee = void 0 : (x = ee,
        ee = e),
        ee !== e ? O = U : (x = O,
        O = e)) : (x = O,
        O = e),
        O
    }
    function ki() {
        var O;
        return O = Wa(),
        O === e && (O = na(),
        O === e && (O = fo(),
        O === e && (O = Ja()))),
        O
    }
    function ho() {
        var O;
        return O = ki(),
        O === e && (O = Ka(),
        O === e && (n.substr(x, 2) === W ? (O = W,
        x += 2) : (O = e,
        be === 0 && it(ri)),
        O === e && (n.substr(x, 3) === I ? (O = I,
        x += 3) : (O = e,
        be === 0 && it(Ii)),
        O === e && (n.substr(x, 2) === N ? (O = N,
        x += 2) : (O = e,
        be === 0 && it(qs)),
        O === e && (O = ta()))))),
        O
    }
    function ra() {
        var O, U, ee;
        for (O = [],
        U = ki(),
        U === e && (U = ""); U !== e; )
            O.push(U),
            U = x,
            n.charCodeAt(x) === 46 ? (ee = E,
            x++) : (ee = e,
            be === 0 && it(_e)),
            ee !== e ? (ee = ki(),
            ee === e && (ee = ""),
            ee === e ? (x = U,
            U = e) : U = ee) : U = ee;
        return O
    }
    function Za() {
        var O, U, ee;
        for (O = [],
        U = ho(),
        U === e && (U = ""); U !== e; )
            O.push(U),
            U = x,
            n.charCodeAt(x) === 46 ? (ee = E,
            x++) : (ee = e,
            be === 0 && it(_e)),
            ee !== e ? (ee = ho(),
            ee === e && (ee = ""),
            ee === e ? (x = U,
            U = e) : U = ee) : U = ee;
        return O
    }
    if (jn = a(),
    t.peg$library)
        return {
            peg$result: jn,
            peg$currPos: x,
            peg$FAILED: e,
            peg$maxFailExpected: Zn,
            peg$maxFailPos: kt
        };
    if (jn !== e && x === n.length)
        return jn;
    throw jn !== e && x < n.length && it(si()),
    cu(Zn, kt < n.length ? n.charAt(kt) : null, kt < n.length ? ii(kt, kt + 1) : ii(kt, kt))
}
var JD = {
    StartRules: ["Start"],
    SyntaxError: Po,
    parse: WD
}
  , Z1 = {};
const KD = /\p{Zs}/u
  , ZD = /\p{ID_Start}/u
  , YD = /\p{ID_Continue}/u
  , QD = {
    CallExpression: "callee",
    AccessExpression: "object",
    ArraySlice: "object"
}
  , XD = new Set(["abs", "al", "and", "as", "break", "by", "catch", "const", "continue", "defer", "del", "dot", "drop", "ed", "else", "export", "false", "finally", "fn", "for", "from", "if", "import", "in", "inf", "labs", "lest", "let", "lift", "max", "mdot", "min", "mod", "modc", "module", "MOS", "nan", "niente", "not", "of", "or", "pop$", "pop$$", "rd", "rdc", "return", "riff", "sof", "tmpr", "tns", "throw", "to", "try", "true", "vand", "vdot", "vnot", "vor", "where", "while", "case", "debugger", "default", "immutable", "is", "match", "yield"])
  , e9 = new Set([1, 4, 5, 1.5, 4.5, 7.5])
  , t9 = new Set([4, 5, 1.5, 7.5])
  , n9 = new Set([2, 3, 6, 7, 2.5, 3.5, 5.5, 6.5]);
function AE(n, t) {
    return {
        type: "UpdateExpression",
        operator: n,
        argument: t
    }
}
function yl(n, t, e) {
    return {
        type: "UnaryExpression",
        operator: n,
        operand: t,
        uniform: e
    }
}
function Xu(n, t, e, r, i) {
    return {
        type: "BinaryExpression",
        operator: n,
        left: t,
        right: e,
        preferLeft: r,
        preferRight: i
    }
}
function r9(n, t) {
    return [n].concat(t ?? [])
}
function ma(n, t) {
    const e = n
      , [r,i,a,l] = t;
    return Xu(i, e, l, !!r, !!a)
}
function qu(n, t) {
    const e = n
      , [r,i] = t;
    return Xu(r, e, i, !1, !1)
}
function CE(n, t) {
    let e = n;
    for (const r of t)
        r[QD[r.type]] = e,
        e = r;
    return e
}
function s9(n, t) {
    function e() {
        this.constructor = n
    }
    e.prototype = t.prototype,
    n.prototype = new e
}
function Do(n, t, e, r) {
    var i = Error.call(this, n);
    return Object.setPrototypeOf && Object.setPrototypeOf(i, Do.prototype),
    i.expected = t,
    i.found = e,
    i.location = r,
    i.name = "SyntaxError",
    i
}
s9(Do, Error);
function Nv(n, t, e) {
    return e = e || " ",
    n.length > t ? n : (t -= n.length,
    e += e.repeat(t),
    n + e.slice(0, t))
}
Do.prototype.format = function(n) {
    var t = "Error: " + this.message;
    if (this.location) {
        var e = null, r;
        for (r = 0; r < n.length; r++)
            if (n[r].source === this.location.source) {
                e = n[r].text.split(/\r\n|\n|\r/g);
                break
            }
        var i = this.location.start
          , a = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i
          , l = this.location.source + ":" + a.line + ":" + a.column;
        if (e) {
            var f = this.location.end
              , h = Nv("", a.line.toString().length, " ")
              , p = e[i.line - 1]
              , m = i.line === f.line ? f.column : p.length + 1
              , g = m - i.column || 1;
            t += `
 --> ` + l + `
` + h + ` |
` + a.line + " | " + p + `
` + h + " | " + Nv("", i.column - 1, " ") + Nv("", g, "^")
        } else
            t += `
 at ` + l
    }
    return t
}
;
Do.buildMessage = function(n, t) {
    var e = {
        literal: function(p) {
            return '"' + i(p.text) + '"'
        },
        class: function(p) {
            var m = p.parts.map(function(g) {
                return Array.isArray(g) ? a(g[0]) + "-" + a(g[1]) : a(g)
            });
            return "[" + (p.inverted ? "^" : "") + m.join("") + "]"
        },
        any: function() {
            return "any character"
        },
        end: function() {
            return "end of input"
        },
        other: function(p) {
            return p.description
        }
    };
    function r(p) {
        return p.charCodeAt(0).toString(16).toUpperCase()
    }
    function i(p) {
        return p.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function a(p) {
        return p.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function l(p) {
        return e[p.type](p)
    }
    function f(p) {
        var m = p.map(l), g, b;
        if (m.sort(),
        m.length > 0) {
            for (g = 1,
            b = 1; g < m.length; g++)
                m[g - 1] !== m[g] && (m[b] = m[g],
                b++);
            m.length = b
        }
        switch (m.length) {
        case 1:
            return m[0];
        case 2:
            return m[0] + " or " + m[1];
        default:
            return m.slice(0, -1).join(", ") + ", or " + m[m.length - 1]
        }
    }
    function h(p) {
        return p ? '"' + i(p) + '"' : "end of input"
    }
    return "Expected " + f(n) + " but " + h(t) + " found."
}
;
function i9(n, t) {
    t = t !== void 0 ? t : {};
    var e = {}, r = t.grammarSource, i = {
        Start: eb
    }, a = eb, l = "abs", f = "al", h = "and", p = "as", m = "break", g = "by", b = "catch", E = "const", S = "continue", F = "defer", B = "del", Q = "dot", ae = "drop", V = "ed", k = "else", z = "export", Z = "false", re = "finally", C = "for", D = "from", R = "if", W = "import", I = "in", N = "inf", P = "labs", J = "lest", X = "let", ie = "lift", ce = "max", Le = "mdot", he = "min", Fe = "mod", Te = "modc", ye = "module", qe = "nan", Ge = "niente", Se = "not", L = "of", K = "or", de = "pop$", $e = "pop$$", Re = "rd", me = "rdc", T = "return", j = "riff", ge = "fn", Me = "sof", Oe = "tmpr", Be = "tns", ze = "throw", Ye = "to", He = "try", Ue = "true", at = "vand", rt = "vdot", _e = "vnot", xe = "vor", Ze = "where", st = "while", je = "~", ct = "=", Et = "(", It = ")", Bt = "^", yn = "/", qt = ",", Nt = "...", xt = "[", Lt = "]", pe = "{", Pe = "}", Xe = "*", ft = ";", Ht = "al~", Yt = "==", $r = "<>", Ds = "~=", xi = "~<>", vs = "<=", ys = ">=", as = "<", ri = ">", Ii = "::", qs = ":", Fi = "/+", Jo = "", Ri = "/-", Ko = "", ro = "", Zo = "", Mr = "", bs = "--", so = "^/", Bs = "/_", io = "/^", oo = "-", ks = "+", Pi = "_", ls = "\\", ao = "++", ts = "..", x = "v", De = "", zt = "r", kt = "e", Zn = "z", be = ".", jn = "@", _n = "", ws = "", an = "", fn = "", lo = "", si = "rgb", Es = "a", Di = "%", ii = "hsl", it = "deg", uo = "dim", cu = "d", Ba = "m", ka = "neu", $ = "n", en = "maj", _s = "Maj", Or = "M", oi = "aug", we = "Aug", Ls = "P", fu = "", co = ".5", tn = "ms", qn = "", qi = "", za = "", ai = "", Yo = "", us = "", tt = "", Ss = "", kr = "", Qo = "", Er = "alp", Xo = "bet", Va = "gam", rr = "eps", Ua = "zet", ja = "eta", Ha = "the", Ga = "iot", li = "kap", ea = "lam", Bi = "muu", Wa = "nuu", ta = "xii", fo = "omi", Ja = "pii", Ka = "rho", na = "fsi", ki = "sig", ho = "tau", ra = "ups", Za = "phi", O = "chi", U = "psi", ee = "ome", oe = "S", ve = "=>", Ne = "", Tn = "#[", dn = "#{", Kf = "da", Ya = "i", Qa = '"', po = "'", Zf = "MOS", ui = "|", Yf = "L", du = "s", zi = "hardness", hu = "equave", mo = "0", A = "#", H = "b", ne = "f", ue = "t", We = "x", lt = "u", $n = `
`, Ln = "\r", Yn = `\r
`, pn = "(*", mn = "*)", sr = "c", zr = "Hz", yy = "hz", by = "rc", wy = "r", Ey = "1", fA = /^[<>]/, pu = /^[+\-]/, dA = /^[%*\\\xD7\xF7]/, hA = /^[%\-\xF7]/, pA = /^[\/\^\u2227-\u2228]/, _y = /^[\/\\\^v]/, mA = /^[>\u27E9]/, gA = /^[<\u27E8]/, Km = /^[a-z]/i, Ly = /^[+\^]/, Sy = /^[\-v]/, vA = /^[Qqs\xBC-\xBE\u2150-\u215E]/, yA = /^[a\xC2]/, bA = /^[cfhl-nqs-t]/, sa = /^[_v]/, wA = /^[x\u266F#\u2021t\u266E_d\u266Db&ea@]/, EA = /^[\u03B1-\u03C9A-Z]/, Qf = /^[J-Z]/, _A = /^[sqQ]/, Nr = /^[0-9]/, Xf = /^[sqQxdb_ae]/, LA = /^[QRYZEPTGMkhdcm\xB5npfazyrq]/, SA = /^[KMGTPEZYRQ]/, Ay = /^[Ls]/, ed = /^[_0-9]/, Xa = /^[1-9]/, AA = /^["\\]/, Zm = /^[\u2028-\u2029]/, CA = /^['\\]/, $A = /^["'\\]/, MA = /^[0-9ux]/, OA = /^[0-9a-f]/i, NA = /^[$_]/, TA = /^[$\u200C-\u200D]/, xA = /^[\t\v-\f \xA0\uFEFF]/, IA = /^[\n\r\u2028-\u2029]/, FA = /^[\0-\uD7FF\uE000-\uFFFF]/, RA = /^[\uD800-\uDBFF]/, PA = /^[\uDC00-\uDFFF]/, DA = /^[\uD800-\uDFFF]/, qA = fe("abs", !1), BA = fe("al", !1), kA = fe("and", !1), zA = fe("as", !1), VA = fe("break", !1), UA = fe("by", !1), jA = fe("catch", !1), HA = fe("const", !1), GA = fe("continue", !1), WA = fe("defer", !1), Cy = fe("del", !1), JA = fe("dot", !1), KA = fe("drop", !1), ZA = fe("ed", !1), YA = fe("else", !1), QA = fe("export", !1), XA = fe("false", !1), eC = fe("finally", !1), tC = fe("for", !1), nC = fe("from", !1), rC = fe("if", !1), sC = fe("import", !1), iC = fe("in", !1), $y = fe("inf", !1), oC = fe("labs", !1), aC = fe("lest", !1), lC = fe("let", !1), uC = fe("lift", !1), cC = fe("max", !1), fC = fe("mdot", !1), My = fe("min", !1), dC = fe("mod", !1), hC = fe("modc", !1), pC = fe("module", !1), mC = fe("nan", !1), gC = fe("niente", !1), vC = fe("not", !1), yC = fe("of", !1), bC = fe("or", !1), wC = fe("pop$", !1), EC = fe("pop$$", !1), _C = fe("rd", !1), LC = fe("rdc", !1), SC = fe("return", !1), AC = fe("riff", !1), CC = fe("fn", !1), $C = fe("sof", !1), MC = fe("tmpr", !1), OC = fe("tns", !1), NC = fe("throw", !1), TC = fe("to", !1), xC = fe("try", !1), IC = fe("true", !1), FC = fe("vand", !1), RC = fe("vdot", !1), PC = fe("vnot", !1), DC = fe("vor", !1), qC = fe("where", !1), BC = fe("while", !1), Gt = fe("~", !1), ns = fe("=", !1), Vr = fe("(", !1), Ur = fe(")", !1), td = fe("^", !1), As = fe("/", !1), Bn = fe(",", !1), el = fe("...", !1), ir = fe("[", !1), Qn = fe("]", !1), nd = fe("{", !1), ia = fe("}", !1), Oy = fe("*", !1), Ny = fe(";", !1), kC = fe("al~", !1), zC = jr("relational operator"), VC = fe("==", !1), UC = fe("<>", !1), jC = fe("~=", !1), HC = fe("~<>", !1), Ym = fe("<=", !1), Qm = fe(">=", !1), GC = Vt(["<", ">"], !1, !1), oa = fe("<", !1), rd = fe(">", !1), WC = fe("::", !1), Xm = fe(":", !1), JC = jr("additive operator"), mu = Vt(["+", "-"], !1, !1), KC = fe("/+", !1), ZC = fe("", !1), YC = fe("/-", !1), QC = fe("", !1), XC = jr("multiplicative operator"), e$ = Vt(["%", "*", "\\", "", ""], !1, !1), t$ = fe("", !1), n$ = fe("", !1), r$ = Vt(["%", "-", ""], !1, !1), Ty = fe("", !1), xy = fe("--", !1), s$ = jr("exponentiation"), i$ = fe("^/", !1), o$ = fe("/_", !1), a$ = fe("/^", !1), Iy = fe("-", !1), Fy = fe("+", !1), l$ = fe("_", !1), u$ = Vt(["/", "^", ["", ""]], !1, !1), tl = fe("\\", !1), c$ = fe("++", !1), sd = fe("..", !1), eg = fe("v", !1), f$ = fe("", !1), tg = fe("r", !1), Ry = fe("e", !0), d$ = fe("z", !1), go = fe(".", !1), h$ = jr("up-and-down"), Py = Vt(["/", "\\", "^", "v"], !1, !1), p$ = Vt([">", ""], !1, !1), gu = fe("@", !1), m$ = Vt(["<", ""], !1, !1), ng = Vt([["a", "z"]], !1, !0), Dy = Vt(["+", "^"], !1, !1), qy = Vt(["-", "v"], !1, !1), g$ = fe("", !1), v$ = fe("", !1), y$ = fe("", !1), b$ = fe("", !1), w$ = fe("", !1), E$ = fe("rgb", !1), By = fe("a", !1), aa = fe("%", !1), _$ = fe("hsl", !1), ky = fe("deg", !1), L$ = jr("vulgar fraction"), S$ = Vt(["Q", "q", "s", ["", ""], ["", ""]], !1, !1), A$ = fe("dim", !1), C$ = fe("d", !1), $$ = fe("m", !1), M$ = fe("neu", !1), zy = fe("n", !1), O$ = jr("major quality"), N$ = fe("maj", !1), T$ = fe("Maj", !1), x$ = fe("M", !1), I$ = jr("augmented quality"), F$ = fe("aug", !1), R$ = fe("Aug", !1), P$ = Vt(["a", ""], !1, !1), rg = fe("P", !1), D$ = fe("", !1), q$ = fe(".5", !1), sg = fe("ms", !1), B$ = Vt(["c", "f", "h", ["l", "n"], "q", ["s", "t"]], !1, !1), la = Vt(["_", "v"], !1, !1), k$ = fe("", !1), z$ = fe("", !1), V$ = fe("", !1), U$ = fe("", !1), j$ = fe("", !1), H$ = fe("", !1), G$ = fe("", !1), W$ = fe("", !1), J$ = fe("", !1), K$ = fe("", !1), Z$ = Vt(["x", "", "#", "", "t", "", "_", "d", "", "b", "&", "e", "a", "@"], !1, !1), Y$ = jr("accidental"), Q$ = jr("pitch nominal"), X$ = Vt([["", ""], ["A", "Z"]], !1, !1), e3 = fe("alp", !1), t3 = fe("bet", !1), n3 = fe("gam", !1), r3 = fe("eps", !1), s3 = fe("zet", !1), i3 = fe("eta", !1), o3 = fe("the", !1), a3 = fe("iot", !1), l3 = fe("kap", !1), u3 = fe("lam", !1), c3 = fe("muu", !1), f3 = fe("nuu", !1), d3 = fe("xii", !1), h3 = fe("omi", !1), p3 = fe("pii", !1), m3 = fe("rho", !1), g3 = fe("fsi", !1), v3 = fe("sig", !1), y3 = fe("tau", !1), b3 = fe("ups", !1), w3 = fe("phi", !1), E3 = fe("chi", !1), _3 = fe("psi", !1), L3 = fe("ome", !1), id = Vt([["J", "Z"]], !1, !1), S3 = fe("S", !1), Vy = fe("=>", !1), A3 = Vt(["s", "q", "Q"], !1, !1), Tr = Vt([["0", "9"]], !1, !1), od = Vt(["s", "q", "Q", "x", "d", "b", "_", "a", "e"], !1, !1), C3 = fe("", !1), $3 = fe("#[", !1), Uy = fe("#{", !1), M3 = Vt(["Q", "R", "Y", "Z", "E", "P", "T", "G", "M", "k", "h", "d", "c", "m", "", "n", "p", "f", "a", "z", "y", "r", "q"], !1, !1), O3 = fe("da", !1), N3 = Vt(["K", "M", "G", "T", "P", "E", "Z", "Y", "R", "Q"], !1, !1), T3 = fe("i", !1), jy = fe('"', !1), Hy = fe("'", !1), x3 = fe("MOS", !1), Gy = Vt(["L", "s"], !1, !1), I3 = fe("|", !1), Wy = fe("L", !1), ig = fe("s", !1), F3 = fe("hardness", !1), R3 = fe("equave", !1), ad = Vt(["_", ["0", "9"]], !1, !1), nl = Vt([["1", "9"]], !1, !1), vu = fe("0", !1), Jy = fe("#", !1), P3 = Vt(['"', "\\"], !1, !1), og = Vt([["\u2028", "\u2029"]], !1, !1), D3 = Vt(["'", "\\"], !1, !1), q3 = Vt(['"', "'", "\\"], !1, !1), B3 = fe("b", !1), k3 = fe("f", !1), z3 = fe("t", !1), V3 = Vt([["0", "9"], "u", "x"], !1, !1), U3 = fe("x", !1), j3 = fe("u", !1), H3 = Vt([["0", "9"], ["a", "f"]], !1, !0), G3 = Vt(["$", "_"], !1, !1), W3 = Vt(["$", ["", ""]], !1, !1), J3 = jr("whitespace"), K3 = jr("inline whitespace"), Z3 = ix(), Y3 = Vt(["	", ["\v", "\f"], " ", "", "\uFEFF"], !1, !1), Q3 = jr("line break"), X3 = Vt([`
`, "\r", ["\u2028", "\u2029"]], !1, !1), eM = jr("line terminator"), Ky = fe(`
`, !1), tM = fe("\r", !1), nM = fe(`\r
`, !1), rM = jr("any character"), sM = Vt([["\0", ""], ["", ""]], !1, !1), iM = Vt([["\uD800", "\uDBFF"]], !1, !1), oM = Vt([["\uDC00", "\uDFFF"]], !1, !1), aM = Vt([["\uD800", "\uDFFF"]], !1, !1), rl = fe("(*", !1), sl = fe("*)", !1), lM = fe("c", !1), uM = fe("Hz", !1), cM = fe("hz", !1), fM = fe("rc", !1), dM = fe("r", !1), hM = fe("1", !1), pM = function(s) {
        return s
    }, mM = function(s) {
        return {
            type: "Program",
            body: s ?? []
        }
    }, gM = function(s, u) {
        return r9(s, u)
    }, vM = function(s, u, c, d) {
        return {
            preferLeft: !!s,
            preferRight: !!c,
            operator: u,
            value: d
        }
    }, yM = function(s, u) {
        return {
            type: "AssignmentStatement",
            name: s,
            value: u
        }
    }, bM = function(s, u) {
        if (!u)
            return {
                type: "ExpressionStatement",
                expression: s
            };
        const {preferLeft: c, preferRight: d, operator: y, value: _} = u;
        if (s.type === "AccessExpression" || s.type === "ArraySlice" || s.type === "Identifier")
            return y ? {
                type: "AssignmentStatement",
                name: s,
                value: Xu(y, s, _, c, d)
            } : {
                type: "AssignmentStatement",
                name: s,
                value: _
            };
        if (y)
            throw new Error("Left-hand-side expression expected.");
        return c ? {
            type: "ExpressionStatement",
            expression: Xu("~=", s, _, !1, !1)
        } : {
            type: "PitchDeclaration",
            left: s,
            right: _
        }
    }, wM = function(s) {
        return {
            type: "VariableDeclaration",
            parameters: s,
            mutable: !0
        }
    }, EM = function(s) {
        return {
            type: "VariableDeclaration",
            parameters: s,
            mutable: !1
        }
    }, _M = function(s, u, c) {
        return {
            type: "FunctionDeclaration",
            name: s,
            parameters: u,
            body: c.body,
            text: ol()
        }
    }, LM = function(s, u, c) {
        return c ? {
            type: "PitchDeclaration",
            left: s,
            middle: u,
            right: c
        } : u ? {
            type: "PitchDeclaration",
            left: s,
            right: u
        } : s
    }, SM = function(s) {
        return {
            type: "UpDeclaration",
            value: s
        }
    }, AM = function(s) {
        return {
            type: "LiftDeclaration",
            value: s
        }
    }, CM = function(s) {
        return {
            type: "DeleteStatement",
            entry: s
        }
    }, $M = function(s, u) {
        return {
            ...s,
            type: "Parameter",
            defaultValue: u
        }
    }, MM = function(s, u) {
        return {
            type: "Parameters",
            parameters: s,
            rest: u,
            defaultValue: null
        }
    }, OM = function(s, u) {
        return {
            type: "Parameters",
            parameters: s,
            rest: u,
            defaultValue: null
        }
    }, NM = function(s) {
        return {
            type: "Parameters",
            parameters: [],
            rest: s,
            defaultValue: null
        }
    }, TM = function(s, u) {
        return {
            ...s,
            defaultValue: u
        }
    }, xM = function(s, u) {
        return {
            ...s,
            type: "Parameter",
            defaultValue: u
        }
    }, IM = function(s) {
        return {
            type: "Parameters",
            parameters: s,
            defaultValue: null
        }
    }, FM = function(s, u) {
        return {
            ...s,
            defaultValue: u
        }
    }, RM = function(s, u) {
        return {
            type: "Identifiers",
            identifiers: s,
            rest: u
        }
    }, PM = function(s, u) {
        return {
            type: "Argument",
            spread: !!s,
            expression: u
        }
    }, DM = function(s) {
        return {
            type: "BlockStatement",
            body: s ?? []
        }
    }, qM = function(s) {
        return {
            type: "ThrowStatement",
            argument: s
        }
    }, BM = function(s) {
        return {
            type: "ReturnStatement",
            argument: s
        }
    }, kM = function() {
        return {
            type: "ReturnStatement"
        }
    }, zM = function() {
        return {
            type: "BreakStatement"
        }
    }, VM = function() {
        return {
            type: "ContinueStatement"
        }
    }, UM = function(s, u, c) {
        return {
            type: "WhileStatement",
            test: s,
            body: u,
            tail: c
        }
    }, jM = function(s, u, c) {
        return {
            type: "IfStatement",
            test: s,
            consequent: u,
            alternate: c
        }
    }, HM = function(s, u) {
        return {
            type: "IfStatement",
            test: s,
            consequent: u
        }
    }, GM = function(s, u, c, d, y) {
        return {
            type: "IterationStatement",
            element: s,
            kind: u,
            container: c,
            body: d,
            tail: y,
            mutable: !0
        }
    }, WM = function(s, u, c, d, y) {
        return {
            type: "IterationStatement",
            element: s,
            kind: u,
            container: c,
            body: d,
            tail: y,
            mutable: !1
        }
    }, JM = function(s, u, c) {
        return {
            type: "TryStatement",
            body: s,
            handler: u,
            finalizer: c
        }
    }, KM = function(s, u) {
        return {
            type: "TryStatement",
            body: s,
            handler: u
        }
    }, ZM = function(s, u) {
        return {
            type: "TryStatement",
            body: s,
            finalizer: u
        }
    }, YM = function(s, u) {
        return {
            type: "CatchClause",
            parameter: s,
            body: u
        }
    }, QM = function(s) {
        return {
            type: "CatchClause",
            body: s
        }
    }, XM = function(s) {
        return {
            type: "DeferStatement",
            body: s
        }
    }, eO = function(s, u) {
        return {
            type: "ModuleDeclaration",
            name: s.id,
            body: u.body
        }
    }, tO = function(s) {
        return {
            type: "ExportConstantStatement",
            parameter: s
        }
    }, nO = function(s) {
        return {
            ...s,
            type: "ExportFunctionStatement"
        }
    }, rO = function(s) {
        return {
            type: "ExportAllStatement",
            module: s.id
        }
    }, sO = function(s, u) {
        return {
            type: "ImportElement",
            id: s.id,
            alias: u && u.id
        }
    }, iO = function(s, u) {
        return {
            type: "ImportStatement",
            elements: s,
            module: u.id
        }
    }, oO = function(s) {
        return {
            type: "ImportAllStatement",
            module: s.id
        }
    }, aO = function() {
        return {
            type: "EmptyStatement"
        }
    }, lO = function(s) {
        return {
            type: "ExpressionStatement",
            expression: s
        }
    }, uO = function(s) {
        return {
            type: "BlockExpression",
            body: s ?? []
        }
    }, cO = function(s, u) {
        return u.reduce(qu, s)
    }, fO = function(s, u) {
        if (!u.length)
            return s;
        const [c,d,y] = u.pop();
        let _ = {
            type: "ConditionalExpression",
            kind: c,
            test: d,
            alternate: y
        };
        for (; u.length; ) {
            const [M,Y,Je] = u.pop();
            _.consequent = Je,
            _ = {
                type: "ConditionalExpression",
                kind: M,
                test: Y,
                alternate: _
            }
        }
        return _.consequent = s,
        _
    }, dO = function(s, u) {
        return u.reduce(qu, s)
    }, hO = function(s, u) {
        return u.reduce(qu, s)
    }, pO = function(s, u) {
        return s.reduce( (c, d) => yl(d, c, !1), u)
    }, mO = function() {
        return "not of"
    }, gO = function() {
        return "not ~of"
    }, vO = function() {
        return "not in"
    }, yO = function() {
        return "not ~in"
    }, bO = function(s, u, c, d) {
        return {
            type: "RangeRelation",
            leftOperator: s,
            middle: u,
            rightOperator: c,
            right: d
        }
    }, wO = function(s, u, c, d) {
        return {
            type: "RangeRelation",
            leftOperator: s,
            middle: u,
            rightOperator: c,
            right: d
        }
    }, EO = function(s, u) {
        return {
            type: "BinaryExpression",
            operator: s,
            right: u,
            preferLeft: !1,
            preferRight: !1
        }
    }, _O = function(s, u) {
        return u ? {
            ...u,
            left: s
        } : s
    }, LO = function(s, u) {
        return u.reduce(ma, s)
    }, SO = function(s, u) {
        return {
            type: "HarmonicSegment",
            root: s,
            end: u
        }
    }, AO = function(s) {
        return {
            type: "EnumeratedChord",
            mirror: !0,
            enumerals: s
        }
    }, CO = function(s) {
        return {
            type: "EnumeratedChord",
            mirror: !0,
            enumerals: [s]
        }
    }, $O = function(s) {
        return s.length === 1 ? s[0] : {
            type: "EnumeratedChord",
            mirror: !1,
            enumerals: s
        }
    }, MO = function(s, u) {
        return u.reduce(ma, s)
    }, OO = function(s, u) {
        return u.reduce(ma, s)
    }, NO = function(s, u) {
        return u.reduce(ma, s)
    }, TO = function(s, u) {
        return u.reduce(ma, s)
    }, xO = function(s, u) {
        return AE(s, u)
    }, IO = function(s, u) {
        return yl(s, u, !0)
    }, FO = function(s, u) {
        return s ? yl(s, u, !1) : u
    }, RO = function(s, u) {
        return u.reduce(ma, s)
    }, PO = function(s, u) {
        return u.reduce(ma, s)
    }, DO = function(s, u, c) {
        return yl(s, c, !!u)
    }, qO = function(s, u) {
        return yl(s, u, !1)
    }, BO = function(s, u) {
        return s === "+" ? yl(s, u, !1) : s ? AE(s, u) : u
    }, kO = function(s, u) {
        return u.reduce(qu, s)
    }, zO = function(s, u) {
        return u.reduce(qu, s)
    }, VO = function(s) {
        return !!s
    }, Zy = function(s, u) {
        return {
            type: "CallExpression",
            args: u
        }
    }, Yy = function(s, u) {
        return {
            type: "AccessExpression",
            key: u
        }
    }, Qy = function(s, u, c, d, y) {
        return {
            type: "ArraySlice",
            start: u,
            second: c,
            penultimate: d,
            end: y
        }
    }, UO = function(s, u) {
        return u.unshift({
            type: "CallExpression",
            args: s
        }),
        u
    }, jO = function(s, u) {
        return u ? CE(s, u) : s
    }, HO = function(s, u) {
        return u.reduce( (c, [d,y]) => ({
            type: "AccessExpression",
            object: c,
            nullish: !!d,
            key: y
        }), s)
    }, GO = function(s, u) {
        return CE(s, u)
    }, WO = function(s, u) {
        return u.reduce( (c, d) => ({
            type: "AccessExpression",
            object: c,
            nullish: !1,
            key: d
        }), s)
    }, JO = function(s, u) {
        return u.reduce( (c, [d,y,_,M]) => ({
            type: "ArraySlice",
            object: c,
            start: d,
            second: y,
            penultimate: _,
            end: M
        }), s)
    }, KO = function(s, u) {
        return u ? Xu("", s, u, !1, !1) : s.type === "DecimalLiteral" ? s.exponent !== null || s.flavor ? s : {
            type: "CentsLiteral",
            sign: s.sign,
            whole: s.whole,
            fractional: s.fractional,
            exponent: null,
            real: !1
        } : s
    }, ZO = function(s, u, c) {
        return {
            type: "Range",
            start: s,
            penultimate: u,
            end: c
        }
    }, YO = function(s, u, c, d) {
        return {
            type: "Range",
            start: s,
            second: u,
            penultimate: c,
            end: d
        }
    }, QO = function(s, u, c) {
        return {
            element: s,
            kind: u,
            container: c
        }
    }, XO = function(s, u, c) {
        return {
            type: "ArrayComprehension",
            expression: s,
            comprehensions: u,
            test: c
        }
    }, eN = function(s, u) {
        return {
            type: "DownExpression",
            count: s.length,
            operand: u
        }
    }, tN = function(s) {
        return {
            type: "StepLiteral",
            count: s
        }
    }, nN = function(s, u, c, d) {
        return {
            type: "NedjiLiteral",
            numerator: s,
            denominator: u,
            equaveNumerator: c,
            equaveDenominator: d
        }
    }, rN = function(s, u) {
        return {
            type: "NedjiLiteral",
            numerator: s,
            denominator: u,
            equaveNumerator: null,
            equaveDenominator: null
        }
    }, sN = function(s, u, c, d, y) {
        return {
            type: "DecimalLiteral",
            sign: s,
            whole: u ?? 0n,
            fractional: c,
            exponent: d,
            flavor: y
        }
    }, iN = function(s, u, c, d, y) {
        return u === "." || d !== null || y ? {
            type: "DecimalLiteral",
            sign: "",
            whole: s,
            fractional: c,
            exponent: d,
            flavor: y
        } : (c.length && ag("Invalid numeric literal."),
        {
            type: "IntegerLiteral",
            value: s
        })
    }, oN = function(s, u, c) {
        return {
            type: "DecimalLiteral",
            sign: "",
            whole: 0n,
            fractional: s,
            exponent: u,
            flavor: c
        }
    }, aN = function(s, u) {
        return {
            type: "FractionLiteral",
            numerator: s,
            denominator: u
        }
    }, lN = function() {
        const s = ol();
        return {
            ups: (s.match(/\^/g) ?? []).length - (s.match(/v/g) ?? []).length,
            lifts: (s.match(/\//g) ?? []).length - (s.match(/\\/g) ?? []).length
        }
    }, uN = function(s, u, c) {
        return {
            ...s,
            type: "MonzoLiteral",
            components: u,
            basis: c ?? []
        }
    }, cN = function(s) {
        return {
            type: "ValBasisLiteral",
            basis: s
        }
    }, fN = function(s, u) {
        return {
            type: "ValLiteral",
            components: s,
            basis: u ?? []
        }
    }, dN = function(s, u, c, d) {
        return {
            type: "WartsLiteral",
            equave: (s ?? "").toLowerCase(),
            divisions: u,
            warts: c.map(y => y.toLowerCase()),
            basis: d
        }
    }, hN = function(s, u) {
        return {
            element: u,
            tweak: s.length
        }
    }, pN = function(s, u) {
        return {
            element: u,
            tweak: -s.length
        }
    }, mN = function(s, u, c, d) {
        return {
            type: "SparseOffsetVal",
            equave: s ?? "",
            divisions: u,
            tweaks: c ?? [],
            basis: d
        }
    }, gN = function(s) {
        return {
            type: "CentLiteral",
            real: !!s
        }
    }, vN = function() {
        return {
            type: "HertzLiteral",
            prefix: ""
        }
    }, yN = function(s) {
        return {
            type: "HertzLiteral",
            prefix: s
        }
    }, bN = function(s) {
        return {
            type: "SecondLiteral",
            prefix: s
        }
    }, wN = function() {
        return {
            type: "ReciprocalCentLiteral"
        }
    }, EN = function() {
        return {
            type: "ReciprocalLogarithmicHertzLiteral"
        }
    }, _N = function() {
        return {
            type: "PopScale",
            parent: !0
        }
    }, LN = function() {
        return {
            type: "PopScale",
            parent: !1
        }
    }, SN = function() {
        return {
            type: "NoneLiteral"
        }
    }, AN = function() {
        return {
            type: "TrueLiteral"
        }
    }, CN = function() {
        return {
            type: "FalseLiteral"
        }
    }, $N = function() {
        return {
            type: "NotANumberLiteral"
        }
    }, MN = function() {
        return {
            type: "InfinityLiteral"
        }
    }, ON = function(s) {
        return {
            type: "ColorLiteral",
            value: s
        }
    }, NN = function() {
        return {
            type: "ColorLiteral",
            value: ol()
        }
    }, TN = function() {
        return {
            type: "ColorLiteral",
            value: ol()
        }
    }, xN = function(s, u) {
        return {
            fraction: s,
            quality: u
        }
    }, IN = function(s) {
        return {
            fraction: "",
            quality: s
        }
    }, FN = function(s, u) {
        return {
            fraction: s,
            quality: u
        }
    }, RN = function(s) {
        return {
            fraction: "",
            quality: s
        }
    }, PN = function() {
        return {
            fraction: "",
            quality: "P"
        }
    }, DN = function(s, u, c) {
        return u = u - 1 + (c ? .5 : 0),
        {
            negative: !!s,
            base: u % 7 + 1,
            octaves: Math.floor(u / 7),
            imperfect: !1
        }
    }, qN = function(s) {
        return e9.has(s.base)
    }, BN = function(s) {
        return t9.has(s.base)
    }, kN = function(s) {
        return n9.has(s.base)
    }, zN = function(s) {
        return {
            ...s,
            imperfect: !0
        }
    }, VN = function(s, u, c) {
        return {
            type: "Pythagorean",
            quality: s,
            augmentations: u,
            degree: c
        }
    }, UN = function(s, u) {
        return {
            type: "Pythagorean",
            quality: s,
            degree: u
        }
    }, jN = function(s, u) {
        return {
            type: "Pythagorean",
            quality: s,
            degree: u
        }
    }, HN = function(s, u) {
        return {
            type: "Pythagorean",
            quality: s,
            degree: u
        }
    }, GN = function(s, u, c) {
        return {
            type: "MosStep",
            quality: s,
            augmentations: u,
            degree: c
        }
    }, WN = function(s, u) {
        return {
            type: "MosStep",
            quality: s,
            degree: u
        }
    }, JN = function(s) {
        return {
            type: "Superscript",
            inflections: s
        }
    }, KN = function(s) {
        return {
            type: "Subscript",
            inflections: s
        }
    }, ZN = function(s) {
        const u = []
          , c = [];
        for (const d of s)
            d.type === "Superscript" ? u.push(...d.inflections) : c.push(...d.inflections);
        return {
            superscripts: u,
            subscripts: c
        }
    }, YN = function(s, u, c) {
        return {
            ...s,
            type: "FJS",
            pythagorean: u,
            superscripts: c.superscripts,
            subscripts: c.subscripts
        }
    }, QN = function(s, u, c) {
        return {
            ...s,
            type: "MosStepLiteral",
            mosStep: u,
            superscripts: c.superscripts,
            subscripts: c.subscripts
        }
    }, XN = function(s, u) {
        return {
            fraction: s,
            accidental: u
        }
    }, eT = function(s, u, c) {
        return {
            type: "AbsolutePitch",
            nominal: s,
            accidentals: u,
            octave: c
        }
    }, tT = function(s, u, c) {
        return {
            type: "AbsolutePitch",
            nominal: s,
            accidentals: u,
            octave: c
        }
    }, nT = function(s, u, c) {
        return {
            ...s,
            type: "AbsoluteFJS",
            pitch: u,
            superscripts: c.superscripts,
            subscripts: c.subscripts
        }
    }, rT = function(s, u) {
        return {
            type: "SquareSuperparticular",
            start: s,
            end: u
        }
    }, sT = function(s, u) {
        return {
            type: "ArrowFunction",
            parameters: s,
            expression: u,
            text: ol()
        }
    }, iT = function(s, u) {
        return {
            type: "ArrowFunction",
            parameters: s,
            expression: u,
            text: ol()
        }
    }, oT = function(s) {
        return !XD.has(s)
    }, aT = function(s) {
        return {
            type: "Identifier",
            id: s
        }
    }, lT = function(s) {
        return {
            type: "TemplateArgument",
            index: s
        }
    }, uT = function(s) {
        return {
            type: "ArrayLiteral",
            elements: s
        }
    }, cT = function(s) {
        return {
            type: "SetLiteral",
            elements: s
        }
    }, fT = function() {
        return {
            type: "RecordLiteral",
            properties: []
        }
    }, dT = function(s) {
        return {
            type: "RecordLiteral",
            properties: s
        }
    }, hT = function(s, u) {
        return u.concat([s])
    }, pT = function(s, u) {
        return s.type === "StringLiteral" ? s = s.value : s.type === "Identifier" && (s = s.id),
        [s, u]
    }, mT = function(s) {
        return [s.id, s]
    }, gT = function(s) {
        return [null, s]
    }, vT = function(s) {
        return {
            type: "StringLiteral",
            value: s.join("")
        }
    }, yT = function(s) {
        return {
            type: "StringLiteral",
            value: s.join("")
        }
    }, bT = function(s) {
        return {
            type: "MosDeclaration",
            body: s
        }
    }, wT = function() {
        return {
            type: "MosDeclaration",
            body: []
        }
    }, ET = function(s) {
        return [s]
    }, _T = function(s) {
        return s
    }, LT = function(s, u) {
        return {
            type: "RationalEquave",
            numerator: s,
            denominator: u ?? 1
        }
    }, ST = function(s, u) {
        return {
            type: "AbstractStepPattern",
            pattern: s,
            equave: u
        }
    }, AT = function(s, u) {
        return {
            type: "IntegerPattern",
            pattern: s.map(c => parseInt(c, 10)),
            equave: u
        }
    }, CT = function(s, u) {
        return {
            type: "IntegerPattern",
            pattern: s,
            equave: u
        }
    }, $T = function(s, u, c) {
        return {
            type: "UDP",
            up: s,
            down: u,
            period: c
        }
    }, MT = function(s, u, c, d) {
        return {
            type: "PatternUpDownPeriod",
            countLarge: s,
            countSmall: u,
            udp: c,
            equave: d
        }
    }, OT = function(s) {
        return {
            type: "HardnessDeclaration",
            value: s
        }
    }, NT = function(s) {
        return {
            type: "LargeDeclaration",
            value: s
        }
    }, TT = function(s) {
        return {
            type: "SmallDeclaration",
            value: s
        }
    }, xT = function(s) {
        return {
            type: "EquaveDeclaration",
            value: s
        }
    }, IT = function(s) {
        return s.endsWith("_") && ag("Numeric separators are not allowed at the end of numeric literals."),
        s.replace(/_/g, "")
    }, FT = function(s) {
        return s.endsWith("_") && ag("Numeric separators are not allowed at the end of numeric literals."),
        s.replace(/_/g, "")
    }, RT = function(s) {
        return BigInt(s.join(""))
    }, PT = function() {
        return 0n
    }, DT = function(s) {
        return s
    }, qT = function(s) {
        return parseInt(s, 10)
    }, BT = function(s) {
        return parseInt(s, 10)
    }, kT = function(s) {
        return parseInt(s, 10)
    }, zT = function() {
        return ""
    }, VT = function() {
        return "\0"
    }, UT = function() {
        return "\b"
    }, jT = function() {
        return "\f"
    }, HT = function() {
        return `
`
    }, GT = function() {
        return "\r"
    }, WT = function() {
        return "	"
    }, JT = function() {
        return "\v"
    }, KT = function(s) {
        return String.fromCharCode(parseInt(s, 16))
    }, ZT = function(s) {
        return String.fromCharCode(parseInt(s, 16))
    }, YT = function() {
        return " "
    }, QT = function(s) {
        return KD.test(s)
    }, XT = function(s) {
        return ZD.test(s)
    }, ex = function(s) {
        return YD.test(s)
    }, tx = function(s, u, c, d) {
        return {
            sign: s,
            left: u,
            separator: c,
            right: d,
            exponent: null
        }
    }, nx = function(s, u, c, d, y) {
        return {
            sign: s,
            left: u,
            separator: c,
            right: d,
            exponent: y
        }
    }, rx = function(s, u, c) {
        return {
            sign: s,
            left: u,
            separator: "",
            right: "",
            exponent: c
        }
    }, sx = function(s, u, c) {
        return {
            radical: !!s,
            numerator: u,
            denominator: c
        }
    }, o = t.peg$currPos | 0, le = o, il = [{
        line: 1,
        column: 1
    }], zs = o, ld = t.peg$maxFailExpected || [], v = t.peg$silentFails | 0, yu;
    if (t.startRule) {
        if (!(t.startRule in i))
            throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
        a = i[t.startRule]
    }
    function ol() {
        return n.substring(le, o)
    }
    function ag(s, u) {
        throw u = u !== void 0 ? u : lg(le, o),
        ax(s, u)
    }
    function fe(s, u) {
        return {
            type: "literal",
            text: s,
            ignoreCase: u
        }
    }
    function Vt(s, u, c) {
        return {
            type: "class",
            parts: s,
            inverted: u,
            ignoreCase: c
        }
    }
    function ix() {
        return {
            type: "any"
        }
    }
    function ox() {
        return {
            type: "end"
        }
    }
    function jr(s) {
        return {
            type: "other",
            description: s
        }
    }
    function Xy(s) {
        var u = il[s], c;
        if (u)
            return u;
        if (s >= il.length)
            c = il.length - 1;
        else
            for (c = s; !il[--c]; )
                ;
        for (u = il[c],
        u = {
            line: u.line,
            column: u.column
        }; c < s; )
            n.charCodeAt(c) === 10 ? (u.line++,
            u.column = 1) : u.column++,
            c++;
        return il[s] = u,
        u
    }
    function lg(s, u, c) {
        var d = Xy(s)
          , y = Xy(u)
          , _ = {
            source: r,
            start: {
                offset: s,
                line: d.line,
                column: d.column
            },
            end: {
                offset: u,
                line: y.line,
                column: y.column
            }
        };
        return c && r && typeof r.offset == "function" && (_.start = r.offset(_.start),
        _.end = r.offset(_.end)),
        _
    }
    function w(s) {
        o < zs || (o > zs && (zs = o,
        ld = []),
        ld.push(s))
    }
    function ax(s, u) {
        return new Do(s,null,null,u)
    }
    function lx(s, u, c) {
        return new Do(Do.buildMessage(s, u),s,u,c)
    }
    function eb() {
        var s, u;
        return s = o,
        G(),
        u = ux(),
        G(),
        le = s,
        s = pM(u),
        s
    }
    function ux() {
        var s, u;
        return s = o,
        u = pg(),
        u === e && (u = null),
        le = s,
        u = mM(u),
        s = u,
        s
    }
    function cx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === l ? (u = l,
        o += 3) : (u = e,
        v === 0 && w(qA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function fx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === f ? (u = f,
        o += 2) : (u = e,
        v === 0 && w(BA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function dx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === h ? (u = h,
        o += 3) : (u = e,
        v === 0 && w(kA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function hx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === p ? (u = p,
        o += 2) : (u = e,
        v === 0 && w(zA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function px() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === m ? (u = m,
        o += 5) : (u = e,
        v === 0 && w(VA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function mx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === g ? (u = g,
        o += 2) : (u = e,
        v === 0 && w(UA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function tb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === b ? (u = b,
        o += 5) : (u = e,
        v === 0 && w(jA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ug() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === E ? (u = E,
        o += 5) : (u = e,
        v === 0 && w(HA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function gx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 8) === S ? (u = S,
        o += 8) : (u = e,
        v === 0 && w(GA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function vx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === F ? (u = F,
        o += 5) : (u = e,
        v === 0 && w(WA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function yx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === B ? (u = B,
        o += 3) : (u = e,
        v === 0 && w(Cy)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function bx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Q ? (u = Q,
        o += 3) : (u = e,
        v === 0 && w(JA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function wx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === ae ? (u = ae,
        o += 4) : (u = e,
        v === 0 && w(KA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ex() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === V ? (u = V,
        o += 2) : (u = e,
        v === 0 && w(ZA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function al() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === k ? (u = k,
        o += 4) : (u = e,
        v === 0 && w(YA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function cg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === z ? (u = z,
        o += 6) : (u = e,
        v === 0 && w(QA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function _x() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === Z ? (u = Z,
        o += 5) : (u = e,
        v === 0 && w(XA)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Lx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 7) === re ? (u = re,
        o += 7) : (u = e,
        v === 0 && w(eC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function fg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === C ? (u = C,
        o += 3) : (u = e,
        v === 0 && w(tC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function dg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === D ? (u = D,
        o += 4) : (u = e,
        v === 0 && w(nC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function bu() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === R ? (u = R,
        o += 2) : (u = e,
        v === 0 && w(rC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function nb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === W ? (u = W,
        o += 6) : (u = e,
        v === 0 && w(sC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function wu() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === I ? (u = I,
        o += 2) : (u = e,
        v === 0 && w(iC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Sx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === N ? (u = N,
        o += 3) : (u = e,
        v === 0 && w($y)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ax() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === P ? (u = P,
        o += 4) : (u = e,
        v === 0 && w(oC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function rb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === J ? (u = J,
        o += 4) : (u = e,
        v === 0 && w(aC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function sb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === X ? (u = X,
        o += 3) : (u = e,
        v === 0 && w(lC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ib() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === ie ? (u = ie,
        o += 4) : (u = e,
        v === 0 && w(uC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Cx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === ce ? (u = ce,
        o += 3) : (u = e,
        v === 0 && w(cC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function $x() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === Le ? (u = Le,
        o += 4) : (u = e,
        v === 0 && w(fC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Mx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === he ? (u = he,
        o += 3) : (u = e,
        v === 0 && w(My)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ox() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Fe ? (u = Fe,
        o += 3) : (u = e,
        v === 0 && w(dC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Nx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === Te ? (u = Te,
        o += 4) : (u = e,
        v === 0 && w(hC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Tx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === ye ? (u = ye,
        o += 6) : (u = e,
        v === 0 && w(pC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function xx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === qe ? (u = qe,
        o += 3) : (u = e,
        v === 0 && w(mC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ob() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === Ge ? (u = Ge,
        o += 6) : (u = e,
        v === 0 && w(gC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ll() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Se ? (u = Se,
        o += 3) : (u = e,
        v === 0 && w(vC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Eu() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === L ? (u = L,
        o += 2) : (u = e,
        v === 0 && w(yC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ix() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === K ? (u = K,
        o += 2) : (u = e,
        v === 0 && w(bC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Fx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === de ? (u = de,
        o += 4) : (u = e,
        v === 0 && w(wC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Rx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === $e ? (u = $e,
        o += 5) : (u = e,
        v === 0 && w(EC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Px() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === Re ? (u = Re,
        o += 2) : (u = e,
        v === 0 && w(_C)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Dx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === me ? (u = me,
        o += 3) : (u = e,
        v === 0 && w(LC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ab() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === T ? (u = T,
        o += 6) : (u = e,
        v === 0 && w(SC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function lb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === j ? (u = j,
        o += 4) : (u = e,
        v === 0 && w(AC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ub() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === ge ? (u = ge,
        o += 2) : (u = e,
        v === 0 && w(CC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function qx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Me ? (u = Me,
        o += 3) : (u = e,
        v === 0 && w($C)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Bx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === Oe ? (u = Oe,
        o += 4) : (u = e,
        v === 0 && w(MC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function kx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Be ? (u = Be,
        o += 3) : (u = e,
        v === 0 && w(OC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function zx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === ze ? (u = ze,
        o += 5) : (u = e,
        v === 0 && w(NC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Vx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === Ye ? (u = Ye,
        o += 2) : (u = e,
        v === 0 && w(TC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function hg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === He ? (u = He,
        o += 3) : (u = e,
        v === 0 && w(xC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ux() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === Ue ? (u = Ue,
        o += 4) : (u = e,
        v === 0 && w(IC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function jx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === at ? (u = at,
        o += 4) : (u = e,
        v === 0 && w(FC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Hx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === rt ? (u = rt,
        o += 4) : (u = e,
        v === 0 && w(RC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function cb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 4) === _e ? (u = _e,
        o += 4) : (u = e,
        v === 0 && w(PC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Gx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === xe ? (u = xe,
        o += 3) : (u = e,
        v === 0 && w(DC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function fb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === Ze ? (u = Ze,
        o += 5) : (u = e,
        v === 0 && w(qC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Wx() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 5) === st ? (u = st,
        o += 5) : (u = e,
        v === 0 && w(BC)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function pg() {
        var s, u, c, d, y;
        if (s = o,
        u = ur(),
        u !== e) {
            for (c = [],
            d = o,
            G(),
            y = ur(),
            y !== e ? d = y : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                G(),
                y = ur(),
                y !== e ? d = y : (o = d,
                d = e);
            le = s,
            s = gM(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function ur() {
        var s;
        return s = Kx(),
        s === e && (s = Yx(),
        s === e && (s = vg(),
        s === e && (s = bI(),
        s === e && (s = Zx(),
        s === e && (s = db(),
        s === e && (s = Qx(),
        s === e && (s = Xx(),
        s === e && (s = rI(),
        s === e && (s = sI(),
        s === e && (s = iI(),
        s === e && (s = oI(),
        s === e && (s = aI(),
        s === e && (s = lI(),
        s === e && (s = uI(),
        s === e && (s = cI(),
        s === e && (s = fI(),
        s === e && (s = eI(),
        s === e && (s = dI(),
        s === e && (s = hI(),
        s === e && (s = pI(),
        s === e && (s = mI(),
        s === e && (s = vI(),
        s === e && (s = gI(),
        s === e && (s = LF(),
        s === e && (s = SF(),
        s === e && (s = yI())))))))))))))))))))))))))),
        s
    }
    function Jx() {
        var s, u, c, d, y, _;
        return s = o,
        G(),
        n.charCodeAt(o) === 126 ? (u = je,
        o++) : (u = e,
        v === 0 && w(Gt)),
        u === e && (u = null),
        c = EI(),
        c === e && (c = null),
        n.charCodeAt(o) === 126 ? (d = je,
        o++) : (d = e,
        v === 0 && w(Gt)),
        d === e && (d = null),
        n.charCodeAt(o) === 61 ? (y = ct,
        o++) : (y = e,
        v === 0 && w(ns)),
        y !== e ? (G(),
        _ = $t(),
        _ !== e ? (le = s,
        s = vM(u, c, d, _)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Kx() {
        var s, u, c, d, y, _, M;
        return s = o,
        u = o,
        v++,
        c = rs(),
        v--,
        c !== e ? (o = u,
        u = void 0) : u = e,
        u !== e ? (c = gg(),
        c !== e ? (d = G(),
        n.charCodeAt(o) === 61 ? (y = ct,
        o++) : (y = e,
        v === 0 && w(ns)),
        y !== e ? (G(),
        _ = $t(),
        _ !== e ? (M = Hn(),
        M !== e ? (le = s,
        s = yM(c, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = o,
        v++,
        c = rs(),
        v--,
        c !== e ? (o = u,
        u = void 0) : u = e,
        u !== e ? (c = kg(),
        c !== e ? (d = Jx(),
        d === e && (d = null),
        y = Hn(),
        y !== e ? (le = s,
        s = bM(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function Zx() {
        var s, u, c, d;
        return s = o,
        u = sb(),
        u !== e ? (G(),
        c = hb(),
        c !== e ? (d = Hn(),
        d !== e ? (le = s,
        s = wM(c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = ug(),
        u !== e ? (G(),
        c = tI(),
        c !== e ? (d = Hn(),
        d !== e ? (le = s,
        s = EM(c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function db() {
        var s, u, c, d, y, _, M;
        return s = o,
        u = lb(),
        u === e && (u = ub()),
        u !== e ? (G(),
        c = Xn(),
        c !== e ? (G(),
        n.charCodeAt(o) === 40 ? (d = Et,
        o++) : (d = e,
        v === 0 && w(Vr)),
        d !== e ? (G(),
        y = ud(),
        G(),
        n.charCodeAt(o) === 41 ? (_ = It,
        o++) : (_ = e,
        v === 0 && w(Ur)),
        _ !== e ? (G(),
        M = vg(),
        M !== e ? (le = s,
        s = _M(c, y, M)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Yx() {
        var s, u, c, d, y, _, M, Y, Je;
        return s = o,
        u = o,
        v++,
        c = rs(),
        v--,
        c !== e ? (o = u,
        u = void 0) : u = e,
        u !== e ? (c = pd(),
        c !== e ? (d = o,
        y = G(),
        n.charCodeAt(o) === 61 ? (_ = ct,
        o++) : (_ = e,
        v === 0 && w(ns)),
        _ !== e ? (M = G(),
        Y = $t(),
        Y !== e ? d = Y : (o = d,
        d = e)) : (o = d,
        d = e),
        d === e && (d = null),
        y = o,
        _ = G(),
        n.charCodeAt(o) === 61 ? (M = ct,
        o++) : (M = e,
        v === 0 && w(ns)),
        M !== e ? (Y = G(),
        Je = $t(),
        Je !== e ? y = Je : (o = y,
        y = e)) : (o = y,
        y = e),
        y === e && (y = null),
        _ = Hn(),
        _ !== e ? (le = s,
        s = LM(c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Qx() {
        var s, u, c, d, y;
        return s = o,
        n.charCodeAt(o) === 94 ? (u = Bt,
        o++) : (u = e,
        v === 0 && w(td)),
        u !== e ? (G(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (y = Hn(),
        y !== e ? (le = s,
        s = SM(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Xx() {
        var s, u, c, d, y;
        return s = o,
        n.charCodeAt(o) === 47 ? (u = yn,
        o++) : (u = e,
        v === 0 && w(As)),
        u === e && (u = ib()),
        u !== e ? (G(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (y = Hn(),
        y !== e ? (le = s,
        s = AM(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function eI() {
        var s, u, c, d;
        return s = o,
        u = yx(),
        u !== e ? (G(),
        c = _b(),
        c === e && (c = Lb()),
        c !== e ? (d = Hn(),
        d !== e ? (le = s,
        s = CM(c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Vs() {
        var s, u, c, d, y;
        return s = o,
        u = Xn(),
        u !== e ? (c = o,
        G(),
        n.charCodeAt(o) === 61 ? (d = ct,
        o++) : (d = e,
        v === 0 && w(ns)),
        d !== e ? (G(),
        y = $t(),
        y !== e ? c = y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = $M(u, c)) : (o = s,
        s = e),
        s
    }
    function ud() {
        var s, u, c, d, y, _, M, Y;
        for (s = o,
        u = [],
        c = Vs(),
        c === e && (c = ua()); c !== e; )
            u.push(c),
            c = o,
            d = o,
            y = G(),
            n.charCodeAt(o) === 44 ? (_ = qt,
            o++) : (_ = e,
            v === 0 && w(Bn)),
            _ !== e ? (M = G(),
            y = [y, _, M],
            d = y) : (o = d,
            d = e),
            d !== e ? (d = Vs(),
            d === e && (d = ua()),
            d === e ? (o = c,
            c = e) : c = d) : c = d;
        return c = o,
        d = G(),
        n.charCodeAt(o) === 44 ? (y = qt,
        o++) : (y = e,
        v === 0 && w(Bn)),
        y === e && (y = null),
        _ = G(),
        n.substr(o, 3) === Nt ? (M = Nt,
        o += 3) : (M = e,
        v === 0 && w(el)),
        M !== e ? (G(),
        Y = Vs(),
        Y !== e ? c = Y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = MM(u, c),
        s
    }
    function hb() {
        var s, u, c, d, y, _, M, Y, Je;
        for (s = o,
        u = o,
        c = [],
        d = Vs(),
        d === e && (d = ua()); d !== e; )
            c.push(d),
            d = o,
            y = o,
            _ = G(),
            n.charCodeAt(o) === 44 ? (M = qt,
            o++) : (M = e,
            v === 0 && w(Bn)),
            M !== e ? (Y = G(),
            _ = [_, M, Y],
            y = _) : (o = y,
            y = e),
            y !== e ? (y = Vs(),
            y === e && (y = ua()),
            y === e ? (o = d,
            d = e) : d = y) : d = y;
        return c.length < 1 ? (o = u,
        u = e) : u = c,
        u !== e ? (c = o,
        d = G(),
        n.charCodeAt(o) === 44 ? (y = qt,
        o++) : (y = e,
        v === 0 && w(Bn)),
        y === e && (y = null),
        _ = G(),
        n.substr(o, 3) === Nt ? (M = Nt,
        o += 3) : (M = e,
        v === 0 && w(el)),
        M !== e ? (Y = G(),
        Je = Vs(),
        Je !== e ? c = Je : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = OM(u, c)) : (o = s,
        s = e),
        s === e && (s = o,
        n.substr(o, 3) === Nt ? (u = Nt,
        o += 3) : (u = e,
        v === 0 && w(el)),
        u !== e ? (c = G(),
        d = Vs(),
        d !== e ? (le = s,
        s = NM(d)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function ua() {
        var s, u, c, d, y, _, M;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = ud(),
        c !== e ? (G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? (y = o,
        G(),
        n.charCodeAt(o) === 61 ? (_ = ct,
        o++) : (_ = e,
        v === 0 && w(ns)),
        _ !== e ? (G(),
        M = $t(),
        M !== e ? y = M : (o = y,
        y = e)) : (o = y,
        y = e),
        y === e && (y = null),
        le = s,
        s = TM(c, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function mg() {
        var s, u, c, d;
        return s = o,
        u = Xn(),
        u !== e ? (G(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (le = s,
        s = xM(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function tI() {
        var s, u, c, d, y, _, M, Y;
        for (s = o,
        u = o,
        c = [],
        d = mg(),
        d === e && (d = pb()); d !== e; )
            c.push(d),
            d = o,
            y = o,
            _ = G(),
            n.charCodeAt(o) === 44 ? (M = qt,
            o++) : (M = e,
            v === 0 && w(Bn)),
            M !== e ? (Y = G(),
            _ = [_, M, Y],
            y = _) : (o = y,
            y = e),
            y !== e ? (y = mg(),
            y === e && (y = pb()),
            y === e ? (o = d,
            d = e) : d = y) : d = y;
        return c.length < 1 ? (o = u,
        u = e) : u = c,
        u !== e && (le = s,
        u = IM(u)),
        s = u,
        s
    }
    function pb() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = ud(),
        G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? (G(),
        n.charCodeAt(o) === 61 ? (y = ct,
        o++) : (y = e,
        v === 0 && w(ns)),
        y !== e ? (G(),
        _ = $t(),
        _ !== e ? (le = s,
        s = FM(c, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function nI() {
        var s, u, c, d, y, _, M, Y;
        for (s = o,
        u = [],
        c = Xn(),
        c === e && (c = gg()); c !== e; )
            u.push(c),
            c = o,
            d = o,
            y = G(),
            n.charCodeAt(o) === 44 ? (_ = qt,
            o++) : (_ = e,
            v === 0 && w(Bn)),
            _ !== e ? (M = G(),
            y = [y, _, M],
            d = y) : (o = d,
            d = e),
            d !== e ? (d = Xn(),
            d === e && (d = gg()),
            d === e ? (o = c,
            c = e) : c = d) : c = d;
        return c = o,
        d = G(),
        n.charCodeAt(o) === 44 ? (y = qt,
        o++) : (y = e,
        v === 0 && w(Bn)),
        y === e && (y = null),
        _ = G(),
        n.substr(o, 3) === Nt ? (M = Nt,
        o += 3) : (M = e,
        v === 0 && w(el)),
        M !== e ? (G(),
        Y = Xn(),
        Y !== e ? c = Y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = RM(u, c),
        s
    }
    function gg() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = nI(),
        G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? s = c : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function mb() {
        var s, u, c;
        return s = o,
        n.substr(o, 3) === Nt ? (u = Nt,
        o += 3) : (u = e,
        v === 0 && w(el)),
        u === e && (u = null),
        G(),
        c = $t(),
        c !== e ? (le = s,
        s = PM(u, c)) : (o = s,
        s = e),
        s
    }
    function _u() {
        var s, u, c, d, y, _, M;
        for (s = o,
        u = [],
        c = mb(); c !== e; )
            u.push(c),
            c = o,
            d = o,
            y = G(),
            n.charCodeAt(o) === 44 ? (_ = qt,
            o++) : (_ = e,
            v === 0 && w(Bn)),
            _ !== e ? (M = G(),
            y = [y, _, M],
            d = y) : (o = d,
            d = e),
            d !== e ? (d = mb(),
            d === e ? (o = c,
            c = e) : c = d) : c = d;
        return c = G(),
        n.charCodeAt(o) === 44 ? (d = qt,
        o++) : (d = e,
        v === 0 && w(Bn)),
        d === e && (d = null),
        s = u,
        s
    }
    function vg() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 123 ? (u = pe,
        o++) : (u = e,
        v === 0 && w(nd)),
        u !== e ? (G(),
        c = pg(),
        c === e && (c = null),
        G(),
        n.charCodeAt(o) === 125 ? (d = Pe,
        o++) : (d = e,
        v === 0 && w(ia)),
        d !== e ? (le = s,
        s = DM(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function rI() {
        var s, u, c, d;
        return s = o,
        u = zx(),
        u !== e ? (G(),
        c = $t(),
        c !== e ? (d = Hn(),
        d !== e ? (le = s,
        s = qM(c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function sI() {
        var s, u, c, d, y;
        return s = o,
        u = ab(),
        u !== e ? (c = G(),
        d = $t(),
        d !== e ? (y = Hn(),
        y !== e ? (le = s,
        s = BM(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = ab(),
        u !== e ? (c = Hn(),
        c !== e ? (le = s,
        s = kM()) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function iI() {
        var s, u, c;
        return s = o,
        u = px(),
        u !== e ? (c = Hn(),
        c !== e ? (le = s,
        s = zM()) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function oI() {
        var s, u, c;
        return s = o,
        u = gx(),
        u !== e ? (c = Hn(),
        c !== e ? (le = s,
        s = VM()) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function aI() {
        var s, u, c, d, y, _, M, Y, Je;
        return s = o,
        u = Wx(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (G(),
        n.charCodeAt(o) === 41 ? (y = It,
        o++) : (y = e,
        v === 0 && w(Ur)),
        y !== e ? (G(),
        _ = ur(),
        _ !== e ? (M = o,
        G(),
        Y = al(),
        Y !== e ? (G(),
        Je = ur(),
        Je !== e ? M = Je : (o = M,
        M = e)) : (o = M,
        M = e),
        M === e && (M = null),
        le = s,
        s = UM(d, _, M)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function lI() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        u = bu(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (G(),
        n.charCodeAt(o) === 41 ? (y = It,
        o++) : (y = e,
        v === 0 && w(Ur)),
        y !== e ? (G(),
        _ = ur(),
        _ !== e ? (G(),
        M = al(),
        M !== e ? (G(),
        Y = ur(),
        Y !== e ? (le = s,
        s = jM(d, _, Y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = bu(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (G(),
        n.charCodeAt(o) === 41 ? (y = It,
        o++) : (y = e,
        v === 0 && w(Ur)),
        y !== e ? (G(),
        _ = ur(),
        _ !== e ? (le = s,
        s = HM(d, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function yg() {
        var s;
        return s = Eu(),
        s === e && (s = wu()),
        s
    }
    function uI() {
        var s, u, c, d, y, _, M, Y, Je, _t, yr, cr;
        return s = o,
        u = fg(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = sb(),
        d !== e ? (G(),
        y = Vs(),
        y === e && (y = ua()),
        y !== e ? (G(),
        _ = yg(),
        _ !== e ? (G(),
        M = $t(),
        M !== e ? (G(),
        n.charCodeAt(o) === 41 ? (Y = It,
        o++) : (Y = e,
        v === 0 && w(Ur)),
        Y !== e ? (G(),
        Je = ur(),
        Je !== e ? (_t = o,
        G(),
        yr = al(),
        yr !== e ? (G(),
        cr = ur(),
        cr !== e ? _t = cr : (o = _t,
        _t = e)) : (o = _t,
        _t = e),
        _t === e && (_t = null),
        le = s,
        s = GM(y, _, M, Je, _t)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = fg(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = ug(),
        d !== e ? (G(),
        y = Vs(),
        y === e && (y = ua()),
        y !== e ? (G(),
        _ = yg(),
        _ !== e ? (G(),
        M = $t(),
        M !== e ? (G(),
        n.charCodeAt(o) === 41 ? (Y = It,
        o++) : (Y = e,
        v === 0 && w(Ur)),
        Y !== e ? (G(),
        Je = ur(),
        Je !== e ? (_t = o,
        G(),
        yr = al(),
        yr !== e ? (G(),
        cr = ur(),
        cr !== e ? _t = cr : (o = _t,
        _t = e)) : (o = _t,
        _t = e),
        _t === e && (_t = null),
        le = s,
        s = WM(y, _, M, Je, _t)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function cI() {
        var s, u, c, d, y;
        return s = o,
        u = hg(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? (G(),
        d = gb(),
        d !== e ? (G(),
        y = vb(),
        y !== e ? (le = s,
        s = JM(c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = hg(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? (G(),
        d = gb(),
        d !== e ? (le = s,
        s = KM(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = hg(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? (G(),
        d = vb(),
        d !== e ? (le = s,
        s = ZM(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e))),
        s
    }
    function gb() {
        var s, u, c, d, y, _;
        return s = o,
        u = tb(),
        u !== e ? (G(),
        n.charCodeAt(o) === 40 ? (c = Et,
        o++) : (c = e,
        v === 0 && w(Vr)),
        c !== e ? (G(),
        d = Vs(),
        d !== e ? (G(),
        n.charCodeAt(o) === 41 ? (y = It,
        o++) : (y = e,
        v === 0 && w(Ur)),
        y !== e ? (G(),
        _ = ur(),
        _ !== e ? (le = s,
        s = YM(d, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = tb(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? (le = s,
        s = QM(c)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function vb() {
        var s, u, c;
        return s = o,
        u = Lx(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? s = c : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function fI() {
        var s, u, c;
        return s = o,
        u = vx(),
        u !== e ? (G(),
        c = ur(),
        c !== e ? (le = s,
        s = XM(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function dI() {
        var s, u, c, d;
        return s = o,
        u = Tx(),
        u !== e ? (G(),
        c = Xn(),
        c !== e ? (G(),
        d = vg(),
        d !== e ? (le = s,
        s = eO(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function hI() {
        var s, u, c, d, y;
        return s = o,
        u = cg(),
        u !== e ? (G(),
        c = ug(),
        c !== e ? (G(),
        d = mg(),
        d !== e ? (y = Hn(),
        y !== e ? (le = s,
        s = tO(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function pI() {
        var s, u, c;
        return s = o,
        u = cg(),
        u !== e ? (G(),
        c = db(),
        c !== e ? (le = s,
        s = nO(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function mI() {
        var s, u, c, d, y, _;
        return s = o,
        u = cg(),
        u !== e ? (G(),
        n.charCodeAt(o) === 42 ? (c = Xe,
        o++) : (c = e,
        v === 0 && w(Oy)),
        c !== e ? (G(),
        d = dg(),
        d !== e ? (G(),
        y = Xn(),
        y !== e ? (_ = Hn(),
        _ !== e ? (le = s,
        s = rO(y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function yb() {
        var s, u, c, d, y;
        return s = o,
        u = Xn(),
        u !== e ? (c = o,
        G(),
        d = hx(),
        d !== e ? (G(),
        y = Xn(),
        y !== e ? c = y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = sO(u, c)) : (o = s,
        s = e),
        s
    }
    function gI() {
        var s, u, c, d, y, _, M, Y, Je;
        if (s = o,
        u = nb(),
        u !== e) {
            for (G(),
            c = o,
            d = [],
            y = yb(); y !== e; )
                d.push(y),
                y = o,
                _ = o,
                M = G(),
                n.charCodeAt(o) === 44 ? (Y = qt,
                o++) : (Y = e,
                v === 0 && w(Bn)),
                Y !== e ? (Je = G(),
                M = [M, Y, Je],
                _ = M) : (o = _,
                _ = e),
                _ !== e ? (_ = yb(),
                _ === e ? (o = y,
                y = e) : y = _) : y = _;
            d.length < 1 ? (o = c,
            c = e) : c = d,
            c !== e ? (d = G(),
            y = dg(),
            y !== e ? (_ = G(),
            M = Xn(),
            M !== e ? (Y = Hn(),
            Y !== e ? (le = s,
            s = iO(c, M)) : (o = s,
            s = e)) : (o = s,
            s = e)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function vI() {
        var s, u, c, d, y, _;
        return s = o,
        u = nb(),
        u !== e ? (G(),
        n.charCodeAt(o) === 42 ? (c = Xe,
        o++) : (c = e,
        v === 0 && w(Oy)),
        c !== e ? (G(),
        d = dg(),
        d !== e ? (G(),
        y = Xn(),
        y !== e ? (_ = Hn(),
        _ !== e ? (le = s,
        s = oO(y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function yI() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = G(),
        n.charCodeAt(o) === 59 ? (d = ft,
        o++) : (d = e,
        v === 0 && w(Ny)),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e),
        u === e && (u = o,
        c = Qe(),
        d = Ou(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)),
        u !== e && (le = s,
        u = aO()),
        s = u,
        s
    }
    function bI() {
        var s, u, c, d, y;
        return s = o,
        u = o,
        v++,
        c = rs(),
        v--,
        c !== e ? (o = u,
        u = void 0) : u = e,
        u !== e ? (c = o,
        v++,
        d = lb(),
        d === e && (d = ub()),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = MI(),
        d === e && (d = $t()),
        d !== e ? (y = Hn(),
        y !== e ? (le = s,
        s = lO(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function wI() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 123 ? (u = pe,
        o++) : (u = e,
        v === 0 && w(nd)),
        u !== e ? (G(),
        c = pg(),
        c === e && (c = null),
        G(),
        n.charCodeAt(o) === 125 ? (d = Pe,
        o++) : (d = e,
        v === 0 && w(ia)),
        d !== e ? (le = s,
        s = uO(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function $t() {
        var s;
        return s = bg(),
        s === e && (s = wI()),
        s
    }
    function EI() {
        var s;
        return s = wg(),
        s === e && (s = Eg(),
        s === e && (s = Sg(),
        s === e && (s = Cg(),
        s === e && (s = Mg(),
        s === e && (s = Ng(),
        s === e && (s = xg(),
        s === e && (s = Pg(),
        s === e && (s = Dg())))))))),
        s
    }
    function bg() {
        var s, u, c, d, y, _;
        if (s = o,
        u = _I(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            y = rb(),
            y !== e ? (G(),
            _ = bg(),
            _ !== e ? d = [y, _] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                y = rb(),
                y !== e ? (G(),
                _ = bg(),
                _ !== e ? d = [y, _] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = cO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function _I() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Lu(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            y = bu(),
            y === e && (y = fb()),
            y !== e ? (G(),
            _ = Lu(),
            _ !== e ? (G(),
            M = al(),
            M !== e ? (G(),
            Y = Lu(),
            Y !== e ? d = [y, _, Y] : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                y = bu(),
                y === e && (y = fb()),
                y !== e ? (G(),
                _ = Lu(),
                _ !== e ? (G(),
                M = al(),
                M !== e ? (G(),
                Y = Lu(),
                Y !== e ? d = [y, _, Y] : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = fO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function wg() {
        var s;
        return n.substr(o, 3) === Ht ? (s = Ht,
        o += 3) : (s = e,
        v === 0 && w(kC)),
        s === e && (s = fx(),
        s === e && (s = Ix(),
        s === e && (s = Gx()))),
        s
    }
    function Lu() {
        var s, u, c, d, y, _;
        if (s = o,
        u = _g(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            y = wg(),
            y !== e ? (G(),
            _ = _g(),
            _ !== e ? d = [y, _] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                y = wg(),
                y !== e ? (G(),
                _ = _g(),
                _ !== e ? d = [y, _] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = dO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Eg() {
        var s;
        return s = dx(),
        s === e && (s = jx()),
        s
    }
    function _g() {
        var s, u, c, d, y, _;
        if (s = o,
        u = Lg(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            y = Eg(),
            y !== e ? (G(),
            _ = Lg(),
            _ !== e ? d = [y, _] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                y = Eg(),
                y !== e ? (G(),
                _ = Lg(),
                _ !== e ? d = [y, _] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = hO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Lg() {
        var s, u, c, d;
        for (s = o,
        u = [],
        c = ll(),
        c === e && (c = cb()); c !== e; )
            u.push(c),
            c = o,
            d = Qe(),
            d = ll(),
            d === e && (d = cb()),
            d === e ? (o = c,
            c = e) : c = d;
        return c = Qe(),
        d = AI(),
        d !== e ? (le = s,
        s = pO(u, d)) : (o = s,
        s = e),
        s
    }
    function LI() {
        var s, u, c, d, y, _;
        return v++,
        n.substr(o, 2) === Yt ? (s = Yt,
        o += 2) : (s = e,
        v === 0 && w(VC)),
        s === e && (n.substr(o, 2) === $r ? (s = $r,
        o += 2) : (s = e,
        v === 0 && w(UC)),
        s === e && (n.substr(o, 2) === Ds ? (s = Ds,
        o += 2) : (s = e,
        v === 0 && w(jC)),
        s === e && (n.substr(o, 3) === xi ? (s = xi,
        o += 3) : (s = e,
        v === 0 && w(HC)),
        s === e && (n.substr(o, 2) === vs ? (s = vs,
        o += 2) : (s = e,
        v === 0 && w(Ym)),
        s === e && (n.substr(o, 2) === ys ? (s = ys,
        o += 2) : (s = e,
        v === 0 && w(Qm)),
        s === e && (s = n.charAt(o),
        fA.test(s) ? o++ : (s = e,
        v === 0 && w(GC)),
        s === e && (s = Eu(),
        s === e && (s = o,
        u = o,
        c = ll(),
        c !== e ? (d = Qe(),
        y = Eu(),
        y !== e ? (c = [c, d, y],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e && (le = s,
        u = mO()),
        s = u,
        s === e && (s = o,
        u = o,
        n.charCodeAt(o) === 126 ? (c = je,
        o++) : (c = e,
        v === 0 && w(Gt)),
        c !== e ? (d = Eu(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s === e && (s = o,
        u = o,
        c = ll(),
        c !== e ? (d = Qe(),
        n.charCodeAt(o) === 126 ? (y = je,
        o++) : (y = e,
        v === 0 && w(Gt)),
        y !== e ? (_ = Eu(),
        _ !== e ? (c = [c, d, y, _],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e && (le = s,
        u = gO()),
        s = u,
        s === e && (s = wu(),
        s === e && (s = o,
        u = o,
        c = ll(),
        c !== e ? (d = Qe(),
        y = wu(),
        y !== e ? (c = [c, d, y],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e && (le = s,
        u = vO()),
        s = u,
        s === e && (s = o,
        u = o,
        n.charCodeAt(o) === 126 ? (c = je,
        o++) : (c = e,
        v === 0 && w(Gt)),
        c !== e ? (d = wu(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s === e && (s = o,
        u = o,
        c = ll(),
        c !== e ? (d = Qe(),
        n.charCodeAt(o) === 126 ? (y = je,
        o++) : (y = e,
        v === 0 && w(Gt)),
        y !== e ? (_ = wu(),
        _ !== e ? (c = [c, d, y, _],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e && (le = s,
        u = yO()),
        s = u)))))))))))))),
        v--,
        s === e && (u = e,
        v === 0 && w(zC)),
        s
    }
    function SI() {
        var s, u, c, d, y;
        return s = o,
        Qe(),
        n.substr(o, 2) === vs ? (u = vs,
        o += 2) : (u = e,
        v === 0 && w(Ym)),
        u === e && (n.charCodeAt(o) === 60 ? (u = as,
        o++) : (u = e,
        v === 0 && w(oa))),
        u !== e ? (Qe(),
        c = ul(),
        c !== e ? (Qe(),
        n.substr(o, 2) === vs ? (d = vs,
        o += 2) : (d = e,
        v === 0 && w(Ym)),
        d === e && (n.charCodeAt(o) === 60 ? (d = as,
        o++) : (d = e,
        v === 0 && w(oa))),
        d !== e ? (G(),
        y = ul(),
        y !== e ? (le = s,
        s = bO(u, c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        Qe(),
        n.substr(o, 2) === ys ? (u = ys,
        o += 2) : (u = e,
        v === 0 && w(Qm)),
        u === e && (n.charCodeAt(o) === 62 ? (u = ri,
        o++) : (u = e,
        v === 0 && w(rd))),
        u !== e ? (Qe(),
        c = ul(),
        c !== e ? (Qe(),
        n.substr(o, 2) === ys ? (d = ys,
        o += 2) : (d = e,
        v === 0 && w(Qm)),
        d === e && (n.charCodeAt(o) === 62 ? (d = ri,
        o++) : (d = e,
        v === 0 && w(rd))),
        d !== e ? (G(),
        y = ul(),
        y !== e ? (le = s,
        s = wO(u, c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        Qe(),
        u = LI(),
        u !== e ? (G(),
        c = ul(),
        c !== e ? (le = s,
        s = EO(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e))),
        s
    }
    function AI() {
        var s, u, c;
        return s = o,
        u = ul(),
        u !== e ? (c = SI(),
        c === e && (c = null),
        le = s,
        s = _O(u, c)) : (o = s,
        s = e),
        s
    }
    function Sg() {
        var s;
        return s = Vx(),
        s === e && (s = mx()),
        s
    }
    function ul() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Ag(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Sg(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = Ag(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Sg(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = Ag(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = LO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function bb() {
        var s, u, c, d;
        return s = o,
        u = $g(),
        u !== e ? (G(),
        n.substr(o, 2) === Ii ? (c = Ii,
        o += 2) : (c = e,
        v === 0 && w(WC)),
        c !== e ? (G(),
        d = $g(),
        d !== e ? (le = s,
        s = SO(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function cd() {
        var s;
        return s = bb(),
        s === e && (s = $g()),
        s
    }
    function Ag() {
        var s, u, c, d, y, _, M, Y, Je, _t;
        if (s = o,
        n.charCodeAt(o) === 47 ? (u = yn,
        o++) : (u = e,
        v === 0 && w(As)),
        u !== e) {
            for (c = Qe(),
            d = o,
            y = [],
            _ = cd(); _ !== e; )
                y.push(_),
                _ = o,
                M = o,
                Y = G(),
                n.charCodeAt(o) === 58 ? (Je = qs,
                o++) : (Je = e,
                v === 0 && w(Xm)),
                Je !== e ? (_t = G(),
                Y = [Y, Je, _t],
                M = Y) : (o = M,
                M = e),
                M !== e ? (M = cd(),
                M === e ? (o = _,
                _ = e) : _ = M) : _ = M;
            y.length < 2 ? (o = d,
            d = e) : d = y,
            d !== e ? (le = s,
            s = AO(d)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        if (s === e && (s = o,
        n.charCodeAt(o) === 47 ? (u = yn,
        o++) : (u = e,
        v === 0 && w(As)),
        u !== e ? (c = Qe(),
        d = bb(),
        d !== e ? (le = s,
        s = CO(d)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e)) {
            for (s = o,
            u = o,
            c = [],
            d = cd(); d !== e; )
                c.push(d),
                d = o,
                y = o,
                _ = G(),
                n.charCodeAt(o) === 58 ? (M = qs,
                o++) : (M = e,
                v === 0 && w(Xm)),
                M !== e ? (Y = G(),
                _ = [_, M, Y],
                y = _) : (o = y,
                y = e),
                y !== e ? (y = cd(),
                y === e ? (o = d,
                d = e) : d = y) : d = y;
            c.length < 1 ? (o = u,
            u = e) : u = c,
            u !== e && (le = s,
            u = $O(u)),
            s = u
        }
        return s
    }
    function Cg() {
        var s;
        return s = Cx(),
        s === e && (s = Mx()),
        s
    }
    function $g() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Og(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Cg(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = Og(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Cg(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = Og(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = MO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Mg() {
        var s;
        return v++,
        s = n.charAt(o),
        pu.test(s) ? o++ : (s = e,
        v === 0 && w(mu)),
        s === e && (n.substr(o, 2) === Fi ? (s = Fi,
        o += 2) : (s = e,
        v === 0 && w(KC)),
        s === e && (n.charCodeAt(o) === 8853 ? (s = Jo,
        o++) : (s = e,
        v === 0 && w(ZC)),
        s === e && (n.substr(o, 2) === Ri ? (s = Ri,
        o += 2) : (s = e,
        v === 0 && w(YC)),
        s === e && (n.charCodeAt(o) === 8854 ? (s = Ko,
        o++) : (s = e,
        v === 0 && w(QC)))))),
        v--,
        s === e && v === 0 && w(JC),
        s
    }
    function Og() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Tg(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Mg(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = Tg(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Mg(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = Tg(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = OO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Ng() {
        var s;
        return s = Nx(),
        s === e && (s = Ox(),
        s === e && (s = Dx(),
        s === e && (s = Px(),
        s === e && (s = Ex())))),
        s
    }
    function Tg() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Ig(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Ng(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = Ig(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Ng(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = Ig(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = NO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function xg() {
        var s;
        return v++,
        s = n.charAt(o),
        dA.test(s) ? o++ : (s = e,
        v === 0 && w(e$)),
        s === e && (s = qx(),
        s === e && (n.charCodeAt(o) === 183 ? (s = ro,
        o++) : (s = e,
        v === 0 && w(t$)),
        s === e && (s = bx(),
        s === e && (s = $x(),
        s === e && (s = Hx(),
        s === e && (n.charCodeAt(o) === 8855 ? (s = Zo,
        o++) : (s = e,
        v === 0 && w(n$)),
        s === e && (s = kx(),
        s === e && (s = Bx())))))))),
        v--,
        s === e && v === 0 && w(XC),
        s
    }
    function Ig() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Rg(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = xg(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = Rg(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = xg(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = Rg(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = TO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Fg() {
        var s, u;
        return s = n.charAt(o),
        hA.test(s) ? o++ : (s = e,
        v === 0 && w(r$)),
        s === e && (s = o,
        u = cx(),
        u !== e ? (G(),
        s = u) : (o = s,
        s = e),
        s === e && (s = o,
        u = Ax(),
        u !== e ? (G(),
        s = u) : (o = s,
        s = e),
        s === e && (n.charCodeAt(o) === 8730 ? (s = Mr,
        o++) : (s = e,
        v === 0 && w(Ty))))),
        s
    }
    function Rg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === bs ? (u = bs,
        o += 2) : (u = e,
        v === 0 && w(xy)),
        u !== e ? (c = Su(),
        c !== e ? (le = s,
        s = xO(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = Fg(),
        u !== e ? (n.charCodeAt(o) === 126 ? (c = je,
        o++) : (c = e,
        v === 0 && w(Gt)),
        c !== e ? (d = Su(),
        d !== e ? (le = s,
        s = IO(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = Fg(),
        u === e && (u = null),
        c = Su(),
        c !== e ? (le = s,
        s = FO(u, c)) : (o = s,
        s = e))),
        s
    }
    function Pg() {
        var s;
        return v++,
        n.substr(o, 2) === so ? (s = so,
        o += 2) : (s = e,
        v === 0 && w(i$)),
        s === e && (n.charCodeAt(o) === 94 ? (s = Bt,
        o++) : (s = e,
        v === 0 && w(td)),
        s === e && (n.substr(o, 2) === Bs ? (s = Bs,
        o += 2) : (s = e,
        v === 0 && w(o$)),
        s === e && (n.substr(o, 2) === io ? (s = io,
        o += 2) : (s = e,
        v === 0 && w(a$))))),
        v--,
        s === e && v === 0 && w(s$),
        s
    }
    function Su() {
        var s, u, c, d, y, _, M, Y, Je;
        if (s = o,
        u = CI(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Pg(),
            _ !== e ? (M = o,
            v++,
            Y = Wg(),
            Y === e && (Y = pd()),
            v--,
            Y === e ? M = void 0 : (o = M,
            M = e),
            M !== e ? (n.charCodeAt(o) === 126 ? (Y = je,
            o++) : (Y = e,
            v === 0 && w(Gt)),
            Y === e && (Y = null),
            G(),
            Je = Su(),
            Je !== e ? d = [y, _, Y, Je] : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Pg(),
                _ !== e ? (M = o,
                v++,
                Y = Wg(),
                Y === e && (Y = pd()),
                v--,
                Y === e ? M = void 0 : (o = M,
                M = e),
                M !== e ? (n.charCodeAt(o) === 126 ? (Y = je,
                o++) : (Y = e,
                v === 0 && w(Gt)),
                Y === e && (Y = null),
                G(),
                Je = Su(),
                Je !== e ? d = [y, _, Y, Je] : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = RO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Dg() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        n.charCodeAt(o) === 47 ? (u = yn,
        o++) : (u = e,
        v === 0 && w(As)),
        u !== e ? (c = o,
        v++,
        n.charCodeAt(o) === 47 ? (d = yn,
        o++) : (d = e,
        v === 0 && w(As)),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = o,
        v++,
        n.charCodeAt(o) === 45 ? (y = oo,
        o++) : (y = e,
        v === 0 && w(Iy)),
        v--,
        y === e ? d = void 0 : (o = d,
        d = e),
        d !== e ? (y = o,
        v++,
        n.charCodeAt(o) === 43 ? (_ = ks,
        o++) : (_ = e,
        v === 0 && w(Fy)),
        v--,
        _ === e ? y = void 0 : (o = y,
        y = e),
        y !== e ? (_ = o,
        v++,
        n.charCodeAt(o) === 95 ? (M = Pi,
        o++) : (M = e,
        v === 0 && w(l$)),
        v--,
        M === e ? _ = void 0 : (o = _,
        _ = e),
        _ !== e ? (M = o,
        v++,
        n.charCodeAt(o) === 94 ? (Y = Bt,
        o++) : (Y = e,
        v === 0 && w(td)),
        v--,
        Y === e ? M = void 0 : (o = M,
        M = e),
        M !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function CI() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = fd(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            _ = Dg(),
            _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
            o++) : (M = e,
            v === 0 && w(Gt)),
            M === e && (M = null),
            G(),
            Y = fd(),
            Y !== e ? d = [y, _, M, Y] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                _ = Dg(),
                _ !== e ? (n.charCodeAt(o) === 126 ? (M = je,
                o++) : (M = e,
                v === 0 && w(Gt)),
                M === e && (M = null),
                G(),
                Y = fd(),
                Y !== e ? d = [y, _, M, Y] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = PO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function $I() {
        var s;
        return s = n.charAt(o),
        pA.test(s) ? o++ : (s = e,
        v === 0 && w(u$)),
        s === e && (s = ib(),
        s === e && (n.charCodeAt(o) === 92 ? (s = ls,
        o++) : (s = e,
        v === 0 && w(tl)),
        s === e && (s = wx()))),
        s
    }
    function fd() {
        var s, u, c, d;
        return s = o,
        u = Fg(),
        u !== e ? (n.charCodeAt(o) === 126 ? (c = je,
        o++) : (c = e,
        v === 0 && w(Gt)),
        c === e && (c = null),
        d = qg(),
        d !== e ? (le = s,
        s = DO(u, c, d)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = $I(),
        u !== e ? (c = Qe(),
        d = qg(),
        d === e && (d = fd()),
        d !== e ? (le = s,
        s = qO(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        n.substr(o, 2) === bs ? (u = bs,
        o += 2) : (u = e,
        v === 0 && w(xy)),
        u === e && (n.substr(o, 2) === ao ? (u = ao,
        o += 2) : (u = e,
        v === 0 && w(c$)),
        u === e && (n.charCodeAt(o) === 43 ? (u = ks,
        o++) : (u = e,
        v === 0 && w(Fy)))),
        u === e && (u = null),
        c = qg(),
        c !== e ? (le = s,
        s = BO(u, c)) : (o = s,
        s = e))),
        s
    }
    function qg() {
        var s, u, c, d, y, _, M;
        if (s = o,
        u = Bg(),
        u !== e) {
            for (c = [],
            d = o,
            y = vd(),
            y !== e ? (Qe(),
            _ = o,
            v++,
            n.charCodeAt(o) === 60 ? (M = as,
            o++) : (M = e,
            v === 0 && w(oa)),
            v--,
            M === e ? _ = void 0 : (o = _,
            _ = e),
            _ !== e ? (M = Bg(),
            M !== e ? d = [y, M] : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                y = vd(),
                y !== e ? (Qe(),
                _ = o,
                v++,
                n.charCodeAt(o) === 60 ? (M = as,
                o++) : (M = e,
                v === 0 && w(oa)),
                v--,
                M === e ? _ = void 0 : (o = _,
                _ = e),
                _ !== e ? (M = Bg(),
                M !== e ? d = [y, M] : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = kO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function wb() {
        var s;
        return s = OI(),
        s === e && (s = _b(),
        s === e && (s = Xn(),
        s === e && (s = Vb(),
        s === e && (s = Ob(),
        s === e && (s = Kg(),
        s === e && (s = Mb())))))),
        s
    }
    function MI() {
        var s, u, c, d, y, _;
        if (s = o,
        Qe(),
        u = zI(),
        u !== e) {
            for (c = [],
            d = o,
            y = vd(),
            y !== e ? (Qe(),
            _ = wb(),
            _ !== e ? d = [y, _] : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                y = vd(),
                y !== e ? (Qe(),
                _ = wb(),
                _ !== e ? d = [y, _] : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = zO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function cl() {
        var s, u, c;
        return s = o,
        n.substr(o, 2) === ts ? (u = ts,
        o += 2) : (u = e,
        v === 0 && w(sd)),
        u !== e ? (G(),
        n.charCodeAt(o) === 60 ? (c = as,
        o++) : (c = e,
        v === 0 && w(oa)),
        c === e && (c = null),
        le = s,
        s = VO(c)) : (o = s,
        s = e),
        s
    }
    function Eb() {
        var s, u, c, d, y, _, M, Y, Je, _t, yr, cr;
        if (s = o,
        u = o,
        c = Qe(),
        n.charCodeAt(o) === 40 ? (d = Et,
        o++) : (d = e,
        v === 0 && w(Vr)),
        d !== e ? (G(),
        y = _u(),
        G(),
        n.charCodeAt(o) === 41 ? (_ = It,
        o++) : (_ = e,
        v === 0 && w(Ur)),
        _ !== e ? u = y : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 40 ? (y = Et,
            o++) : (y = e,
            v === 0 && w(Vr)),
            y !== e ? (G(),
            _ = _u(),
            G(),
            n.charCodeAt(o) === 41 ? (M = It,
            o++) : (M = e,
            v === 0 && w(Ur)),
            M !== e ? (le = d,
            d = Zy(u, _)) : (o = d,
            d = e)) : (o = d,
            d = e),
            d === e && (d = o,
            Qe(),
            n.charCodeAt(o) === 91 ? (y = xt,
            o++) : (y = e,
            v === 0 && w(ir)),
            y !== e ? (G(),
            _ = $t(),
            _ !== e ? (G(),
            n.charCodeAt(o) === 93 ? (M = Lt,
            o++) : (M = e,
            v === 0 && w(Qn)),
            M !== e ? (le = d,
            d = Yy(u, _)) : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e),
            d === e && (d = o,
            Qe(),
            n.charCodeAt(o) === 91 ? (y = xt,
            o++) : (y = e,
            v === 0 && w(ir)),
            y !== e ? (G(),
            _ = $t(),
            _ === e && (_ = null),
            G(),
            M = o,
            n.charCodeAt(o) === 44 ? (Y = qt,
            o++) : (Y = e,
            v === 0 && w(Bn)),
            Y !== e ? (Je = G(),
            _t = $t(),
            _t !== e ? M = _t : (o = M,
            M = e)) : (o = M,
            M = e),
            M === e && (M = null),
            Y = G(),
            Je = cl(),
            Je !== e ? (_t = G(),
            yr = $t(),
            yr === e && (yr = null),
            G(),
            n.charCodeAt(o) === 93 ? (cr = Lt,
            o++) : (cr = e,
            v === 0 && w(Qn)),
            cr !== e ? (le = d,
            d = Qy(u, _, M, Je, yr)) : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e))); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 40 ? (y = Et,
                o++) : (y = e,
                v === 0 && w(Vr)),
                y !== e ? (G(),
                _ = _u(),
                G(),
                n.charCodeAt(o) === 41 ? (M = It,
                o++) : (M = e,
                v === 0 && w(Ur)),
                M !== e ? (le = d,
                d = Zy(u, _)) : (o = d,
                d = e)) : (o = d,
                d = e),
                d === e && (d = o,
                Qe(),
                n.charCodeAt(o) === 91 ? (y = xt,
                o++) : (y = e,
                v === 0 && w(ir)),
                y !== e ? (G(),
                _ = $t(),
                _ !== e ? (G(),
                n.charCodeAt(o) === 93 ? (M = Lt,
                o++) : (M = e,
                v === 0 && w(Qn)),
                M !== e ? (le = d,
                d = Yy(u, _)) : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e),
                d === e && (d = o,
                Qe(),
                n.charCodeAt(o) === 91 ? (y = xt,
                o++) : (y = e,
                v === 0 && w(ir)),
                y !== e ? (G(),
                _ = $t(),
                _ === e && (_ = null),
                G(),
                M = o,
                n.charCodeAt(o) === 44 ? (Y = qt,
                o++) : (Y = e,
                v === 0 && w(Bn)),
                Y !== e ? (Je = G(),
                _t = $t(),
                _t !== e ? M = _t : (o = M,
                M = e)) : (o = M,
                M = e),
                M === e && (M = null),
                Y = G(),
                Je = cl(),
                Je !== e ? (_t = G(),
                yr = $t(),
                yr === e && (yr = null),
                G(),
                n.charCodeAt(o) === 93 ? (cr = Lt,
                o++) : (cr = e,
                v === 0 && w(Qn)),
                cr !== e ? (le = d,
                d = Qy(u, _, M, Je, yr)) : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e)));
            le = s,
            s = UO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Bg() {
        var s, u, c;
        return s = o,
        u = kg(),
        u !== e ? (c = Eb(),
        c === e && (c = null),
        le = s,
        s = jO(u, c)) : (o = s,
        s = e),
        s
    }
    function kg() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = Lb(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 126 ? (y = je,
            o++) : (y = e,
            v === 0 && w(Gt)),
            y === e && (y = null),
            n.charCodeAt(o) === 91 ? (_ = xt,
            o++) : (_ = e,
            v === 0 && w(ir)),
            _ !== e ? (G(),
            M = $t(),
            M !== e ? (G(),
            n.charCodeAt(o) === 93 ? (Y = Lt,
            o++) : (Y = e,
            v === 0 && w(Qn)),
            Y !== e ? d = [y, M] : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 126 ? (y = je,
                o++) : (y = e,
                v === 0 && w(Gt)),
                y === e && (y = null),
                n.charCodeAt(o) === 91 ? (_ = xt,
                o++) : (_ = e,
                v === 0 && w(ir)),
                _ !== e ? (G(),
                M = $t(),
                M !== e ? (G(),
                n.charCodeAt(o) === 93 ? (Y = Lt,
                o++) : (Y = e,
                v === 0 && w(Qn)),
                Y !== e ? d = [y, M] : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = HO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function OI() {
        var s, u, c;
        return s = o,
        u = kg(),
        u !== e ? (c = Eb(),
        c !== e ? (le = s,
        s = GO(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function _b() {
        var s, u, c, d, y, _, M;
        if (s = o,
        u = Sb(),
        u !== e) {
            if (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 91 ? (y = xt,
            o++) : (y = e,
            v === 0 && w(ir)),
            y !== e ? (G(),
            _ = $t(),
            _ !== e ? (G(),
            n.charCodeAt(o) === 93 ? (M = Lt,
            o++) : (M = e,
            v === 0 && w(Qn)),
            M !== e ? d = _ : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e),
            d !== e)
                for (; d !== e; )
                    c.push(d),
                    d = o,
                    Qe(),
                    n.charCodeAt(o) === 91 ? (y = xt,
                    o++) : (y = e,
                    v === 0 && w(ir)),
                    y !== e ? (G(),
                    _ = $t(),
                    _ !== e ? (G(),
                    n.charCodeAt(o) === 93 ? (M = Lt,
                    o++) : (M = e,
                    v === 0 && w(Qn)),
                    M !== e ? d = _ : (o = d,
                    d = e)) : (o = d,
                    d = e)) : (o = d,
                    d = e);
            else
                c = e;
            c !== e ? (le = s,
            s = WO(u, c)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function Lb() {
        var s, u, c, d, y, _, M, Y, Je, _t;
        if (s = o,
        u = Sb(),
        u !== e) {
            for (c = [],
            d = o,
            Qe(),
            n.charCodeAt(o) === 91 ? (y = xt,
            o++) : (y = e,
            v === 0 && w(ir)),
            y !== e ? (G(),
            _ = $t(),
            _ === e && (_ = null),
            M = o,
            G(),
            n.charCodeAt(o) === 44 ? (Y = qt,
            o++) : (Y = e,
            v === 0 && w(Bn)),
            Y !== e ? (G(),
            Je = $t(),
            Je !== e ? M = Je : (o = M,
            M = e)) : (o = M,
            M = e),
            M === e && (M = null),
            G(),
            Y = cl(),
            Y !== e ? (G(),
            Je = $t(),
            Je === e && (Je = null),
            G(),
            n.charCodeAt(o) === 93 ? (_t = Lt,
            o++) : (_t = e,
            v === 0 && w(Qn)),
            _t !== e ? d = [_, M, Y, Je] : (o = d,
            d = e)) : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                Qe(),
                n.charCodeAt(o) === 91 ? (y = xt,
                o++) : (y = e,
                v === 0 && w(ir)),
                y !== e ? (G(),
                _ = $t(),
                _ === e && (_ = null),
                M = o,
                G(),
                n.charCodeAt(o) === 44 ? (Y = qt,
                o++) : (Y = e,
                v === 0 && w(Bn)),
                Y !== e ? (G(),
                Je = $t(),
                Je !== e ? M = Je : (o = M,
                M = e)) : (o = M,
                M = e),
                M === e && (M = null),
                G(),
                Y = cl(),
                Y !== e ? (G(),
                Je = $t(),
                Je === e && (Je = null),
                G(),
                n.charCodeAt(o) === 93 ? (_t = Lt,
                o++) : (_t = e,
                v === 0 && w(Qn)),
                _t !== e ? d = [_, M, Y, Je] : (o = d,
                d = e)) : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = JO(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function NI() {
        var s, u, c, d;
        return s = o,
        u = TI(),
        u !== e ? (c = o,
        Qe(),
        d = xI(),
        d !== e ? c = d : (o = c,
        c = e),
        c === e && (c = null),
        le = s,
        s = KO(u, c)) : (o = s,
        s = e),
        s
    }
    function TI() {
        var s;
        return s = UI(),
        s === e && (s = VI()),
        s
    }
    function xI() {
        var s;
        return s = YI(),
        s === e && (s = QI(),
        s === e && (s = ZI())),
        s
    }
    function II() {
        var s;
        return s = WI(),
        s === e && (s = KI(),
        s === e && (s = XI(),
        s === e && (s = eF(),
        s === e && (s = tF(),
        s === e && (s = jI(),
        s === e && (s = GI(),
        s === e && (s = qI()))))))),
        s
    }
    function Sb() {
        var s;
        return s = pF(),
        s === e && (s = _F(),
        s === e && (s = II(),
        s === e && (s = PI(),
        s === e && (s = DI(),
        s === e && (s = Mb(),
        s === e && (s = nF(),
        s === e && (s = rF(),
        s === e && (s = sF(),
        s === e && (s = iF(),
        s === e && (s = kI(),
        s === e && (s = BI(),
        s === e && (s = NI(),
        s === e && (s = Ob(),
        s === e && (s = hF(),
        s === e && (s = cF(),
        s === e && (s = Wg(),
        s === e && (s = pd(),
        s === e && (s = Xn(),
        s === e && (s = Vb(),
        s === e && (s = vF(),
        s === e && (s = bF(),
        s === e && (s = HI(),
        s === e && (s = yF(),
        s === e && (s = Kg())))))))))))))))))))))))),
        s
    }
    function FI() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = $t(),
        c !== e ? (G(),
        d = cl(),
        d !== e ? (G(),
        y = $t(),
        y !== e ? (G(),
        n.charCodeAt(o) === 93 ? (_ = Lt,
        o++) : (_ = e,
        v === 0 && w(Qn)),
        _ !== e ? (le = s,
        s = ZO(c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function RI() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = $t(),
        c !== e ? (G(),
        n.charCodeAt(o) === 44 ? (d = qt,
        o++) : (d = e,
        v === 0 && w(Bn)),
        d !== e ? (G(),
        y = $t(),
        y !== e ? (G(),
        _ = cl(),
        _ !== e ? (G(),
        M = $t(),
        M !== e ? (G(),
        n.charCodeAt(o) === 93 ? (Y = Lt,
        o++) : (Y = e,
        v === 0 && w(Qn)),
        Y !== e ? (le = s,
        s = YO(c, y, _, M)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function PI() {
        var s;
        return s = RI(),
        s === e && (s = FI()),
        s
    }
    function Ab() {
        var s, u, c, d, y;
        return s = o,
        G(),
        u = fg(),
        u !== e ? (G(),
        c = Vs(),
        c === e && (c = ua()),
        c !== e ? (G(),
        d = yg(),
        d !== e ? (G(),
        y = $t(),
        y !== e ? (le = s,
        s = QO(c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function DI() {
        var s, u, c, d, y, _, M, Y, Je;
        if (s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e)
            if (G(),
            c = $t(),
            c !== e) {
                if (d = [],
                y = Ab(),
                y !== e)
                    for (; y !== e; )
                        d.push(y),
                        y = Ab();
                else
                    d = e;
                d !== e ? (y = G(),
                _ = o,
                M = bu(),
                M !== e ? (Y = G(),
                Je = $t(),
                Je !== e ? _ = Je : (o = _,
                _ = e)) : (o = _,
                _ = e),
                _ === e && (_ = null),
                M = G(),
                n.charCodeAt(o) === 93 ? (Y = Lt,
                o++) : (Y = e,
                v === 0 && w(Qn)),
                Y !== e ? (le = s,
                s = XO(c, d, _)) : (o = s,
                s = e)) : (o = s,
                s = e)
            } else
                o = s,
                s = e;
        else
            o = s,
            s = e;
        return s
    }
    function qI() {
        var s, u, c, d, y;
        if (s = o,
        u = [],
        n.charCodeAt(o) === 118 ? (c = x,
        o++) : (c = e,
        v === 0 && w(eg)),
        c !== e)
            for (; c !== e; )
                u.push(c),
                n.charCodeAt(o) === 118 ? (c = x,
                o++) : (c = e,
                v === 0 && w(eg));
        else
            u = e;
        return u !== e ? (n.charCodeAt(o) === 123 ? (c = pe,
        o++) : (c = e,
        v === 0 && w(nd)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (G(),
        n.charCodeAt(o) === 125 ? (y = Pe,
        o++) : (y = e,
        v === 0 && w(ia)),
        y !== e ? (le = s,
        s = eN(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function BI() {
        var s, u, c;
        return s = o,
        u = xr(),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 176 ? (c = De,
        o++) : (c = e,
        v === 0 && w(f$)),
        c === e && (c = tw()),
        c !== e ? (le = s,
        s = tN(u)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function kI() {
        var s, u, c, d, y, _, M, Y, Je;
        return s = o,
        u = xr(),
        u !== e ? (n.charCodeAt(o) === 92 ? (c = ls,
        o++) : (c = e,
        v === 0 && w(tl)),
        c !== e ? (d = ci(),
        d !== e ? (n.charCodeAt(o) === 60 ? (y = as,
        o++) : (y = e,
        v === 0 && w(oa)),
        y !== e ? (_ = ci(),
        _ !== e ? (M = o,
        n.charCodeAt(o) === 47 ? (Y = yn,
        o++) : (Y = e,
        v === 0 && w(As)),
        Y !== e ? (Je = ci(),
        Je !== e ? M = Je : (o = M,
        M = e)) : (o = M,
        M = e),
        M === e && (M = null),
        n.charCodeAt(o) === 62 ? (Y = ri,
        o++) : (Y = e,
        v === 0 && w(rd)),
        Y !== e ? (le = s,
        s = nN(u, d, _, M)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = xr(),
        u !== e ? (n.charCodeAt(o) === 92 ? (c = ls,
        o++) : (c = e,
        v === 0 && w(tl)),
        c !== e ? (d = ci(),
        d !== e ? (le = s,
        s = rN(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function zg() {
        var s;
        return n.charCodeAt(o) === 114 ? (s = zt,
        o++) : (s = e,
        v === 0 && w(tg)),
        s === e && (s = n.charAt(o),
        s.toLowerCase() === kt ? o++ : (s = e,
        v === 0 && w(Ry)),
        s === e && (n.charCodeAt(o) === 122 ? (s = Zn,
        o++) : (s = e,
        v === 0 && w(d$)),
        s === e && (s = ""))),
        s
    }
    function zI() {
        var s, u, c, d, y, _, M;
        if (s = o,
        u = gd(),
        c = Au(),
        c === e && (c = null),
        n.charCodeAt(o) === 44 ? (d = qt,
        o++) : (d = e,
        v === 0 && w(Bn)),
        d !== e) {
            if (y = o,
            _ = [],
            M = _r(),
            M !== e)
                for (; M !== e; )
                    _.push(M),
                    M = _r();
            else
                _ = e;
            _ !== e ? y = n.substring(y, o) : y = _,
            y !== e ? (_ = Cu(),
            _ === e && (_ = null),
            M = zg(),
            M !== e ? (le = s,
            s = sN(u, c, y, _, M)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function VI() {
        var s, u, c, d, y, _;
        return s = o,
        u = Au(),
        u !== e ? (c = o,
        d = o,
        v++,
        n.substr(o, 2) === ts ? (y = ts,
        o += 2) : (y = e,
        v === 0 && w(sd)),
        v--,
        y === e ? d = void 0 : (o = d,
        d = e),
        d !== e ? (n.charCodeAt(o) === 46 ? (y = be,
        o++) : (y = e,
        v === 0 && w(go)),
        y !== e ? c = y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = null),
        d = Yg(),
        y = Cu(),
        y === e && (y = null),
        _ = zg(),
        _ !== e ? (le = s,
        s = iN(u, c, d, y, _)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = o,
        v++,
        n.substr(o, 2) === ts ? (c = ts,
        o += 2) : (c = e,
        v === 0 && w(sd)),
        v--,
        c === e ? u = void 0 : (o = u,
        u = e),
        u !== e ? (n.charCodeAt(o) === 46 ? (c = be,
        o++) : (c = e,
        v === 0 && w(go)),
        c !== e ? (d = PF(),
        d !== e ? (y = Cu(),
        y === e && (y = null),
        _ = zg(),
        _ !== e ? (le = s,
        s = oN(d, y, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function UI() {
        var s, u, c, d;
        return s = o,
        u = Au(),
        u !== e ? (n.charCodeAt(o) === 47 ? (c = yn,
        o++) : (c = e,
        v === 0 && w(As)),
        c !== e ? (d = Gb(),
        d !== e ? (le = s,
        s = aN(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function dd() {
        var s, u, c;
        for (v++,
        s = o,
        u = [],
        c = n.charAt(o),
        _y.test(c) ? o++ : (c = e,
        v === 0 && w(Py)); c !== e; )
            u.push(c),
            c = n.charAt(o),
            _y.test(c) ? o++ : (c = e,
            v === 0 && w(Py));
        return le = s,
        u = lN(),
        s = u,
        v--,
        u = e,
        v === 0 && w(h$),
        s
    }
    function jI() {
        var s, u, c, d, y, _, M, Y, Je, _t;
        return s = o,
        u = dd(),
        n.charCodeAt(o) === 91 ? (c = xt,
        o++) : (c = e,
        v === 0 && w(ir)),
        c !== e ? (G(),
        d = ew(),
        G(),
        y = n.charAt(o),
        mA.test(y) ? o++ : (y = e,
        v === 0 && w(p$)),
        y !== e ? (_ = o,
        n.charCodeAt(o) === 64 ? (M = jn,
        o++) : (M = e,
        v === 0 && w(gu)),
        M !== e ? (Y = o,
        Je = o,
        v++,
        _t = Xg(),
        v--,
        _t === e ? Je = void 0 : (o = Je,
        Je = e),
        Je !== e ? (_t = Xn(),
        _t !== e ? Y = _t : (o = Y,
        Y = e)) : (o = Y,
        Y = e),
        Y === e && (Y = tR()),
        Y !== e ? _ = Y : (o = _,
        _ = e)) : (o = _,
        _ = e),
        _ === e && (_ = null),
        le = s,
        s = uN(u, d, _)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Cb() {
        var s, u, c;
        for (s = [],
        u = dl(),
        u === e && (u = ""); u !== e; )
            s.push(u),
            u = o,
            n.charCodeAt(o) === 46 ? (c = be,
            o++) : (c = e,
            v === 0 && w(go)),
            c !== e ? (c = dl(),
            c === e && (c = ""),
            c === e ? (o = u,
            u = e) : u = c) : u = c;
        return s
    }
    function HI() {
        var s, u, c, d, y;
        return s = o,
        n.charCodeAt(o) === 64 ? (u = jn,
        o++) : (u = e,
        v === 0 && w(gu)),
        u !== e ? (c = o,
        d = o,
        v++,
        y = Tu(),
        v--,
        y === e ? d = void 0 : (o = d,
        d = e),
        d !== e ? (y = Xn(),
        y !== e ? c = y : (o = c,
        c = e)) : (o = c,
        c = e),
        c === e && (c = sw()),
        c !== e ? (le = s,
        s = cN(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function GI() {
        var s, u, c, d, y, _, M, Y, Je;
        return s = o,
        u = n.charAt(o),
        gA.test(u) ? o++ : (u = e,
        v === 0 && w(m$)),
        u !== e ? (G(),
        c = ew(),
        G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? (y = o,
        n.charCodeAt(o) === 64 ? (_ = jn,
        o++) : (_ = e,
        v === 0 && w(gu)),
        _ !== e ? (M = o,
        Y = o,
        v++,
        Je = Tu(),
        v--,
        Je === e ? Y = void 0 : (o = Y,
        Y = e),
        Y !== e ? (Je = Xn(),
        Je !== e ? M = Je : (o = M,
        M = e)) : (o = M,
        M = e),
        M === e && (M = sw()),
        M !== e ? y = M : (o = y,
        y = e)) : (o = y,
        y = e),
        y === e && (y = null),
        le = s,
        s = fN(c, y)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function WI() {
        var s, u, c, d, y, _;
        if (s = o,
        u = n.charAt(o),
        Km.test(u) ? o++ : (u = e,
        v === 0 && w(ng)),
        u === e && (u = null),
        c = xr(),
        c !== e) {
            for (d = [],
            y = n.charAt(o),
            Km.test(y) ? o++ : (y = e,
            v === 0 && w(ng)); y !== e; )
                d.push(y),
                y = n.charAt(o),
                Km.test(y) ? o++ : (y = e,
                v === 0 && w(ng));
            n.charCodeAt(o) === 64 ? (y = jn,
            o++) : (y = e,
            v === 0 && w(gu)),
            y !== e ? (_ = Xn(),
            _ === e && (_ = Cb()),
            _ !== e ? (le = s,
            s = dN(u, c, d, _)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function $b() {
        var s, u, c;
        if (s = o,
        u = [],
        c = n.charAt(o),
        Ly.test(c) ? o++ : (c = e,
        v === 0 && w(Dy)),
        c !== e)
            for (; c !== e; )
                u.push(c),
                c = n.charAt(o),
                Ly.test(c) ? o++ : (c = e,
                v === 0 && w(Dy));
        else
            u = e;
        if (u !== e ? (c = dl(),
        c !== e ? (le = s,
        s = hN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e) {
            for (s = o,
            u = [],
            c = n.charAt(o),
            Sy.test(c) ? o++ : (c = e,
            v === 0 && w(qy)); c !== e; )
                u.push(c),
                c = n.charAt(o),
                Sy.test(c) ? o++ : (c = e,
                v === 0 && w(qy));
            c = dl(),
            c !== e ? (le = s,
            s = pN(u, c)) : (o = s,
            s = e)
        }
        return s
    }
    function JI() {
        var s, u, c, d, y, _;
        for (s = [],
        u = $b(); u !== e; )
            s.push(u),
            u = o,
            c = o,
            d = G(),
            n.charCodeAt(o) === 44 ? (y = qt,
            o++) : (y = e,
            v === 0 && w(Bn)),
            y !== e ? (_ = G(),
            d = [d, y, _],
            c = d) : (o = c,
            c = e),
            c !== e ? (c = $b(),
            c === e ? (o = u,
            u = e) : u = c) : u = c;
        return s
    }
    function KI() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        u = o,
        n.charCodeAt(o) === 91 ? (c = xt,
        o++) : (c = e,
        v === 0 && w(ir)),
        c !== e ? (d = dl(),
        d !== e ? (n.charCodeAt(o) === 93 ? (y = Lt,
        o++) : (y = e,
        v === 0 && w(Qn)),
        y !== e ? u = d : (o = u,
        u = e)) : (o = u,
        u = e)) : (o = u,
        u = e),
        u === e && (u = null),
        c = xr(),
        c !== e ? (d = o,
        n.charCodeAt(o) === 91 ? (y = xt,
        o++) : (y = e,
        v === 0 && w(ir)),
        y !== e ? (_ = G(),
        M = JI(),
        G(),
        n.charCodeAt(o) === 93 ? (Y = Lt,
        o++) : (Y = e,
        v === 0 && w(Qn)),
        Y !== e ? d = M : (o = d,
        d = e)) : (o = d,
        d = e),
        d === e && (d = null),
        n.charCodeAt(o) === 64 ? (y = jn,
        o++) : (y = e,
        v === 0 && w(gu)),
        y !== e ? (_ = Xn(),
        _ === e && (_ = Cb()),
        _ !== e ? (le = s,
        s = mN(u, c, d, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function ZI() {
        var s, u, c;
        return s = o,
        n.charCodeAt(o) === 114 ? (u = zt,
        o++) : (u = e,
        v === 0 && w(tg)),
        u === e && (u = null),
        c = XF(),
        c === e && (n.charCodeAt(o) === 162 ? (c = _n,
        o++) : (c = e,
        v === 0 && w(g$))),
        c !== e ? (le = s,
        s = gN(u)) : (o = s,
        s = e),
        s
    }
    function YI() {
        var s, u, c;
        return s = o,
        u = Qg(),
        u !== e && (le = s,
        u = vN()),
        s = u,
        s === e && (s = o,
        u = jb(),
        u === e && (u = Ub()),
        u === e && (u = null),
        c = nw(),
        c === e && (c = Qg()),
        c !== e ? (le = s,
        s = yN(u)) : (o = s,
        s = e)),
        s
    }
    function QI() {
        var s, u, c;
        return s = o,
        u = jb(),
        u === e && (u = Ub()),
        u === e && (u = null),
        c = rw(),
        c !== e ? (le = s,
        s = bN(u)) : (o = s,
        s = e),
        s
    }
    function XI() {
        var s, u;
        return s = o,
        n.charCodeAt(o) === 8364 ? (u = ws,
        o++) : (u = e,
        v === 0 && w(v$)),
        u !== e && (le = s,
        u = wN()),
        s = u,
        s
    }
    function eF() {
        var s, u;
        return s = o,
        n.charCodeAt(o) === 182 ? (u = an,
        o++) : (u = e,
        v === 0 && w(y$)),
        u !== e && (le = s,
        u = EN()),
        s = u,
        s
    }
    function tF() {
        var s, u;
        return s = o,
        n.substr(o, 2) === fn ? (u = fn,
        o += 2) : (u = e,
        v === 0 && w(b$)),
        u === e && (u = Rx()),
        u !== e && (le = s,
        u = _N()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 163 ? (u = lo,
        o++) : (u = e,
        v === 0 && w(w$)),
        u === e && (u = Fx()),
        u !== e && (le = s,
        u = LN()),
        s = u),
        s
    }
    function Mb() {
        var s, u;
        return s = o,
        u = ob(),
        u !== e && (le = s,
        u = SN()),
        s = u,
        s
    }
    function nF() {
        var s, u;
        return s = o,
        u = Ux(),
        u !== e && (le = s,
        u = AN()),
        s = u,
        s
    }
    function rF() {
        var s, u;
        return s = o,
        u = _x(),
        u !== e && (le = s,
        u = CN()),
        s = u,
        s
    }
    function sF() {
        var s, u;
        return s = o,
        u = xx(),
        u !== e && (le = s,
        u = $N()),
        s = u,
        s
    }
    function iF() {
        var s, u;
        return s = o,
        u = Sx(),
        u !== e && (le = s,
        u = MN()),
        s = u,
        s
    }
    function Ob() {
        var s, u, c, d, y, _, M, Y, Je, _t, yr, cr, yo, xu;
        return s = o,
        u = o,
        c = kF(),
        c !== e ? u = c : (o = u,
        u = e),
        u === e && (u = o,
        c = BF(),
        c !== e ? u = c : (o = u,
        u = e)),
        u !== e && (le = s,
        u = ON(u)),
        s = u,
        s === e && (s = o,
        n.substr(o, 3) === si ? (u = si,
        o += 3) : (u = e,
        v === 0 && w(E$)),
        u !== e ? (n.charCodeAt(o) === 97 ? (c = Es,
        o++) : (c = e,
        v === 0 && w(By)),
        c === e && (c = null),
        n.charCodeAt(o) === 40 ? (d = Et,
        o++) : (d = e,
        v === 0 && w(Vr)),
        d !== e ? (Qe(),
        y = vo(),
        y !== e ? (n.charCodeAt(o) === 37 ? o++ : v === 0 && w(aa),
        Qe(),
        _ = vo(),
        _ !== e ? (n.charCodeAt(o) === 37 ? o++ : v === 0 && w(aa),
        Qe(),
        M = vo(),
        M !== e ? (n.charCodeAt(o) === 37 ? o++ : v === 0 && w(aa),
        Y = o,
        Je = Qe(),
        n.charCodeAt(o) === 47 ? (_t = yn,
        o++) : (_t = e,
        v === 0 && w(As)),
        _t !== e ? (yr = Qe(),
        cr = Qe(),
        yo = vo(),
        yo !== e ? (n.charCodeAt(o) === 37 ? (xu = Di,
        o++) : (xu = e,
        v === 0 && w(aa)),
        xu === e && (xu = null),
        Je = [Je, _t, yr, cr, yo, xu],
        Y = Je) : (o = Y,
        Y = e)) : (o = Y,
        Y = e),
        Y === e && (Y = null),
        Je = Qe(),
        n.charCodeAt(o) === 41 ? (_t = It,
        o++) : (_t = e,
        v === 0 && w(Ur)),
        _t !== e ? (le = s,
        s = NN()) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        n.substr(o, 3) === ii ? (u = ii,
        o += 3) : (u = e,
        v === 0 && w(_$)),
        u !== e ? (n.charCodeAt(o) === 97 ? (c = Es,
        o++) : (c = e,
        v === 0 && w(By)),
        c === e && (c = null),
        n.charCodeAt(o) === 40 ? (d = Et,
        o++) : (d = e,
        v === 0 && w(Vr)),
        d !== e ? (Qe(),
        y = vo(),
        y !== e ? (n.substr(o, 3) === it ? o += 3 : v === 0 && w(ky),
        Qe(),
        _ = vo(),
        _ !== e ? (n.charCodeAt(o) === 37 ? o++ : v === 0 && w(aa),
        Qe(),
        M = vo(),
        M !== e ? (n.charCodeAt(o) === 37 ? o++ : v === 0 && w(aa),
        Y = o,
        Je = Qe(),
        n.charCodeAt(o) === 47 ? (_t = yn,
        o++) : (_t = e,
        v === 0 && w(As)),
        _t !== e ? (yr = Qe(),
        cr = vo(),
        cr !== e ? (n.charCodeAt(o) === 37 ? (yo = Di,
        o++) : (yo = e,
        v === 0 && w(aa)),
        yo === e && (yo = null),
        Je = [Je, _t, yr, cr, yo],
        Y = Je) : (o = Y,
        Y = e)) : (o = Y,
        Y = e),
        Y === e && (Y = null),
        Je = Qe(),
        n.charCodeAt(o) === 41 ? (_t = It,
        o++) : (_t = e,
        v === 0 && w(Ur)),
        _t !== e ? (le = s,
        s = TN()) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e))),
        s
    }
    function Vg() {
        var s;
        return v++,
        s = n.charAt(o),
        vA.test(s) ? o++ : (s = e,
        v === 0 && w(S$)),
        s === e && (s = ""),
        v--,
        s === e && v === 0 && w(L$),
        s
    }
    function Ug() {
        var s;
        return n.substr(o, 3) === uo ? (s = uo,
        o += 3) : (s = e,
        v === 0 && w(A$)),
        s === e && (n.charCodeAt(o) === 100 ? (s = cu,
        o++) : (s = e,
        v === 0 && w(C$))),
        s
    }
    function Nb() {
        var s;
        return n.substr(o, 3) === he ? (s = he,
        o += 3) : (s = e,
        v === 0 && w(My)),
        s === e && (n.charCodeAt(o) === 109 ? (s = Ba,
        o++) : (s = e,
        v === 0 && w($$))),
        s
    }
    function jg() {
        var s;
        return n.substr(o, 3) === ka ? (s = ka,
        o += 3) : (s = e,
        v === 0 && w(M$)),
        s === e && (n.charCodeAt(o) === 110 ? (s = $,
        o++) : (s = e,
        v === 0 && w(zy))),
        s
    }
    function Tb() {
        var s;
        return v++,
        n.substr(o, 3) === en ? (s = en,
        o += 3) : (s = e,
        v === 0 && w(N$)),
        s === e && (n.substr(o, 3) === _s ? (s = _s,
        o += 3) : (s = e,
        v === 0 && w(T$)),
        s === e && (n.charCodeAt(o) === 77 ? (s = Or,
        o++) : (s = e,
        v === 0 && w(x$)))),
        v--,
        s === e && v === 0 && w(O$),
        s
    }
    function ca() {
        var s;
        return v++,
        n.substr(o, 3) === oi ? (s = oi,
        o += 3) : (s = e,
        v === 0 && w(F$)),
        s === e && (n.substr(o, 3) === we ? (s = we,
        o += 3) : (s = e,
        v === 0 && w(R$)),
        s === e && (s = n.charAt(o),
        yA.test(s) ? o++ : (s = e,
        v === 0 && w(P$)))),
        v--,
        s === e && v === 0 && w(I$),
        s
    }
    function xb() {
        var s, u, c;
        return s = o,
        u = Vg(),
        u !== e ? (c = Ug(),
        c === e && (c = ca()),
        c !== e ? (le = s,
        s = xN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ib() {
        var s, u, c;
        return s = o,
        u = jg(),
        u !== e && (le = s,
        u = IN(u)),
        s = u,
        s === e && (s = o,
        u = Vg(),
        u !== e ? (c = Tb(),
        c === e && (c = Nb()),
        c !== e ? (le = s,
        s = FN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function oF() {
        var s, u;
        return s = o,
        n.charCodeAt(o) === 80 ? (u = Ls,
        o++) : (u = e,
        v === 0 && w(rg)),
        u === e && (u = jg()),
        u !== e && (le = s,
        u = RN(u)),
        s = u,
        s
    }
    function Fb() {
        var s, u;
        return s = o,
        n.charCodeAt(o) === 80 ? (u = Ls,
        o++) : (u = e,
        v === 0 && w(rg)),
        u !== e && (le = s,
        u = PN()),
        s = u,
        s
    }
    function Hg() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 45 ? (u = oo,
        o++) : (u = e,
        v === 0 && w(Iy)),
        u === e && (u = null),
        c = ci(),
        c !== e ? (n.charCodeAt(o) === 189 ? (d = fu,
        o++) : (d = e,
        v === 0 && w(D$)),
        d === e && (n.substr(o, 2) === co ? (d = co,
        o += 2) : (d = e,
        v === 0 && w(q$))),
        d === e && (d = null),
        le = s,
        s = DN(u, c, d)) : (o = s,
        s = e),
        s
    }
    function Rb() {
        var s, u, c;
        return s = o,
        u = Hg(),
        u !== e ? (le = o,
        c = qN(u),
        c ? c = void 0 : c = e,
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function aF() {
        var s, u, c;
        return s = o,
        u = Hg(),
        u !== e ? (le = o,
        c = BN(u),
        c ? c = void 0 : c = e,
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Pb() {
        var s, u, c;
        return s = o,
        u = Hg(),
        u !== e ? (le = o,
        c = kN(u),
        c ? c = void 0 : c = e,
        c !== e ? (le = s,
        s = zN(u)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function lF() {
        var s, u, c, d;
        if (s = o,
        u = xb(),
        u !== e) {
            for (c = [],
            d = ca(); d !== e; )
                c.push(d),
                d = ca();
            d = Pb(),
            d === e && (d = Rb()),
            d !== e ? (le = s,
            s = VN(u, c, d)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s === e && (s = o,
        u = Ib(),
        u !== e ? (c = Pb(),
        c !== e ? (le = s,
        s = UN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = oF(),
        u !== e ? (c = aF(),
        c !== e ? (le = s,
        s = jN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = Fb(),
        u !== e ? (c = Rb(),
        c !== e ? (le = s,
        s = HN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e)))),
        s
    }
    function uF() {
        var s, u, c, d, y;
        if (s = o,
        u = xb(),
        u !== e) {
            for (c = [],
            d = ca(); d !== e; )
                c.push(d),
                d = ca();
            d = fl(),
            d !== e ? (n.substr(o, 2) === tn ? (y = tn,
            o += 2) : (y = e,
            v === 0 && w(sg)),
            y !== e ? (le = s,
            s = GN(u, c, d)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s === e && (s = o,
        u = Ib(),
        u === e && (u = Fb()),
        u !== e ? (c = fl(),
        c !== e ? (n.substr(o, 2) === tn ? (d = tn,
        o += 2) : (d = e,
        v === 0 && w(sg)),
        d !== e ? (le = s,
        s = WN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function Db() {
        var s;
        return s = n.charAt(o),
        bA.test(s) ? o++ : (s = e,
        v === 0 && w(B$)),
        s === e && (s = ""),
        s
    }
    function qb() {
        var s, u, c, d, y;
        for (s = [],
        u = o,
        c = xr(),
        c !== e ? (d = Db(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e); u !== e; )
            s.push(u),
            u = o,
            n.charCodeAt(o) === 44 ? (c = qt,
            o++) : (c = e,
            v === 0 && w(Bn)),
            c !== e ? (c = o,
            d = xr(),
            d !== e ? (y = Db(),
            y !== e ? (d = [d, y],
            c = d) : (o = c,
            c = e)) : (o = c,
            c = e),
            c === e ? (o = u,
            u = e) : u = c) : u = c;
        return s
    }
    function Bb() {
        var s, u, c;
        return s = o,
        n.charCodeAt(o) === 94 ? (u = Bt,
        o++) : (u = e,
        v === 0 && w(td)),
        u !== e ? (c = qb(),
        le = s,
        s = JN(c)) : (o = s,
        s = e),
        s
    }
    function kb() {
        var s, u, c;
        return s = o,
        u = n.charAt(o),
        sa.test(u) ? o++ : (u = e,
        v === 0 && w(la)),
        u !== e ? (c = qb(),
        le = s,
        s = KN(c)) : (o = s,
        s = e),
        s
    }
    function Gg() {
        var s, u, c;
        for (s = o,
        u = [],
        c = Bb(),
        c === e && (c = kb()); c !== e; )
            u.push(c),
            c = Bb(),
            c === e && (c = kb());
        return le = s,
        u = ZN(u),
        s = u,
        s
    }
    function Wg() {
        var s, u, c, d;
        return s = o,
        u = dd(),
        c = lF(),
        c !== e ? (d = Gg(),
        le = s,
        s = YN(u, c, d)) : (o = s,
        s = e),
        s
    }
    function cF() {
        var s, u, c, d;
        return s = o,
        u = dd(),
        c = uF(),
        c !== e ? (d = Gg(),
        le = s,
        s = QN(u, c, d)) : (o = s,
        s = e),
        s
    }
    function fF() {
        var s;
        return n.substr(o, 2) === qn ? (s = qn,
        o += 2) : (s = e,
        v === 0 && w(k$)),
        s === e && (n.substr(o, 2) === qi ? (s = qi,
        o += 2) : (s = e,
        v === 0 && w(z$)),
        s === e && (n.substr(o, 2) === za ? (s = za,
        o += 2) : (s = e,
        v === 0 && w(V$)),
        s === e && (n.substr(o, 2) === ai ? (s = ai,
        o += 2) : (s = e,
        v === 0 && w(U$)),
        s === e && (n.substr(o, 2) === Yo ? (s = Yo,
        o += 2) : (s = e,
        v === 0 && w(j$)),
        s === e && (n.substr(o, 2) === us ? (s = us,
        o += 2) : (s = e,
        v === 0 && w(H$)),
        s === e && (n.substr(o, 2) === tt ? (s = tt,
        o += 2) : (s = e,
        v === 0 && w(G$)),
        s === e && (n.substr(o, 2) === Ss ? (s = Ss,
        o += 2) : (s = e,
        v === 0 && w(W$)),
        s === e && (n.substr(o, 2) === kr ? (s = kr,
        o += 2) : (s = e,
        v === 0 && w(J$)),
        s === e && (n.substr(o, 2) === Qo ? (s = Qo,
        o += 2) : (s = e,
        v === 0 && w(K$)),
        s === e && (s = n.charAt(o),
        wA.test(s) ? o++ : (s = e,
        v === 0 && w(Z$)))))))))))),
        s
    }
    function hd() {
        var s, u, c;
        return v++,
        s = o,
        u = Vg(),
        u !== e ? (c = fF(),
        c !== e ? (le = s,
        s = XN(u, c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        v--,
        s === e && (u = e,
        v === 0 && w(Y$)),
        s
    }
    function zb() {
        var s;
        return v++,
        s = n.charAt(o),
        EA.test(s) ? o++ : (s = e,
        v === 0 && w(X$)),
        s === e && (n.substr(o, 3) === Er ? (s = Er,
        o += 3) : (s = e,
        v === 0 && w(e3)),
        s === e && (n.substr(o, 3) === Xo ? (s = Xo,
        o += 3) : (s = e,
        v === 0 && w(t3)),
        s === e && (n.substr(o, 3) === Va ? (s = Va,
        o += 3) : (s = e,
        v === 0 && w(n3)),
        s === e && (n.substr(o, 3) === B ? (s = B,
        o += 3) : (s = e,
        v === 0 && w(Cy)),
        s === e && (n.substr(o, 3) === rr ? (s = rr,
        o += 3) : (s = e,
        v === 0 && w(r3)),
        s === e && (n.substr(o, 3) === Ua ? (s = Ua,
        o += 3) : (s = e,
        v === 0 && w(s3)),
        s === e && (n.substr(o, 3) === ja ? (s = ja,
        o += 3) : (s = e,
        v === 0 && w(i3)),
        s === e && (n.substr(o, 3) === Ha ? (s = Ha,
        o += 3) : (s = e,
        v === 0 && w(o3)),
        s === e && (n.substr(o, 3) === Ga ? (s = Ga,
        o += 3) : (s = e,
        v === 0 && w(a3)),
        s === e && (n.substr(o, 3) === li ? (s = li,
        o += 3) : (s = e,
        v === 0 && w(l3)),
        s === e && (n.substr(o, 3) === ea ? (s = ea,
        o += 3) : (s = e,
        v === 0 && w(u3)),
        s === e && (n.substr(o, 3) === Bi ? (s = Bi,
        o += 3) : (s = e,
        v === 0 && w(c3)),
        s === e && (n.substr(o, 3) === Wa ? (s = Wa,
        o += 3) : (s = e,
        v === 0 && w(f3)),
        s === e && (n.substr(o, 3) === ta ? (s = ta,
        o += 3) : (s = e,
        v === 0 && w(d3)),
        s === e && (n.substr(o, 3) === fo ? (s = fo,
        o += 3) : (s = e,
        v === 0 && w(h3)),
        s === e && (n.substr(o, 3) === Ja ? (s = Ja,
        o += 3) : (s = e,
        v === 0 && w(p3)),
        s === e && (n.substr(o, 3) === Ka ? (s = Ka,
        o += 3) : (s = e,
        v === 0 && w(m3)),
        s === e && (n.substr(o, 3) === na ? (s = na,
        o += 3) : (s = e,
        v === 0 && w(g3)),
        s === e && (n.substr(o, 3) === ki ? (s = ki,
        o += 3) : (s = e,
        v === 0 && w(v3)),
        s === e && (n.substr(o, 3) === ho ? (s = ho,
        o += 3) : (s = e,
        v === 0 && w(y3)),
        s === e && (n.substr(o, 3) === ra ? (s = ra,
        o += 3) : (s = e,
        v === 0 && w(b3)),
        s === e && (n.substr(o, 3) === Za ? (s = Za,
        o += 3) : (s = e,
        v === 0 && w(w3)),
        s === e && (n.substr(o, 3) === O ? (s = O,
        o += 3) : (s = e,
        v === 0 && w(E3)),
        s === e && (n.substr(o, 3) === U ? (s = U,
        o += 3) : (s = e,
        v === 0 && w(_3)),
        s === e && (n.substr(o, 3) === ee ? (s = ee,
        o += 3) : (s = e,
        v === 0 && w(L3))))))))))))))))))))))))))),
        v--,
        s === e && v === 0 && w(Q$),
        s
    }
    function dF() {
        var s, u, c, d, y;
        for (s = o,
        u = o,
        c = o,
        d = [],
        y = n.charAt(o),
        Qf.test(y) ? o++ : (y = e,
        v === 0 && w(id)); y !== e; )
            d.push(y),
            y = n.charAt(o),
            Qf.test(y) ? o++ : (y = e,
            v === 0 && w(id));
        if (d.length < 2 ? (o = c,
        c = e) : c = d,
        c !== e ? u = n.substring(u, o) : u = c,
        u !== e) {
            if (c = [],
            d = hd(),
            d !== e)
                for (; d !== e; )
                    c.push(d),
                    d = hd();
            else
                c = e;
            c !== e ? (d = fl(),
            d !== e ? (le = s,
            s = eT(u, c, d)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        if (s === e)
            if (s = o,
            u = zb(),
            u !== e) {
                for (c = [],
                d = hd(); d !== e; )
                    c.push(d),
                    d = hd();
                d = fl(),
                d !== e ? (le = s,
                s = tT(u, c, d)) : (o = s,
                s = e)
            } else
                o = s,
                s = e;
        return s
    }
    function pd() {
        var s, u, c, d;
        return s = o,
        u = dd(),
        c = dF(),
        c !== e ? (d = Gg(),
        le = s,
        s = nT(u, c, d)) : (o = s,
        s = e),
        s
    }
    function hF() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 83 ? (u = oe,
        o++) : (u = e,
        v === 0 && w(S3)),
        u !== e ? (c = Au(),
        c !== e ? (d = o,
        n.substr(o, 2) === ts ? (y = ts,
        o += 2) : (y = e,
        v === 0 && w(sd)),
        y !== e ? (_ = Au(),
        _ !== e ? d = _ : (o = d,
        d = e)) : (o = d,
        d = e),
        d === e && (d = null),
        le = s,
        s = rT(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function pF() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 40 ? (u = Et,
        o++) : (u = e,
        v === 0 && w(Vr)),
        u !== e ? (G(),
        c = ud(),
        G(),
        n.charCodeAt(o) === 41 ? (d = It,
        o++) : (d = e,
        v === 0 && w(Ur)),
        d !== e ? (G(),
        n.substr(o, 2) === ve ? (y = ve,
        o += 2) : (y = e,
        v === 0 && w(Vy)),
        y !== e ? (G(),
        _ = $t(),
        _ !== e ? (le = s,
        s = sT(c, _)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = hb(),
        u !== e ? (G(),
        n.substr(o, 2) === ve ? (c = ve,
        o += 2) : (c = e,
        v === 0 && w(Vy)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (le = s,
        s = iT(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function mF() {
        var s, u, c, d, y, _, M, Y, Je;
        if (s = o,
        u = n.charAt(o),
        _A.test(u) ? o++ : (u = e,
        v === 0 && w(A3)),
        u === e && (u = null),
        c = [],
        d = Ug(),
        d !== e)
            for (; d !== e; )
                c.push(d),
                d = Ug();
        else
            c = e;
        if (c === e) {
            if (c = [],
            d = ca(),
            d !== e)
                for (; d !== e; )
                    c.push(d),
                    d = ca();
            else
                c = e;
            c === e && (c = Tb(),
            c === e && (c = Nb(),
            c === e && (c = jg(),
            c === e && (n.charCodeAt(o) === 80 ? (c = Ls,
            o++) : (c = e,
            v === 0 && w(rg))))))
        }
        if (c !== e) {
            if (d = [],
            y = n.charAt(o),
            Nr.test(y) ? o++ : (y = e,
            v === 0 && w(Tr)),
            y !== e)
                for (; y !== e; )
                    d.push(y),
                    y = n.charAt(o),
                    Nr.test(y) ? o++ : (y = e,
                    v === 0 && w(Tr));
            else
                d = e;
            if (d !== e) {
                for (n.substr(o, 2) === tn ? (y = tn,
                o += 2) : (y = e,
                v === 0 && w(sg)),
                y === e && (y = null),
                _ = [],
                M = o,
                Y = n.charAt(o),
                sa.test(Y) ? o++ : (Y = e,
                v === 0 && w(la)),
                Y !== e ? (Je = n.charAt(o),
                Nr.test(Je) ? o++ : (Je = e,
                v === 0 && w(Tr)),
                Je !== e ? (Y = [Y, Je],
                M = Y) : (o = M,
                M = e)) : (o = M,
                M = e); M !== e; )
                    _.push(M),
                    M = o,
                    Y = n.charAt(o),
                    sa.test(Y) ? o++ : (Y = e,
                    v === 0 && w(la)),
                    Y !== e ? (Je = n.charAt(o),
                    Nr.test(Je) ? o++ : (Je = e,
                    v === 0 && w(Tr)),
                    Je !== e ? (Y = [Y, Je],
                    M = Y) : (o = M,
                    M = e)) : (o = M,
                    M = e);
                u = [u, c, d, y, _],
                s = u
            } else
                o = s,
                s = e
        } else
            o = s,
            s = e;
        if (s === e) {
            for (s = o,
            u = o,
            c = [],
            d = n.charAt(o),
            Qf.test(d) ? o++ : (d = e,
            v === 0 && w(id)); d !== e; )
                c.push(d),
                d = n.charAt(o),
                Qf.test(d) ? o++ : (d = e,
                v === 0 && w(id));
            if (c.length < 2 ? (o = u,
            u = e) : u = c,
            u !== e) {
                if (c = [],
                d = n.charAt(o),
                Xf.test(d) ? o++ : (d = e,
                v === 0 && w(od)),
                d !== e)
                    for (; d !== e; )
                        c.push(d),
                        d = n.charAt(o),
                        Xf.test(d) ? o++ : (d = e,
                        v === 0 && w(od));
                else
                    c = e;
                if (c !== e) {
                    if (d = [],
                    y = n.charAt(o),
                    Nr.test(y) ? o++ : (y = e,
                    v === 0 && w(Tr)),
                    y !== e)
                        for (; y !== e; )
                            d.push(y),
                            y = n.charAt(o),
                            Nr.test(y) ? o++ : (y = e,
                            v === 0 && w(Tr));
                    else
                        d = e;
                    if (d !== e) {
                        for (y = [],
                        _ = o,
                        M = n.charAt(o),
                        sa.test(M) ? o++ : (M = e,
                        v === 0 && w(la)),
                        M !== e ? (Y = n.charAt(o),
                        Nr.test(Y) ? o++ : (Y = e,
                        v === 0 && w(Tr)),
                        Y !== e ? (M = [M, Y],
                        _ = M) : (o = _,
                        _ = e)) : (o = _,
                        _ = e); _ !== e; )
                            y.push(_),
                            _ = o,
                            M = n.charAt(o),
                            sa.test(M) ? o++ : (M = e,
                            v === 0 && w(la)),
                            M !== e ? (Y = n.charAt(o),
                            Nr.test(Y) ? o++ : (Y = e,
                            v === 0 && w(Tr)),
                            Y !== e ? (M = [M, Y],
                            _ = M) : (o = _,
                            _ = e)) : (o = _,
                            _ = e);
                        u = [u, c, d, y],
                        s = u
                    } else
                        o = s,
                        s = e
                } else
                    o = s,
                    s = e
            } else
                o = s,
                s = e;
            if (s === e)
                if (s = o,
                u = zb(),
                u !== e) {
                    for (c = [],
                    d = n.charAt(o),
                    Xf.test(d) ? o++ : (d = e,
                    v === 0 && w(od)); d !== e; )
                        c.push(d),
                        d = n.charAt(o),
                        Xf.test(d) ? o++ : (d = e,
                        v === 0 && w(od));
                    if (d = [],
                    y = n.charAt(o),
                    Nr.test(y) ? o++ : (y = e,
                    v === 0 && w(Tr)),
                    y !== e)
                        for (; y !== e; )
                            d.push(y),
                            y = n.charAt(o),
                            Nr.test(y) ? o++ : (y = e,
                            v === 0 && w(Tr));
                    else
                        d = e;
                    if (d !== e) {
                        for (y = [],
                        _ = o,
                        M = n.charAt(o),
                        sa.test(M) ? o++ : (M = e,
                        v === 0 && w(la)),
                        M !== e ? (Y = n.charAt(o),
                        Nr.test(Y) ? o++ : (Y = e,
                        v === 0 && w(Tr)),
                        Y !== e ? (M = [M, Y],
                        _ = M) : (o = _,
                        _ = e)) : (o = _,
                        _ = e); _ !== e; )
                            y.push(_),
                            _ = o,
                            M = n.charAt(o),
                            sa.test(M) ? o++ : (M = e,
                            v === 0 && w(la)),
                            M !== e ? (Y = n.charAt(o),
                            Nr.test(Y) ? o++ : (Y = e,
                            v === 0 && w(Tr)),
                            Y !== e ? (M = [M, Y],
                            _ = M) : (o = _,
                            _ = e)) : (o = _,
                            _ = e);
                        u = [u, c, d, y],
                        s = u
                    } else
                        o = s,
                        s = e
                } else
                    o = s,
                    s = e
        }
        return s
    }
    function gF() {
        var s, u, c;
        return s = o,
        u = zF(),
        u !== e ? (le = o,
        c = oT(u),
        c ? c = void 0 : c = e,
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Xn() {
        var s, u, c, d;
        return s = o,
        u = o,
        v++,
        c = Qb(),
        v--,
        c !== e ? (o = u,
        u = void 0) : u = e,
        u !== e ? (c = o,
        v++,
        d = mF(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = gF(),
        d !== e ? (le = s,
        s = aT(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Vb() {
        var s, u, c;
        return s = o,
        n.charCodeAt(o) === 165 ? (u = Ne,
        o++) : (u = e,
        v === 0 && w(C3)),
        u !== e ? (c = xr(),
        c !== e ? (le = s,
        s = lT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function vF() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 91 ? (u = xt,
        o++) : (u = e,
        v === 0 && w(ir)),
        u !== e ? (G(),
        c = _u(),
        G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? (le = s,
        s = uT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function yF() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === Tn ? (u = Tn,
        o += 2) : (u = e,
        v === 0 && w($3)),
        u !== e ? (G(),
        c = _u(),
        G(),
        n.charCodeAt(o) === 93 ? (d = Lt,
        o++) : (d = e,
        v === 0 && w(Qn)),
        d !== e ? (le = s,
        s = cT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function bF() {
        var s, u, c, d, y, _;
        return s = o,
        n.substr(o, 2) === dn ? (u = dn,
        o += 2) : (u = e,
        v === 0 && w(Uy)),
        u !== e ? (G(),
        n.charCodeAt(o) === 125 ? (c = Pe,
        o++) : (c = e,
        v === 0 && w(ia)),
        c !== e ? (le = s,
        s = fT()) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        n.substr(o, 2) === dn ? (u = dn,
        o += 2) : (u = e,
        v === 0 && w(Uy)),
        u !== e ? (G(),
        c = wF(),
        c !== e ? (G(),
        d = o,
        n.charCodeAt(o) === 44 ? (y = qt,
        o++) : (y = e,
        v === 0 && w(Bn)),
        y !== e ? (_ = G(),
        y = [y, _],
        d = y) : (o = d,
        d = e),
        d === e && (d = null),
        n.charCodeAt(o) === 125 ? (y = Pe,
        o++) : (y = e,
        v === 0 && w(ia)),
        y !== e ? (le = s,
        s = dT(c)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)),
        s
    }
    function wF() {
        var s, u, c, d, y, _;
        if (s = o,
        u = Jg(),
        u !== e) {
            for (c = [],
            d = o,
            G(),
            n.charCodeAt(o) === 44 ? (y = qt,
            o++) : (y = e,
            v === 0 && w(Bn)),
            y !== e ? (G(),
            _ = Jg(),
            _ !== e ? d = _ : (o = d,
            d = e)) : (o = d,
            d = e); d !== e; )
                c.push(d),
                d = o,
                G(),
                n.charCodeAt(o) === 44 ? (y = qt,
                o++) : (y = e,
                v === 0 && w(Bn)),
                y !== e ? (G(),
                _ = Jg(),
                _ !== e ? d = _ : (o = d,
                d = e)) : (o = d,
                d = e);
            le = s,
            s = hT(u, c)
        } else
            o = s,
            s = e;
        return s
    }
    function Jg() {
        var s, u, c, d;
        return s = o,
        u = EF(),
        u !== e ? (G(),
        n.charCodeAt(o) === 58 ? (c = qs,
        o++) : (c = e,
        v === 0 && w(Xm)),
        c !== e ? (G(),
        d = $t(),
        d !== e ? (le = s,
        s = pT(u, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = Xn(),
        u !== e && (le = s,
        u = mT(u)),
        s = u,
        s === e && (s = o,
        n.substr(o, 3) === Nt ? (u = Nt,
        o += 3) : (u = e,
        v === 0 && w(el)),
        u !== e ? (Qe(),
        c = $t(),
        c !== e ? (le = s,
        s = gT(c)) : (o = s,
        s = e)) : (o = s,
        s = e))),
        s
    }
    function EF() {
        var s;
        return s = Kg(),
        s === e && (s = Xn()),
        s
    }
    function _F() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 40 ? (u = Et,
        o++) : (u = e,
        v === 0 && w(Vr)),
        u !== e ? (G(),
        c = $t(),
        c !== e ? (G(),
        n.charCodeAt(o) === 41 ? (d = It,
        o++) : (d = e,
        v === 0 && w(Ur)),
        d !== e ? s = c : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Ub() {
        var s;
        return s = n.charAt(o),
        LA.test(s) ? o++ : (s = e,
        v === 0 && w(M3)),
        s === e && (n.substr(o, 2) === Kf ? (s = Kf,
        o += 2) : (s = e,
        v === 0 && w(O3)),
        s === e && (s = "")),
        s
    }
    function jb() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = n.charAt(o),
        SA.test(c) ? o++ : (c = e,
        v === 0 && w(N3)),
        c !== e ? (n.charCodeAt(o) === 105 ? (d = Ya,
        o++) : (d = e,
        v === 0 && w(T3)),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function Kg() {
        var s, u, c, d;
        if (s = o,
        n.charCodeAt(o) === 34 ? (u = Qa,
        o++) : (u = e,
        v === 0 && w(jy)),
        u !== e) {
            for (c = [],
            d = Wb(); d !== e; )
                c.push(d),
                d = Wb();
            n.charCodeAt(o) === 34 ? (d = Qa,
            o++) : (d = e,
            v === 0 && w(jy)),
            d !== e ? (le = s,
            s = vT(c)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        if (s === e)
            if (s = o,
            n.charCodeAt(o) === 39 ? (u = po,
            o++) : (u = e,
            v === 0 && w(Hy)),
            u !== e) {
                for (c = [],
                d = Jb(); d !== e; )
                    c.push(d),
                    d = Jb();
                n.charCodeAt(o) === 39 ? (d = po,
                o++) : (d = e,
                v === 0 && w(Hy)),
                d !== e ? (le = s,
                s = yT(c)) : (o = s,
                s = e)
            } else
                o = s,
                s = e;
        return s
    }
    function Hb() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === Zf ? (u = Zf,
        o += 3) : (u = e,
        v === 0 && w(x3)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function LF() {
        var s, u, c;
        return s = o,
        u = Hb(),
        u !== e ? (G(),
        c = AF(),
        c !== e ? (le = s,
        s = bT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function SF() {
        var s, u, c, d;
        return s = o,
        u = Hb(),
        u !== e ? (G(),
        c = ob(),
        c !== e ? (d = Hn(),
        d !== e ? (le = s,
        s = wT()) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Zg() {
        var s;
        return s = xF(),
        s === e && (s = IF(),
        s === e && (s = FF(),
        s === e && (s = RF(),
        s === e && (s = $F(),
        s === e && (s = TF(),
        s === e && (s = OF(),
        s === e && (s = MF()))))))),
        s
    }
    function AF() {
        var s, u, c, d;
        return s = o,
        u = o,
        G(),
        c = Zg(),
        c !== e ? (d = Hn(),
        d !== e ? u = c : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e && (le = s,
        u = ET(u)),
        s = u,
        s === e && (s = CF()),
        s
    }
    function CF() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        n.charCodeAt(o) === 123 ? (u = pe,
        o++) : (u = e,
        v === 0 && w(nd)),
        u !== e) {
            for (G(),
            c = o,
            d = [],
            y = o,
            _ = G(),
            M = Zg(),
            M !== e ? (Y = Hn(),
            Y !== e ? y = M : (o = y,
            y = e)) : (o = y,
            y = e); y !== e; )
                d.push(y),
                y = o,
                _ = G(),
                M = Zg(),
                M !== e ? (Y = Hn(),
                Y !== e ? y = M : (o = y,
                y = e)) : (o = y,
                y = e);
            d.length < 1 ? (o = c,
            c = e) : c = d,
            c !== e ? (d = G(),
            n.charCodeAt(o) === 125 ? (y = Pe,
            o++) : (y = e,
            v === 0 && w(ia)),
            y !== e ? (_ = Hn(),
            _ !== e ? (le = s,
            s = _T(c)) : (o = s,
            s = e)) : (o = s,
            s = e)) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function md() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 60 ? (u = as,
        o++) : (u = e,
        v === 0 && w(oa)),
        u !== e ? (c = ci(),
        c !== e ? (d = o,
        n.charCodeAt(o) === 47 ? (y = yn,
        o++) : (y = e,
        v === 0 && w(As)),
        y !== e ? (_ = ci(),
        _ !== e ? d = _ : (o = d,
        d = e)) : (o = d,
        d = e),
        d === e && (d = null),
        n.charCodeAt(o) === 62 ? (y = ri,
        o++) : (y = e,
        v === 0 && w(rd)),
        y !== e ? (le = s,
        s = LT(c, d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function $F() {
        var s, u, c, d;
        if (s = o,
        u = [],
        c = n.charAt(o),
        Ay.test(c) ? o++ : (c = e,
        v === 0 && w(Gy)),
        c !== e)
            for (; c !== e; )
                u.push(c),
                c = n.charAt(o),
                Ay.test(c) ? o++ : (c = e,
                v === 0 && w(Gy));
        else
            u = e;
        return u !== e ? (c = Qe(),
        d = md(),
        d === e && (d = null),
        le = s,
        s = ST(u, d)) : (o = s,
        s = e),
        s
    }
    function MF() {
        var s, u, c, d;
        if (s = o,
        u = [],
        c = n.charAt(o),
        Nr.test(c) ? o++ : (c = e,
        v === 0 && w(Tr)),
        c !== e)
            for (; c !== e; )
                u.push(c),
                c = n.charAt(o),
                Nr.test(c) ? o++ : (c = e,
                v === 0 && w(Tr));
        else
            u = e;
        return u !== e ? (c = Qe(),
        d = md(),
        d === e && (d = null),
        le = s,
        s = AT(u, d)) : (o = s,
        s = e),
        s
    }
    function OF() {
        var s, u, c, d, y, _, M, Y;
        for (s = o,
        u = o,
        c = [],
        d = xr(); d !== e; )
            c.push(d),
            d = o,
            y = o,
            _ = G(),
            n.charCodeAt(o) === 44 ? (M = qt,
            o++) : (M = e,
            v === 0 && w(Bn)),
            M !== e ? (Y = G(),
            _ = [_, M, Y],
            y = _) : (o = y,
            y = e),
            y !== e ? (y = xr(),
            y === e ? (o = d,
            d = e) : d = y) : d = y;
        return c.length < 2 ? (o = u,
        u = e) : u = c,
        u !== e ? (c = o,
        d = Qe(),
        n.charCodeAt(o) === 44 ? (y = qt,
        o++) : (y = e,
        v === 0 && w(Bn)),
        y === e && (y = null),
        _ = Qe(),
        M = md(),
        M === e && (M = null),
        c = M,
        le = s,
        s = CT(u, c)) : (o = s,
        s = e),
        s
    }
    function NF() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        u = xr(),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 124 ? (c = ui,
        o++) : (c = e,
        v === 0 && w(I3)),
        c !== e ? (Qe(),
        d = xr(),
        d !== e ? (Qe(),
        y = o,
        n.charCodeAt(o) === 40 ? (_ = Et,
        o++) : (_ = e,
        v === 0 && w(Vr)),
        _ !== e ? (Qe(),
        M = ci(),
        M !== e ? (Qe(),
        n.charCodeAt(o) === 41 ? (Y = It,
        o++) : (Y = e,
        v === 0 && w(Ur)),
        Y !== e ? y = M : (o = y,
        y = e)) : (o = y,
        y = e)) : (o = y,
        y = e),
        y === e && (y = null),
        le = s,
        s = $T(u, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function TF() {
        var s, u, c, d, y, _, M;
        return s = o,
        u = ci(),
        u !== e ? (n.charCodeAt(o) === 76 ? (c = Yf,
        o++) : (c = e,
        v === 0 && w(Wy)),
        c !== e ? (Qe(),
        d = ci(),
        d !== e ? (n.charCodeAt(o) === 115 ? (y = du,
        o++) : (y = e,
        v === 0 && w(ig)),
        y !== e ? (Qe(),
        _ = NF(),
        _ === e && (_ = null),
        Qe(),
        M = md(),
        M === e && (M = null),
        le = s,
        s = MT(u, d, _, M)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function xF() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 8) === zi ? (u = zi,
        o += 8) : (u = e,
        v === 0 && w(F3)),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (Qe(),
        d = $t(),
        d !== e ? (le = s,
        s = OT(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function IF() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 76 ? (u = Yf,
        o++) : (u = e,
        v === 0 && w(Wy)),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (Qe(),
        d = $t(),
        d !== e ? (le = s,
        s = NT(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function FF() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 115 ? (u = du,
        o++) : (u = e,
        v === 0 && w(ig)),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (Qe(),
        d = $t(),
        d !== e ? (le = s,
        s = TT(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function RF() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 6) === hu ? (u = hu,
        o += 6) : (u = e,
        v === 0 && w(R3)),
        u !== e ? (Qe(),
        n.charCodeAt(o) === 61 ? (c = ct,
        o++) : (c = e,
        v === 0 && w(ns)),
        c !== e ? (Qe(),
        d = $t(),
        d !== e ? (le = s,
        s = xT(d)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Yg() {
        var s, u, c, d;
        for (s = o,
        u = o,
        c = [],
        d = n.charAt(o),
        ed.test(d) ? o++ : (d = e,
        v === 0 && w(ad)); d !== e; )
            c.push(d),
            d = n.charAt(o),
            ed.test(d) ? o++ : (d = e,
            v === 0 && w(ad));
        return u = n.substring(u, o),
        le = s,
        u = IT(u),
        s = u,
        s
    }
    function PF() {
        var s, u, c, d, y, _;
        if (s = o,
        u = o,
        c = o,
        d = n.charAt(o),
        Nr.test(d) ? o++ : (d = e,
        v === 0 && w(Tr)),
        d !== e) {
            for (y = [],
            _ = n.charAt(o),
            ed.test(_) ? o++ : (_ = e,
            v === 0 && w(ad)); _ !== e; )
                y.push(_),
                _ = n.charAt(o),
                ed.test(_) ? o++ : (_ = e,
                v === 0 && w(ad));
            d = [d, y],
            c = d
        } else
            o = c,
            c = e;
        return c !== e ? u = n.substring(u, o) : u = c,
        u !== e && (le = s,
        u = FT(u)),
        s = u,
        s
    }
    function Gb() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = n.charAt(o),
        Xa.test(c) ? o++ : (c = e,
        v === 0 && w(nl)),
        c !== e ? (d = Yg(),
        c = [c, d],
        u = c) : (o = u,
        u = e),
        u !== e && (le = s,
        u = RT(u)),
        s = u,
        s
    }
    function Au() {
        var s, u;
        return s = o,
        n.charCodeAt(o) === 48 ? (u = mo,
        o++) : (u = e,
        v === 0 && w(vu)),
        u !== e && (le = s,
        u = PT()),
        s = u,
        s === e && (s = Gb()),
        s
    }
    function gd() {
        var s, u;
        return s = o,
        u = n.charAt(o),
        pu.test(u) ? o++ : (u = e,
        v === 0 && w(mu)),
        u === e && (u = null),
        s = n.substring(s, o),
        s
    }
    function DF() {
        var s;
        return s = n.charAt(o),
        s.toLowerCase() === kt ? o++ : (s = e,
        v === 0 && w(Ry)),
        s
    }
    function Cu() {
        var s, u, c;
        return s = o,
        u = DF(),
        u !== e ? (c = fl(),
        c !== e ? (le = s,
        s = DT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function xr() {
        var s, u, c, d, y, _;
        if (s = o,
        u = o,
        n.charCodeAt(o) === 48 ? (c = mo,
        o++) : (c = e,
        v === 0 && w(vu)),
        c === e)
            if (c = o,
            d = n.charAt(o),
            Xa.test(d) ? o++ : (d = e,
            v === 0 && w(nl)),
            d !== e) {
                for (y = [],
                _ = _r(); _ !== e; )
                    y.push(_),
                    _ = _r();
                d = [d, y],
                c = d
            } else
                o = c,
                c = e;
        return c !== e ? u = n.substring(u, o) : u = c,
        u !== e && (le = s,
        u = qT(u)),
        s = u,
        s
    }
    function ci() {
        var s, u, c, d, y, _;
        if (s = o,
        u = o,
        c = o,
        d = n.charAt(o),
        Xa.test(d) ? o++ : (d = e,
        v === 0 && w(nl)),
        d !== e) {
            for (y = [],
            _ = _r(); _ !== e; )
                y.push(_),
                _ = _r();
            d = [d, y],
            c = d
        } else
            o = c,
            c = e;
        return c !== e ? u = n.substring(u, o) : u = c,
        u !== e && (le = s,
        u = BT(u)),
        s = u,
        s
    }
    function qF() {
        var s, u, c, d, y;
        if (s = o,
        u = o,
        c = n.charAt(o),
        Xa.test(c) ? o++ : (c = e,
        v === 0 && w(nl)),
        c !== e) {
            for (d = [],
            y = _r(); y !== e; )
                d.push(y),
                y = _r();
            c = [c, d],
            u = c
        } else
            o = u,
            u = e;
        return u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function fl() {
        var s, u, c, d, y, _, M, Y;
        if (s = o,
        u = o,
        c = o,
        d = n.charAt(o),
        pu.test(d) ? o++ : (d = e,
        v === 0 && w(mu)),
        d === e && (d = null),
        n.charCodeAt(o) === 48 ? (y = mo,
        o++) : (y = e,
        v === 0 && w(vu)),
        y === e)
            if (y = o,
            _ = n.charAt(o),
            Xa.test(_) ? o++ : (_ = e,
            v === 0 && w(nl)),
            _ !== e) {
                for (M = [],
                Y = _r(); Y !== e; )
                    M.push(Y),
                    Y = _r();
                _ = [_, M],
                y = _
            } else
                o = y,
                y = e;
        return y !== e ? (d = [d, y],
        c = d) : (o = c,
        c = e),
        c !== e ? u = n.substring(u, o) : u = c,
        u !== e && (le = s,
        u = kT(u)),
        s = u,
        s
    }
    function BF() {
        var s, u, c, d, y, _;
        if (s = o,
        u = o,
        n.charCodeAt(o) === 35 ? (c = A,
        o++) : (c = e,
        v === 0 && w(Jy)),
        c !== e) {
            for (d = o,
            y = [],
            _ = fi(); _ !== e; )
                y.push(_),
                y.length >= 3 ? _ = e : _ = fi();
            y.length < 3 ? (o = d,
            d = e) : d = y,
            d !== e ? (c = [c, d],
            u = c) : (o = u,
            u = e)
        } else
            o = u,
            u = e;
        return u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function kF() {
        var s, u, c, d, y, _;
        if (s = o,
        u = o,
        n.charCodeAt(o) === 35 ? (c = A,
        o++) : (c = e,
        v === 0 && w(Jy)),
        c !== e) {
            for (d = o,
            y = [],
            _ = fi(); _ !== e; )
                y.push(_),
                y.length >= 6 ? _ = e : _ = fi();
            y.length < 6 ? (o = d,
            d = e) : d = y,
            d !== e ? (c = [c, d],
            u = c) : (o = u,
            u = e)
        } else
            o = u,
            u = e;
        return u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function vo() {
        var s, u, c, d, y, _, M;
        if (s = o,
        u = n.charAt(o),
        pu.test(u) ? o++ : (u = e,
        v === 0 && w(mu)),
        u === e && (u = null),
        n.charCodeAt(o) === 48 ? (c = mo,
        o++) : (c = e,
        v === 0 && w(vu)),
        c === e)
            if (c = o,
            d = n.charAt(o),
            Xa.test(d) ? o++ : (d = e,
            v === 0 && w(nl)),
            d !== e) {
                for (y = [],
                _ = _r(); _ !== e; )
                    y.push(_),
                    _ = _r();
                d = [d, y],
                c = d
            } else
                o = c,
                c = e;
        if (c !== e) {
            if (d = o,
            n.charCodeAt(o) === 46 ? (y = be,
            o++) : (y = e,
            v === 0 && w(go)),
            y !== e) {
                for (_ = [],
                M = _r(); M !== e; )
                    _.push(M),
                    M = _r();
                y = [y, _],
                d = y
            } else
                o = d,
                d = e;
            d === e && (d = null),
            u = [u, c, d],
            s = u
        } else
            o = s,
            s = e;
        if (s === e)
            if (s = o,
            u = n.charAt(o),
            pu.test(u) ? o++ : (u = e,
            v === 0 && w(mu)),
            u === e && (u = null),
            n.charCodeAt(o) === 46 ? (c = be,
            o++) : (c = e,
            v === 0 && w(go)),
            c !== e) {
                if (d = [],
                y = _r(),
                y !== e)
                    for (; y !== e; )
                        d.push(y),
                        y = _r();
                else
                    d = e;
                d !== e ? (u = [u, c, d],
                s = u) : (o = s,
                s = e)
            } else
                o = s,
                s = e;
        return s
    }
    function zF() {
        var s, u, c, d, y;
        if (s = o,
        u = o,
        c = Qb(),
        c !== e) {
            for (d = [],
            y = ht(); y !== e; )
                d.push(y),
                y = ht();
            c = [c, d],
            u = c
        } else
            o = u,
            u = e;
        return u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function Wb() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = o,
        v++,
        d = n.charAt(o),
        AA.test(d) ? o++ : (d = e,
        v === 0 && w(P3)),
        d === e && (d = Mu()),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = rs(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s === e && (s = n.charAt(o),
        Zm.test(s) ? o++ : (s = e,
        v === 0 && w(og)),
        s === e && (s = o,
        n.charCodeAt(o) === 92 ? (u = ls,
        o++) : (u = e,
        v === 0 && w(tl)),
        u !== e ? (c = Zb(),
        c !== e ? s = c : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = Kb()))),
        s
    }
    function Jb() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = o,
        v++,
        d = n.charAt(o),
        CA.test(d) ? o++ : (d = e,
        v === 0 && w(D3)),
        d === e && (d = Mu()),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = rs(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s === e && (s = n.charAt(o),
        Zm.test(s) ? o++ : (s = e,
        v === 0 && w(og)),
        s === e && (s = o,
        n.charCodeAt(o) === 92 ? (u = ls,
        o++) : (u = e,
        v === 0 && w(tl)),
        u !== e ? (c = Zb(),
        c !== e ? s = c : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = Kb()))),
        s
    }
    function Kb() {
        var s, u, c;
        return s = o,
        n.charCodeAt(o) === 92 ? (u = ls,
        o++) : (u = e,
        v === 0 && w(tl)),
        u !== e ? (c = Ou(),
        c !== e ? (le = s,
        s = zT()) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Zb() {
        var s, u, c, d;
        return s = VF(),
        s === e && (s = o,
        n.charCodeAt(o) === 48 ? (u = mo,
        o++) : (u = e,
        v === 0 && w(vu)),
        u !== e ? (c = o,
        v++,
        d = _r(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (le = s,
        s = VT()) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = HF(),
        s === e && (s = GF()))),
        s
    }
    function VF() {
        var s;
        return s = Yb(),
        s === e && (s = UF()),
        s
    }
    function Yb() {
        var s, u;
        return s = n.charAt(o),
        $A.test(s) ? o++ : (s = e,
        v === 0 && w(q3)),
        s === e && (s = o,
        n.charCodeAt(o) === 98 ? (u = H,
        o++) : (u = e,
        v === 0 && w(B3)),
        u !== e && (le = s,
        u = UT()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 102 ? (u = ne,
        o++) : (u = e,
        v === 0 && w(k3)),
        u !== e && (le = s,
        u = jT()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 110 ? (u = $,
        o++) : (u = e,
        v === 0 && w(zy)),
        u !== e && (le = s,
        u = HT()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 114 ? (u = zt,
        o++) : (u = e,
        v === 0 && w(tg)),
        u !== e && (le = s,
        u = GT()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 116 ? (u = ue,
        o++) : (u = e,
        v === 0 && w(z3)),
        u !== e && (le = s,
        u = WT()),
        s = u,
        s === e && (s = o,
        n.charCodeAt(o) === 118 ? (u = x,
        o++) : (u = e,
        v === 0 && w(eg)),
        u !== e && (le = s,
        u = JT()),
        s = u)))))),
        s
    }
    function UF() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = o,
        v++,
        d = jF(),
        d === e && (d = Mu()),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (d = rs(),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s
    }
    function jF() {
        var s;
        return s = Yb(),
        s === e && (s = n.charAt(o),
        MA.test(s) ? o++ : (s = e,
        v === 0 && w(V3))),
        s
    }
    function HF() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 120 ? (u = We,
        o++) : (u = e,
        v === 0 && w(U3)),
        u !== e ? (c = o,
        d = o,
        y = fi(),
        y !== e ? (_ = fi(),
        _ !== e ? (y = [y, _],
        d = y) : (o = d,
        d = e)) : (o = d,
        d = e),
        d !== e ? c = n.substring(c, o) : c = d,
        c !== e ? (le = s,
        s = KT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function GF() {
        var s, u, c, d, y, _, M, Y;
        return s = o,
        n.charCodeAt(o) === 117 ? (u = lt,
        o++) : (u = e,
        v === 0 && w(j3)),
        u !== e ? (c = o,
        d = o,
        y = fi(),
        y !== e ? (_ = fi(),
        _ !== e ? (M = fi(),
        M !== e ? (Y = fi(),
        Y !== e ? (y = [y, _, M, Y],
        d = y) : (o = d,
        d = e)) : (o = d,
        d = e)) : (o = d,
        d = e)) : (o = d,
        d = e),
        d !== e ? c = n.substring(c, o) : c = d,
        c !== e ? (le = s,
        s = ZT(c)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function _r() {
        var s;
        return s = n.charAt(o),
        Nr.test(s) ? o++ : (s = e,
        v === 0 && w(Tr)),
        s
    }
    function fi() {
        var s;
        return s = n.charAt(o),
        OA.test(s) ? o++ : (s = e,
        v === 0 && w(H3)),
        s
    }
    function Qb() {
        var s;
        return s = YF(),
        s === e && (s = n.charAt(o),
        NA.test(s) ? o++ : (s = e,
        v === 0 && w(G3))),
        s
    }
    function ht() {
        var s;
        return s = QF(),
        s === e && (s = n.charAt(o),
        TA.test(s) ? o++ : (s = e,
        v === 0 && w(W3))),
        s
    }
    function G() {
        var s, u;
        for (v++,
        s = [],
        u = $u(),
        u === e && (u = Ou(),
        u === e && (u = yd())); u !== e; )
            s.push(u),
            u = $u(),
            u === e && (u = Ou(),
            u === e && (u = yd()));
        return v--,
        u = e,
        v === 0 && w(J3),
        s
    }
    function Qe() {
        var s, u;
        for (v++,
        s = [],
        u = $u(),
        u === e && (u = Nu()); u !== e; )
            s.push(u),
            u = $u(),
            u === e && (u = Nu());
        return v--,
        u = e,
        v === 0 && w(K3),
        s
    }
    function vd() {
        var s, u;
        return s = o,
        u = $u(),
        u === e && (u = Nu()),
        u !== e && (le = s,
        u = YT()),
        s = u,
        s
    }
    function Hn() {
        var s, u, c, d;
        return s = o,
        u = G(),
        n.charCodeAt(o) === 59 ? (c = ft,
        o++) : (c = e,
        v === 0 && w(Ny)),
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e),
        s === e && (s = o,
        u = Qe(),
        c = Ou(),
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e),
        s === e && (s = o,
        u = Qe(),
        c = o,
        v++,
        n.charCodeAt(o) === 125 ? (d = Pe,
        o++) : (d = e,
        v === 0 && w(ia)),
        v--,
        d !== e ? (o = c,
        c = void 0) : c = e,
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e),
        s === e && (s = o,
        u = G(),
        c = WF(),
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e)))),
        s
    }
    function WF() {
        var s, u;
        return s = o,
        v++,
        n.length > o ? (u = n.charAt(o),
        o++) : (u = e,
        v === 0 && w(Z3)),
        v--,
        u === e ? s = void 0 : (o = s,
        s = e),
        s
    }
    function $u() {
        var s;
        return s = n.charAt(o),
        xA.test(s) ? o++ : (s = e,
        v === 0 && w(Y3)),
        s === e && (s = JF()),
        s
    }
    function Mu() {
        var s;
        return v++,
        s = n.charAt(o),
        IA.test(s) ? o++ : (s = e,
        v === 0 && w(X3)),
        v--,
        s === e && v === 0 && w(Q3),
        s
    }
    function Ou() {
        var s, u, c, d;
        return v++,
        n.charCodeAt(o) === 10 ? (s = $n,
        o++) : (s = e,
        v === 0 && w(Ky)),
        s === e && (s = o,
        n.charCodeAt(o) === 13 ? (u = Ln,
        o++) : (u = e,
        v === 0 && w(tM)),
        u !== e ? (c = o,
        v++,
        n.charCodeAt(o) === 10 ? (d = $n,
        o++) : (d = e,
        v === 0 && w(Ky)),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = n.charAt(o),
        Zm.test(s) ? o++ : (s = e,
        v === 0 && w(og)),
        s === e && (n.substr(o, 2) === Yn ? (s = Yn,
        o += 2) : (s = e,
        v === 0 && w(nM))))),
        v--,
        s === e && (u = e,
        v === 0 && w(eM)),
        s
    }
    function JF() {
        var s, u, c;
        return s = o,
        u = rs(),
        u !== e ? (le = o,
        c = QT(u),
        c ? c = void 0 : c = e,
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function rs() {
        var s;
        return v++,
        s = KF(),
        s === e && (s = ZF()),
        v--,
        s === e && v === 0 && w(rM),
        s
    }
    function KF() {
        var s;
        return s = n.charAt(o),
        FA.test(s) ? o++ : (s = e,
        v === 0 && w(sM)),
        s
    }
    function ZF() {
        var s, u, c, d;
        return s = o,
        u = o,
        c = n.charAt(o),
        RA.test(c) ? o++ : (c = e,
        v === 0 && w(iM)),
        c !== e ? (d = n.charAt(o),
        PA.test(d) ? o++ : (d = e,
        v === 0 && w(oM)),
        d !== e ? (c = [c, d],
        u = c) : (o = u,
        u = e)) : (o = u,
        u = e),
        u !== e ? s = n.substring(s, o) : s = u,
        s === e && (s = n.charAt(o),
        DA.test(s) ? o++ : (s = e,
        v === 0 && w(aM))),
        s
    }
    function YF() {
        var s, u, c;
        return s = o,
        u = rs(),
        u !== e ? (le = o,
        c = XT(u),
        c ? c = void 0 : c = e,
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function QF() {
        var s, u, c;
        return s = o,
        u = rs(),
        u !== e ? (le = o,
        c = ex(u),
        c ? c = void 0 : c = e,
        c !== e ? (u = [u, c],
        s = u) : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function yd() {
        var s, u, c, d, y, _;
        if (s = o,
        n.substr(o, 2) === pn ? (u = pn,
        o += 2) : (u = e,
        v === 0 && w(rl)),
        u !== e) {
            for (c = [],
            d = o,
            y = o,
            v++,
            n.substr(o, 2) === pn ? (_ = pn,
            o += 2) : (_ = e,
            v === 0 && w(rl)),
            _ === e && (n.substr(o, 2) === mn ? (_ = mn,
            o += 2) : (_ = e,
            v === 0 && w(sl))),
            v--,
            _ === e ? y = void 0 : (o = y,
            y = e),
            y !== e ? (_ = rs(),
            _ !== e ? (y = [y, _],
            d = y) : (o = d,
            d = e)) : (o = d,
            d = e),
            d === e && (d = yd()); d !== e; )
                c.push(d),
                d = o,
                y = o,
                v++,
                n.substr(o, 2) === pn ? (_ = pn,
                o += 2) : (_ = e,
                v === 0 && w(rl)),
                _ === e && (n.substr(o, 2) === mn ? (_ = mn,
                o += 2) : (_ = e,
                v === 0 && w(sl))),
                v--,
                _ === e ? y = void 0 : (o = y,
                y = e),
                y !== e ? (_ = rs(),
                _ !== e ? (y = [y, _],
                d = y) : (o = d,
                d = e)) : (o = d,
                d = e),
                d === e && (d = yd());
            n.substr(o, 2) === mn ? (d = mn,
            o += 2) : (d = e,
            v === 0 && w(sl)),
            d !== e ? (u = [u, c, d],
            s = u) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function Nu() {
        var s, u, c, d, y, _;
        if (s = o,
        n.substr(o, 2) === pn ? (u = pn,
        o += 2) : (u = e,
        v === 0 && w(rl)),
        u !== e) {
            for (c = [],
            d = o,
            y = o,
            v++,
            n.substr(o, 2) === pn ? (_ = pn,
            o += 2) : (_ = e,
            v === 0 && w(rl)),
            _ === e && (n.substr(o, 2) === mn ? (_ = mn,
            o += 2) : (_ = e,
            v === 0 && w(sl)),
            _ === e && (_ = Mu())),
            v--,
            _ === e ? y = void 0 : (o = y,
            y = e),
            y !== e ? (_ = rs(),
            _ !== e ? (y = [y, _],
            d = y) : (o = d,
            d = e)) : (o = d,
            d = e),
            d === e && (d = Nu()); d !== e; )
                c.push(d),
                d = o,
                y = o,
                v++,
                n.substr(o, 2) === pn ? (_ = pn,
                o += 2) : (_ = e,
                v === 0 && w(rl)),
                _ === e && (n.substr(o, 2) === mn ? (_ = mn,
                o += 2) : (_ = e,
                v === 0 && w(sl)),
                _ === e && (_ = Mu())),
                v--,
                _ === e ? y = void 0 : (o = y,
                y = e),
                y !== e ? (_ = rs(),
                _ !== e ? (y = [y, _],
                d = y) : (o = d,
                d = e)) : (o = d,
                d = e),
                d === e && (d = Nu());
            n.substr(o, 2) === mn ? (d = mn,
            o += 2) : (d = e,
            v === 0 && w(sl)),
            d !== e ? (u = [u, c, d],
            s = u) : (o = s,
            s = e)
        } else
            o = s,
            s = e;
        return s
    }
    function Xb() {
        var s, u, c, d, y, _;
        return s = o,
        u = gd(),
        c = xr(),
        c !== e ? (n.charCodeAt(o) === 47 ? (d = yn,
        o++) : (d = e,
        v === 0 && w(As)),
        d !== e ? (y = qF(),
        y !== e ? (le = s,
        s = tx(u, c, d, y)) : (o = s,
        s = e)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = gd(),
        c = xr(),
        c !== e ? (n.charCodeAt(o) === 46 ? (d = be,
        o++) : (d = e,
        v === 0 && w(go)),
        d !== e ? (y = Yg(),
        _ = Cu(),
        _ === e && (_ = null),
        le = s,
        s = nx(u, c, d, y, _)) : (o = s,
        s = e)) : (o = s,
        s = e),
        s === e && (s = o,
        u = gd(),
        c = xr(),
        c !== e ? (d = Cu(),
        d === e && (d = null),
        le = s,
        s = rx(u, c, d)) : (o = s,
        s = e))),
        s
    }
    function ew() {
        var s, u, c, d, y, _;
        for (s = [],
        u = Xb(); u !== e; )
            s.push(u),
            u = o,
            c = o,
            d = G(),
            n.charCodeAt(o) === 44 ? (y = qt,
            o++) : (y = e,
            v === 0 && w(Bn)),
            y === e && (y = null),
            _ = G(),
            d = [d, y, _],
            c = d,
            c = Xb(),
            c === e ? (o = u,
            u = e) : u = c;
        return s
    }
    function dl() {
        var s, u, c, d, y, _;
        return s = o,
        n.charCodeAt(o) === 8730 ? (u = Mr,
        o++) : (u = e,
        v === 0 && w(Ty)),
        u === e && (u = null),
        c = fl(),
        c !== e ? (d = o,
        n.charCodeAt(o) === 47 ? (y = yn,
        o++) : (y = e,
        v === 0 && w(As)),
        y !== e ? (_ = xr(),
        _ !== e ? d = _ : (o = d,
        d = e)) : (o = d,
        d = e),
        d === e && (d = null),
        le = s,
        s = sx(u, c, d)) : (o = s,
        s = e),
        s
    }
    function XF() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 99 ? (u = sr,
        o++) : (u = e,
        v === 0 && w(lM)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function tw() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 3) === it ? (u = it,
        o += 3) : (u = e,
        v === 0 && w(ky)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function nw() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === zr ? (u = zr,
        o += 2) : (u = e,
        v === 0 && w(uM)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Qg() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === yy ? (u = yy,
        o += 2) : (u = e,
        v === 0 && w(cM)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function eR() {
        var s, u, c, d;
        return s = o,
        n.substr(o, 2) === by ? (u = by,
        o += 2) : (u = e,
        v === 0 && w(fM)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function rw() {
        var s, u, c, d;
        return s = o,
        n.charCodeAt(o) === 115 ? (u = du,
        o++) : (u = e,
        v === 0 && w(ig)),
        u !== e ? (c = o,
        v++,
        d = ht(),
        v--,
        d === e ? c = void 0 : (o = c,
        c = e),
        c !== e ? s = u : (o = s,
        s = e)) : (o = s,
        s = e),
        s
    }
    function Tu() {
        var s;
        return s = dl(),
        s === e && (s = rw(),
        s === e && (s = nw(),
        s === e && (s = Qg()))),
        s
    }
    function Xg() {
        var s;
        return s = Tu(),
        s === e && (s = eR(),
        s === e && (n.substr(o, 2) === wy ? (s = wy,
        o += 2) : (s = e,
        v === 0 && w(dM)),
        s === e && (n.substr(o, 3) === N ? (s = N,
        o += 3) : (s = e,
        v === 0 && w($y)),
        s === e && (n.substr(o, 2) === Ey ? (s = Ey,
        o += 2) : (s = e,
        v === 0 && w(hM)),
        s === e && (s = tw()))))),
        s
    }
    function sw() {
        var s, u, c;
        for (s = [],
        u = Tu(),
        u === e && (u = ""); u !== e; )
            s.push(u),
            u = o,
            n.charCodeAt(o) === 46 ? (c = be,
            o++) : (c = e,
            v === 0 && w(go)),
            c !== e ? (c = Tu(),
            c === e && (c = ""),
            c === e ? (o = u,
            u = e) : u = c) : u = c;
        return s
    }
    function tR() {
        var s, u, c;
        for (s = [],
        u = Xg(),
        u === e && (u = ""); u !== e; )
            s.push(u),
            u = o,
            n.charCodeAt(o) === 46 ? (c = be,
            o++) : (c = e,
            v === 0 && w(go)),
            c !== e ? (c = Xg(),
            c === e && (c = ""),
            c === e ? (o = u,
            u = e) : u = c) : u = c;
        return s
    }
    if (yu = a(),
    t.peg$library)
        return {
            peg$result: yu,
            peg$currPos: o,
            peg$FAILED: e,
            peg$maxFailExpected: ld,
            peg$maxFailPos: zs
        };
    if (yu !== e && o === n.length)
        return yu;
    throw yu !== e && o < n.length && w(ox()),
    lx(ld, zs < n.length ? n.charAt(zs) : null, zs < n.length ? lg(zs, zs + 1) : lg(zs, zs))
}
var o9 = {
    StartRules: ["Start"],
    SyntaxError: Do,
    parse: i9
}
  , Im = {};
Object.defineProperty(Im, "__esModule", {
    value: !0
});
Im.CSS_COLOR_CONTEXT = void 0;
const a9 = hn
  , l9 = `aliceblue #F0F8FF
antiquewhite #FAEBD7
aqua #00FFFF
aquamarine #7FFFD4
azure #F0FFFF
beige #F5F5DC
bisque #FFE4C4
black #000000
blanchedalmond #FFEBCD
blue #0000FF
blueviolet #8A2BE2
brown #A52A2A
burlywood #DEB887
cadetblue #5F9EA0
chartreuse #7FFF00
chocolate #D2691E
coral #FF7F50
cornflowerblue #6495ED
cornsilk #FFF8DC
crimson #DC143C
cyan #00FFFF
darkblue #00008B
darkcyan #008B8B
darkgoldenrod #B8860B
darkgray #A9A9A9
darkgreen #006400
darkgrey #A9A9A9
darkkhaki #BDB76B
darkmagenta #8B008B
darkolivegreen #556B2F
darkorange #FF8C00
darkorchid #9932CC
darkred #8B0000
darksalmon #E9967A
darkseagreen #8FBC8F
darkslateblue #483D8B
darkslategray #2F4F4F
darkslategrey #2F4F4F
darkturquoise #00CED1
darkviolet #9400D3
deeppink #FF1493
deepskyblue #00BFFF
dimgray #696969
dimgrey #696969
dodgerblue #1E90FF
firebrick #B22222
floralwhite #FFFAF0
forestgreen #228B22
fuchsia #FF00FF
gainsboro #DCDCDC
ghostwhite #F8F8FF
gold #FFD700
goldenrod #DAA520
gray #808080
green #008000
greenyellow #ADFF2F
grey #808080
honeydew #F0FFF0
hotpink #FF69B4
indianred #CD5C5C
indigo #4B0082
ivory #FFFFF0
khaki #F0E68C
lavender #E6E6FA
lavenderblush #FFF0F5
lawngreen #7CFC00
lemonchiffon #FFFACD
lightblue #ADD8E6
lightcoral #F08080
lightcyan #E0FFFF
lightgoldenrodyellow #FAFAD2
lightgray #D3D3D3
lightgreen #90EE90
lightgrey #D3D3D3
lightpink #FFB6C1
lightsalmon #FFA07A
lightseagreen #20B2AA
lightskyblue #87CEFA
lightslategray #778899
lightslategrey #778899
lightsteelblue #B0C4DE
lightyellow #FFFFE0
lime #00FF00
limegreen #32CD32
linen #FAF0E6
magenta #FF00FF
maroon #800000
mediumaquamarine #66CDAA
mediumblue #0000CD
mediumorchid #BA55D3
mediumpurple #9370DB
mediumseagreen #3CB371
mediumslateblue #7B68EE
mediumspringgreen #00FA9A
mediumturquoise #48D1CC
mediumvioletred #C71585
midnightblue #191970
mintcream #F5FFFA
mistyrose #FFE4E1
moccasin #FFE4B5
navajowhite #FFDEAD
navy #000080
oldlace #FDF5E6
olive #808000
olivedrab #6B8E23
orange #FFA500
orangered #FF4500
orchid #DA70D6
palegoldenrod #EEE8AA
palegreen #98FB98
paleturquoise #AFEEEE
palevioletred #DB7093
papayawhip #FFEFD5
peachpuff #FFDAB9
peru #CD853F
pink #FFC0CB
plum #DDA0DD
powderblue #B0E0E6
purple #800080
rebeccapurple #663399
red #FF0000
rosybrown #BC8F8F
royalblue #4169E1
saddlebrown #8B4513
salmon #FA8072
sandybrown #F4A460
seagreen #2E8B57
seashell #FFF5EE
sienna #A0522D
silver #C0C0C0
skyblue #87CEEB
slateblue #6A5ACD
slategray #708090
slategrey #708090
snow #FFFAFA
springgreen #00FF7F
steelblue #4682B4
tan #D2B48C
teal #008080
thistle #D8BFD8
tomato #FF6347
turquoise #40E0D0
violet #EE82EE
wheat #F5DEB3
white #FFFFFF
whitesmoke #F5F5F5
yellow #FFFF00
yellowgreen #9ACD32`;
Im.CSS_COLOR_CONTEXT = new Map(l9.split(`
`).map(n => n.split(" ")).map(n => [n[0], new a9.Color(n[0])]));
var Hl = {}
  , Ms = {}
  , _c = {};
Object.defineProperty(_c, "__esModule", {
    value: !0
});
_c.getHardness = void 0;
const $E = [["equalized", 1, 1], ["supersoft", 4, 3], ["soft", 3, 2], ["semisoft", 5, 3], ["basic", 2, 1], ["semihard", 5, 2], ["hard", 3, 1], ["superhard", 4, 1], ["collapsed", 1, 0]]
  , ME = [["ultrasoft", 6, 8], ["parasoft", 8, 9], ["quasisoft", 9, 10], ["minisoft", 10, 12], ["minihard", 12, 15], ["quasihard", 15, 18], ["parahard", 18, 24], ["ultrahard", 24, 1 / 0]];
function u9(n, t) {
    if (!n && !t)
        return "stationary";
    const e = n * t;
    let r = Math.abs(n)
      , i = Math.abs(t)
      , a = "";
    i > r && (a = "anti-" + a,
    [r,i] = [i, r]),
    e < 0 && (a = "trans-" + a);
    for (let l = 0; l < $E.length; ++l) {
        const [f,h,p] = $E[l];
        if (r * p === h * i)
            return a + f
    }
    for (let l = 0; l < ME.length; ++l) {
        const [f,h,p] = ME[l];
        if (h * i < 6 * r && 6 * r < p * i)
            return a + f
    }
    throw new Error("Unable to determine hardness")
}
_c.getHardness = u9;
var Vo = {};
const c9 = {
    "1L 1s": {
        name: "monowood",
        prefix: "monowd",
        abbreviation: "wood",
        familyPrefix: "monowood",
        nonOctaveName: "trivial",
        nonOctavePrefix: "triv",
        nonOctaveAbbreviation: "trv"
    },
    "1L 2s": {
        name: "antrial",
        prefix: "atri"
    },
    "2L 1s": {
        name: "trial",
        prefix: "tri"
    },
    "1L 3s": {
        name: "antetric",
        prefix: "atetra",
        abbreviation: "att"
    },
    "2L 2s": {
        name: "biwood",
        prefix: "biwd",
        abbreviation: "bw",
        familyPrefix: "biwood"
    },
    "3L 1s": {
        name: "tetric",
        prefix: "tetra",
        abbreviation: "tt"
    },
    "1L 4s": {
        name: "pedal",
        prefix: "ped"
    },
    "2L 3s": {
        name: "pentic",
        prefix: "pent",
        abbreviation: "pt"
    },
    "3L 2s": {
        name: "antipentic",
        prefix: "apent",
        abbreviation: "apt"
    },
    "4L 1s": {
        name: "manual",
        prefix: "manu"
    },
    "1L 5s": {
        name: "antimachinoid",
        prefix: "amech"
    },
    "2L 4s": {
        name: "malic",
        prefix: "mal"
    },
    "3L 3s": {
        name: "triwood",
        prefix: "triwd",
        abbreviation: "trw",
        familyPrefix: "triwood"
    },
    "4L 2s": {
        name: "citric",
        prefix: "citro",
        abbreviation: "cit"
    },
    "5L 1s": {
        name: "machinoid",
        prefix: "mech",
        familyPrefix: "mecha"
    },
    "1L 6s": {
        name: "onyx",
        prefix: "on"
    },
    "2L 5s": {
        name: "antidiatonic",
        prefix: "pel"
    },
    "3L 4s": {
        name: "mosh",
        prefix: "mosh"
    },
    "4L 3s": {
        name: "smitonic",
        prefix: "smi"
    },
    "5L 2s": {
        name: "diatonic",
        prefix: "dia"
    },
    "6L 1s": {
        name: "archeotonic",
        prefix: "arch",
        familyPrefix: "archeo"
    },
    "1L 7s": {
        name: "antipine",
        prefix: "apine"
    },
    "2L 6s": {
        name: "subaric",
        prefix: "subar"
    },
    "3L 5s": {
        name: "checkertonic",
        prefix: "check",
        abbreviation: "chk",
        familyPrefix: "checke"
    },
    "4L 4s": {
        name: "tetrawood",
        prefix: "tetwd",
        abbreviation: "ttw",
        familyPrefix: "tetwood",
        nickname: "diminished"
    },
    "5L 3s": {
        name: "oneirotonic",
        prefix: "oneiro",
        abbreviation: "onei"
    },
    "6L 2s": {
        name: "ekic",
        prefix: "ek",
        familyPrefix: "eki"
    },
    "7L 1s": {
        name: "pine",
        prefix: "pine"
    },
    "1L 8s": {
        name: "antisubneutralic",
        prefix: "ablu"
    },
    "2L 7s": {
        name: "balzano",
        prefix: "bal",
        familyPrefix: "balo"
    },
    "3L 6s": {
        name: "tcherepnin",
        prefix: "cher",
        abbreviation: "ch",
        familyPrefix: "chere"
    },
    "4L 5s": {
        name: "gramitonic",
        prefix: "gram",
        familyPrefix: "grami"
    },
    "5L 4s": {
        name: "semiquartal",
        prefix: "cthon",
        abbreviation: "cth",
        familyPrefix: "chtono"
    },
    "6L 3s": {
        name: "hyrulic",
        prefix: "hyru"
    },
    "7L 2s": {
        name: "armotonic",
        nickname: "superdiatonic",
        prefix: "arm",
        familyPrefix: "armo"
    },
    "8L 1s": {
        name: "subneutralic",
        prefix: "blu"
    },
    "1L 9s": {
        name: "antisinatonic",
        prefix: "asina",
        abbreviation: "asi"
    },
    "2L 8s": {
        name: "jaric",
        prefix: "jara",
        abbreviation: "jar"
    },
    "3L 7s": {
        name: "sephiroid",
        prefix: "seph",
        familyPrefix: "sephi"
    },
    "4L 6s": {
        name: "lime",
        prefix: "lime"
    },
    "5L 5s": {
        name: "pentawood",
        prefix: "penwd",
        abbreviation: "pw",
        familyPrefix: "penwood"
    },
    "6L 4s": {
        name: "lemon",
        prefix: "lem",
        familyPrefix: "lemo"
    },
    "7L 3s": {
        name: "dicoid",
        prefix: "dico"
    },
    "8L 2s": {
        name: "taric",
        prefix: "tara",
        abbreviation: "tar"
    },
    "9L 1s": {
        name: "sinatonic",
        prefix: "sina",
        abbreviation: "si"
    },
    "1L 10s": {
        name: "tanzanite",
        prefix: "tan",
        nickname: "tenorite"
    },
    "2L 9s": {
        name: "antivillatonic",
        prefix: "anvil"
    },
    "4L 7s": {
        name: "kleistonic",
        prefix: "klei"
    },
    "7L 4s": {
        nickname: "suprasmitonic",
        prefix: "susmi",
        name: "daemotonic"
    },
    "9L 2s": {
        name: "villatonic",
        prefix: "vil",
        nickname: "superarmotonic"
    },
    "10L 1s": {
        name: "antitanzanite",
        prefix: "antan",
        nickname: "antitenorite"
    },
    "1L 11s": {
        name: "helenite",
        prefix: "hel"
    },
    "5L 7s": {
        name: "p-chromatic",
        prefix: "pychro"
    },
    "6L 6s": {
        name: "hexawood",
        prefix: "hexwd",
        abbreviation: "hw",
        familyPrefix: "hexwood"
    },
    "7L 5s": {
        name: "m-chromatic",
        prefix: "mellow"
    },
    "11L 1s": {
        name: "antihelenite",
        prefix: "anhel"
    },
    "1L 12s": {
        name: "zircon",
        prefix: "zir"
    },
    "2L 11s": {
        name: "antihendecoid",
        prefix: "anhen"
    },
    "11L 2s": {
        name: "hendecoid",
        prefix: "hen"
    },
    "12L 1s": {
        name: "antizircon",
        prefix: "anzir"
    },
    "1L 13s": {
        name: "antrollic",
        prefix: "antro"
    },
    "13L 1s": {
        name: "trollic",
        prefix: "tro"
    },
    "7L 7s": {
        name: "septawood",
        prefix: "septwd",
        abbreviation: "sw",
        familyPrefix: "septwood"
    },
    "8L 8s": {
        name: "octawood",
        prefix: "otcwd",
        abbreviation: "ow",
        familyPrefix: "octwood"
    },
    "2L 15s": {
        name: "liesic",
        prefix: "lisa"
    },
    "15L 2s": {
        name: "antiliesic",
        prefix: "alisa"
    },
    "9L 9s": {
        name: "nonawood",
        prefix: "nonwd",
        abbreviation: "nw",
        familyPrefix: "nonwood"
    },
    "3L 16s": {
        name: "magicaltonic"
    },
    "16L 3s": {
        name: "muggletonic"
    },
    "10L 10s": {
        name: "decawood",
        prefix: "decwd",
        abbreviation: "dw",
        familyPrefix: "decwood"
    },
    "10L 11s": {
        name: "miracloid"
    },
    "11L 10s": {
        name: "antimiracloid"
    },
    "19L 3s": {
        name: "giedraitic",
        prefix: "kai"
    },
    "3L 19s": {
        name: "zheligowskic",
        prefix: "zheli"
    },
    "21L 1s": {
        name: "escapist"
    },
    "1L 21s": {
        name: "antiescapist"
    },
    "22L 1s": {
        name: "quartismoid"
    },
    "1L 22s": {
        name: "antiquartismoid"
    },
    "5L 12s": {
        name: "s-enharmonic",
        prefix: "supen"
    },
    "12L 5s": {
        name: "p-enharmonic",
        prefix: "pyen"
    },
    "7L 12s": {
        name: "f-enharmonic",
        prefix: "flaen"
    },
    "12L 7s": {
        name: "m-enharmonic",
        prefix: "meen"
    },
    "12L 17s": {
        name: "pythagotonic"
    },
    "17L 12s": {
        name: "gothitonic"
    },
    "12L 19s": {
        name: "fauxrussian"
    },
    "19L 12s": {
        name: "fauxarabian"
    },
    "17L 5s": {
        name: "protofractalic"
    },
    "5L 17s": {
        name: "reinhardic"
    },
    "19L 7s": {
        name: "velic"
    },
    "7L 19s": {
        name: "siskoic"
    },
    "12L 29s": {
        name: "pythamystonic"
    },
    "29L 12s": {
        name: "antipythamystonic"
    },
    "12L 31s": {
        name: "fauxmuscovian"
    },
    "31L 12s": {
        name: "fauxsiberian"
    },
    "19L 31s": {
        name: "fauxsaudi"
    },
    "31L 19s": {
        name: "fauxomani"
    },
    "17L 22s": {
        name: "antifractalic"
    },
    "22L 17s": {
        name: "fractalic"
    },
    "17L 29s": {
        name: "perotinic"
    },
    "29L 17s": {
        name: "martinic"
    },
    "19L 26s": {
        name: "veljentyttonic"
    },
    "26L 19s": {
        name: "veljenpoikanic"
    },
    "7L 26s": {
        name: "siskontyttonic"
    },
    "26L 7s": {
        name: "siskonpoikanic"
    },
    "5L 22s": {
        name: "reinatonic"
    },
    "22L 5s": {
        name: "antireinatonic"
    },
    "41L 12s": {
        name: "pythomerc"
    },
    "420L 69s": {
        name: "memic",
        prefix: "funi"
    },
    "69L 420s": {
        name: "antimemic",
        prefix: "unfuni"
    }
}
  , f9 = "Pentatonic Ionian"
  , d9 = "Pentatonic Mixolydian"
  , h9 = "Pentatonic Dorian"
  , p9 = "Pentatonic Aeolian"
  , m9 = "Pentatonic Phrygian"
  , g9 = "Pentatonic Anti-Ionian"
  , v9 = "Pentatonic Anti-Mixolydian"
  , y9 = "Pentatonic Anti-Dorian"
  , b9 = "Pentatonic Anti-Aeolian"
  , w9 = "Pentatonic Anti-Phrygian"
  , E9 = "Minimal"
  , _9 = "Medicinal"
  , L9 = "Medial"
  , S9 = "Indical"
  , A9 = "Pollical"
  , C9 = "Erev"
  , $9 = "Oplen"
  , M9 = "Layla"
  , O9 = "Shemesh"
  , N9 = "Boqer"
  , T9 = "Tsohorayim"
  , x9 = "Tonic"
  , I9 = "Dominant"
  , F9 = "Chinchillian"
  , R9 = "Badgerian"
  , P9 = "Zebrian"
  , D9 = "Dingoian"
  , q9 = "Gazelian"
  , B9 = "Lemurian"
  , k9 = "Pandian"
  , z9 = "Anti-locrian"
  , V9 = "Anti-phrygian"
  , U9 = "Anti-aeolian"
  , j9 = "Anti-dorian"
  , H9 = "Anti-mixolydian"
  , G9 = "Anti-ionian"
  , W9 = "Anti-lydian"
  , J9 = "Dril"
  , K9 = "Gil"
  , Z9 = "Kleeth"
  , Y9 = "Bish"
  , Q9 = "Fish"
  , X9 = "Jwl"
  , eq = "Led"
  , tq = "Nerevarine"
  , nq = "Vivecan"
  , rq = "Lorkhanic"
  , sq = "Sothic"
  , iq = "Kagrenacan"
  , oq = "Almalexian"
  , aq = "Dagothic"
  , lq = "Lydian"
  , uq = "Ionian"
  , cq = "Mixolydian"
  , fq = "Dorian"
  , dq = "Aeolian"
  , hq = "Phrygian"
  , pq = "Locrian"
  , mq = "Ryonian"
  , gq = "Karakalian"
  , vq = "Lobonian"
  , yq = "Horthathian"
  , bq = "Oukranian"
  , wq = "Tamashian"
  , Eq = "Zo-Kalarian"
  , _q = "Incubus"
  , Lq = "Succubus"
  , Sq = "Nightmare"
  , Aq = "Paralysis"
  , Cq = "Octopus"
  , $q = "Mantis"
  , Mq = "Dolphin"
  , Oq = "Crab"
  , Nq = "Tuna"
  , Tq = "Salmon"
  , xq = "Starfish"
  , Iq = "Whale"
  , Fq = "Tonic"
  , Rq = "Dominant"
  , Pq = "Anti-Sarnathian"
  , Dq = "Anti-Hlanithian"
  , qq = "Anti-Kadathian"
  , Bq = "Anti-Mnarian"
  , kq = "Anti-Ultharian"
  , zq = "Anti-Celephasian"
  , Vq = "Anti-Illarnekian"
  , Uq = "Anti-Dylathian"
  , jq = "Dylathian"
  , Hq = "Illarnekian"
  , Gq = "Celephasian"
  , Wq = "Ultharian"
  , Jq = "Mnarian"
  , Kq = "Kadathian"
  , Zq = "Hlanithian"
  , Yq = "Sarnathian"
  , Qq = "Superlydian"
  , Xq = "Superionian"
  , e8 = "Supermixolydian"
  , t8 = "Supercorinthian"
  , n8 = "Superolympian"
  , r8 = "Superdorian"
  , s8 = "Superaeolian"
  , i8 = "Superphrygian"
  , o8 = "Superlocrian"
  , a8 = "Anti-Superlydian"
  , l8 = "Anti-Superionian"
  , u8 = "Anti-Supermixolydian"
  , c8 = "Anti-Supercorinthian"
  , f8 = "Anti-Superolympian"
  , d8 = "Anti-Superdorian"
  , h8 = "Anti-Superaeolian"
  , p8 = "Anti-Superphrygian"
  , m8 = "Anti-Superlocrian"
  , g8 = "Roi"
  , v8 = "Steno"
  , y8 = "Limni"
  , b8 = "Telma"
  , w8 = "Krini"
  , E8 = "Elos"
  , _8 = "Mychos"
  , L8 = "Akti"
  , S8 = "Dini"
  , A8 = "Cristatan"
  , C8 = "Pican"
  , $8 = "Stellerian"
  , M8 = "Cornician"
  , O8 = "Nucifragan"
  , N8 = "Coracian"
  , T8 = "Frugilegian"
  , x8 = "Coloean"
  , I8 = "Pyrrhocoracian"
  , F8 = "Austro-Hungarian Minor"
  , R8 = "Ultra-Hittite"
  , P8 = "Estranged"
  , D8 = "Carolingian"
  , q8 = "Symmetric Negri Major"
  , B8 = "Amended"
  , k8 = "Faceless"
  , z8 = "Negri Augmented Major"
  , V8 = "Reoriented"
  , U8 = "Keter"
  , j8 = "Chesed"
  , H8 = "Netzach"
  , G8 = "Malkuth"
  , W8 = "Binah"
  , J8 = "Tiferet"
  , K8 = "Yesod"
  , Z8 = "Chokmah"
  , Y8 = "Gevurah"
  , Q8 = "Hod"
  , X8 = "Major"
  , eB = "Minor"
  , tB = "Supernerevarine"
  , nB = "Supervivecan"
  , rB = "Superbaardauan"
  , sB = "Superlorkhanic"
  , iB = "Supervvardenic"
  , oB = "Supersothic"
  , aB = "Supernumidian"
  , lB = "Superkagrenacan"
  , uB = "Supernecromic"
  , cB = "Superalmalexian"
  , fB = "Superdagothic"
  , dB = "Anti-Supernerevarine"
  , hB = "Anti-Supervivecan"
  , pB = "Anti-Superbaardauan"
  , mB = "Anti-Superlorkhanic"
  , gB = "Anti-Supervvardenic"
  , vB = "Anti-Supersothic"
  , yB = "Anti-Supernumidian"
  , bB = "Anti-Superkagrenacan"
  , wB = "Anti-Supernecromic"
  , EB = "Anti-Superalmalexian"
  , _B = "Anti-Superdagothic"
  , LB = "Ultralydian"
  , SB = "Ultraionian"
  , AB = "Ultramixolydian"
  , CB = "Ultracorinthian"
  , $B = "Ultraolympian"
  , MB = "Ultralycian"
  , OB = "Ultrapisidian"
  , NB = "Ultradorian"
  , TB = "Ultraaeolian"
  , xB = "Ultraphrygian"
  , IB = "Ultralocrian"
  , FB = "Rat"
  , RB = "Ox"
  , PB = "Tiger"
  , DB = "Rabbit"
  , qB = "Dragon"
  , BB = "Snake"
  , kB = "Horse"
  , zB = "Goat"
  , VB = "Monkey"
  , UB = "Rooster"
  , jB = "Dog"
  , HB = "Pig"
  , GB = {
    ssLsL: f9,
    sLssL: d9,
    sLsLs: h9,
    LssLs: p9,
    LsLss: m9,
    LLsLs: g9,
    LsLLs: v9,
    LsLsL: y9,
    sLLsL: b9,
    sLsLL: w9,
    LLLLs: E9,
    LLLsL: _9,
    LLsLL: L9,
    LsLLL: S9,
    sLLLL: A9,
    LLLLLs: C9,
    LLLLsL: $9,
    LLLsLL: M9,
    LLsLLL: O9,
    LsLLLL: N9,
    sLLLLL: T9,
    LsLsLs: x9,
    sLsLsL: I9,
    Lssssss: F9,
    sLsssss: R9,
    ssLssss: P9,
    sssLsss: D9,
    ssssLss: q9,
    sssssLs: B9,
    ssssssL: k9,
    LssLsss: z9,
    LsssLss: V9,
    sLssLss: U9,
    sLsssLs: j9,
    ssLssLs: H9,
    ssLsssL: G9,
    sssLssL: W9,
    LsLsLss: J9,
    LsLssLs: K9,
    LssLsLs: Z9,
    sLsLsLs: Y9,
    sLsLssL: Q9,
    sLssLsL: X9,
    ssLsLsL: eq,
    LLsLsLs: tq,
    LsLLsLs: nq,
    LsLsLLs: rq,
    LsLsLsL: sq,
    sLLsLsL: iq,
    sLsLLsL: oq,
    sLsLsLL: aq,
    LLLsLLs: lq,
    LLsLLLs: uq,
    LLsLLsL: cq,
    LsLLLsL: fq,
    LsLLsLL: dq,
    sLLLsLL: hq,
    sLLsLLL: pq,
    LLLLLLs: mq,
    LLLLLsL: gq,
    LLLLsLL: vq,
    LLLsLLL: yq,
    LLsLLLL: bq,
    LsLLLLL: wq,
    sLLLLLL: Eq,
    sLLLsLLL: _q,
    LsLLLsLL: Lq,
    LLsLLLsL: Sq,
    LLLsLLLs: Aq,
    LLLLLLLs: Cq,
    LLLLLLsL: $q,
    LLLLLsLL: Mq,
    LLLLsLLL: Oq,
    LLLsLLLL: Nq,
    LLsLLLLL: Tq,
    LsLLLLLL: xq,
    sLLLLLLL: Iq,
    LsLsLsLs: Fq,
    sLsLsLsL: Rq,
    LsLssLss: Pq,
    LssLsLss: Dq,
    LssLssLs: qq,
    sLsLssLs: Bq,
    sLssLsLs: kq,
    sLssLssL: zq,
    ssLsLssL: Vq,
    ssLssLsL: Uq,
    LLsLLsLs: jq,
    LLsLsLLs: Hq,
    LsLLsLLs: Gq,
    LsLLsLsL: Wq,
    LsLsLLsL: Jq,
    sLLsLLsL: Kq,
    sLLsLsLL: Zq,
    sLsLLsLL: Yq,
    LLLLsLLLs: Qq,
    LLLsLLLLs: Xq,
    LLLsLLLsL: e8,
    LLsLLLLsL: t8,
    LLsLLLsLL: n8,
    LsLLLLsLL: r8,
    LsLLLsLLL: s8,
    sLLLLsLLL: i8,
    sLLLsLLLL: o8,
    ssssLsssL: a8,
    sssLssssL: l8,
    sssLsssLs: u8,
    ssLssssLs: c8,
    ssLsssLss: f8,
    sLssssLss: d8,
    sLsssLsss: h8,
    LssssLsss: p8,
    LsssLssss: m8,
    LsLsLsLss: g8,
    LsLsLssLs: v8,
    LsLssLsLs: y8,
    LssLsLsLs: b8,
    sLsLsLsLs: w8,
    sLsLsLssL: E8,
    sLsLssLsL: _8,
    sLssLsLsL: L8,
    ssLsLsLsL: S8,
    LLsLsLsLs: A8,
    LsLLsLsLs: C8,
    LsLsLLsLs: $8,
    LsLsLsLLs: M8,
    LsLsLsLsL: O8,
    sLLsLsLsL: N8,
    sLsLLsLsL: T8,
    sLsLsLLsL: x8,
    sLsLsLsLL: I8,
    Lssssssss: F8,
    sLsssssss: R8,
    ssLssssss: P8,
    sssLsssss: D8,
    ssssLssss: q8,
    sssssLsss: B8,
    ssssssLss: k8,
    sssssssLs: z8,
    ssssssssL: V8,
    sssLssLssL: U8,
    ssLssLssLs: j8,
    sLssLssLss: H8,
    LssLssLsss: G8,
    ssLssLsssL: W8,
    sLssLsssLs: J8,
    LssLsssLss: K8,
    ssLsssLssL: Z8,
    sLsssLssLs: Y8,
    LsssLssLss: Q8,
    LsLsLsLsLs: X8,
    sLsLsLsLsL: eB,
    LsLssLssLss: tB,
    LssLsLssLss: nB,
    LssLssLsLss: rB,
    LssLssLssLs: sB,
    sLsLssLssLs: iB,
    sLssLsLssLs: oB,
    sLssLssLsLs: aB,
    sLssLssLssL: lB,
    ssLsLssLssL: uB,
    ssLssLsLssL: cB,
    ssLssLssLsL: fB,
    sLsLLsLLsLL: dB,
    sLLsLsLLsLL: hB,
    sLLsLLsLsLL: pB,
    sLLsLLsLLsL: mB,
    LsLsLLsLLsL: gB,
    LsLLsLsLLsL: vB,
    LsLLsLLsLsL: yB,
    LsLLsLLsLLs: bB,
    LLsLsLLsLLs: wB,
    LLsLLsLsLLs: EB,
    LLsLLsLLsLs: _B,
    LLLLLsLLLLs: LB,
    LLLLsLLLLLs: SB,
    LLLLsLLLLsL: AB,
    LLLsLLLLLsL: CB,
    LLLsLLLLsLL: $B,
    LLsLLLLLsLL: MB,
    LLsLLLLsLLL: OB,
    LsLLLLLsLLL: NB,
    LsLLLLsLLLL: TB,
    sLLLLLsLLLL: xB,
    sLLLLsLLLLL: IB,
    LsLsLssLsLss: FB,
    LsLssLsLsLss: RB,
    LsLssLsLssLs: PB,
    LssLsLsLssLs: DB,
    LssLsLssLsLs: qB,
    sLsLsLssLsLs: BB,
    sLsLssLsLsLs: kB,
    sLsLssLsLssL: zB,
    sLssLsLsLssL: VB,
    sLssLsLssLsL: UB,
    ssLsLsLssLsL: jB,
    ssLsLssLsLsL: HB
};
Object.defineProperty(Vo, "__esModule", {
    value: !0
});
Vo.modeName = Vo.tamnamsInfo = void 0;
const B0 = c9
  , WB = GB;
function Tv(n, t) {
    return n + t <= 10 || n === t && n <= 10 ? !0 : `${n}L ${t}s`in B0
}
function Yd(n, t) {
    let e, r;
    if (typeof n == "string" ? (r = n,
    e = parseInt(r.split("L")[0]),
    t = parseInt(r.split("L")[1].slice(1, -1))) : (r = `${n}L ${t}s`,
    e = n),
    e < 1 || t < 1)
        return;
    if (r in B0) {
        const m = B0[r];
        return !("abbreviation"in m) && "prefix"in m && (m.abbreviation = m.prefix),
        !("familyPrefix"in m) && "prefix"in m && (m.familyPrefix = m.prefix),
        m
    }
    if (e === t)
        return {
            name: `${e}-wood`
        };
    const i = Math.min(e, t)
      , a = Math.abs(e - t);
    if (Tv(i, a)) {
        const m = Yd(i, a);
        return e > t ? {
            name: "m-chro " + m.name
        } : {
            name: "p-chro " + m.name
        }
    }
    const l = Math.min(i, a)
      , f = Math.abs(i - a);
    if (Tv(l, f)) {
        const g = Yd(l, f).name;
        return i > a ? e > t ? {
            name: "m-enhar " + g
        } : {
            name: "f-enhar " + g
        } : e > t ? {
            name: "p-enhar " + g
        } : {
            name: "s-enhar " + g
        }
    }
    const h = Math.min(l, f)
      , p = Math.abs(l - f);
    if (Tv(h, p)) {
        const g = Yd(h, p).name;
        return l > f ? i > a ? e > t ? {
            name: "quso-" + g
        } : {
            name: "miso-" + g
        } : e > t ? {
            name: "paso-" + g
        } : {
            name: "uso-" + g
        } : i > a ? e > t ? {
            name: "quha-" + g
        } : {
            name: "miha-" + g
        } : e > t ? {
            name: "paha-" + g
        } : {
            name: "uha-" + g
        }
    }
}
Vo.tamnamsInfo = Yd;
function JB(n, t=!1) {
    let e = WB[n];
    return t && (n === "LLsLLLs" ? e = e + " (Major)" : n === "LsLLsLL" && (e = e + " (Minor)")),
    e
}
Vo.modeName = JB;
var hs = {};
Object.defineProperty(hs, "__esModule", {
    value: !0
});
hs.mosGeneratorMonzo = hs.cumsum = hs.bresenham = hs.bjorklundStr = hs.bjorklund = void 0;
const Y1 = Ie;
function KB(n, t, e, r) {
    return Array.from(Fm(n, t)).map(i => i === "s" ? r : e)
}
hs.bjorklund = KB;
function Fm(n, t) {
    if (isNaN(n) || isNaN(t))
        throw new Error("Invalid input");
    const e = (0,
    Y1.gcd)(n, t);
    if (e === 1) {
        let[r,i] = [n, t]
          , a = "L"
          , l = "s";
        for (; i !== 1; )
            r > i ? ([r,i] = [i, r - i],
            [a,l] = [a.concat(l), a]) : (i = i - r,
            a = a.concat(l)),
            a > l && ([r,i] = [i, r],
            [a,l] = [l, a]);
        return a.repeat(r).concat(l)
    } else
        return Fm(n / e, t / e).repeat(e)
}
hs.bjorklundStr = Fm;
function Z2(n, t, e, r) {
    const i = (0,
    Y1.gcd)(n, t);
    if (i === 1) {
        const a = [];
        let[l,f] = [0, 0];
        for (; l < n || f < t; )
            n * (f + 1) <= t * l ? (a.push(r),
            f += 1) : (a.push(e),
            l += 1);
        return a
    } else
        return Array(i).fill(Z2(n / i, t / i, e, r)).flat()
}
hs.bresenham = Z2;
function ZB(n) {
    if (!n.length)
        return [];
    const t = [n[0]];
    for (let e = 1; e < n.length; ++e)
        t.push(t[e - 1] + n[e]);
    return t
}
hs.cumsum = ZB;
const OE = new Map([["2,5", [1, 2]], ["5,2", [3, 1]], ["2,9", [1, 4]], ["3,8", [2, 5]], ["4,7", [3, 5]], ["7,4", [2, 1]], ["8,3", [3, 1]], ["9,2", [5, 1]], ["3,5", [2, 3]], ["5,3", [2, 1]], ["2,7", [1, 3]], ["7,2", [4, 1]], ["3,7", [1, 2]], ["7,3", [5, 2]], ["5,7", [3, 4]], ["7,5", [3, 2]]]);
function YB(n, t) {
    if (t === 1)
        return [1, 0];
    if (n === 1)
        return [1, t - 1];
    if (n === t - 1)
        return [1, 1];
    if (n === t + 1)
        return [n - 1, t - 1];
    const e = `${n},${t}`;
    if (OE.has(e))
        return OE.get(e);
    if (n === 0)
        return [0, 1];
    if (t === 0)
        return [1, 0];
    const r = n + t
      , i = (0,
    Y1.modInv)(t, r)
      , a = Fm(n, t)
      , l = [0, 0]
      , f = [l];
    for (const h of a)
        h === "L" ? l[0] += 1 : l[1] += 1,
        f.push([...l]);
    return f[i]
}
hs.mosGeneratorMonzo = YB;
var is = {};
Object.defineProperty(is, "__esModule", {
    value: !0
});
is.scaleInfo = is.mosPatterns = is.toBrightGeneratorPerPeriod = is.isBright = is.mosSizes = is.mosForms = void 0;
const Uo = Ie
  , k0 = Vo
  , _i = new Uo.Fraction(1);
function Rm(n) {
    return typeof n == "number" ? new Uo.Fraction(n).simplify(1e-12).mmod(_i) : n.mmod(_i)
}
function Q1(n, t, e) {
    e !== void 0 && (e += 2),
    n = Rm(n);
    const r = (0,
    Uo.getConvergents)(n, t, e, !0, !0);
    return r.shift(),
    r.shift(),
    r
}
is.mosForms = Q1;
function QB(n, t, e) {
    return Q1(n, t, e).map(r => r.d)
}
is.mosSizes = QB;
function Y2(n, t) {
    const e = Rm(n)
      , r = _i.sub(e)
      , i = [...Array(t).keys()]
      , a = i.map(f => e.mul(f).mmod(_i));
    a.sort( (f, h) => f.compare(h)),
    a.push(_i);
    const l = i.map(f => r.mul(f).mmod(_i));
    l.sort( (f, h) => f.compare(h)),
    l.push(_i);
    for (let f = 1; f < a.length; ++f) {
        const h = a[f].sub(a[0])
          , p = l[f].sub(l[0])
          , m = h.compare(p);
        if (m > 0)
            return !0;
        if (m < 0)
            return !1
    }
    return !0
}
is.isBright = Y2;
function XB(n, t) {
    const e = Rm(n);
    return Y2(n, t) ? typeof n == "number" ? (0,
    Uo.mmod)(n, 1) : e : typeof n == "number" ? (0,
    Uo.mmod)(-n, 1) : _i.sub(e)
}
is.toBrightGeneratorPerPeriod = XB;
function ek(n, t=1, e, r) {
    r !== void 0 && (r += 1);
    const i = Q1(n, void 0, r)
      , a = [];
    let l;
    for (let f = 0; f < i.length; ++f) {
        const h = i[f];
        if (l !== void 0) {
            if (l * t > e)
                break;
            const p = [...Array(l).keys()].map(F => h.mul(F).mmod(_i));
            p.push(new Uo.Fraction(1)),
            p.sort( (F, B) => F.compare(B));
            let m = p[1];
            for (let F = 0; F < l; ++F) {
                const B = p[F + 1].sub(p[F])
                  , Q = B.compare(m);
                if (Q < 0) {
                    m = B;
                    break
                } else if (Q > 0)
                    break
            }
            let g = 0
              , b = 0;
            for (let F = 0; F < l; ++F)
                p[F].add(m).equals(p[F + 1]) ? g++ : b++;
            l *= t,
            b *= t,
            g *= t;
            const E = `${b}L ${g}s`
              , S = {
                size: l,
                numberOfLargeSteps: b,
                numberOfSmallSteps: g,
                mosPattern: E
            };
            Object.assign(S, (0,
            k0.tamnamsInfo)(E)),
            a.push(S)
        }
        l = h.d
    }
    return a
}
is.mosPatterns = ek;
function tk(n) {
    const t = new Uo.FractionSet;
    for (let e = 1; e < n.length; ++e)
        t.add(n[e].sub(n[e - 1]));
    if (t.size === 1)
        return "M".repeat(n.length);
    if (t.size === 2) {
        const e = [...t];
        e.sort( (i, a) => i.compare(a));
        let r = "";
        for (let i = 1; i < n.length; ++i)
            n[i].sub(n[i - 1]).equals(e[0]) ? r += "s" : r += "L";
        return r
    }
    if (t.size === 3) {
        const e = [...t];
        e.sort( (i, a) => i.compare(a));
        let r = "";
        for (let i = 1; i < n.length; ++i) {
            const a = n[i].sub(n[i - 1]);
            a.equals(e[0]) ? r += "s" : a.equals(e[1]) ? r += "M" : r += "L"
        }
        return r
    }
    throw new Error(`Too many step sizes (${t.size})`)
}
function nk(n, t, e, r=1) {
    if (t % r)
        throw new Error("Size must be divisible by the number of periods");
    if (e % r)
        throw new Error("Number of generators must be divisible by the number of periods");
    t /= r,
    e /= r,
    n = Rm(n);
    const i = n.clone()
      , a = [...Array(t).keys()].map(g => i.mul(g - e).mmod(_i));
    a.push(new Uo.Fraction(1)),
    a.sort( (g, b) => g.compare(b));
    const l = tk(a)
      , f = {
        stepPattern: l.repeat(r)
    };
    if (l.includes("M"))
        return f;
    let h = 0
      , p = 0;
    [...l].forEach(g => {
        g === "s" ? h++ : p++
    }
    ),
    h *= r,
    p *= r;
    const m = `${p}L ${h}s`;
    return f.mosPattern = m,
    f.modeName = (0,
    k0.modeName)(l.repeat(r)),
    Object.assign(f, (0,
    k0.tamnamsInfo)(m)),
    f
}
is.scaleInfo = nk;
var Q2 = {};
Object.defineProperty(Q2, "__esModule", {
    value: !0
});
var X2 = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.generateNotation = n.nthNominal = n.DIAMOND_MOS_ALPHABET = void 0;
    const t = Ie
      , e = hs;
    n.DIAMOND_MOS_ALPHABET = ["J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z"];
    function r(a) {
        if (a < 0 || !Number.isInteger(a))
            throw new Error("Invalid nominal index");
        return a >= n.DIAMOND_MOS_ALPHABET.length ? r(Math.floor(a / n.DIAMOND_MOS_ALPHABET.length) - 1) + n.DIAMOND_MOS_ALPHABET[a % n.DIAMOND_MOS_ALPHABET.length] : n.DIAMOND_MOS_ALPHABET[a]
    }
    n.nthNominal = r;
    function i(a) {
        const l = new Map;
        let f = 0;
        const h = [0, 0];
        let p = !1
          , m = !1;
        for (const V of a)
            if (l.set(r(f++), [...h]),
            V === "L")
                h[0]++,
                p = !0;
            else if (V === "s")
                h[1]++,
                m = !0;
            else
                throw new Error(`Invalid abstract step '${V}'.`);
        if (!p || !m)
            throw new Error("The scale must contain both 'L' and 's' steps.");
        const g = [...h]
          , b = (0,
        t.gcd)(g[0], g[1])
          , E = [g[0] / b, g[1] / b]
          , S = (0,
        e.mosGeneratorMonzo)(E[0], E[1])
          , F = E[0] + E[1]
          , B = 2 * E[0] + E[1]
          , Q = [[0, [0, 0], !0, void 0]];
        if (F === 2)
            Q.push([2, [S[0] - .5, S[1] + .5], !1, void 0]);
        else {
            Q.push([B - 2 * S[0] - S[1], [E[0] - S[0], E[1] - S[1]], !0, [E[0] - S[0] + .5, E[1] - S[1] - .5]]);
            let V = 2 * S[0] + S[1];
            Q.push([V, [...S], !0, [S[0] - .5, S[1] + .5]]),
            h[0] = S[0],
            h[1] = S[1];
            for (let k = 2; k < F - 1; ++k) {
                for (V += 2 * S[0] + S[1],
                h[0] += S[0],
                h[1] += S[1]; V >= B; )
                    V -= B,
                    h[0] -= E[0],
                    h[1] -= E[1];
                Q.push([V, [h[0] - .5, h[1] + .5], !1, void 0])
            }
        }
        Q.sort( (V, k) => V[0] - k[0]);
        const ae = [];
        for (const [V,k,z,Z] of Q)
            ae.push({
                center: k,
                perfect: z,
                mid: Z
            });
        return {
            scale: l,
            degrees: ae,
            equave: g,
            period: E,
            brightGenerator: S
        }
    }
    n.generateNotation = i
}
)(X2);
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(R, W, I, N) {
        N === void 0 && (N = I);
        var P = Object.getOwnPropertyDescriptor(W, I);
        (!P || ("get"in P ? !W.__esModule : P.writable || P.configurable)) && (P = {
            enumerable: !0,
            get: function() {
                return W[I]
            }
        }),
        Object.defineProperty(R, N, P)
    }
    : function(R, W, I, N) {
        N === void 0 && (N = I),
        R[N] = W[I]
    }
    )
      , e = Zt && Zt.__exportStar || function(R, W) {
        for (var I in R)
            I !== "default" && !Object.prototype.hasOwnProperty.call(W, I) && t(W, R, I)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.generatorRanges = n.allForEdo = n.anyForEdo = n.makeEdoMap = n.daughterMos = n.mosScaleInfo = n.parentMos = n.splitMosPattern = n.modeInfo = n.mosModes = n.mosWithDaughter = n.mosWithParent = n.mos = n.stepString = n.brightGeneratorMonzo = n.euclid = void 0;
    const r = _c
      , i = Vo
      , a = hs
      , l = Ie;
    e(_c, n),
    e(Vo, n),
    e(is, n),
    e(Q2, n),
    e(X2, n);
    function f(R, W) {
        return (0,
        a.bjorklund)(R, W, !0, !1)
    }
    n.euclid = f;
    function h(R, W) {
        const I = (0,
        l.gcd)(R, W);
        return [...(0,
        a.mosGeneratorMonzo)(R / I, W / I)]
    }
    n.brightGeneratorMonzo = h;
    function p(R, W, I) {
        let N = 0;
        if (R.up !== void 0) {
            if (N = W * I - I - R.up,
            R.down !== void 0 && N !== R.down)
                throw new Error("Incompatible up and down with the scale size")
        } else
            R.down !== void 0 && (N = R.down);
        if (N < 0)
            throw new Error("Down must not be negative");
        if (N >= W * I)
            throw new Error("Up must not be negative");
        if (N % I !== 0)
            throw new Error("Up/down must be divisible by the number of periods");
        return N
    }
    function m(R, W, I) {
        if (!R)
            return "s".repeat(W);
        if (!W)
            return "L".repeat(R);
        I ?? (I = {});
        const N = (0,
        a.bjorklundStr)(R, W);
        let P = N;
        const J = [];
        for (; J.push(P),
        P = P.slice(1) + P[0],
        P !== N; )
            ;
        J.sort();
        const X = (0,
        l.gcd)(R, W)
          , ie = (R + W) / X
          , ce = p(I, ie, X);
        return J[ce / X]
    }
    n.stepString = m;
    function g(R, W, I) {
        var N, P;
        const J = m(R, W, I)
          , X = (N = I == null ? void 0 : I.sizeOfLargeStep) !== null && N !== void 0 ? N : 2
          , ie = (P = I == null ? void 0 : I.sizeOfSmallStep) !== null && P !== void 0 ? P : 1;
        let ce = 0;
        const Le = [];
        for (const he of J)
            he === "L" ? ce += X : ce += ie,
            Le.push(ce);
        return Le
    }
    n.mos = g;
    function b(R, W, I) {
        var N, P;
        I ?? (I = {});
        const J = (0,
        l.gcd)(R, W)
          , X = (R + W) / J
          , ie = (N = I.sizeOfLargeStep) !== null && N !== void 0 ? N : 2
          , ce = (P = I.sizeOfSmallStep) !== null && P !== void 0 ? P : 1
          , Le = p(I, X, J)
          , he = R / J
          , Fe = W / J
          , Te = Le / J
          , ye = he * ie + Fe * ce
          , qe = (0,
        a.mosGeneratorMonzo)(he, Fe)
          , Ge = qe[0] * ie + qe[1] * ce
          , Se = Math.max(he, Fe)
          , L = new Map;
        for (let Re = 0; Re < X; ++Re) {
            let me;
            I.accidentals === "flat" ? me = X - Re <= Se : me = Re < Se,
            L.set((0,
            l.mmod)((Re - Te) * Ge, ye), me)
        }
        const K = [...L.keys()].sort( (Re, me) => Re - me);
        let de = new Map;
        for (let Re = 0; Re < J; ++Re)
            K.forEach(me => {
                de = de.set(me + Re * ye, L.get(me))
            }
            );
        const $e = de.get(0);
        return de.delete(0),
        de.set(J * ye, $e),
        de
    }
    n.mosWithParent = b;
    function E(R, W, I) {
        var N, P, J;
        I ?? (I = {});
        const X = (0,
        l.gcd)(R, W)
          , ie = (R + W) / X
          , ce = (N = I.sizeOfLargeStep) !== null && N !== void 0 ? N : 2
          , Le = (P = I.sizeOfSmallStep) !== null && P !== void 0 ? P : 1
          , he = p(I, ie, X)
          , Fe = R / X
          , Te = W / X
          , ye = he / X
          , qe = Fe * ce + Te * Le
          , Ge = (0,
        a.mosGeneratorMonzo)(Fe, Te)
          , Se = Ge[0] * ce + Ge[1] * Le
          , L = 2 * Fe + Te
          , K = new Map;
        for (let T = 0; T < ie; ++T)
            K.set((0,
            l.mmod)((T - ye) * Se, qe), "parent");
        const de = (J = I.accidentals) !== null && J !== void 0 ? J : "sharp";
        if (de === "flat" || de === "both" && ce > 2)
            for (let T = ie - L; T < 0; ++T)
                K.set((0,
                l.mmod)((T - ye) * Se, qe), "flat");
        if (de === "sharp" || de === "both") {
            const T = ce === 2 ? "both" : "sharp";
            for (let j = ie; j < L; ++j)
                K.set((0,
                l.mmod)((j - ye) * Se, qe), T)
        }
        const $e = [...K.keys()].sort( (T, j) => T - j);
        let Re = new Map;
        for (let T = 0; T < X; ++T)
            $e.forEach(j => {
                Re = Re.set(j + T * qe, K.get(j))
            }
            );
        const me = Re.get(0);
        return Re.delete(0),
        Re.set(X * qe, me),
        Re
    }
    n.mosWithDaughter = E;
    function S(R, W, I=!1) {
        const N = (0,
        l.gcd)(R, W)
          , P = (R + W) / N
          , J = R / N
          , X = W / N
          , ie = J * 2 + X
          , ce = (0,
        a.mosGeneratorMonzo)(J, X)
          , Le = ce[0] * 2 + ce[1]
          , he = [];
        for (let Fe = 0; Fe < P; ++Fe) {
            const Te = [];
            for (let L = 0; L < P; ++L)
                Te.push((0,
                l.mmod)((Fe - L) * Le, ie));
            Te.sort( (L, K) => L - K);
            let ye = Te;
            for (let L = 1; L < N; ++L)
                ye = ye.concat(Te.map(K => K + L * ie));
            ye.push(N * ie);
            let qe = "";
            for (let L = 1; L < ye.length; ++L)
                ye[L] - ye[L - 1] === 2 ? qe += "L" : qe += "s";
            const Ge = (0,
            i.modeName)(qe, I);
            let Se = `${Fe * N}|${(P - 1 - Fe) * N}`;
            N > 1 && (Se += `(${N})`),
            he.push({
                period: P,
                numberOfPeriods: N,
                udp: Se,
                mode: qe,
                modeName: Ge
            })
        }
        return he
    }
    n.mosModes = S;
    function F(R, W, I) {
        I ?? (I = {});
        const N = (0,
        l.gcd)(R, W)
          , P = (R + W) / N
          , J = p(I, P, N)
          , X = g(R, W, I);
        X.unshift(0);
        let ie = "";
        for (let Fe = 1; Fe < X.length; ++Fe)
            X[Fe] - X[Fe - 1] === 2 ? ie += "L" : ie += "s";
        const ce = (0,
        i.modeName)(ie, I.extraNames);
        let he = `${(P - 1) * N - J}|${J}`;
        return N > 1 && (he += `(${N})`),
        {
            period: P,
            numberOfPeriods: N,
            udp: he,
            mode: ie,
            modeName: ce
        }
    }
    n.modeInfo = F;
    function B(R) {
        const [W,I] = R.split("L")
          , N = parseInt(W.trim(), 10)
          , P = parseInt(I.split("s")[0].trim(), 10);
        return [N, P]
    }
    n.splitMosPattern = B;
    function Q(R, W) {
        let I;
        if (typeof R == "string")
            [I,W] = B(R);
        else if (I = R,
        typeof W != "number")
            throw new Error("Number of small steps must be given");
        const N = Math.max(I, W);
        I = Math.min(I, W),
        W = N - I;
        const P = `${I}L ${W}s`
          , J = {
            size: N,
            numberOfLargeSteps: I,
            numberOfSmallSteps: W,
            mosPattern: P
        };
        return Object.assign(J, (0,
        i.tamnamsInfo)(P)),
        J
    }
    n.parentMos = Q;
    function ae(R, W, I=2, N=1) {
        const P = `${R}L ${W}s`
          , J = (0,
        l.gcd)(R, W)
          , X = R * I + W * N
          , ie = X / J
          , ce = [R / J, W / J]
          , Le = (0,
        a.mosGeneratorMonzo)(...ce)
          , he = (0,
        l.dot)(Le, [I, N])
          , Fe = {
            numberOfLargeSteps: R,
            numberOfSmallSteps: W,
            sizeOfLargeStep: I,
            sizeOfSmallStep: N,
            edo: X,
            numberOfPeriods: J,
            period: ie,
            brightGenerator: he,
            darkGenerator: ie - he,
            periodMonzo: ce,
            brightGeneratorMonzo: Le,
            mosPattern: P,
            hardness: (0,
            r.getHardness)(I, N)
        };
        return Object.assign(Fe, (0,
        i.tamnamsInfo)(P)),
        Fe
    }
    n.mosScaleInfo = ae;
    function V(R, W, I, N) {
        const P = R + W;
        if (I >= 2 * N)
            W = P,
            I -= N;
        else {
            W = R,
            R = P;
            const J = N;
            N = I - N,
            I = J
        }
        return ae(R, W, I, N)
    }
    n.daughterMos = V;
    const k = [[2, 1], [3, 2], [3, 1], [4, 3], [4, 1], [5, 3], [5, 2], [5, 4], [5, 1], [7, 5], [7, 4], [7, 3], [7, 2], [8, 5], [8, 3]];
    function z(R=12) {
        const W = new Map;
        return k.forEach( ([I,N]) => {
            const P = (0,
            r.getHardness)(I, N);
            for (let J = 2; J <= R; ++J)
                for (let X = 1; X < J; ++X) {
                    const ie = J - X
                      , ce = `${X}L ${ie}s`
                      , Le = X * I + ie * N
                      , he = {
                        mosPattern: ce,
                        numberOfLargeSteps: X,
                        numberOfSmallSteps: ie,
                        sizeOfLargeStep: I,
                        sizeOfSmallStep: N,
                        hardness: P
                    };
                    Object.assign(he, (0,
                    i.tamnamsInfo)(ce));
                    const Fe = W.get(Le) || [];
                    Fe.push(he),
                    W.set(Le, Fe)
                }
        }
        ),
        W
    }
    n.makeEdoMap = z;
    const Z = [[5, 2], [4, 3], [3, 4], [2, 5], [3, 5], [5, 3], [6, 2], [2, 6], [4, 2], [2, 4], [5, 1], [2, 3], [3, 2], [1, 4], [1, 3], [1, 2], [2, 1], [1, 1]];
    function re(R) {
        if (R <= 1)
            throw new Error("Minimum size is 2");
        if (R === 2)
            return {
                mosPattern: "1L 1s",
                numberOfLargeSteps: 1,
                numberOfSmallSteps: 1,
                sizeOfLargeStep: 1,
                sizeOfSmallStep: 1,
                edo: R,
                numberOfPeriods: 1,
                period: R,
                brightGenerator: 1,
                darkGenerator: 1,
                periodMonzo: [1, 1],
                brightGeneratorMonzo: [1, 0],
                hardness: "equalized",
                name: "trivial",
                subset: !1
            };
        for (let W = 0; W < Z.length; ++W) {
            const [I,N] = Z[W];
            let P = 2;
            for (; ; ) {
                const J = P * I
                  , X = R - J;
                if (X <= 0)
                    break;
                if (X % N === 0) {
                    const ie = X / N;
                    if (P <= 3 * ie && 3 * ie <= 2 * P) {
                        const ce = `${I}L ${N}s`
                          , Le = (0,
                        r.getHardness)(P, ie)
                          , he = (0,
                        l.gcd)(I, N)
                          , Fe = R / he
                          , Te = [I / he, N / he]
                          , ye = (0,
                        a.mosGeneratorMonzo)(...Te)
                          , qe = (0,
                        l.dot)(ye, [P, ie])
                          , Ge = {
                            mosPattern: ce,
                            numberOfLargeSteps: I,
                            numberOfSmallSteps: N,
                            sizeOfLargeStep: P,
                            sizeOfSmallStep: ie,
                            edo: R,
                            numberOfPeriods: he,
                            period: Fe,
                            brightGenerator: qe,
                            darkGenerator: Fe - qe,
                            periodMonzo: Te,
                            brightGeneratorMonzo: ye,
                            hardness: Le
                        };
                        return Object.assign(Ge, (0,
                        i.tamnamsInfo)(ce)),
                        Ge
                    }
                }
                P++
            }
        }
        throw new Error(`Failed to find MOS pattern for ${R}`)
    }
    n.anyForEdo = re;
    function C(R, W=2, I, N) {
        if (I === void 0 && (I = R),
        W < 2)
            throw new Error("Minimum size must be at least 2");
        if (I > R)
            throw new Error(`Maximum size must be smaller or equal to edo (${R})`);
        const P = [];
        for (let J = 1; J < I; ++J)
            for (let X = Math.max(1, W - J); X <= I - J; X++)
                for (const ie of (0,
                l.fareyInterior)(R - X)) {
                    const {n: ce, d: Le} = ie;
                    if (!(N && Le > ce * N) && J * Le + X * ce === R) {
                        const he = `${J}L ${X}s`
                          , Fe = (0,
                        r.getHardness)(Le, ce)
                          , Te = (0,
                        l.gcd)(J, X)
                          , ye = R / Te
                          , qe = [J / Te, X / Te]
                          , Ge = (0,
                        a.mosGeneratorMonzo)(...qe)
                          , Se = (0,
                        l.dot)(Ge, [Le, ce])
                          , L = {
                            mosPattern: he,
                            numberOfLargeSteps: J,
                            numberOfSmallSteps: X,
                            sizeOfLargeStep: Le,
                            sizeOfSmallStep: ce,
                            hardness: Fe,
                            edo: R,
                            numberOfPeriods: Te,
                            period: ye,
                            brightGenerator: Se,
                            darkGenerator: ye - Se,
                            periodMonzo: qe,
                            brightGeneratorMonzo: Ge
                        };
                        Object.assign(L, (0,
                        i.tamnamsInfo)(he)),
                        P.push(L)
                    }
                }
        return P
    }
    n.allForEdo = C;
    function D(R, W=!1) {
        const I = [];
        for (let N = 1; N < R; N++) {
            const P = R - N
              , J = (0,
            l.gcd)(N, P);
            if (!W && J !== 1)
                continue;
            const X = new l.Fraction(1,J)
              , ie = (0,
            a.mosGeneratorMonzo)(N / J, P / J);
            let ce = new l.Fraction(ie[0],N)
              , Le = new l.Fraction(ie[0] + ie[1],R);
            ce.compare(Le) > 0 && ([ce,Le] = [Le, ce]),
            I.push({
                period: X,
                lowerBound: ce,
                upperBound: Le,
                numberOfLargeSteps: N,
                numberOfSmallSteps: P,
                bright: !0
            }),
            I.push({
                period: X,
                lowerBound: X.sub(Le),
                upperBound: X.sub(ce),
                numberOfLargeSteps: N,
                numberOfSmallSteps: P,
                bright: !1
            })
        }
        return I.sort( (N, P) => N.period.compare(P.period) || N.lowerBound.compare(P.lowerBound)),
        I
    }
    n.generatorRanges = D
}
)(Ms);
var vn = {};
Object.defineProperty(vn, "__esModule", {
    value: !0
});
vn.stepString = vn.norm = vn.letters = vn.stepVectorArity = vn.wordArity = vn.stepVectorMatrix = vn.stepSignature = vn.getStepVector = vn.rotate = vn.sub = vn.neg = vn.scalarMult = vn.add = vn.zeroVector = void 0;
const rk = Ie
  , sk = An
  , Pm = vr
  , NE = [[], ["x"], ["s", "L"], ["s", "M", "L"], ["s", "n", "M", "L"], ["s", "n", "M", "L", "H"], ["t", "s", "n", "M", "L", "H"], ["t", "s", "n", "M", "L", "H", "B"], ["w", "t", "s", "n", "M", "L", "H", "B"], ["w", "t", "s", "n", "M", "L", "H", "C", "B"], ["w", "t", "s", "p", "n", "M", "L", "H", "C", "B"], ["w", "t", "s", "p", "n", "M", "L", "H", "C", "G", "B"], ["w", "t", "s", "p", "n", "m", "M", "L", "H", "G", "C", "B"], ["w", "t", "s", "p", "n", "m", "M", "L", "H", "G", "E", "C", "B"], ["w", "u", "t", "s", "p", "n", "m", "M", "L", "H", "G", "E", "C", "B"], ["w", "u", "t", "s", "p", "n", "m", "N", "M", "L", "H", "G", "E", "C", "B"]]
  , TE = [[], [""], ["", ""]]
  , ik = new sk.TimeMonzo(Pm.ZERO,[]);
function ok(n) {
    let t = 0;
    return n.forEach(e => {
        t += e
    }
    ),
    t
}
function Lc() {
    return {}
}
vn.zeroVector = Lc;
function eS(n, t) {
    const e = {
        ...n
    };
    for (const [r,i] of Object.entries(t))
        (0,
        Pm.hasOwn)(n, r) ? i + n[r] === 0 ? delete e[r] : e[r] += i : e[r] = i;
    return e
}
vn.add = eS;
function Eh(n, t) {
    if (t === 0)
        return Lc();
    {
        const e = {
            ...n
        };
        for (const r of Object.keys(e))
            e[r] *= t;
        return e
    }
}
vn.scalarMult = Eh;
function tS(n) {
    return Eh(n, -1)
}
vn.neg = tS;
function ak(n, t) {
    return eS(n, tS(t))
}
vn.sub = ak;
function nS(n, t) {
    return [...Array(n.length).keys()].map(e => n[(0,
    rk.mmod)(e + t, n.length)]).join("")
}
vn.rotate = nS;
function rS(n, t) {
    if (t ?? (t = n.length),
    n.length === 0)
        return Lc();
    if (t % n.length === 0)
        return Eh(z0(n), Math.floor(t / n.length));
    {
        const e = Eh(z0(n), Math.floor(t / n.length))
          , r = String(n).slice(0, t % n.length);
        return Array.from(r).forEach(i => {
            (0,
            Pm.hasOwn)(e, i) ? e[i]++ : e[i] = 1
        }
        ),
        e
    }
}
vn.getStepVector = rS;
function z0(n) {
    if (n === "")
        return Lc();
    const t = Lc();
    return Array.from(n).forEach(e => {
        (0,
        Pm.hasOwn)(t, e) ? t[e]++ : t[e] = 1
    }
    ),
    t
}
vn.stepSignature = z0;
function lk(n) {
    const t = []
      , e = [...Array(n.length + 1).keys()];
    for (let r = 0; r < n.length; ++r) {
        const i = nS(n, r);
        t.push(e.map(a => rS(i, a)))
    }
    return t
}
vn.stepVectorMatrix = lk;
function uk(n) {
    return new Set(n).size
}
vn.wordArity = uk;
function ck(n) {
    return Object.keys(n).length
}
vn.stepVectorArity = ck;
function fk(n) {
    return Object.keys(n).sort()
}
vn.letters = fk;
function dk(n) {
    return ok(Object.values(n).map(t => Math.abs(t)))
}
vn.norm = dk;
function hk(n) {
    if (!n.length)
        return "";
    const t = [n[0].clone()];
    for (let p = 1; p < n.length; ++p)
        t.push(n[p].div(n[p - 1]));
    const e = [...t];
    e.sort( (p, m) => p.compare(m));
    const r = [e.shift()];
    for (const p of e)
        p.equals(r[r.length - 1]) || r.push(p);
    let i = 0
      , a = 0
      , l = 0;
    for (const p of r) {
        const m = p.compare(ik);
        m < 0 ? i++ : m > 0 ? l++ : a++
    }
    const f = [];
    if (i < TE.length)
        f.push(...TE[i]);
    else {
        for (; i > 25; )
            f.push(""),
            i--;
        for (let p = 0; p < i; ++p)
            f.unshift(String.fromCharCode(945 + p))
    }
    if (a && f.push("z"),
    l < NE.length)
        l === 1 && f.length ? f.push("P") : f.push(...NE[l]);
    else {
        for (; l > 51; )
            f.push("?"),
            l--;
        const p = Math.floor(l / 2);
        for (let g = p - 1; g >= 0; --g)
            f.push(String.fromCharCode(97 + g));
        const m = Math.ceil(l / 2);
        for (let g = m - 1; g >= 0; --g)
            f.push(String.fromCharCode(65 + g))
    }
    let h = "";
    for (const p of t)
        for (let m = 0; m < r.length; ++m)
            p.strictEquals(r[m]) && (h += f[m]);
    return h
}
vn.stepString = hk;
var Fa = {};
Object.defineProperty(Fa, "__esModule", {
    value: !0
});
Fa.hasConstantStructure = Fa.subtensions = void 0;
function pk(n) {
    const t = n.length;
    if (!t)
        return [];
    const e = Math.max(...n.map(l => l.numberOfComponents))
      , r = n.map(l => l.clone());
    for (const l of r)
        l.numberOfComponents = e;
    const i = r[t - 1];
    for (const l of [...r])
        r.push(i.mul(l));
    const a = [];
    for (let l = 0; l < t; ++l) {
        for (const {monzo: f, subtensions: h} of a)
            f.strictEquals(r[l]) && h.add(l + 1);
        a.push({
            monzo: r[l],
            subtensions: new Set([l + 1])
        })
    }
    for (let l = 0; l < t - 1; ++l)
        for (let f = 1; f < t; ++f) {
            const h = r[l + f].div(r[l]);
            let p = !0;
            for (const {monzo: m, subtensions: g} of a)
                h.strictEquals(m) && (g.add(f),
                p = !1);
            p && a.push({
                monzo: h,
                subtensions: new Set([f])
            })
        }
    return a
}
Fa.subtensions = pk;
function mk(n) {
    const t = n.length;
    if (!t)
        return !0;
    const e = Math.max(...n.map(l => l.numberOfComponents))
      , r = n.map(l => l.clone());
    for (const l of r)
        l.numberOfComponents = e;
    const i = r[t - 1];
    for (const l of [...r])
        r.push(i.mul(l));
    const a = [];
    for (let l = 0; l < t; ++l) {
        for (const [f] of a)
            if (f.strictEquals(r[l]))
                return !1;
        a.push([r[l], l + 1])
    }
    for (let l = 0; l < t - 1; ++l)
        for (let f = 1; f < t; ++f) {
            const h = r[l + f].div(r[l]);
            let p = !0;
            for (const [m,g] of a)
                if (h.strictEquals(m)) {
                    if (g !== f)
                        return !1;
                    p = !1
                }
            p && a.push([h, f])
        }
    return !0
}
Fa.hasConstantStructure = mk;
var Mi = {};
Object.defineProperty(Mi, "__esModule", {
    value: !0
});
Mi.absoluteMosMonzo = Mi.mosMonzo = Mi.scaleMonzos = void 0;
const gk = Ie
  , sS = An
  , _h = xm
  , iS = vr;
function vk(n) {
    const t = Array.from(n.scale);
    t.sort( (r, i) => r[0].length < i[0].length ? -1 : r[0].length > i[0].length ? 1 : r[0].localeCompare(i[0]));
    const e = t.map(r => r[1]);
    return e.push(e.shift().mul(n.equave)),
    e
}
Mi.scaleMonzos = vk;
function yk(n, t) {
    const e = (0,
    gk.mmod)(Math.abs(n.degree), t.degrees.length)
      , r = (n.degree - e) / t.degrees.length
      , i = t.degrees[e]
      , a = n.quality.quality;
    let l = new sS.TimeMonzo(iS.ZERO,[]);
    if (a === "a" || a === "" || a === "aug" || a === "Aug" ? l = t.am : a === "d" || a === "dim" ? l = t.am.inverse() : a === "M" || a === "maj" || a === "Maj" ? l = t.semiam : (a === "m" || a === "min") && (l = t.semiam.inverse()),
    n.quality.fraction !== "") {
        const f = _h.VULGAR_FRACTIONS.get(n.quality.fraction);
        l = l.pow(f)
    }
    for (const f of n.augmentations ?? [])
        f === "d" || f === "dim" ? l = l.div(t.am) : l = l.mul(t.am);
    if (i.imperfect) {
        if (a === "a" || a === "" || a === "aug" || a === "Aug" ? l = l.mul(t.semiam) : (a === "d" || a === "dim") && (l = l.div(t.semiam)),
        a === "P")
            throw new Error(`The mosstep ${e} does not have a perfect variant.`)
    } else if (a === "n" || a === "neu") {
        if (!i.mid)
            throw new Error("Missing mid mosstep quality.");
        return i.mid
    } else if (a === "M" || a === "maj" || a === "Maj" || a === "m" || a === "min")
        throw new Error(`The mosstep ${e} does not have minor or major variants.`);
    return i.center.mul(l).mul(t.period.pow(r))
}
Mi.mosMonzo = yk;
function bk(n, t) {
    switch (n) {
    case "&":
        return t.am;
    case "e":
        return t.semiam;
    case "@":
        return t.am.inverse();
    case "a":
        return t.semiam.inverse()
    }
    if (!_h.ACCIDENTAL_VECTORS.has(n))
        throw new Error(`Accidental ${n} is unassigned.`);
    const e = _h.ACCIDENTAL_VECTORS.get(n);
    return new sS.TimeMonzo(iS.ZERO,e)
}
function wk(n, t) {
    if (!t.scale.has(n.nominal))
        throw new Error(`Nominal ${n.nominal} is unassigned.`);
    let e = t.scale.get(n.nominal).clone();
    for (const r of n.accidentals) {
        const i = bk(r.accidental, t)
          , a = _h.VULGAR_FRACTIONS.get(r.fraction)
          , l = i.pow(a);
        e = e.mul(l)
    }
    return e.mul(t.equave.pow(n.octave - 4))
}
Mi.absoluteMosMonzo = wk;
var Dm = {};
Object.defineProperty(Dm, "__esModule", {
    value: !0
});
Dm.MATH_BUILTINS = void 0;
const Rs = hn
  , ti = An
  , Hs = In
  , Ek = new Rs.Interval(ti.TimeReal.fromValue(Math.E),"linear")
  , _k = new Rs.Interval(ti.TimeReal.fromValue(Math.LN10),"linear")
  , Lk = new Rs.Interval(ti.TimeReal.fromValue(Math.LN2),"linear")
  , Sk = new Rs.Interval(ti.TimeReal.fromValue(Math.LOG10E),"linear")
  , Ak = new Rs.Interval(ti.TimeReal.fromValue(Math.LOG2E),"linear")
  , Ck = new Rs.Interval(ti.TimeReal.fromValue(Math.PI),"linear")
  , $k = new Rs.Interval(ti.TimeMonzo.fromEqualTemperament("-1/2"),"linear")
  , Mk = new Rs.Interval(ti.TimeMonzo.fromEqualTemperament("1/2"),"linear")
  , Ok = new Rs.Interval(ti.TimeReal.fromValue(2 * Math.PI),"linear")
  , oS = {}
  , Nk = ["acos", "asin", "atan", "clz32", "cos", "expm1", "fround", "imul", "log1p", "sin", "tan"]
  , Tk = ["acos", "asin", "atan", "clz32", "log1p"];
for (const n of Nk) {
    let e = function(r) {
        if ((0,
        Hs.requireParameters)({
            x: r
        }),
        typeof r == "boolean" || r instanceof Rs.Interval)
            return r = (0,
            Hs.upcastBool)(r),
            new Rs.Interval(ti.TimeReal.fromValue(t(r.valueOf())),Tk.includes(n) ? "linear" : r.domain,0,void 0,r);
        const i = e.bind(this);
        return Hs.unaryBroadcast.bind(this)(r, i)
    };
    const t = Math[n];
    Object.defineProperty(e, "name", {
        value: n,
        enumerable: !1
    }),
    e.__doc__ = `Calculate ${String(n)} x.`,
    e.__node__ = (0,
    Hs.builtinNode)(e),
    oS[n] = e
}
function Gl(n, t) {
    return (0,
    Hs.isArrayOrRecord)(n) || (0,
    Hs.isArrayOrRecord)(t) ? Hs.binaryBroadcast.bind(this)(n, t, Gl.bind(this)) : (n = (0,
    Hs.upcastBool)(n),
    t = (0,
    Hs.upcastBool)(t),
    new Rs.Interval(ti.TimeReal.fromValue(Math.atan2(n.valueOf(), t.valueOf())),"linear"))
}
Gl.__doc__ = "Calculate atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (; ], positive anticlockwise.";
Gl.__node__ = (0,
Hs.builtinNode)(Gl);
function Lh(n, t) {
    return Gl.bind(this)(t, n)
}
Lh.__doc__ = "Calculate atanXY(x, y) = atan2(y, x) which is the angle between (1, 0) and (x, y), chosen to lie in (; ], positive anticlockwise.";
Lh.__node__ = (0,
Hs.builtinNode)(Lh);
Dm.MATH_BUILTINS = {
    ...oS,
    atan2: Gl,
    atanXY: Lh,
    E: Ek,
    LN10: _k,
    LN2: Lk,
    LOG10E: Sk,
    LOG2E: Ak,
    PI: Ck,
    SQRT1_2: $k,
    SQRT2: Mk,
    TAU: Ok
};
var qm = {}
  , Bm = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.valToSparseOffset = n.valToWarts = n.sparseOffsetToVal = n.wartsToVal = n.parseValSubgroup = n.parseSubgroup = n.STEP_ELEMENT = void 0;
    const t = Ie
      , e = An
      , r = vr
      , i = hn
      , a = new e.TimeMonzo(r.ZERO,[r.ONE])
      , l = new e.TimeMonzo(r.ONE,[])
      , f = new e.TimeMonzo(r.NEGATIVE_ONE,[])
      , h = new e.TimeReal(0,1.0005777895065548)
      , p = new e.TimeReal(0,1 / 0);
    n.STEP_ELEMENT = Symbol();
    function m(k, z, Z) {
        if (!k)
            return z[0];
        const re = k.charCodeAt(0) - 97;
        if (re < 15)
            return e.TimeMonzo.fromFraction(t.PRIMES[re]);
        if (re > 15)
            return Z[re - 16]
    }
    function g(k, z) {
        for (let re = 0; re < z.length; ++re)
            if (k.equals(z[re])) {
                if (re > 9)
                    throw new Error("Out of non-prime letters.");
                return String.fromCharCode(113 + re)
            }
        const Z = t.BIG_INT_PRIMES.indexOf(k.toBigInteger());
        if (Z < 0 || Z > 14)
            throw new Error("Out of prime letters.");
        return String.fromCharCode(97 + Z)
    }
    function b(k, z) {
        const Z = []
          , re = [];
        let C = 0
          , D = !1;
        function R() {
            if (D)
                throw new Error("Can only span subgroups to primes.");
            D = !1
        }
        for (const W of k)
            if (W === "s")
                Z.push(l),
                R();
            else if (W === "Hz" || W === "hz")
                Z.push(f),
                R();
            else if (W === "rc" || W === "r")
                Z.push(h),
                R();
            else if (W === "inf")
                Z.push(p);
            else if (W === "1" || W === "deg")
                Z.push(n.STEP_ELEMENT),
                R();
            else if (W === "")
                D = !0;
            else if ((W.denominator === null || W.denominator === 1) && !W.radical)
                if (t.PRIMES.includes(W.numerator)) {
                    const I = t.PRIMES.indexOf(W.numerator);
                    if (D)
                        for (let N = C; N <= I; ++N) {
                            const P = e.TimeMonzo.fromFraction(t.PRIMES[N]);
                            Z.push(P)
                        }
                    else {
                        const N = e.TimeMonzo.fromFraction(W.numerator);
                        Z.push(N)
                    }
                    C = I + 1,
                    D = !1
                } else {
                    const I = e.TimeMonzo.fromFraction(W.numerator);
                    Z.push(I),
                    re.push(I),
                    R()
                }
            else {
                let I = e.TimeMonzo.fromFraction(new t.Fraction(W.numerator,W.denominator ?? void 0));
                if (W.radical) {
                    const N = I.sqrt();
                    if (N instanceof e.TimeMonzo)
                        I = N;
                    else
                        throw new Error("Not enough components for a radical subgroup.")
                }
                Z.push(I),
                re.push(I),
                R()
            }
        if (D)
            if (z === void 0)
                for (let W = C; W < (0,
                e.getNumberOfComponents)(); ++W) {
                    const I = e.TimeMonzo.fromFraction(t.PRIMES[W]);
                    Z.push(I)
                }
            else {
                const W = C - 1 + z;
                for (; Z.length < z; ) {
                    const I = e.TimeMonzo.fromFraction(t.PRIMES[C++], W);
                    Z.push(I)
                }
            }
        return {
            subgroup: Z,
            nonPrimes: re
        }
    }
    n.parseSubgroup = b;
    function E(k, z) {
        return b(k, z)
    }
    n.parseValSubgroup = E;
    function S(k, z) {
        for (const C of z) {
            if (C.timeExponent.n)
                throw new Error("Vals cannot be constructed from absolute basis elements.");
            if (C.residual.s !== 1)
                throw new Error("Vals cannot be constructed from non-positive basis elements.")
        }
        const Z = k / Math.log(z[0].valueOf());
        return z.map(C => Z * Math.log(C.valueOf())).map(Math.round)
    }
    function F(k, z) {
        for (let Z = 0; Z < z.length; ++Z)
            if (z[Z].equals(k)) {
                z.unshift(z.splice(Z, 1)[0]);
                return
            }
        throw new Error("Equave outside subgroup.")
    }
    function B(k, z) {
        let Z, re;
        if (Array.isArray(k.basis))
            ({subgroup: Z, nonPrimes: re} = E(k.basis));
        else {
            if (!z)
                throw new Error("An explicit basis must be provided.");
            Z = [...z.value],
            re = z.nonPrimes
        }
        const C = m(k.equave, Z, re);
        C && F(C, Z);
        const D = k.divisions / Math.log(Z[0].valueOf())
          , R = Z.map(P => D * Math.log(P.valueOf()))
          , W = R.map(Math.round)
          , I = Array(Z.length).fill(0);
        for (const P of k.warts) {
            const J = m(P, Z, re);
            if (J)
                for (let X = 0; X < Z.length; ++X)
                    Z[X].equals(J) && I[X]++
        }
        for (let P = 0; P < Z.length; ++P) {
            let J = Math.ceil(I[P] * .5);
            I[P] % 2 === 0 && (J = -J),
            R[P] - W[P] >= 0 ? W[P] += J : W[P] -= J
        }
        const N = z ? void 0 : k;
        return z = new i.ValBasis(Z),
        i.Val.fromBasisMap(W, z, N)
    }
    n.wartsToVal = B;
    function Q(k, z) {
        let Z;
        if (Array.isArray(k.basis))
            ({subgroup: Z} = E(k.basis));
        else {
            if (!z)
                throw new Error("An explicit basis must be provided.");
            Z = [...z.value]
        }
        let re = a;
        if (k.equave) {
            if (re = e.TimeMonzo.fromFraction(new t.Fraction(k.equave.numerator,k.equave.denominator ?? 1)),
            k.equave.radical) {
                const R = re.sqrt();
                if (R instanceof e.TimeReal)
                    throw new Error("Unable to split val equave.");
                re = R
            }
            F(re, Z)
        }
        const C = S(k.divisions, Z);
        for (const R of k.tweaks) {
            const W = e.TimeMonzo.fromFraction(new t.Fraction(R.element.numerator,R.element.denominator ?? 1));
            let I = !1;
            for (let N = 0; N < Z.length; ++N)
                Z[N].equals(W) && (C[N] += R.tweak,
                I = !0);
            if (!I)
                throw new Error("Tweak outside subgroup.")
        }
        const D = z ? void 0 : k;
        return z = new i.ValBasis(Z),
        i.Val.fromBasisMap(C, z, D)
    }
    n.sparseOffsetToVal = Q;
    function ae(k, z) {
        const {subgroup: Z, nonPrimes: re} = E(z)
          , C = Z.map(W => W.dot(k).valueOf())
          , D = C[0].valueOf();
        if (!Number.isInteger(D))
            throw new Error("Fractional divisions cannot be formatted as warts.");
        const R = [];
        for (let W = 1; W < Z.length; ++W) {
            const I = Z[W].log(Z[0]).valueOf() * D
              , N = Math.round(I)
              , P = C[W] - N;
            if (P) {
                const J = g(Z[W], re);
                let X = 2 * Math.abs(P);
                I >= N ? P > 0 && X-- : P < 0 && X--;
                for (let ie = 0; ie < X; ++ie)
                    R.push(J)
            }
        }
        return {
            type: "WartsLiteral",
            equave: "",
            divisions: D,
            warts: R,
            basis: z
        }
    }
    n.valToWarts = ae;
    function V(k, z) {
        const {subgroup: Z} = E(z)
          , re = Z.map(R => R.dot(k).valueOf())
          , C = re[0].valueOf();
        if (!Number.isInteger(C))
            throw new Error("Fractional divisions cannot be formatted as Sparse Offset Vals.");
        const D = [];
        for (let R = 1; R < Z.length; ++R) {
            const W = Z[R].log(Z[0]).valueOf() * C
              , I = Math.round(W)
              , N = re[R] - I;
            if (N) {
                let P = Z[R]
                  , J = !1;
                P.isFractional() || (J = !0,
                P = P.pow(2));
                const {s: X, n: ie, d: ce} = Z[R].toFraction()
                  , Le = {
                    radical: J,
                    numerator: X * ie,
                    denominator: ce === 1 ? null : ce
                };
                D.push({
                    element: Le,
                    tweak: N
                })
            }
        }
        return {
            type: "SparseOffsetVal",
            equave: "",
            divisions: C,
            tweaks: D,
            basis: z
        }
    }
    n.valToSparseOffset = V
}
)(Bm);
Object.defineProperty(qm, "__esModule", {
    value: !0
});
qm.TEMPER_BUILTINS = void 0;
const Sc = Ie
  , At = hn
  , Xr = An
  , vt = In
  , xv = Wt
  , V0 = vr
  , aS = Bm
  , xk = $i;
function jo(n, t, e) {
    if (n instanceof At.Val && (n = [n]),
    !Array.isArray(n))
        throw new Error("An array of vals is required.");
    for (const a of n)
        if (!(a instanceof At.Val))
            throw new Error("An array of vals is required.");
    t instanceof At.Interval && (t = [t]);
    let r;
    if (t !== void 0) {
        if (!Array.isArray(t))
            throw new Error("An array of weights is required.");
        r = t.map(a => (0,
        vt.upcastBool)(a).valueOf())
    }
    const i = n;
    return i.length && this.spendGas(i[0].basis.size * i.length),
    At.Temperament.fromVals(i, r, (0,
    vt.sonicTruth)(e))
}
Object.defineProperty(jo, "name", {
    value: "Temperament",
    enumerable: !1
});
jo.__doc__ = "Construct a Temperament instance from an array of vals. Optional weights are applied multiplicatively on top of Tenney weights. Optionally equaves are normalized to pure.";
jo.__node__ = (0,
vt.builtinNode)(jo);
function Sh(n, t, e, r, i) {
    if (n instanceof At.Interval && (n = [n]),
    !Array.isArray(n))
        throw new Error("An array of intervals is required.");
    const a = [];
    for (let f of n) {
        if (f = (0,
        vt.upcastBool)(f),
        f.value instanceof Xr.TimeReal)
            throw new Error("Real values not supported as commas.");
        a.push(f.value)
    }
    e instanceof At.Interval && (e = [e]);
    let l;
    if (e !== void 0) {
        if (!Array.isArray(e))
            throw new Error("An array of weights is required.");
        l = e.map(f => (0,
        vt.upcastBool)(f).valueOf())
    }
    if (t !== void 0) {
        if (t instanceof At.Interval) {
            const f = Sc.PRIMES.indexOf(t.toInteger()) + 1;
            if (!f)
                throw new Error("A prime limit is required.");
            t = new At.ValBasis(f)
        }
        if (!(t instanceof At.ValBasis))
            throw new Error("A basis is required.")
    }
    return a.length && this.spendGas(a[0].numberOfComponents * a.length),
    At.Temperament.fromCommas(a, t, l, (0,
    vt.sonicTruth)(r), void 0, (0,
    vt.sonicTruth)(i))
}
Sh.__doc__ = "Construct a Temperament instance from an array of commas. Optional weights are applied multiplicatively on top of Tenney weights. Optionally equaves are normalized to pure. Optionally the full prime limit is assumed based on the commas.";
Sh.__node__ = (0,
vt.builtinNode)(Sh);
function Ac(n, t) {
    if ((0,
    vt.requireParameters)({
        interval: n,
        index: t
    }),
    n instanceof At.Interval || typeof n == "boolean")
        return n = (0,
        vt.upcastBool)(n),
        new At.Interval(n.value.tail(t.toInteger()),n.domain,n.steps,void 0,n);
    const e = Ac.bind(this);
    return vt.unaryBroadcast.bind(this)(n, r => e(r, t))
}
Ac.__doc__ = "Return the higher prime tail of an interval starting from the given index. Prime 2 has index 0.";
Ac.__node__ = (0,
vt.builtinNode)(Ac);
function Cc(n, t=!1) {
    if ((0,
    vt.isArrayOrRecord)(n)) {
        const r = Cc.bind(this);
        return vt.unaryBroadcast.bind(this)(n, i => r(i, t))
    }
    let e;
    if (n instanceof At.Val) {
        if (t)
            return (0,
            vt.fromInteger)(n.value.numberOfComponents);
        if (!n.value.residual.isUnity())
            throw new Error("Non-standard val encountered.");
        e = n.value.primeExponents
    } else {
        const r = (0,
        vt.upcastBool)(n).value;
        if (r instanceof Xr.TimeReal)
            return new At.Interval(new Xr.TimeReal(0,1 / 0),"linear");
        if (!r.residual.isUnity()) {
            const i = (0,
            Sc.primeLimit)(r.residual, !0);
            return Number.isInteger(i) ? (0,
            vt.fromInteger)(i) : new At.Interval(new Xr.TimeReal(0,i),"linear")
        }
        if (t)
            return (0,
            vt.fromInteger)(r.numberOfComponents);
        e = r.primeExponents
    }
    for (let r = e.length - 1; r >= 0; --r)
        if (e[r].n)
            return (0,
            vt.fromInteger)(r + 1);
    return (0,
    vt.fromInteger)(0)
}
Cc.__doc__ = "Compute the prime limit ordinal of an interval or val. 1/1 has a complexity of 0, 2/1 has complexity 1, 3/1 has complexity 2, 5/1 has complexity 3, etc.. If `countZeros` is true, measure the complexity of the internal representation instead.";
Cc.__node__ = (0,
vt.builtinNode)(Cc);
function $c(n) {
    if ((0,
    vt.isArrayOrRecord)(n)) {
        const t = $c.bind(this);
        return vt.unaryBroadcast.bind(this)(n, t)
    }
    if (n instanceof At.Val || n instanceof At.Temperament)
        return n.basis;
    throw new Error("A val is required.")
}
$c.__doc__ = "Return the basis of a val or a temperament.";
$c.__node__ = (0,
vt.builtinNode)($c);
function Mc(n, t) {
    if ((0,
    vt.requireParameters)({
        val: n,
        basis: t
    }),
    (0,
    vt.isArrayOrRecord)(n)) {
        const e = Mc.bind(this);
        return vt.unaryBroadcast.bind(this)(n, r => e(r, t))
    }
    if (n instanceof At.Val)
        return new At.Val(n.value.clone(),t);
    throw new Error("A val is required.")
}
Mc.__doc__ = "Change the basis of the val.";
Mc.__node__ = (0,
vt.builtinNode)(Mc);
function Oc(n) {
    var t;
    if ((0,
    vt.requireParameters)({
        val: n
    }),
    n instanceof At.Val) {
        if (((t = n.node) == null ? void 0 : t.type) === "WartsLiteral")
            return n;
        const e = n.basis.toWartBasis()
          , r = (0,
        aS.valToWarts)(n.value, e);
        return new At.Val(n.value,n.basis,r)
    }
    return vt.unaryBroadcast.bind(this)(n, Oc.bind(this))
}
Oc.__doc__ = "Format a val using warts shorthand notation.";
Oc.__node__ = (0,
vt.builtinNode)(Oc);
function Nc(n) {
    var t;
    if ((0,
    vt.requireParameters)({
        val: n
    }),
    n instanceof At.Val) {
        if (((t = n.node) == null ? void 0 : t.type) === "SparseOffsetVal")
            return n;
        const e = n.basis.toWartBasis()
          , r = (0,
        aS.valToSparseOffset)(n.value, e);
        return new At.Val(n.value,n.basis,r)
    }
    return vt.unaryBroadcast.bind(this)(n, Nc.bind(this))
}
Nc.__doc__ = "Format a val using Sparse Offset Val notation.";
Nc.__node__ = (0,
vt.builtinNode)(Nc);
function Ah(n) {
    if (n instanceof At.Val) {
        const t = n.divisions;
        return [new At.Interval(n.equave.pow(t.inverse()),"logarithmic")]
    }
    if (!(n instanceof At.Temperament))
        throw new Error("A temperament is required.");
    return n.generators.map(t => new At.Interval(Xr.TimeReal.fromCents(t),"logarithmic"))
}
Ah.__doc__ = "Obtain the generators of a temperament with period first. See `mappingBasis` for the untempered mapping generators.";
Ah.__node__ = (0,
vt.builtinNode)(Ah);
function Ch(n) {
    if (n instanceof At.Val)
        return (0,
        vt.fromInteger)(n.divisions.valueOf());
    if (!(n instanceof At.Temperament))
        throw new Error("A temperament is required.");
    return (0,
    vt.fromInteger)(n.numberOfPeriods)
}
Ch.__doc__ = "Obtain the number of periods per equave in a temperament.";
Ch.__node__ = (0,
vt.builtinNode)(Ch);
function $h(n) {
    if (n instanceof At.Val && (n = jo.bind(this)(n)),
    !(n instanceof At.Temperament))
        throw new Error("A temperament is required.");
    return n.preimage
}
$h.__doc__ = "Obtain the mapping generators (preimage) of a temperament or a val with period first. See `generatorsOf` for the tempered generators.";
$h.__node__ = (0,
vt.builtinNode)($h);
function Mh(n) {
    if (n instanceof At.Val && (n = jo.bind(this)(n)),
    !(n instanceof At.Temperament))
        throw new Error("A temperament is required.");
    return n.commaBasis
}
Mh.__doc__ = "Obtain the comma basis (null space) of a temperament or a val.";
Mh.__node__ = (0,
vt.builtinNode)(Mh);
function Oh(...n) {
    const t = xv.relative.bind(this)
      , e = n.map( (a, l) => a ? t(a).value : Xr.TimeMonzo.fromBigInt(Sc.BIG_INT_PRIMES[l]));
    function r(a) {
        if ((0,
        vt.isArrayOrRecord)(a)) {
            const p = r.bind(this);
            return vt.unaryBroadcast.bind(this)(a, p)
        }
        a = (0,
        vt.upcastBool)(a);
        const l = xv.relative.bind(this)(a).value;
        if (l instanceof Xr.TimeReal)
            return new At.Interval(l,"logarithmic",0,l.asCentsLiteral(),a);
        this.spendGas(e.length),
        l.numberOfComponents = e.length;
        let f = new Xr.TimeMonzo(V0.ZERO,[],l.residual);
        for (; f.primeExponents.length < e.length; )
            f.primeExponents.push(V0.ZERO);
        for (let p = 0; p < e.length; ++p)
            f = f.mul(e[p].pow(l.primeExponents[p]));
        let h = f.asCentsLiteral();
        return h || (f = Xr.TimeReal.fromCents(f.totalCents()),
        h = f.asCentsLiteral()),
        new At.Interval(f,"logarithmic",0,h,a)
    }
    const i = xv.repr.bind(this);
    return Object.defineProperty(r, "name", {
        value: `PrimeMapping(${n.map(i).join(", ")})`,
        enumerable: !1
    }),
    r.__doc__ = "Prime re-mapper.",
    r.__node__ = (0,
    vt.builtinNode)(r),
    r
}
Oh.__doc__ = "Construct a prime mapping for tempering intervals to specified cents. Remaining primes are left untempered.";
Oh.__node__ = (0,
vt.builtinNode)(Oh);
function X1(n, t) {
    const e = [];
    if (n instanceof At.Interval)
        e.push(n.valueOf());
    else if (n) {
        if (!Array.isArray(n))
            throw new Error("Weights must be an array if given.");
        e.push(...n.map(r => (0,
        vt.upcastBool)(r).valueOf()))
    }
    for (; e.length < t; )
        e.push(1);
    return e
}
function Tc(n, t, e=!1) {
    if (n instanceof At.Val) {
        const i = X1(t, n.basis.size);
        return this.spendGas(5 * i.length),
        e = (0,
        vt.sonicTruth)(e),
        e ? At.Interval.fromValue(n.errorTE(i, e)) : new At.Interval(Xr.TimeReal.fromCents(n.errorTE(i)),"logarithmic")
    }
    if (n instanceof At.Temperament) {
        if (t !== void 0)
            throw new Error("No additional weights may be given for temperaments.");
        if ((0,
        vt.sonicTruth)(e))
            throw new Error("Only RMS error supported with temperaments.");
        return new At.Interval(Xr.TimeReal.fromCents(n.errorTE()),"logarithmic")
    }
    const r = Tc.bind(this);
    return vt.unaryBroadcast.bind(this)(n, i => r(i, t))
}
Tc.__doc__ = "Calculate Tenney-Euclid error w.r.t the vals basis. Weights are applied multiplicatively on top of Tenney weights if given. Unnormalized values are slightly faster to compute and are in the linear domain instead of (logarithmic) cents.";
Tc.__node__ = (0,
vt.builtinNode)(Tc);
function xc(n, t) {
    if (n instanceof At.Val) {
        const r = X1(t, n.basis.size);
        return n.nextGPV(r)
    }
    const e = xc.bind(this);
    return vt.unaryBroadcast.bind(this)(n, r => e(r, t))
}
xc.__doc__ = "Obtain the next generalized patent val in the sequence.";
xc.__node__ = (0,
vt.builtinNode)(xc);
function Nh(n, t, e) {
    if (!Array.isArray(n))
        throw new Error("An array of vals is required.");
    if (!n.length)
        throw new Error("At least one val is required.");
    for (const g of n)
        if (!(g instanceof At.Val))
            throw new Error("An array of vals is required.");
    const r = n
      , i = r[0].basis;
    for (const g of r.slice(1))
        if (!g.basis.equals(i))
            throw new Error("Vals bases must agree in tuning.");
    const a = t === void 0 ? 1 : (0,
    vt.upcastBool)(t).toInteger();
    this.spendGas(.25 * i.numberOfComponents * (2 * a + 1) ** n.length);
    const l = i.value.map(g => g.totalCents())
      , f = X1(e, i.size)
      , h = r.map(g => (0,
    Sc.applyWeights)((0,
    Sc.unapplyWeights)(i.value.map(b => b.dot(g.value).valueOf()), l), f))
      , p = (0,
    xk.intCombineTuningMaps)(f, h, a);
    let m = r[0].mul((0,
    vt.fromInteger)(p[0]));
    for (let g = 1; g < p.length; ++g)
        m = m.add(r[g].mul((0,
        vt.fromInteger)(p[g])));
    return m.abs()
}
Nh.__doc__ = "Attempt to combine the given vals into a more Tenney-Euclid optimal val. Weights are applied multiplicatively on top of Tenney weights of the subgroup basis.";
Nh.__node__ = (0,
vt.builtinNode)(Nh);
function Ic(...n) {
    const t = [];
    for (let e of n) {
        if (e = (0,
        vt.upcastBool)(e),
        e.value instanceof Xr.TimeReal)
            throw new Error("Can only create basis from radicals.");
        t.push(e.value)
    }
    return new At.ValBasis(t)
}
Ic.__doc__ = "Construct a subgroup basis from intervals.";
Ic.__node__ = (0,
vt.builtinNode)(Ic);
function Th(n) {
    return n.value.map(t => new At.Interval(t,"linear"))
}
Th.__doc__ = "Convert a subgroup basis to an array of basis elements.";
Th.__node__ = (0,
vt.builtinNode)(Th);
function lS(n, t) {
    if (typeof n == "boolean" || n instanceof At.Interval) {
        n = (0,
        vt.upcastBool)(n);
        let r = n.value
          , i = V0.ONE;
        if (!r.isFractional()) {
            if (r instanceof Xr.TimeReal)
                return n;
            try {
                const h = r.toEqualTemperament();
                r = Xr.TimeMonzo.fromFraction(h.equave),
                i = h.fractionOfEquave
            } catch {}
        }
        let a = r.tenneyHeight()
          , l = r;
        for (; l; ) {
            r = l,
            l = void 0;
            for (const h of t) {
                this.spendGas();
                const p = r.mul(h);
                let m = p.tenneyHeight();
                !i.isUnity() && p.pow(i).isFractional() && (m -= 1e4),
                m < a && (l = p,
                a = m)
            }
        }
        const f = n.domain === "linear";
        return i.isUnity() ? new At.Interval(r,n.domain,n.steps,(0,
        At.intervalValueAs)(r, n.node, f),n) : (r = r.pow(i),
        new At.Interval(r,n.domain,n.steps,(0,
        At.intervalValueAs)(r, n.node, f),n))
    }
    const e = lS.bind(this);
    return vt.unaryBroadcast.bind(this)(n, r => e(r, t))
}
function xh(n, t) {
    if ((n instanceof At.Interval || n instanceof At.Val) && (n = [n]),
    Array.isArray(n)) {
        if (!n.length)
            throw new Error("At least one comma or val is required.");
        n[0]instanceof At.Interval ? n = Ic.bind(this)(...n) : n = jo.bind(this)(n)
    }
    if (n instanceof At.Temperament) {
        const l = n;
        if (t === void 0) {
            let f = function(h) {
                if (h = (0,
                vt.upcastBool)(h),
                h.value instanceof Xr.TimeReal)
                    return h;
                this.spendGas(l.commaBasis.size);
                const p = l.respell(h.value);
                return new At.Interval(p,h.domain,h.steps,(0,
                At.intervalValueAs)(p, h.node, !0),h)
            };
            return f.__doc__ = "Respeller",
            f.__node__ = (0,
            vt.builtinNode)(f),
            f
        }
        n = l.commaBasis
    }
    if (!(n instanceof At.ValBasis))
        throw new Error("A basis is required.");
    this.spendGas(.3 * n.numberOfComponents * n.size ** 2),
    n = n.lll("tenney");
    let e = 1;
    t !== void 0 && (e = (0,
    vt.upcastBool)(t).toInteger()),
    this.spendGas((2 * e + 1) ** n.size);
    const r = n.hypercube(e, !0)
      , i = lS.bind(this)
      , a = l => i(l, r);
    return a.__doc__ = "Respeller",
    a.__node__ = (0,
    vt.builtinNode)(a),
    a
}
xh.__doc__ = "Respell i.e. simplify fractions in the the current scale treating intervals separated by the given commas as the same. Search radius (default 1) is an integer for discovering harder-to-find simplifications. (Creates a respelling function.)";
xh.__node__ = (0,
vt.builtinNode)(xh);
qm.TEMPER_BUILTINS = {
    Temperament: jo,
    commaList: Sh,
    tail: Ac,
    complexityOf: Cc,
    basisOf: $c,
    withBasis: Mc,
    warts: Oc,
    SOV: Nc,
    generatorsOf: Ah,
    periodsOf: Ch,
    mappingBasis: $h,
    commaBasis: Mh,
    PrimeMapping: Oh,
    errorTE: Tc,
    nextGPV: xc,
    tune: Nh,
    basis: Ic,
    basisToArray: Th,
    respell: xh
};
const Ik = "sonic-weave"
  , Fk = "0.10.10"
  , Rk = "Lumi Pakkanen"
  , Pk = "The SonicWeave DSL for manipulating musical frequencies, ratios and equal temperaments"
  , Dk = "MIT"
  , qk = "dist/index"
  , Bk = {
    type: "git",
    url: "git+https://github.com/xenharmonic-devs/sonic-weave.git"
}
  , kk = {
    url: "https://github.com/xenharmonic-devs/sonic-weave/issues"
}
  , zk = "https://github.com/xenharmonic-devs/sonic-weave#readme"
  , Vk = ["Microtonal", "Music", "Xenharmonic", "Scales", "Frequency", "Equal Temperament", "DSL"]
  , Uk = {
    type: "github",
    url: "https://github.com/sponsors/frostburn"
}
  , jk = ["dist", "bin"]
  , Hk = {
    "sonic-weave": "bin/sonic-weave.js"
}
  , Gk = {
    lint: "gts lint",
    clean: "gts clean",
    "compile-sw2-parser": "peggy src/grammars/scale-workshop-2.pegjs -o src/scale-workshop-2-ast.js",
    "compile-chord-parser": "peggy src/grammars/sonic-weave-chord.pegjs src/grammars/base.pegjs -o src/parser/sonic-weave-chord.js",
    "compile-sonic-weave-parser": "peggy src/grammars/sonic-weave.pegjs src/grammars/mos.pegjs src/grammars/base.pegjs -o src/parser/sonic-weave-ast.js",
    "compile-paren-counter": "peggy src/grammars/paren-counter.pegjs src/grammars/base.pegjs -o src/parser/paren-counter.js",
    "compile-parsers": "npm run compile-sonic-weave-parser && npm run compile-chord-parser && npm run compile-sw2-parser && npm run compile-paren-counter",
    precompile: "npm run compile-parsers",
    compile: "tsc",
    fix: "gts fix",
    prepare: "npm run compile",
    pretest: "npm run compile",
    posttest: "npm run lint",
    test: "vitest",
    prebench: "npm run compile",
    bench: "vitest bench",
    doc: "typedoc src/index.ts . --name sonic-weave",
    preautodoc: "npm run precompile && tsc -p tsconfig-autodoc.json",
    autodoc: "node .temp/scripts/builtin-docs.js > documentation/BUILTIN.md",
    "preinspect-grammar": "npm run compile-sonic-weave-parser",
    "inspect-grammar": "node scripts/inspect-printable-ascii.js",
    "preinspect-random": "npm run compile-sonic-weave-parser",
    "inspect-random": "node scripts/inspect-random-programs.js"
}
  , Wk = {
    "@types/node": "20.8.2",
    gts: "^5.3.1",
    peggy: "^4.2.0",
    typedoc: "^0.25.13",
    typescript: "~5.2.0",
    vitest: "^1.6.0"
}
  , Jk = {
    "moment-of-symmetry": "^0.8.4",
    "xen-dev-utils": "^0.11.1"
}
  , Kk = {
    node: ">=12.0.0"
}
  , Zk = {
    commander: "^12.1.0"
}
  , uS = {
    name: Ik,
    version: Fk,
    author: Rk,
    description: Pk,
    license: Dk,
    main: qk,
    repository: Bk,
    bugs: kk,
    homepage: zk,
    keywords: Vk,
    funding: Uk,
    files: jk,
    bin: Hk,
    scripts: Gk,
    devDependencies: Wk,
    dependencies: Jk,
    engines: Kk,
    optionalDependencies: Zk
};
Object.defineProperty(Hl, "__esModule", {
    value: !0
});
Hl.BUILTIN_CONTEXT = Hl.factorColor = void 0;
const Un = Ie
  , Ke = hn
  , On = An
  , cS = Ms
  , Yk = Rf
  , U0 = pt
  , Wl = vr
  , fS = vn
  , Qk = Fa
  , q = In
  , Xt = Wt
  , xE = Mi
  , Xk = Dm
  , ez = qm
  , {version: tz} = uS
  , nr = {
    scale: {
        type: "Identifier",
        id: "$$"
    },
    array: {
        type: "Identifier",
        id: "$$"
    }
};
function Ih(n) {
    if (n === void 0)
        return (0,
        q.fromInteger)((0,
        On.getNumberOfComponents)());
    (0,
    On.setNumberOfComponents)((0,
    q.upcastBool)(n).toInteger())
}
Ih.__doc__ = "Get/set the number of prime exponents to support in monzos. Also sets the length of vals.";
Ih.__node__ = (0,
q.builtinNode)(Ih);
function Fh(n) {
    if (typeof n != "string")
        throw new Error("A string is required.");
    this.spendGas(n.length);
    const t = {};
    for (const [e,r] of Object.entries((0,
    fS.stepSignature)(n)))
        t[e] = (0,
        q.fromInteger)(r);
    return t
}
Fh.__doc__ = "Calculate the step signature of an entire scale word.";
Fh.__node__ = (0,
q.builtinNode)(Fh);
function Rh(n) {
    const t = (0,
    q.upcastBool)(n).value.divisors();
    return this.spendGas(t.length * 1.5),
    t.map(q.fromInteger)
}
Rh.__doc__ = "Obtain an array of divisors of a natural number.";
Rh.__node__ = (0,
q.builtinNode)(Rh);
function Ph(n, t="tenney") {
    if (!(n instanceof Ke.ValBasis))
        throw new Error("A basis is required.");
    return this.spendGas(.3 * n.numberOfComponents * n.size ** 2),
    n.lll(t)
}
Ph.__doc__ = "Perform Lensta-Lenstra-Lovsz basis reduction.";
Ph.__node__ = (0,
q.builtinNode)(Ph);
function Dh(n, t) {
    if ((0,
    q.requireParameters)({
        set: n
    }),
    t = (0,
    q.upcastBool)(t),
    !Array.isArray(n))
        throw new Error("Set must be an array.");
    const e = t.toInteger();
    return this.spendGas((0,
    Un.binomial)(n.length, e)),
    (0,
    Un.kCombinations)(n, e)
}
Dh.__doc__ = "Obtain all k-sized combinations in a set";
Dh.__node__ = (0,
q.builtinNode)(Dh);
function Fc(n) {
    return (0,
    q.requireParameters)({
        n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? (0,
    Un.isPrime)((0,
    q.upcastBool)(n).valueOf()) : q.unaryBroadcast.bind(this)(n, Fc.bind(this))
}
Fc.__doc__ = "Return `true` if `n` is a prime number, `false` otherwise.";
Fc.__node__ = (0,
q.builtinNode)(Fc);
function Rc(n) {
    if ((0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval) {
        const t = (0,
        q.upcastBool)(n).toInteger();
        if (t < 0)
            throw new Error("A non-negative integer is required.");
        return this.spendGas(t / 3),
        (0,
        q.fromInteger)((0,
        Un.nthPrime)(t))
    }
    return q.unaryBroadcast.bind(this)(n, Rc.bind(this))
}
Rc.__doc__ = "Obtain the nth odd prime or prime 2 if n = 0.";
Rc.__node__ = (0,
q.builtinNode)(Rc);
function qh(n, t) {
    const e = (0,
    q.upcastBool)(n).valueOf();
    if (t) {
        const r = (0,
        q.upcastBool)(t).valueOf();
        return this.spendGas(Math.max(0, r - e)),
        (0,
        Un.primes)(e, r).map(i => (0,
        q.fromInteger)(i))
    }
    return this.spendGas(Math.max(0, e)),
    (0,
    Un.primes)(e).map(r => (0,
    q.fromInteger)(r))
}
qh.__doc__ = "Obtain an array of prime numbers such that start <= p <= end. Or p <= start if end is omitted.";
qh.__node__ = (0,
q.builtinNode)(qh);
function Bh(n, t) {
    const e = (0,
    q.upcastBool)(n).toInteger();
    if (t) {
        const r = (0,
        q.upcastBool)(t).toInteger();
        return this.spendGas(Math.max(0, (r - e) / 3)),
        (0,
        Un.primeRange)(e, r).map(i => (0,
        q.fromInteger)(i))
    }
    return this.spendGas(Math.max(0, e / 3)),
    (0,
    Un.primeRange)(e).map(r => (0,
    q.fromInteger)(r))
}
Bh.__doc__ = "Obtain a range of primes starting at the given ordinal. Prime 2 has ordinal 0. (End - start) elements are returned.";
Bh.__node__ = (0,
q.builtinNode)(Bh);
function kh(n, t, e, r, i, a) {
    const l = (0,
    q.upcastBool)(n).toInteger()
      , f = (0,
    q.upcastBool)(t).toInteger();
    this.spendGas(Math.abs(l) + Math.abs(f));
    const h = {};
    return e !== void 0 && (h.sizeOfLargeStep = (0,
    q.upcastBool)(e).toInteger()),
    r !== void 0 && (h.sizeOfSmallStep = (0,
    q.upcastBool)(r).toInteger()),
    i !== void 0 && (h.up = (0,
    q.upcastBool)(i).toInteger()),
    a !== void 0 && (h.down = (0,
    q.upcastBool)(a).toInteger()),
    (0,
    cS.mos)(l, f, h).map(p => (0,
    q.fromInteger)(p))
}
kh.__doc__ = "Calculate a subset of equally tempered degrees with maximum variety two per scale degree.";
kh.__node__ = (0,
q.builtinNode)(kh);
function zh(n) {
    const t = (0,
    q.upcastBool)(n).toInteger();
    this.spendGas(t * t);
    const e = [];
    for (const r of (0,
    Un.fareySequence)(t)) {
        const i = On.TimeMonzo.fromFraction(r);
        e.push(new Ke.Interval(i,"linear",0,i.asFractionLiteral()))
    }
    return e
}
zh.__doc__ = "Generate the n'th Farey sequence i.e. all fractions between 0 and 1 inclusive with denominator below or at the given limit.";
zh.__node__ = (0,
q.builtinNode)(zh);
function Vh(n) {
    const t = (0,
    q.upcastBool)(n).toInteger();
    this.spendGas(t * t);
    const e = [];
    for (const r of (0,
    Un.fareyInterior)(t)) {
        const i = On.TimeMonzo.fromFraction(r);
        e.push(new Ke.Interval(i,"linear",0,i.asFractionLiteral()))
    }
    return e
}
Vh.__doc__ = "Generate the interior of the n'th Farey sequence i.e. all fractions between 0 and 1 exclusive with denominator below or at the given limit.";
Vh.__node__ = (0,
q.builtinNode)(Vh);
function Pc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, Pc.bind(this)) : (0,
    Xt.simplify)(n)
}
Pc.__doc__ = "Get rid of interval formatting. Simplifies a ratio to lowest terms.";
Pc.__node__ = (0,
q.builtinNode)(Pc);
function Dc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? (0,
    Xt.bleach)(n) : q.unaryBroadcast.bind(this)(n, Dc.bind(this))
}
Dc.__doc__ = "Get rid of interval coloring and label.";
Dc.__node__ = (0,
q.builtinNode)(Dc);
function qc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? (0,
    Xt.linear)(n) : q.unaryBroadcast.bind(this)(n, qc.bind(this))
}
qc.__doc__ = "Convert interval to linear representation. Formatting information of logarithmic quantities is lost.";
qc.__node__ = (0,
q.builtinNode)(qc);
function Bc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? (0,
    Xt.logarithmic)(n) : q.unaryBroadcast.bind(this)(n, Bc.bind(this))
}
Bc.__doc__ = "Convert interval to logarithmic representation. Formatting information of linear quantities is lost.";
Bc.__node__ = (0,
q.builtinNode)(Bc);
function kc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? Xt.absolute.bind(this)(n) : q.unaryBroadcast.bind(this)(n, kc.bind(this))
}
kc.__doc__ = "Convert interval to absolute representation. Normalized to a frequency.";
kc.__node__ = (0,
q.builtinNode)(kc);
function zc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? Xt.relative.bind(this)(n) : q.unaryBroadcast.bind(this)(n, zc.bind(this))
}
zc.__doc__ = "Convert interval to relative representation.";
zc.__node__ = (0,
q.builtinNode)(zc);
function Uh(n) {
    return (0,
    q.requireParameters)({
        value: n
    }),
    (0,
    q.sonicTruth)(n)
}
Uh.__doc__ = "Convert value to a boolean.";
Uh.__node__ = (0,
q.builtinNode)(Uh);
function Vc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "string" ? (0,
    q.fromInteger)(parseInt(n, 10)) : typeof n == "boolean" || n instanceof Ke.Interval ? (n = Xt.relative.bind(this)((0,
    q.upcastBool)(n)),
    Ke.Interval.fromInteger(n.toInteger())) : q.unaryBroadcast.bind(this)(n, Vc.bind(this))
}
Vc.__doc__ = "Convert value to an integer. Throws an error if conversion is impossible.";
Vc.__node__ = (0,
q.builtinNode)(Vc);
function Uc(n, t) {
    if ((0,
    q.isArrayOrRecord)(n)) {
        const r = Uc.bind(this);
        return q.unaryBroadcast.bind(this)(n, i => r(i, t))
    }
    typeof n == "string" && (n = Ke.Interval.fromFraction(n));
    const e = Xt.relative.bind(this)((0,
    q.upcastBool)(n));
    if (t !== void 0) {
        const r = 10 ** t.toInteger()
          , i = Math.round(e.value.valueOf() * r);
        e.value = On.TimeMonzo.fromFraction(new Un.Fraction(i,r))
    }
    return e.node = e.value.asDecimalLiteral(),
    e.domain = "linear",
    e
}
Uc.__doc__ = "Convert interval to a decimal number.";
Uc.__node__ = (0,
q.builtinNode)(Uc);
function jc(n, t, e, r) {
    if ((0,
    q.isArrayOrRecord)(n)) {
        const p = jc.bind(this);
        return q.unaryBroadcast.bind(this)(n, m => p(m, t, e, r))
    }
    typeof n == "string" && (n = Ke.Interval.fromFraction(n));
    const i = e ? (0,
    q.upcastBool)(e).value.toBigInteger() : 0n
      , a = r ? (0,
    q.upcastBool)(r).value.toBigInteger() : 0n
      , l = Xt.relative.bind(this)((0,
    q.upcastBool)(n));
    let f;
    if (t === void 0) {
        if (l.value instanceof On.TimeReal)
            throw new Error("Input is irrational and no tolerance given.");
        f = l.value.clone()
    } else {
        const p = new Un.Fraction(l.value.valueOf()).simplifyRelative((0,
        q.upcastBool)(t).totalCents());
        f = On.TimeMonzo.fromFraction(p)
    }
    const h = f.asFractionLiteral();
    if (!h)
        throw new Error("Failed to convert to fraction.");
    if (i && h.numerator && i % h.numerator === 0n) {
        const p = i / h.numerator;
        h.numerator = i,
        h.denominator *= p
    } else if (a && a % h.denominator === 0n) {
        const p = a / h.denominator;
        h.numerator *= p,
        h.denominator = a
    }
    return new Ke.Interval(f,"linear",0,h,l)
}
jc.__doc__ = "Convert interval to a fraction. Throws an error if conversion is impossible and no tolerance (in cents) for approximation is given.";
jc.__node__ = (0,
q.builtinNode)(jc);
function Jl(n, t, e) {
    if ((0,
    q.isArrayOrRecord)(n)) {
        const m = Jl.bind(this);
        return q.unaryBroadcast.bind(this)(n, g => m(g, t, e))
    }
    typeof n == "string" && (n = Ke.Interval.fromFraction(n));
    const r = Xt.relative.bind(this)((0,
    q.upcastBool)(n))
      , i = t ? (0,
    q.upcastBool)(t).toInteger() : void 0;
    if (r.value.isEqualTemperament()) {
        const m = r.value.asRadicalLiteral();
        if (i === void 0) {
            if (m)
                return new Ke.Interval(r.value.clone(),"linear",0,m,r);
            throw new Error("Failed to convert to a radical.")
        } else if (m && m.exponent.d <= i)
            return new Ke.Interval(r.value.clone(),"linear",0,m,r)
    } else if (i === void 0)
        throw new Error("Input is not equally tempered and no maximum index given.");
    const a = e ? (0,
    q.upcastBool)(e).toInteger() : 5e4
      , {index: l, radicand: f} = (0,
    Un.approximateRadical)(r.value.valueOf(), i, a)
      , h = On.TimeMonzo.fromFraction(f).pow(new Un.Fraction(l).inverse())
      , p = h.asRadicalLiteral();
    if (p)
        return new Ke.Interval(h,"linear",0,p,r);
    {
        const m = (0,
        Un.approximateRadical)(r.value.valueOf(), 1, a).radicand
          , g = On.TimeMonzo.fromFraction(m);
        return new Ke.Interval(g,"linear",0,g.asFractionLiteral(),r)
    }
}
Jl.__doc__ = "Convert interval to a radical expression. Throws an error if conversion is impossible and no maximum index (2 means square root, 3 means cube root, etc.) for approximation is given.";
Jl.__node__ = (0,
q.builtinNode)(Jl);
function Hc(n, t, e, r, i) {
    var b;
    if ((0,
    q.isArrayOrRecord)(n)) {
        const E = Hc.bind(this);
        return q.unaryBroadcast.bind(this)(n, S => E(S, r, e, r, i))
    }
    if (typeof n == "string") {
        let[E,S] = n.replace("ed", "<").split("<");
        S.endsWith(">") && (S = S.slice(0, -1));
        const F = On.TimeMonzo.fromEqualTemperament(E.replace("\\", "/"), S);
        n = new Ke.Interval(F,"logarithmic")
    }
    const a = t ? (0,
    q.upcastBool)(t).toInteger() : 0
      , l = e ? (0,
    q.upcastBool)(e).toInteger() : 0
      , f = r ? (0,
    q.upcastBool)(r).toInteger() : 0
      , h = i ? (0,
    q.upcastBool)(i).toInteger() : 0
      , p = Jl.bind(this)(n);
    if (((b = p.node) == null ? void 0 : b.type) !== "RadicalLiteral")
        throw new Error("NEDJI conversion failed.");
    const m = p.node
      , g = {
        type: "NedjiLiteral",
        numerator: m.exponent.n * m.exponent.s,
        denominator: m.exponent.d,
        equaveNumerator: m.argument.n * m.exponent.s,
        equaveDenominator: m.argument.d
    };
    if (a && g.numerator && a % g.numerator === 0) {
        const E = a / g.numerator;
        g.numerator = a,
        g.denominator *= E
    } else if (l && l % g.denominator === 0) {
        const E = l / g.denominator;
        g.numerator *= E,
        g.denominator = l
    }
    if (f && g.equaveNumerator && f % g.equaveNumerator === 0) {
        const E = f / g.equaveNumerator;
        g.equaveNumerator = f,
        g.equaveDenominator *= E
    } else if (h && h % g.equaveDenominator === 0) {
        const E = h / g.equaveDenominator;
        g.equaveNumerator *= E,
        g.equaveDenominator = h
    }
    return !f && !h && m.argument.equals(Wl.TWO) && (g.equaveNumerator = null,
    g.equaveDenominator = null),
    new Ke.Interval(p.value,"logarithmic",0,g,p)
}
Hc.__doc__ = "Convert interval to N-steps-of-Equally-Divided-interval-of-Just-Intonation.";
Hc.__node__ = (0,
q.builtinNode)(Hc);
function Gc(n, t) {
    if ((0,
    q.isArrayOrRecord)(n)) {
        const a = Gc.bind(this);
        return q.unaryBroadcast.bind(this)(n, l => a(l, t))
    }
    if (typeof n == "string") {
        const a = On.TimeMonzo.fromFractionalCents(n);
        n = new Ke.Interval(a,"logarithmic")
    }
    const e = Xt.relative.bind(this)((0,
    q.upcastBool)(n));
    if (t !== void 0) {
        const a = 10 ** t.toInteger()
          , l = Math.round(e.totalCents() * a);
        e.value = new On.TimeMonzo(Wl.ZERO,[new Un.Fraction(l,a * 1200)])
    }
    const r = e.value.asCentsLiteral();
    if (r)
        return e.node = r,
        e.domain = "logarithmic",
        e;
    const i = On.TimeReal.fromCents(e.totalCents());
    return new Ke.Interval(i,"logarithmic",0,i.asCentsLiteral())
}
Gc.__doc__ = "Convert interval to cents. `fractionDigits` represents the number of decimal digits in the cents representation. May produce non-algebraic (real) results if number of digits is not given. String arguments are interpreted as denoting cent quantities, not linear fractions.";
Gc.__node__ = (0,
q.builtinNode)(Gc);
function dS(n) {
    if (n === "l" || n === "s")
        throw new Error(`Conversion not implemented for FJS flavor '${n}'.`);
    if (n !== "" && n !== "c" && n !== "f" && n !== "h" && n !== "m" && n !== "n" && n !== "q" && n !== "t")
        throw new Error(`Unrecognized FJS flavor '${n}'.`);
    return n
}
function Kl(n, t="") {
    if (!this.rootContext)
        throw new Error("Root context required for absolute FJS.");
    if ((0,
    q.isArrayOrRecord)(n)) {
        const l = Kl.bind(this);
        return q.unaryBroadcast.bind(this)(n, f => l(f, t))
    }
    if (typeof n == "string")
        throw new Error("String parsing of absolute FJS not implemented yet.");
    n = (0,
    q.upcastBool)(n);
    const e = this.rootContext.C4;
    let r;
    e.timeExponent.n === 0 ? r = Xt.relative.bind(this)(n).value : r = Xt.absolute.bind(this)(n).value;
    const i = new Ke.Interval(r,"logarithmic",n.steps,{
        type: "AspiringAbsoluteFJS",
        flavor: dS(t)
    })
      , a = i.realizeNode(this.rootContext);
    if (a)
        return i.node = a,
        this.rootContext.fragiles.push(i),
        i;
    throw new Error(`Conversion failed. Try absoluteFJS(fraction(x, 1e-4), '${t}') to approximate.`)
}
Kl.__doc__ = "Convert interval to absolute FJS.";
Kl.__node__ = (0,
q.builtinNode)(Kl);
function Wc(n, t="") {
    if (!this.rootContext)
        throw new Error("Root context required for FJS.");
    if ((0,
    q.isArrayOrRecord)(n)) {
        const a = Wc.bind(this);
        return q.unaryBroadcast.bind(this)(n, l => a(l, t))
    }
    if (typeof n == "string")
        throw new Error("String parsing of FJS not implemented yet.");
    n = (0,
    q.upcastBool)(n);
    const e = Xt.relative.bind(this)(n).value
      , r = new Ke.Interval(e,"logarithmic",n.steps,{
        type: "AspiringFJS",
        flavor: dS(t)
    })
      , i = r.realizeNode(this.rootContext);
    if (i)
        return r.node = i,
        r;
    throw new Error(`Conversion failed. Try FJS(fraction(x, 1e-4), '${t}') to approximate.`)
}
Wc.__doc__ = "Convert interval to (relative) FJS.";
Wc.__node__ = (0,
q.builtinNode)(Wc);
function Jc(n, t="") {
    if (!this.rootContext)
        throw new Error("Root context required for FJS.");
    if ((0,
    q.isArrayOrRecord)(n)) {
        const e = Jc.bind(this);
        return q.unaryBroadcast.bind(this)(n, r => e(r, t))
    }
    if (n = (0,
    q.upcastBool)(n),
    !n.node || n.node.type !== "AbsoluteFJS" && n.node.type !== "AspiringAbsoluteFJS" ? n = Kl.bind(this)(n, t) : n = n.shallowClone(),
    n.node && n.node.type === "AspiringAbsoluteFJS" && (n.node = n.realizeNode(this.rootContext)),
    !n.node || n.node.type !== "AbsoluteFJS")
        return n.label = "?",
        n.color = new Ke.Color("gray"),
        n;
    n.label = (0,
    U0.formatAbsoluteFJS)(n.node, !1),
    n.color = new Ke.Color("white");
    for (const e of n.node.pitch.accidentals)
        if (!(e.accidental === "" || e.accidental === "_")) {
            n.color = new Ke.Color("black");
            break
        }
    return n
}
Jc.__doc__ = "Convert interval to absolute FJS and label without octaves. Color black if there are accidentals, white otherwise.";
Jc.__node__ = (0,
q.builtinNode)(Jc);
function Zl(n) {
    var t;
    if ((0,
    q.isArrayOrRecord)(n)) {
        const e = Zl.bind(this);
        return q.unaryBroadcast.bind(this)(n, e)
    }
    if (typeof n == "string")
        throw new Error("String parsing of monzos not implemented yet.");
    return n = (0,
    q.upcastBool)(n),
    ((t = n.node) == null ? void 0 : t.type) === "MonzoLiteral" ? n.shallowClone() : new Ke.Interval(n.value,"logarithmic",n.steps,n.asMonzoLiteral(),n)
}
Object.defineProperty(Zl, "name", {
    value: "monzo",
    enumerable: !1
});
Zl.__doc__ = "Convert interval to a prime count vector a.k.a. monzo.";
Zl.__node__ = (0,
q.builtinNode)(Zl);
function Kc(n) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        if (n = (0,
        q.upcastBool)(n),
        n.steps)
            throw new Error("Edosteps cannot be converted to prime monzos.");
        const t = n.value;
        if (t instanceof On.TimeReal)
            throw new Error("Irrational intervals cannot be converted to prime monzos.");
        if (!t.isScalar())
            throw new Error("A relative interval is required.");
        if (t.residual.s !== 1)
            throw new Error("A positive interval is required.");
        const e = []
          , r = []
          , i = t.primeExponents
          , a = null;
        for (let p = 0; p < i.length; ++p)
            i[p].n && (e.push((0,
            U0.fractionToVectorComponent)(i[p])),
            r.push({
                numerator: Un.PRIMES[p],
                denominator: a,
                radical: !1
            }));
        const l = (0,
        Un.primeFactorize)(t.residual)
          , f = Array.from(l.keys()).sort( (p, m) => p - m);
        for (const p of f)
            e.push((0,
            U0.integerToVectorComponent)(l.get(p))),
            r.push({
                numerator: p,
                denominator: a,
                radical: !1
            });
        const h = {
            type: "MonzoLiteral",
            components: e,
            basis: r,
            ups: 0,
            lifts: 0
        };
        return new Ke.Interval(t,"logarithmic",0,h,n)
    }
    return q.unaryBroadcast.bind(this)(n, Kc.bind(this))
}
Kc.__doc__ = "Convert interval to a prime count vector a.k.a. monzo with all primes listed in the subgroup part.";
Kc.__node__ = (0,
q.builtinNode)(Kc);
function Zc(n, t) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        if (typeof t == "boolean" || t instanceof Ke.Interval) {
            n = (0,
            q.upcastBool)(n),
            t = (0,
            q.upcastBool)(t);
            const e = {
                type: "SquareSuperparticular",
                start: n.value.toBigInteger(),
                end: t.value.toBigInteger()
            };
            return this.visit(e)
        } else if (t === void 0) {
            n = (0,
            q.upcastBool)(n);
            const e = {
                type: "SquareSuperparticular",
                start: n.value.toBigInteger(),
                end: null
            };
            return this.visit(e)
        }
    }
    return q.binaryBroadcast.bind(this)(n, t, Zc.bind(this))
}
Zc.__doc__ = "Compute (k)/(k-1) or a product of a range of such square-superparticulars.";
Zc.__node__ = (0,
q.builtinNode)(Zc);
function jh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return n instanceof Ke.Interval
}
jh.__doc__ = "Return `true` if the value is an interval.";
jh.__node__ = (0,
q.builtinNode)(jh);
function Hh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return n instanceof Ke.Val
}
Hh.__doc__ = "Return `true` if the value is a val.";
Hh.__node__ = (0,
q.builtinNode)(Hh);
function Gh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return n instanceof Ke.ValBasis
}
Gh.__doc__ = "Return `true` if the value is a basis.";
Gh.__node__ = (0,
q.builtinNode)(Gh);
function Wh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return n instanceof Ke.Temperament
}
Wh.__doc__ = "Return `true` if the value is a temperament.";
Wh.__node__ = (0,
q.builtinNode)(Wh);
function Jh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return n instanceof Ke.Color
}
Jh.__doc__ = "Return `true` if the value is a color.";
Jh.__node__ = (0,
q.builtinNode)(Jh);
function Kh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return typeof n == "string"
}
Kh.__doc__ = "Return `true` if the value is a string.";
Kh.__node__ = (0,
q.builtinNode)(Kh);
function Zh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return typeof n == "boolean"
}
Zh.__doc__ = "Return `true` if the value is a boolean.";
Zh.__node__ = (0,
q.builtinNode)(Zh);
function Yh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return typeof n == "function"
}
Yh.__doc__ = "Return `true` if the value is a riff or an arrow function.";
Yh.__node__ = (0,
q.builtinNode)(Yh);
function Qh(n) {
    if (arguments.length < 1)
        throw new Error("Parameter 'value' is required.");
    return Array.isArray(n)
}
Qh.__doc__ = "Return `true` if the value is an array.";
Qh.__node__ = (0,
q.builtinNode)(Qh);
function Yc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, Yc.bind(this)) : n instanceof Ke.Interval ? n.isAbsolute() : !1
}
Yc.__doc__ = "Return `true` if the interval belongs to the absolute echelon.";
Yc.__node__ = (0,
q.builtinNode)(Yc);
function Qc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, Qc.bind(this)) : typeof n == "boolean" ? !0 : n instanceof Ke.Interval ? n.isRelative() : !1
}
Qc.__doc__ = "Return `true` if the interval belongs to the relative echelon.";
Qc.__node__ = (0,
q.builtinNode)(Qc);
function Xc(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, Xc.bind(this)) : typeof n == "boolean" ? !0 : n instanceof Ke.Interval ? n.domain === "linear" : !1
}
Xc.__doc__ = "Return `true` if the interval belongs to the linear domain.";
Xc.__node__ = (0,
q.builtinNode)(Xc);
function ef(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, ef.bind(this)) : n instanceof Ke.Interval ? n.domain === "logarithmic" : !1
}
ef.__doc__ = "Return `true` if the interval belongs to the logarithmic domain.";
ef.__node__ = (0,
q.builtinNode)(ef);
function Xh(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" ? !0 : n instanceof Ke.Interval ? n.value.isIntegral() : !1
}
Xh.__doc__ = "Return `true` if the interval is an integer.";
Xh.__node__ = (0,
q.builtinNode)(Xh);
function ep(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    n instanceof Ke.Interval ? n.value.isFractional() : !1
}
ep.__doc__ = "Return `true` if the interval is a rational number.";
ep.__node__ = (0,
q.builtinNode)(ep);
function tp(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    n instanceof Ke.Interval ? n.value instanceof On.TimeMonzo : !1
}
tp.__doc__ = "Return `true` if the interval is an nth root.";
tp.__node__ = (0,
q.builtinNode)(tp);
function np(n, t) {
    if (typeof n != "string")
        throw new Error("A string is required.");
    if (t === void 0) {
        if (n)
            return (0,
            q.fromInteger)(n.charCodeAt(0));
        throw new Error("A non-empty string is required.")
    }
    let e = (0,
    q.upcastBool)(t).toInteger();
    if (e < 0 && (e += n.length),
    e < 0 || e >= n.length)
        throw new Error("Index out of range.");
    return (0,
    q.fromInteger)(n.charCodeAt(e))
}
np.__doc__ = "Obtain an integer between 0 and 65535 representing the UTF-16 code unit at the given index.";
np.__node__ = (0,
q.builtinNode)(np);
function rp(n, t) {
    if (typeof n != "string")
        throw new Error("A string is required.");
    if (t === void 0) {
        if (n)
            return (0,
            q.fromInteger)(n.codePointAt(0));
        throw new Error("A non-empty string is required.")
    }
    let e = (0,
    q.upcastBool)(t).toInteger();
    if (e < 0 && (e += n.length),
    e < 0 || e >= n.length)
        throw new Error("Index out of range.");
    return (0,
    q.fromInteger)(n.codePointAt(e))
}
rp.__doc__ = "Obtain a non-negative integer that is the Unicode code point value of the character starting at the given index. Note that the index is still based on UTF-16 code units, not Unicode code points.";
rp.__node__ = (0,
q.builtinNode)(rp);
function sp(...n) {
    return String.fromCharCode(...n.map(t => (0,
    q.upcastBool)(t).toInteger()))
}
sp.__doc__ = "Obtain a string created from the specified sequence of UTF-16 code units.";
sp.__node__ = (0,
q.builtinNode)(sp);
function ip(...n) {
    return String.fromCodePoint(...n.map(t => (0,
    q.upcastBool)(t).toInteger()))
}
ip.__doc__ = "Obtain a string created from the specified sequence of code points.";
ip.__node__ = (0,
q.builtinNode)(ip);
function op(n) {
    return Xt.track.bind(this)((0,
    q.upcastBool)(n))
}
op.__doc__ = "Attach a tracking ID to the interval.";
op.__node__ = (0,
q.builtinNode)(op);
function ap(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    n instanceof Ke.Interval ? Array.from(n.trackingIds).map(t => (0,
    q.fromInteger)(t)) : []
}
ap.__doc__ = "Obtain an array of the tracking IDs attached to the interval.";
ap.__node__ = (0,
q.builtinNode)(ap);
function lp(n, t) {
    if ((0,
    q.requireParameters)({
        array: n
    }),
    Array.isArray(n)) {
        let e = 1 / 0;
        return t !== void 0 && (e = t.toInteger()),
        n.flat(e)
    }
    return [n]
}
lp.__doc__ = "Returns a new array with all sub-array elements concatenated into it recursively up to the specified depth (default `inf`).";
lp.__node__ = (0,
q.builtinNode)(lp);
function up(n) {
    n ?? (n = this.currentScale),
    n.length = 0
}
up.__doc__ = "Remove the contents of the current/given scale.";
up.__node__ = (0,
q.builtinNode)(up, nr);
function tf(n) {
    if ((0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n)) {
        const t = tf.bind(this);
        return q.unaryBroadcast.bind(this)(n, t)
    }
    if (n instanceof Ke.Interval)
        return n.color
}
tf.__doc__ = "Return the color of the interval.";
tf.__node__ = (0,
q.builtinNode)(tf);
function nf(n) {
    if ((0,
    q.requireParameters)({
        interval: n
    }),
    (0,
    q.isArrayOrRecord)(n)) {
        const t = nf.bind(this);
        return q.unaryBroadcast.bind(this)(n, t)
    }
    return n instanceof Ke.Interval ? n.label : ""
}
nf.__doc__ = "Return the label of the interval.";
nf.__node__ = (0,
q.builtinNode)(nf);
function rf(n) {
    if ((0,
    q.isArrayOrRecord)(n))
        return q.unaryBroadcast.bind(this)(n, rf.bind(this));
    n = (0,
    q.upcastBool)(n);
    const t = Xt.relative.bind(this)(n).value;
    if (t instanceof On.TimeReal)
        return new Ke.Interval(t,"logarithmic",0,void 0,n);
    const e = On.TimeReal.fromCents(t.totalCents(!0));
    return t.residual.s < 0 && (e.value = -e.value),
    new Ke.Interval(e,"logarithmic",0,void 0,n)
}
rf.__doc__ = "The Just Intonation Point. Converts intervals to real cents.";
rf.__node__ = (0,
q.builtinNode)(rf);
function sf(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    n === !0 ? new Ke.Interval(On.TimeReal.fromValue(1),"linear") : n === !1 ? new Ke.Interval(On.TimeReal.fromValue(0),"linear") : n instanceof Ke.Interval ? (n = Xt.relative.bind(this)(n),
    new Ke.Interval(On.TimeReal.fromValue(n.valueOf()),"linear")) : q.unaryBroadcast.bind(this)(n, sf.bind(this))
}
sf.__doc__ = "Convert interval to a linear real value.";
sf.__node__ = (0,
q.builtinNode)(sf);
function of(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? Xt.tenneyHeight.bind(this)(n) : q.unaryBroadcast.bind(this)(n, of.bind(this))
}
of.__doc__ = "Calculate the Tenney height of the interval. Natural logarithm of numerator times denominator.";
of.__node__ = (0,
q.builtinNode)(of);
function af(n) {
    return (0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval ? Xt.wilsonHeight.bind(this)(n) : q.unaryBroadcast.bind(this)(n, af.bind(this))
}
af.__doc__ = "Calculate the Wilson height of the interval. Sum of prime absolute factors with repetition..";
af.__node__ = (0,
q.builtinNode)(af);
function lf(n, t) {
    if (n === void 0 && t === void 0) {
        let e = new On.TimeMonzo(Wl.ZERO,[],Wl.ZERO);
        for (const r of this.currentScale)
            e = e.gcd(r.value);
        return new Ke.Interval(e,"linear")
    }
    return (0,
    q.isArrayOrRecord)(n) || (0,
    q.isArrayOrRecord)(t) ? q.binaryBroadcast.bind(this)(n, t, lf.bind(this)) : new Ke.Interval((0,
    q.upcastBool)(n).value.gcd((0,
    q.upcastBool)(t).value),"linear")
}
lf.__doc__ = "Obtain the largest (linear) multiplicative factor shared the two arguments or by all intervals or the current scale if no arguments are given.";
lf.__node__ = (0,
q.builtinNode)(lf);
function uf(n, t) {
    if (n === void 0 && t === void 0) {
        const e = this.currentScale;
        if (!e.length)
            return (0,
            q.fromInteger)(0);
        let r = e[0].value.clone();
        for (const i of e.slice(1))
            r = r.lcm(i.value);
        return new Ke.Interval(r,"linear")
    }
    return (0,
    q.isArrayOrRecord)(n) || (0,
    q.isArrayOrRecord)(t) ? q.binaryBroadcast.bind(this)(n, t, uf.bind(this)) : new Ke.Interval((0,
    q.upcastBool)(n).value.lcm((0,
    q.upcastBool)(t).value),"linear")
}
uf.__doc__ = "Obtain the smallest (linear) interval that shares both arguments as multiplicative factors. Applies to the current scale if not arguments are given.";
uf.__node__ = (0,
q.builtinNode)(uf);
function Yl(n, t) {
    if ((0,
    q.isArrayOrRecord)(n) || (0,
    q.isArrayOrRecord)(t))
        return q.binaryBroadcast.bind(this)(n, t, Yl.bind(this));
    const e = Xt.compare.bind(this)((0,
    q.upcastBool)(n), (0,
    q.upcastBool)(t));
    return e < 0 ? (0,
    q.fromInteger)(-1) : e > 0 ? (0,
    q.fromInteger)(1) : (0,
    q.fromInteger)(0)
}
Object.defineProperty(Yl, "name", {
    value: "compare",
    enumerable: !1
});
Yl.__doc__ = "Compare two values. Result is -1 if x < y, +1 if x > y and 0 if the arguments are equal.";
Yl.__node__ = (0,
q.builtinNode)(Yl);
function cf(n) {
    if ((0,
    q.requireParameters)({
        interval: n
    }),
    typeof n == "boolean" || n instanceof Ke.Interval) {
        const t = (0,
        q.upcastBool)(n).value;
        if (t instanceof On.TimeReal)
            throw new Error("Unable to convert irrational value to vector.");
        if (!t.residual.isUnity())
            throw new Error("Interval too complex to convert to vector.");
        const e = [...t.primeExponents];
        for (; e.length && !e[e.length - 1].n; )
            e.pop();
        return e.map(r => Ke.Interval.fromFraction(r))
    } else if (n instanceof Ke.Val)
        return n.value.primeExponents.map(t => Ke.Interval.fromFraction(t));
    return q.unaryBroadcast.bind(this)(n, cf.bind(this))
}
cf.__doc__ = "Convert interval to an array of its prime counts.";
cf.__node__ = (0,
q.builtinNode)(cf);
function cp(n) {
    if (!Array.isArray(n))
        throw new Error("An array is required.");
    const t = new On.TimeMonzo(Wl.ZERO,n.map(e => (0,
    q.upcastBool)(e).toFraction()));
    return new Ke.Interval(t,"logarithmic",0,t.asMonzoLiteral())
}
cp.__doc__ = "Convert an array of prime counts to a monzo.";
cp.__node__ = (0,
q.builtinNode)(cp);
function fp(n, t) {
    if (!Array.isArray(n))
        throw new Error("An array is required.");
    const e = new On.TimeMonzo(Wl.ZERO,n.map(r => (0,
    q.upcastBool)(r).toFraction()));
    return t === void 0 && (t = new Ke.ValBasis(n.length)),
    new Ke.Val(e,t)
}
fp.__doc__ = "Convert an array of prime mapping entries to a val.";
fp.__node__ = (0,
q.builtinNode)(fp);
function dp(n) {
    if (!Array.isArray(n))
        return n;
    if (!Array.isArray(n[0]))
        return [...n];
    const t = n.reduce( (r, i) => Math.max(r, i.length), 0);
    this.spendGas(n.length * t);
    const e = [];
    for (let r = 0; r < t; ++r) {
        const i = [];
        for (let a = 0; a < n.length; ++a)
            i.push(n[a][r] ?? (0,
            q.fromInteger)(0));
        e.push(i)
    }
    return e
}
dp.__doc__ = "Transpose a matrix. For modal transposition see rotate().";
dp.__node__ = (0,
q.builtinNode)(dp);
function hS(n) {
    if (!Array.isArray(n) || !Array.isArray(n[0]))
        throw new Error("Argument must be a matrix.");
    let t = !0;
    const e = []
      , r = [];
    for (const i of n) {
        const a = []
          , l = [];
        for (const f of i) {
            const h = (0,
            q.upcastBool)(f);
            if (!h.isRelative())
                throw new Error("Matrix methods are only implemented in the relative echelon.");
            try {
                a.push(h.toFraction())
            } catch {
                t = !1
            }
            l.push(h.valueOf())
        }
        e.push(a),
        r.push(l)
    }
    return {
        isFractional: t,
        fracMat: e,
        mat: r
    }
}
function hp(n) {
    const {isFractional: t, fracMat: e, mat: r} = hS(n);
    if (this.spendGas(r.length ** 3),
    t)
        try {
            return (0,
            Un.fractionalInv)(e).map(l => l.map(f => Ke.Interval.fromFraction(f)))
        } catch {}
    return (0,
    Un.inv)(r).map(a => a.map(l => Ke.Interval.fromValue(l)))
}
hp.__doc__ = "Compute the inverse of a matrix. Domain is ignored, all values coerced to linear.";
hp.__node__ = (0,
q.builtinNode)(hp);
function pp(n) {
    const {isFractional: t, fracMat: e, mat: r} = hS(n);
    if (this.spendGas(r.length ** 3),
    t)
        try {
            const a = (0,
            Un.fractionalDet)(e);
            return Ke.Interval.fromFraction(a)
        } catch {}
    const i = (0,
    Un.det)(r);
    return Ke.Interval.fromValue(i)
}
pp.__doc__ = "Compute the determinant of a matrix. Domain is ignored, all values coerced to linear.";
pp.__node__ = (0,
q.builtinNode)(pp);
function ff(n) {
    n ?? (n = this.currentScale),
    this.spendGas(n.length * n.length);
    const t = Xt.relative.bind(this)
      , e = n.map(r => t(r).value);
    for (const r of e)
        if (r instanceof On.TimeReal)
            return (0,
            Un.hasMarginConstantStructure)(e.map(i => i.totalCents()), 0);
    return (0,
    Qk.hasConstantStructure)(e)
}
Object.defineProperty(ff, "name", {
    value: "hasConstantStructure",
    enumerable: !1
});
ff.__doc__ = "Returns `true` if the current/given scale has constant structure (i.e. every scale degree is unambiguous).";
ff.__node__ = (0,
q.builtinNode)(ff, nr);
function df(n) {
    n ?? (n = this.currentScale);
    const t = Xt.relative.bind(this)
      , e = n.map(r => t(r).value);
    return this.spendGas(e.length ** 2),
    (0,
    fS.stepString)(e)
}
Object.defineProperty(df, "name", {
    value: "stepString",
    enumerable: !1
});
df.__doc__ = 'Obtain the step string associated with the scale e.g. "LLsLLLs" for Ionian.';
df.__node__ = (0,
q.builtinNode)(df, nr);
function mp(n, t, e) {
    return (0,
    q.requireParameters)({
        array: n,
        indexStart: t
    }),
    n.slice(t.toInteger(), e === void 0 || e == null ? void 0 : e.toInteger())
}
mp.__doc__ = "Obtain a slice of a string or scale between the given indices.";
mp.__node__ = (0,
q.builtinNode)(mp);
function gp(...n) {
    const t = Math.min(...n.map(r => r.length))
      , e = [];
    for (let r = 0; r < t; ++r)
        e.push(n.map(i => i[r]));
    return e
}
gp.__doc__ = "Combine elements of each array into tuples until one of them is exhausted.";
gp.__node__ = (0,
q.builtinNode)(gp);
function vp(...n) {
    const t = Math.max(...n.map(r => r.length))
      , e = [];
    for (let r = 0; r < t; ++r)
        e.push(n.map(i => i[r]));
    return e
}
vp.__doc__ = "Combine elements of each array into tuples until all of them are exhausted. Pads missing values with `niente`.";
vp.__node__ = (0,
q.builtinNode)(vp);
function hf(...n) {
    if (n.length === 0) {
        const r = On.TimeReal.fromValue(Math.random());
        return new Ke.Interval(r,"linear")
    }
    const t = []
      , e = n.shift().toInteger();
    for (let r = 0; r < e; ++r)
        t.push(hf(...n));
    return t
}
hf.__doc__ = "Obtain a random value between (linear) 0 and 1.";
hf.__node__ = (0,
q.builtinNode)(hf);
function pf(...n) {
    if (n.length === 0) {
        const r = On.TimeReal.fromCents(Math.random());
        return new Ke.Interval(r,"logarithmic")
    }
    const t = []
      , e = n.shift().toInteger();
    for (let r = 0; r < e; ++r)
        t.push(pf(...n));
    return t
}
pf.__doc__ = "Obtain random cents between (logarithmic) 0.0c and 1.0c.";
pf.__node__ = (0,
q.builtinNode)(pf);
function mf(n) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        n = Xt.relative.bind(this)((0,
        q.upcastBool)(n));
        const t = Math.floor(n.value.valueOf());
        return Ke.Interval.fromInteger(t, n)
    }
    return q.unaryBroadcast.bind(this)(n, mf.bind(this))
}
mf.__doc__ = "Round value down to the nearest integer.";
mf.__node__ = (0,
q.builtinNode)(mf);
function gf(n) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        n = Xt.relative.bind(this)((0,
        q.upcastBool)(n));
        const t = Math.round(n.value.valueOf());
        return Ke.Interval.fromInteger(t, n)
    }
    return q.unaryBroadcast.bind(this)(n, gf.bind(this))
}
gf.__doc__ = "Round value to the nearest integer.";
gf.__node__ = (0,
q.builtinNode)(gf);
function vf(n) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        n = Xt.relative.bind(this)((0,
        q.upcastBool)(n));
        const t = Math.trunc(n.value.valueOf());
        return Ke.Interval.fromInteger(t, n)
    }
    return q.unaryBroadcast.bind(this)(n, vf.bind(this))
}
vf.__doc__ = "Truncate value towards zero to the nearest integer.";
vf.__node__ = (0,
q.builtinNode)(vf);
function yf(n) {
    if (typeof n == "boolean" || n instanceof Ke.Interval) {
        n = Xt.relative.bind(this)((0,
        q.upcastBool)(n));
        const t = Math.ceil(n.value.valueOf());
        return Ke.Interval.fromInteger(t, n)
    }
    return q.unaryBroadcast.bind(this)(n, yf.bind(this))
}
yf.__doc__ = "Round value up to the nearest integer.";
yf.__node__ = (0,
q.builtinNode)(yf);
function yp(...n) {
    const t = Xt.compare.bind(this);
    return n.slice(1).reduce( (e, r) => t(e, r) <= 0 ? e : r, n[0])
}
yp.__doc__ = "Obtain the argument with the minimum value.";
yp.__node__ = (0,
q.builtinNode)(yp);
function bp(...n) {
    const t = Xt.compare.bind(this);
    return n.slice(1).reduce( (e, r) => t(e, r) >= 0 ? e : r, n[0])
}
bp.__doc__ = "Obtain the argument with the maximum value.";
bp.__node__ = (0,
q.builtinNode)(bp);
function bf(n, t) {
    Xt.sortInPlace.bind(this)(n, t)
}
bf.__doc__ = "Sort the current/given scale in ascending order.";
bf.__node__ = (0,
q.builtinNode)(bf, nr);
function wp(n, t) {
    if (n ?? (n = this.popScale(!1)),
    !Array.isArray(n))
        throw new Error("Only arrays can be sorted.");
    return n = [...n],
    bf.bind(this)(n, t),
    n
}
wp.__doc__ = "Obtain a sorted copy of the popped/given scale in ascending order.";
wp.__node__ = (0,
q.builtinNode)(wp);
function Ep(n) {
    if (n ?? (n = this.popScale(!1)),
    !Array.isArray(n))
        throw new Error("An array is required.");
    if (!n.length)
        return [];
    const t = new Set
      , e = n.pop();
    e instanceof Ke.Interval ? t.add(e.valueOf()) : n.push(e);
    const r = [];
    for (const i of n) {
        const a = i && i.valueOf();
        t.has(a) || (r.push(i),
        t.add(a))
    }
    return e instanceof Ke.Interval && r.push(e),
    r
}
Ep.__doc__ = "Obtain a copy of the popped/given scale with only unique intervals kept.";
Ep.__node__ = (0,
q.builtinNode)(Ep);
function _p() {
    const n = this.currentScale
      , t = this.rootContext;
    if (!(t != null && t.mosConfig) || n.length)
        return;
    if (this.spendGas(t.mosConfig.scale.size),
    t.C4.isUnity() || t.unisonFrequency && t.C4.equals(t.unisonFrequency)) {
        const i = t.C4
          , a = (0,
        xE.scaleMonzos)(t.mosConfig).map(f => i.mul(f))
          , l = a.map( (f, h) => new Ke.Interval(f,"logarithmic",0,{
            type: "AbsoluteFJS",
            pitch: {
                type: "AbsolutePitch",
                nominal: (0,
                cS.nthNominal)((0,
                Un.mmod)(h + 1, a.length)),
                accidentals: [{
                    accidental: "",
                    fraction: ""
                }],
                octave: h === a.length - 1 ? 5 : 4
            },
            ups: 0,
            lifts: 0,
            superscripts: [],
            subscripts: []
        }));
        return t.fragiles.push(...l),
        l
    }
    const e = (0,
    xE.scaleMonzos)(t.mosConfig)
      , r = [];
    for (let i = 0; i < e.length; ++i) {
        const a = e[i]
          , l = a.reduce(t.mosConfig.period)
          , f = i + 1
          , h = t.mosConfig.degrees[f % t.mosConfig.degrees.length]
          , p = {
            type: "MosStepLiteral",
            mosStep: {
                type: "MosStep",
                degree: f,
                quality: {
                    fraction: "",
                    quality: "P"
                }
            },
            ups: 0,
            lifts: 0,
            superscripts: [],
            subscripts: []
        };
        if (h.imperfect) {
            if (h.center.mul(t.mosConfig.semiam).equals(l)) {
                p.mosStep.quality.quality = "Maj",
                r.push(new Ke.Interval(a,"logarithmic",0,p));
                continue
            }
            if (h.center.div(t.mosConfig.semiam).equals(l)) {
                p.mosStep.quality.quality = "min",
                r.push(new Ke.Interval(a,"logarithmic",0,p));
                continue
            }
        } else {
            if (h.center.mul(t.mosConfig.am).equals(l)) {
                p.mosStep.quality.quality = "Aug",
                r.push(new Ke.Interval(a,"logarithmic",0,p));
                continue
            }
            if (h.center.div(t.mosConfig.am).equals(l)) {
                p.mosStep.quality.quality = "dim",
                r.push(new Ke.Interval(a,"logarithmic",0,p));
                continue
            }
        }
        if (h.center.equals(l)) {
            r.push(new Ke.Interval(a,"logarithmic",0,p));
            continue
        }
        r.push(new Ke.Interval(a,"logarithmic",0))
    }
    return r
}
_p.__doc__ = "If the current scale is empty, generate absolute Diamond-mos notation based on the current config. Uses relative notation if J4 does not coincide with 1/1.";
_p.__node__ = (0,
q.builtinNode)(_p);
function wf(n) {
    n ?? (n = this.currentScale),
    n.reverse()
}
wf.__doc__ = "Reverse the order of the current/given scale.";
wf.__node__ = (0,
q.builtinNode)(wf, nr);
function Lp(n) {
    return n ?? (n = this.popScale(!1)),
    n = [...n],
    wf.bind(this)(n),
    n
}
Lp.__doc__ = "Obtain a copy of the popped/given scale in reversed order.";
Lp.__node__ = (0,
q.builtinNode)(Lp);
function Sp(n, t) {
    if (n ?? (n = this.currentScale),
    !n.length)
        throw new Error("Pop from an empty scale.");
    if (t) {
        let e = t.toInteger();
        if (e < 0 && (e += n.length),
        e < 0 || e >= n.length)
            throw new Error("Pop index out of range.");
        return n.splice(e, 1)[0]
    }
    return n.pop()
}
Sp.__doc__ = "Remove and return the last interval in the current/given scale. Optionally an index to pop may be given.";
Sp.__node__ = (0,
q.builtinNode)(Sp, nr);
function Ap(n) {
    n ?? (n = this.currentScale);
    const t = [...n];
    return n.length = 0,
    t
}
Ap.__doc__ = "Remove and return all intervals in the current/given scale.";
Ap.__node__ = (0,
q.builtinNode)(Ap, nr);
function Cp(n, t, e) {
    if ((0,
    q.requireParameters)({
        interval: n
    }),
    t ?? (t = this.currentScale),
    e) {
        let r = e.toInteger();
        if (r < 0 && (r += t.length),
        r < 0) {
            t.unshift(n);
            return
        }
        if (r >= t.length) {
            t.push(n);
            return
        }
        t.splice(r, 0, n);
        return
    }
    t.push(n)
}
Cp.__doc__ = "Append an interval onto the current/given scale. Optionally an index to push after may be given.";
Cp.__node__ = (0,
q.builtinNode)(Cp, nr);
function $p(n) {
    if (n ?? (n = this.currentScale),
    !n.length)
        throw new Error("Shift from an empty scale.");
    return n.shift()
}
$p.__doc__ = "Remove and return the first interval in the current/given scale.";
$p.__node__ = (0,
q.builtinNode)($p, nr);
function Mp(n, t) {
    (0,
    q.requireParameters)({
        interval: n
    }),
    t ?? (t = this.currentScale),
    t.unshift(n)
}
Mp.__doc__ = "Prepend an interval at the beginning of the current/given scale.";
Mp.__node__ = (0,
q.builtinNode)(Mp, nr);
function Op(n, t) {
    (0,
    q.requireParameters)({
        interval: n
    }),
    t ?? (t = this.currentScale);
    const e = Xt.compare.bind(this);
    for (let r = 0; r < t.length; ++r)
        if (e(n, t[r]) < 0) {
            t.splice(r, 0, n);
            return
        }
    t.push(n)
}
Op.__doc__ = "Insert an interval into the current/given scale keeping it sorted.";
Op.__node__ = (0,
q.builtinNode)(Op, nr);
function Np(n, t) {
    if ((0,
    q.requireParameters)({
        element: n
    }),
    t ?? (t = this.currentScale),
    n instanceof Ke.Interval) {
        for (let e = 0; e < t.length; ++e) {
            const r = t[e];
            if (r instanceof Ke.Interval && n.strictEquals(r))
                return t.splice(e, 1)[0]
        }
        throw new Error("Failed to locate interval to dislodge.")
    }
    for (let e = 0; e < t.length; ++e)
        if (n === t[e])
            return t.splice(e, 1)[0];
    throw new Error("Failed to locate element to dislodge.")
}
Np.__doc__ = "Remove and return the first element equal to the given one from the current/given scale.";
Np.__node__ = (0,
q.builtinNode)(Np, nr);
function Tp(n, ...t) {
    (0,
    q.requireParameters)({
        first: n
    });
    for (const e of t)
        n.push(...e)
}
Tp.__doc__ = "Extend the first array with the contents of the rest.";
Tp.__node__ = (0,
q.builtinNode)(Tp);
function xp(n, ...t) {
    return (0,
    q.requireParameters)({
        first: n
    }),
    typeof n == "string" ? n.concat(...t.map(e => typeof e == "string" ? e : Ra.bind(this)(e))) : n.concat(...t)
}
xp.__doc__ = "Combine two or more arrays/strings.";
xp.__node__ = (0,
q.builtinNode)(xp);
function Ip(n) {
    return n instanceof Ke.ValBasis ? (0,
    q.fromInteger)(n.size) : (n ?? (n = this.currentScale),
    (0,
    q.fromInteger)(n.length))
}
Ip.__doc__ = "Return the number of intervals in the scale, the length of a string or the size of a basis.";
Ip.__node__ = (0,
q.builtinNode)(Ip, nr);
function Ef(n, t) {
    return (0,
    q.requireParameters)({
        mapper: n
    }),
    n = n.bind(this),
    t ?? (t = this.currentScale),
    t.map( (e, r, i) => n(e, (0,
    q.fromInteger)(r), i))
}
Ef.__doc__ = "Map a riff over the given/current scale producing a new scale.";
Ef.__node__ = (0,
q.builtinNode)(Ef, nr);
function Fp(n, t) {
    (0,
    q.requireParameters)({
        mapper: n
    }),
    t ?? (t = this.currentScale);
    const e = Ef.bind(this)(n, t);
    t.length = 0,
    t.push(...e)
}
Fp.__doc__ = "Map a riff over the given/current scale replacing the contents.";
Fp.__node__ = (0,
q.builtinNode)(Fp, nr);
function _f(n, t) {
    return (0,
    q.requireParameters)({
        tester: n
    }),
    n = n.bind(this),
    t ?? (t = this.currentScale),
    t.filter( (e, r, i) => (0,
    q.sonicTruth)(n(e, (0,
    q.fromInteger)(r), i)))
}
_f.__doc__ = "Obtain a copy of the given/current scale containing values that evaluate to `true` according to the `tester` riff.";
_f.__node__ = (0,
q.builtinNode)(_f, nr);
function Rp(n, t) {
    (0,
    q.requireParameters)({
        tester: n
    }),
    t ?? (t = this.currentScale);
    const e = _f.bind(this)(n, t);
    t.length = 0,
    t.push(...e)
}
Rp.__doc__ = "Remove intervals from the given/current scale that evaluate to `false` according to the `tester` riff.";
Rp.__node__ = (0,
q.builtinNode)(Rp, nr);
function Pp(n, t, e) {
    if ((0,
    q.requireParameters)({
        reducer: n
    }),
    typeof n != "function")
        throw new Error("The first argument of arrayReduce must be a function.");
    return n = n.bind(this),
    t ?? (t = this.currentScale),
    arguments.length >= 3 ? t.reduce( (r, i, a, l) => n(r, i, (0,
    q.fromInteger)(a), l), e) : t.reduce( (r, i, a, l) => n(r, i, (0,
    q.fromInteger)(a), l))
}
Pp.__doc__ = "Reduce the given/current scale to a single value by the `reducer` riff which takes an accumulator, the current value, the current index and the array as arguments.";
Pp.__node__ = (0,
q.builtinNode)(Pp, nr);
function Dp(n, t) {
    (0,
    q.requireParameters)({
        count: n
    });
    const e = n.toInteger();
    return typeof t == "string" ? t.repeat(e) : e === 0 ? [] : (t ?? (t = this.currentScale),
    this.spendGas(e * t.length),
    [].concat(...Array(e).fill(t)))
}
Dp.__doc__ = "Repeat the given/current array or string `count` times.";
Dp.__node__ = (0,
q.builtinNode)(Dp, nr);
function qp(n, t) {
    return n || (n = this.currentScale),
    this.spendGas(n.length),
    t ? n.some( (e, r, i) => t(e, (0,
    q.fromInteger)(r), i)) : n.some(q.sonicTruth)
}
qp.__doc__ = "Test whether at least one element in the array passes the test implemented by the provided function. It returns true if, in the array, it finds an element for which the provided function returns true; otherwise it returns false. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.";
qp.__node__ = (0,
q.builtinNode)(qp, nr);
function Bp(n, t) {
    return n || (n = this.currentScale),
    this.spendGas(n.length),
    t ? n.every( (e, r, i) => t(e, (0,
    q.fromInteger)(r), i)) : n.every(q.sonicTruth)
}
Bp.__doc__ = "Tests whether all elements in the array pass the test implemented by the provided function. It returns a Boolean value. It doesn't modify the array. If no array is provided it defaults to the current scale. If no test is provided it defaults to truthiness.";
Bp.__node__ = (0,
q.builtinNode)(Bp, nr);
function kp(n) {
    if (typeof n != "object")
        throw new Error("A record expected.");
    if (Array.isArray(n) || n instanceof Ke.Color || n instanceof Ke.Interval || n instanceof Ke.Val)
        throw new Error("A record expected.");
    return Object.entries(n)
}
kp.__doc__ = "Obtain an array of `[key, value]` pairs of the record.";
kp.__node__ = (0,
q.builtinNode)(kp);
function zp(n) {
    if (!this.rootContext)
        throw new Error("Root context required to access template arguments.");
    return this.rootContext.templateArguments[(0,
    q.upcastBool)(n).toInteger()]
}
zp.__doc__ = "Access the nth template argument when using the `sw` tag inside JavaScript.";
zp.__node__ = (0,
q.builtinNode)(zp);
function Ra(n) {
    return Xt.repr.bind(this)(n)
}
Ra.__doc__ = "Obtain a string representation of the value (with color and label).";
Ra.__node__ = (0,
q.builtinNode)(Ra);
function Vp(n) {
    return Xt.str.bind(this)(n)
}
Vp.__doc__ = "Obtain a string representation of the value (w/o color or label).";
Vp.__node__ = (0,
q.builtinNode)(Vp);
function Lf(n) {
    return (0,
    q.isArrayOrRecord)(n) ? q.unaryBroadcast.bind(this)(n, Lf.bind(this)) : Xt.str.bind(this)(n)
}
Lf.__doc__ = "Obtain a string representation of a primitive value (w/o color or label). Vectorizes over arrays.";
Lf.__node__ = (0,
q.builtinNode)(Lf);
function Up(n, t) {
    const e = (0,
    q.upcastBool)(t).toInteger();
    if ((0,
    q.isArrayOrRecord)(n)) {
        const r = Xt.lstr.bind(this);
        return q.unaryBroadcast.bind(this)(n, i => r(i, e))
    }
    return Xt.lstr.bind(this)(n, e)
}
Up.__doc__ = 'Obtain a "best effort" short string representing a primitive value. Vectorizes over arrays.';
Up.__node__ = (0,
q.builtinNode)(Up);
function jp(...n) {
    const t = Ra.bind(this);
    console.log(...n.map(e => typeof e == "string" ? e : t(e)))
}
jp.__doc__ = "Print the arguments to the console.";
jp.__node__ = (0,
q.builtinNode)(jp);
function Hp(...n) {
    const t = Ra.bind(this);
    console.log(...n.map(e => typeof e == "string" ? e : t(e)))
}
Hp.__doc__ = 'Print the arguments to the console with "warning" emphasis.';
Hp.__node__ = (0,
q.builtinNode)(Hp);
function Gp(n) {
    console.dir(n, {
        depth: null
    })
}
Gp.__doc__ = "Obtain the javascript representation of the value.";
Gp.__node__ = (0,
q.builtinNode)(Gp);
function Wp(n) {
    return (0,
    q.requireParameters)({
        riff: n
    }),
    n.__doc__
}
Wp.__doc__ = "Obtain the docstring of the given riff.";
Wp.__node__ = (0,
q.builtinNode)(Wp);
function Jp(n) {
    (0,
    q.requireParameters)({
        riff: n
    }),
    console.log(`Help on ${n.name}`),
    console.log(n.__doc__);
    const t = n.__node__.parameters;
    if (t.parameters.length || t.rest) {
        console.log("Parameters:");
        const e = t.parameters.map(r => r.type === "Parameter" ? r.id : "[...]" + (r.defaultValue ? " = " + (0,
        Yk.expressionToString)(r.defaultValue) : ""));
        t.rest && e.push("..." + t.rest.id),
        console.log(e.join(", "))
    } else
        console.log("(No parameters)")
}
Jp.__doc__ = "Print information about the given riff to the console.";
Jp.__node__ = (0,
q.builtinNode)(Jp);
function os(n, t=3) {
    return n.value.valueOf().toFixed(t)
}
function Kp(n, t, e) {
    return (0,
    q.requireParameters)({
        red: n,
        green: t,
        blue: e
    }),
    new Ke.Color(`rgb(${os(n)} ${os(t)} ${os(e)})`)
}
Kp.__doc__ = "RGB color (Red range 0-255, Green range 0-255, Blue range 0-255).";
Kp.__node__ = (0,
q.builtinNode)(Kp);
function Zp(n, t, e, r) {
    return (0,
    q.requireParameters)({
        red: n,
        green: t,
        blue: e,
        alpha: r
    }),
    new Ke.Color(`rgba(${os(n)} ${os(t)} ${os(e)} / ${os(r, 5)})`)
}
Zp.__doc__ = "RGBA color (Red range 0-255, Green range 0-255, Blue range 0-255, Alpha range 0-1).";
Zp.__node__ = (0,
q.builtinNode)(Zp);
function Yp(n, t, e) {
    return (0,
    q.requireParameters)({
        hue: n,
        saturation: t,
        lightness: e
    }),
    new Ke.Color(`hsl(${os(n)}deg ${os(t)}% ${os(e)}%)`)
}
Yp.__doc__ = "HSL color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100).";
Yp.__node__ = (0,
q.builtinNode)(Yp);
function Qp(n, t, e, r) {
    return (0,
    q.requireParameters)({
        hue: n,
        saturation: t,
        lightness: e,
        alpha: r
    }),
    new Ke.Color(`hsla(${os(n)}deg ${os(t)}% ${os(e)}% / ${os(r, 5)})`)
}
Qp.__doc__ = "HSLA color (Hue range 0-360, Saturation range 0-100, Lightness range 0-100, Alpha range 0-1).";
Qp.__node__ = (0,
q.builtinNode)(Qp);
function Sf(n) {
    return Array.isArray(n) ? (this.spendGas(n.length),
    n.map(Sf)) : Xt.centsColor.bind(this)((0,
    q.upcastBool)(n))
}
Sf.__doc__ = "Color based on the size of the interval. Hue wraps around every 1200 cents.";
Sf.__node__ = (0,
q.builtinNode)(Sf);
function Ql(n) {
    return Array.isArray(n) ? (this.spendGas(n.length),
    n.map(Ql)) : Xt.factorColor.bind(this)((0,
    q.upcastBool)(n))
}
Hl.factorColor = Ql;
Ql.__doc__ = "Color an interval based on its prime factors.";
Ql.__node__ = (0,
q.builtinNode)(Ql);
Hl.BUILTIN_CONTEXT = {
    ...Xk.MATH_BUILTINS,
    ...ez.TEMPER_BUILTINS,
    VERSION: tz,
    numComponents: Ih,
    stepSignature: Fh,
    divisors: Rh,
    lll: Ph,
    mosSubset: kh,
    isPrime: Fc,
    nthPrime: Rc,
    primes: qh,
    primeRange: Bh,
    fareySequence: zh,
    fareyInterior: Vh,
    simplify: Pc,
    bleach: Dc,
    linear: qc,
    logarithmic: Bc,
    absolute: kc,
    relative: zc,
    bool: Uh,
    int: Vc,
    decimal: Uc,
    fraction: jc,
    radical: Jl,
    nedji: Hc,
    cents: Gc,
    absoluteFJS: Kl,
    FJS: Wc,
    labelAbsoluteFJS: Jc,
    monzo: Zl,
    primeMonzo: Kc,
    S: Zc,
    isInterval: jh,
    isVal: Hh,
    isBasis: Gh,
    isTemperament: Wh,
    isColor: Jh,
    isString: Kh,
    isBoolean: Zh,
    isFunction: Yh,
    isArray: Qh,
    isAbsolute: Yc,
    isRelative: Qc,
    isLinear: Xc,
    isLogarithmic: ef,
    isInt: Xh,
    isRational: ep,
    isRadical: tp,
    floor: mf,
    round: gf,
    trunc: vf,
    ceil: yf,
    charCodeAt: np,
    codePointAt: rp,
    fromCharCode: sp,
    fromCodePoint: ip,
    track: op,
    trackingIds: ap,
    flatten: lp,
    clear: up,
    colorOf: tf,
    labelOf: nf,
    JIP: rf,
    real: sf,
    tenneyHeight: of,
    wilsonHeight: af,
    gcd: lf,
    lcm: uf,
    compare: Yl,
    toPrimeArray: cf,
    monzoFromPrimeArray: cp,
    valFromPrimeArray: fp,
    transpose: dp,
    inv: hp,
    det: pp,
    hasConstantStructure: ff,
    stepString: df,
    repr: Ra,
    str: Vp,
    vstr: Lf,
    lstr: Up,
    slice: mp,
    zip: gp,
    zipLongest: vp,
    minimum: yp,
    maximum: bp,
    random: hf,
    randomCents: pf,
    sort: wp,
    sortInPlace: bf,
    keepUnique: Ep,
    automos: _p,
    reverse: Lp,
    reverseInPlace: wf,
    pop: Sp,
    popAll: Ap,
    push: Cp,
    shift: $p,
    unshift: Mp,
    insert: Op,
    dislodge: Np,
    extend: Tp,
    concat: xp,
    length: Ip,
    print: jp,
    warn: Hp,
    dir: Gp,
    doc: Wp,
    help: Jp,
    map: Ef,
    remap: Fp,
    filter: _f,
    distill: Rp,
    arrayReduce: Pp,
    arrayRepeat: Dp,
    some: qp,
    every: Bp,
    kCombinations: Dh,
    entries: kp,
    templateArg: zp,
    rgb: Kp,
    rgba: Zp,
    hsl: Yp,
    hsla: Qp,
    centsColor: Sf,
    factorColor: Ql
};
var Xl = {};
Object.defineProperty(Xl, "__esModule", {
    value: !0
});
Xl.PRELUDE_SOURCE = Xl.PRELUDE_VOLATILES = void 0;
Xl.PRELUDE_VOLATILES = `
(* XXX: This is only here to bypass scope optimization so that Scale Workshop can hook warn(). *)
riff reduce(scale = ) {
  "Obtain a copy of the popped/given scale reduced by its equave. Issue a warning if the scale was already reduced.";
  if (not scale)
    return [];
  if (every(scale >= 1 vand scale <= scale[-1])) {
    warn("The scale was already reduced by its equave. Did you mean 'simplify'?");
    return scale[..];
  }
  return equaveReduce(scale);
}
`;
Xl.PRELUDE_SOURCE = `
(** Root context dependents **)

(**
 * Note that this could be golfed to:
 * const ablin = i => i linear absolute,
 * but it would lead to weird behavior if i is a function.
 *)
riff ablin(interval) {
  "Convert interval to absolute linear representation.";
  return absolute(linear interval);
}

riff ablog(interval) {
  "Convert interval to absolute logarithmic representation.";
  return absolute(logarithmic interval);
}

riff relin(interval) {
  "Convert interval to relative linear representation.";
  return relative(linear interval);
}

riff relog(interval) {
  "Convert interval to relative logarithmic representation.";
  return relative(logarithmic interval);
}

riff NFJS(interval) {
  "Convert interval to (relative) FJS using neutral comma flavors.";
  return FJS(interval, 'n');
}

riff absoluteNFJS(interval) {
  "Convert interval to absolute FJS using neutral comma flavors.";
  return absoluteFJS(interval, 'n');
}

riff HEJI(interval) {
  "Convert interval to (relative) FJS using HEJI comma flavors.";
  return FJS(interval, 'h');
}

riff absoluteHEJI(interval) {
  "Convert interval to absolute FJS using HEJI comma flavors.";
  return absoluteFJS(interval, 'h');
}

(** Functions **)
riff vbool(value) {
  "Convert value to a boolean. Vectorizes over arrays.";
  return vnot vnot value;
}

riff keys(record) {
  "Obtain an array of keys of the record.";
  return map([key] => key, entries record);
}

riff values(record) {
  "Obtain an array of values of the record.";
  return map([_, value] => value, entries record);
}

riff range(start, stop = niente, step = 1) {
  "Obtain an array of integers from \`start\` to \`stop - 1\`. When only a single parameter is given \`range(0, n)\` is returned.";
  if (stop == niente) {
    stop = start;
    start = 0;
  }
  return [start, start+step .. < stop];
}

riff sanitize(interval) {
  "Get rid of interval formatting, color and label.";
  return bleach(simplify interval);
}

riff fail(message) {
  "Throw the given message as an error.";
  throw message;
}

riff trap(message) {
  "Produce a function that fails with the given message when called.";
  return () => fail(message);
}

riff assert(test, message = "Assertion failed.") {
  "Assert that the test expression is true or fail with the given message.";
  if (not test)
    fail(message);
}

riff domainOf(interval) {
  "Return the domain of the given interval as a callable converter.";
  return linear where isLinear(interval)
    else logarithmic where isLogarithmic(interval)
      else trap("An interval is required.");
}

riff sqrt(x) {
  "Calculate the square root of the input.";
  return x;
}

riff cbrt(x) {
  "Calculate the cube root of the input.";
  return x ~/^ 3;
}
riff exp(x) {
  "Calculate e raised to the power of x.";
  return E ~^ x;
}
riff log(x, y = E) {
  "Calculate the logarithm of x base y. Base defaults to E.";
  return x ~/_ y;
}
riff log10(x) {
  "Calculate the logarithm of x base 10.";
  return x ~/_ 10;
}
riff log2(x) {
  "Calculate the logarithm of x base 2.";
  return x ~/_ 2;
}
riff acosh(x) {
  "Calculate the inverse hyperbolic cosine of x.";
  return log(x ~+ sqrt(x ~^ 2 ~- 1));
}
riff asinh(x) {
  "Calculate the inverse hyperbolic sine of x.";
  return log(x ~+ sqrt(x ~^ 2 ~+ 1));
}
riff atanh(x) {
  "Calculate the inverse hyperbolic tangent of x.";
  return log((1 +~ x) ~% (1 -~ x)) ~% 2;
}
riff cosh(x) {
  "Calculate the hyperbolic cosine of x.";
  return (exp(x) ~+ exp(-~x)) ~% 2;
}
riff sinh(x) {
  "Calculate the hyperbolic sine of x.";
  return (exp(x) ~- exp(-~x)) ~% 2;
}
riff tanh(x) {
  "Calculate the hyperbolic tangent of x.";
  return (exp(x) ~- exp(-~x)) ~% (exp(x) ~+ exp(-~x));
}
riff pow(x, y) {
  "Calculate x to the power of y.";
  return x ~^ y;
}
riff numerator(x) {
  "Calculate the numerator of x in reduced form.";
  return lcm(1, x);
}
riff denominator(x) {
  "Calculate the denominator of x in reduced form.";
  return %gcd(1, x);
}
riff sign(x) {
  "Calculate the sign of x.";
  return 1 where x > 0 else -1 where x < 0 else 0 where x == 0 else nan;
}
riff oddLimitOf(x, equave = 2) {
  "Calculate the odd limit of x. Here 'odd' means not divisible by the equave.";
  const noEquaves = x ~% equave^(%logarithmic(equave) dot x);
  return numerator(noEquaves) max denominator(noEquaves);
}
riff weilHeight(x) {
  "Calculate the Weil height of the interval. Natural logarithm of the maximum of numerator or denominator.";
  return (tenneyHeight x ~+ log(labs~x)) ~/ 2;
}
riff hypot(...args) {
  "Calculate the square root of the sum of squares of the arguments.";
  return sum(map(a => a ~^ 2, args)) ~/^ 2;
}

riff bpm(beats) {
  "Calculate the frequency corresponding to the given number of beats per minute.";
  return beats % 60s;
}

riff avg(...terms) {
  "Calculate the arithmetic mean of the terms.";
  return arrayReduce((a, b) => a ~+ b, terms) ~% length(terms);
}

riff havg(...terms) {
  "Calculate the harmonic mean of the terms.";
  return arrayReduce((a, b) => a ~/+ b, terms) ~* length(terms);
}

riff geoavg(...factors) {
  "Calculate the geometric mean of the factors.";
  return arrayReduce((a, b) => a ~* b, factors) ~/^ length(factors);
}

riff circleDifference(a, b, equave = 2) {
  "Calculate the geometric difference of two intervals on a circle.";
  const half = equave ~/^ 2;
  return logarithmic((a ~% b ~* half) ~rd equave ~% half);
}

riff circleDistance(a, b, equave = 2) {
  "Calculate the geometric distance of two intervals on a circle.";
  return labs~circleDifference(a, b, equave);
}

riff mtof(index) {
  "Convert MIDI note number to absolute frequency.";
  return 440 Hz * 2 ^ (index - 69)/12;
}
riff ftom(freq) {
  "Convert absolute frequency to MIDI note number / MTS value (fractional semitones with A440 = 69).";
  return freq/440Hz /_ 2 * 12 + 69;
}

riff void() {
  "Get rid of expression results. \`void(++i)\` increments the value but doesn't push anything onto the scale.";
  return;
}

riff sum(terms = $$) {
  "Calculate the (linear) sum of the terms or the current scale.";
  return arrayReduce((total, element) => total +~ element, terms);
}

riff add(...terms) {
  "Calculate the (linear) sum of the arguments.";
  return sum terms;
}

riff prod(factors = $$) {
  "Calculate the (linear) product of the factors or the current scale i.e. the logarithmic sum.";
  return arrayReduce((total, element) => total *~ element, factors);
}

riff mul(...factors) {
  "Calculate the (linear) product of the arguments i.e. the logarithmic sum.";
  return prod factors;
}

riff stackLinear(array = ) {
  "Cumulatively sum the numbers of the popped/given array.";
  array;
  let i = 0r;
  const len = real(length($));
  while (++i < len)
    $[i] ~+= $[i-1r];
}

riff cumsum(array) {
  "Calculate the cumulative sums of the terms in the array.";
  return stackLinear(array);
}

riff stack(array = ) {
  "Cumulatively stack the popped/given intervals on top of each other.";
  array;
  let i = 0r;
  const len = real(length($));
  while (++i < len)
    $[i] ~*= $[i-1r];
}

riff cumprod(array) {
  "Calculate the cumulative products of the factors in the array i.e. logarithmic cumulative sums.";
  return stack(array);
}

riff diff(array) {
  "Calculate the (linear) differences between the terms.";
  array;
  let i = real(length($));
  while (--i)
    $[i] ~-= $[i - 1r];
}

riff unstack(array = ) {
  "Unstack the popped/given scale into steps.";
  array;
  let i = real(length($));
  while (--i)
    $[i] ~%= $[i - 1r];
}

riff geodiff(array) {
  "Calculate the geometric differences between the factors.";
  return unstack(array);
}

riff unstackPeriodic(array = ) {
  "Convert the popped/given periodic sequence of steps into inflections of the last interval as the guide generator.";
  array;
  const first = $[0] ~% $[-1];
  let i = real(length($));
  while (--i)
    $[i] ~%= $[i - 1r];
  $[0] = first;
}

riff stackPeriodic(guideGenerator, array = ) {
  "Stack the popped/given inflections along with the guide generator into a periodic sequence of steps.";
  if (not isInterval(guideGenerator))
    throw "Guide generator must be an interval.";
  array;
  $[0] ~*= guideGenerator;
  let i = 0r;
  const len = real(length($));
  while (++i < len)
    $[i] ~*= $[i-1r];
}

riff enumerate(array = $$) {
  "Produce an array of [index, element] pairs from the given current/given array.";
  return [[i, array[i]] for i in array];
}

riff supportingGPVs(initialVal, commas, count = 5, weights = niente, maxIter = 1000) {
  "Obtain generalized patent vals in the same sequence as the initial val that make the given commas vanish.";
  if (not isArray(commas)) {
    commas = [commas];
  }
  const result = [];
  let iter = 0;
  while (length(result) < count and ++iter <= maxIter) {
    let valid = true;
    for (const comma of commas) {
      if (initialVal dot comma <> 0)
        break;
    } else {
      push(initialVal, result);
    }
    initialVal = nextGPV(initialVal);
  }
  return result;
}

riff colorsOf(scale = $$) {
  "Obtain an array of colors of the current/given scale.";
  return map(colorOf, scale);
}

riff labelsOf(scale = $$) {
  "Obtain an array of labels of the current/given scale.";
  return map(labelOf, scale);
}

riff edColors(divisions = 12, offset = 0, equave = 2) {
  "Color every interval in the scale with hue repeating every step of an equal division of \`equave\`. \`offset\` rotates the hue wheel.";

  const base = (equave ~/^ divisions) ~/^ 360;
  riff edColor(interval) {
    "Color an interval wih hue repeating every step of an equal divisions.";
    return interval hsl((offset ~+ interval ~/_ base) ~mod 360, 100, 50);
  }
  return edColor;
}

riff TE(valsOrCommas, basis=niente) {
  "Create a Tenney-Euclid optimal temperament from an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a different basis or a prime limit may be given."
  if (not isArray(valsOrCommas)) {
    valsOrCommas = [valsOrCommas];
  }
  if (isVal(valsOrCommas[0])) {
    return Temperament(valsOrCommas);
  }
  return commaList(valsOrCommas, basis, niente, false, true);
}

riff CTE(valsOrCommas, primeLimit=niente) {
  "Create a constrained (nearly) Tenney-Euclid optimal temperament from an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a higher one or an explicit basis can be given."
  if (not isArray(valsOrCommas)) {
    valsOrCommas = [valsOrCommas];
  }
  const EQUAVE_WEIGHT = 5000;
  if (isVal(valsOrCommas[0])) {
    return Temperament(valsOrCommas, EQUAVE_WEIGHT, true);
  }
  return commaList(valsOrCommas, primeLimit, EQUAVE_WEIGHT, true, true);
}

riff POTE(valsOrCommas, primeLimit=niente) {
  "Create a nave pure-equaves tuning by normalizing the Tenney-Euclid optimal temperament based on an array of vals or commas. Note: Comma lists will always use the full inferred prime limit, but a higher one or an explicit basis can be given."
  if (not isArray(valsOrCommas)) {
    valsOrCommas = [valsOrCommas];
  }
  if (isVal(valsOrCommas[0])) {
    return Temperament(valsOrCommas, niente, true);
  }
  return commaList(valsOrCommas, primeLimit, niente, true, true);
}

riff So(start, end = niente) {
  "Compute the geometric difference between successive odd harmonics \`(2*start + 1) / (2*start - 1)\` and \`(2*start + 3) / (2*start + 1)\`. If \`end\` is given, \`(2*end + 3) / (2*end + 1)\` is used as the endpoint instead.";
  start = int(start);
  end = start if end == niente else int(end);
  return logarithmic((2*start + 1)/(2*start - 1) % (2*end + 3)/(2*end + 1));
}

(** Scale generation **)
riff tet(divisions, equave = 2) {
  "Generate an equal temperament with the given number of divisions of the given equave/octave.";
  if (equave == 2)
    return [1..divisions] \\ divisions;
  return [1..divisions] \\ divisions ed equave;
}

riff tetStack(steps, equave = 2) {
  "Stack relative edosteps up to the given equave/octave.";
  stackLinear(steps);
  if (equave == 2)
    return $ \\ $[-1];
  return $ \\ $[-1] ed equave;
}

riff afdo(divisions, equave = 2) {
  "Generate arithmetic frequency divisions of the given equave/octave.";
  const delta = (equave ~- 1) ~/ divisions;
  return 1 +~ [1..divisions] *~ delta;
}

riff afdoStack(steps, equave = 2) {
  "Stack arithmetic frequency deltas up to the given equave/octave.";
  stackLinear(steps);
  const delta = (equave ~- 1) ~/ $[-1];
  return 1 +~ $ *~ delta;
}

riff subharmonics(start, end) {
  "Generate a subharmonic segment including the given start and end points.";
  /end::start;
}

riff mos(numberOfLargeSteps, numberOfSmallSteps, sizeOfLargeStep = 2, sizeOfSmallStep = 1, up = niente, down = niente, equave = 2) {
  "Generate a Moment-Of-Symmetry scale with the given number number of large and small steps. \\
  \`up\` defines the brightness of the mode i.e. the number of major intervals from the root. \\
  Alternatively \`down\` defines the darkness of the mode i.e. the number of minor intervals from the root. \\
  The default \`equave\` is the octave \`2/1\`.";
  mosSubset(numberOfLargeSteps, numberOfSmallSteps, sizeOfLargeStep, sizeOfSmallStep, up, down);
  const divisions = abs $[-1];
  if (equave == 2)
    return $ \\ divisions;
  else
    return $ \\ divisions ed equave;
}

riff rank2(generator, up, down = 0, period = niente, numPeriods = 1, generatorSizeHint = niente, periodSizeHint = niente) {
  "Create a finite segment of a Rank-2 scale by stacking the given generator against the given period (or the octave by default).\\
  \`up\` and \`down\` must be multiples of \`numPeriods\`. The size hints are used to get the correct period reduction when generating a preimage.";
  if (up ~mod numPeriods)
    throw "Up must be a multiple of the number of periods.";
  if (down ~mod numPeriods)
    throw "Down must be a multiple of the number of periods.";
  up ~%= numPeriods;
  down ~%= numPeriods;
  period al= 2 al~ generator;
  if (generatorSizeHint == niente and periodSizeHint == niente) {
    generator ~^ [-down..-1] ~rd period;
    generator ~^ [1..up] ~rd period;
    period;
    sort();
    repeat(numPeriods);
    return $;
  }
  generatorSizeHint al= generator;
  periodSizeHint al= period;
  const hint = generatorSizeHint ~^ [-down..up];
  const periods = ceil(hint ~/_ periodSizeHint) - 1;
  const scale = generator ~^ [-down..up] ~% period ~^ periods;
  const scales = zip(scale, hint ~rdc periodSizeHint);
  sortInPlace(scales, (a, b) => compare(a[1], b[1]));
  [a for [a, b] of scales];
  period vor pop();
  return repeat(numPeriods);
}

riff cps(factors, count, equave = niente, withUnity = false) {
  "Generate a combination product set from the given factors and combination size.";
  for (const combination of kCombinations(factors, count))
    prod(combination);
  sort();
  if ($ and not withUnity)
    ground();
  equave al (2 al~ $~[0]);
  equaveReduce();
  return sort();
}

riff wellTemperament(commaFractions, comma = 81/80, down = 0, generator = 3/2, period = niente) {
  "Generate a well-temperament by cumulatively modifying the pure fifth \`3/2\` (or a given generator) by fractions of the syntonic/given comma.";
  period al= 2 al~ generator;
  1;
  generator ~* comma ~^ commaFractions;
  stack();
   ~/ [down] rdc period;
  sort();
  period vor pop();
}

riff parallelotope(basis, ups = niente, downs = niente, equave = niente, basisSizeHints = niente, equaveSizeHint = niente) {
  "Span a parallelotope by extending a basis combinatorically. \`ups\` defaults to all ones while \`downs\` defaults to all zeros.\\
  The size hints are used to get the correct period reduction when generating a preimage.";
  equave al= 2 al~ basis~[0];
  const basis_ = basis[..];
  const ups_ = ups[..] if ups else [];
  const downs_ = downs[..] if downs else [];
  while (length(ups_) < length(basis_)) push(1, ups_);
  while (length(downs_) < length(basis_)) push(0, downs_);
  basis = basis_[..];
  ups = ups_[..];
  downs = downs_[..];

  equave ~^ 0;

  while (basis) {
    const generator = pop(basis);
    const up = pop(ups);
    const down = pop(downs);

    (* Don't impose color on unity. *)
    const axis = generator ~^ [-down..up];
    axis[down] = bleach(axis[down]);

    axis ~tns~ ;
  }

  (* It's too hard to keep track of good formatting during tensoring. Simplify non-unison linears. *)
  const l = isLinear($)
  if (l)
    l[0] = false
  $[l] = simplify $[l]

  if (basisSizeHints == niente and equaveSizeHint == niente)
    return sort($ ~rdc equave);

  const scale = ;
  basis = basis_;
  ups = ups_;
  downs = downs_;

  basisSizeHints al= [];
  equaveSizeHint al= equave;
  while (length(basisSizeHints) < length(basis))
    push(basis[length(basisSizeHints)], basisSizeHints);

  equaveSizeHint ~^ 0;

  while (basisSizeHints) {
    const generator = pop(basisSizeHints);
    const up = pop(ups);
    const down = pop(downs);

    generator ~^ [-down..up] ~tns~ ;
  }

  const hint = ;
  const equaves = ceil(hint ~/_ equaveSizeHint) - 1;

  const scales = zip(scale ~% equave ~^ equaves, hint ~rdc equaveSizeHint);
  [a for [a, b] of sort(scales, (a, b) => compare(a[1], b[1]))];
}

riff eulerGenus(guide, root = 1, equave = niente) {
  "Span a lattice from all divisors of the guide-tone rotated to the root-tone.";
  if (guide ~mod root) {
    throw "Root must divide the guide tone.";
  }
  equave al= 2 al~ guide;
  while (not (guide ~mod equave))
    guide /= equave;

  (divisors(guide) ~% root ~rdc equave) colorOf(guide) labelOf(guide);
  sort();
  equave vor pop();
}

riff octaplex(b0, b1, b2, b3, equave = niente, withUnity = false) {
  "Generate a 4-dimensional octaplex a.k.a. 20-cell from the given basis intervals.";
  equave al= 2 al~ b0;
  const s1 = [-1, -1, 1, 1];
  const s2 = [-1, 1, -1, 1];

  b0 ~^ s1 ~* b1 ~^ s2;
  b0 ~^ s1 ~* b2 ~^ s2;
  b0 ~^ s1 ~* b3 ~^ s2;
  b1 ~^ s1 ~* b3 ~^ s2;
  b2 ~^ s1 ~* b3 ~^ s2;
  b1 ~^ s1 ~* b2 ~^ s2;

  sort();
  if (not withUnity)
    ground();
  equave;
  equaveReduce();
  return sort();
}

riff gs(generators, size, period = niente, numPeriods = 1) {
  "Stack a periodic array of generators up to the given size which must be a multiple of the number of periods.";
  period al= 2 al~ generators~[0];
  size = round(size % numPeriods);
  generators[[0..size-2] mod length(generators)];
  stack();
  period;
  equaveReduce();
  sort();
  return repeat(numPeriods);
}

riff csgs(generators, ordinal = 1, period = niente, numPeriods = 1, maxSize = 100) {
  "Generate a constant structure generator sequence. Zero ordinal corresponds to the (trivial) stack of all generators while positive ordinals denote scales with constant structure ordered by increasing size.";
  cumprod(map(simplify, generators));
  period al= 2 al~ generators~[0];
  let accumulator = $[-1];
  period;
  equaveReduce();
  sort();
  let i = -1r;
  const len = real(length(generators));
  ordinal = real(ordinal);
  while (ordinal) {
    accumulator *~= generators[++i mod len];
    push(accumulator ~rd period, $$);
    if (length($$) > maxSize) {
      throw "No constant structure found before reaching maximum size.";
    }
    sortInPlace($$);
    if (hasConstantStructure($$)) {
      void(--ordinal);
    }
  }
  return repeat(numPeriods);
}

riff vao(denominator, maxNumerator, divisions = 12, tolerance = 5.0, equave = 2) {
  "Generate a vertically aligned object i.e. a subset of the harmonic series that sounds like the given equal temperament (default \`12\`) within the given tolerance (default \`5c\`). Harmonics equated by the \`equave\` (default \`2/1\`) are only included once. The returned segment begins at unison.";
  const step = equave ~/^ divisions;
  const witnesses = [];
  for (const numerator of [denominator .. maxNumerator]) {
    const candidate = numerator % denominator;
    if (labs~((candidate ~by step) %~ candidate) < tolerance) {
      const witness = candidate ~rd equave;
      if (witness not of witnesses) {
        candidate;
        push(witness, witnesses);
      }
    }
  }
}

riff concordanceShell(denominator, maxNumerator, divisions = 12, tolerance = 5.0, equave = 2) {
  "Generate a concordance shell i.e. a vertically aligned object reduced to an equal temperament. Intervals are labeled by their harmonics.";
  let step = 1 \\ divisions ed equave;
  if (equave == 2) {
    step = 1 \\ divisions;
  }
  const result = [];
  for (const harmonic of vao(denominator, maxNumerator, divisions, tolerance, equave)) {
    const candidate = (harmonic by~ step) ~rdc equave;
    const label = (harmonic ~* denominator) simplify str;
    if (candidate of result) {
      const existing = dislodge(candidate, result);
      push(existing concat(labelOf existing, ' & ', label), result);
    } else {
      push(candidate label, result);
    }
  }
  equave = divisions * step;
  if (equave not of result)
    equave;
  result;
  return sort();
}

riff oddLimit(limit, equave = 2) {
  "Generate all fractions with odd limit <= \`limit\` reduced to between 1 (exclusive) and \`equave\` (inclusive).";
  let remainder = 0;
  while (++remainder < equave) {
    [remainder, remainder ~+ equave .. limit];
  }
  [n % d for n of  for d of  if gcd(n, d) == 1];
  return sort($ rdc equave);
}

riff realizeWord(word, sizes, equave = niente) {
  'Realize a scale word like "LLsLLLs" as a concrete scale with the given step sizes such as \`#{L: 9/8, s:256/243}\`. One step size may be omitted and inferred based on the size of the \`equave\` (default \`2\`).';
  const signature = stepSignature(word);
  let numMissing = 0;
  let missingLetter = niente;
  for (const letter in signature) {
    if (letter not in sizes) {
      numMissing += 1;
      missingLetter = letter;
    }
  }
  if (numMissing > 1) {
    throw "Only a single step size may be omitted.";
  }
  if (numMissing == 1) {
    equave al= 2;
    let total = 1;
    for (const [letter, count] of entries(signature)) {
      if (letter == missingLetter)
        continue;
      total = total *~ sizes[letter] ~^ count;
    }
    sizes = #{...sizes};
    sizes[missingLetter] = (equave %~ total) ~/^ signature[missingLetter];
  } else if (equave <> niente) {
    let total = 1;
    for (const [letter, count] of entries(signature)) {
      total = total *~ sizes[letter] ~^ count;
    }
    if (total ~<> equave) {
      throw "Given sizes must be compatible with an explicit equave.";
    }
  }
  for (const letter of word) {
    sizes[letter];
  }
  return stack();
}

(** Scale modification **)
riff equaveReduce(scale = ) {
  "Obtain a copy of the popped/given scale reduced by its equave.";
  return scale ~rdc scale[-1];
}

riff revpose(scale = ) {
  "Obtain a copy of the popped/given scale that sounds in the opposite direction."
  scale;
  const equave = pop();
   ~% equave;
  reverse();
  %equave;
}

riff retrovert(scale = ) {
  "Obtain an retroverted copy of the popped/given scale (negative harmony i.e. reflect and transpose).";
  scale;
  const equave = pop();
  equave %~ ;
  reverse();
  equave;
}

riff reflect(scale = ) {
  "Obtain a copy of the popped/given scale reflected about unison.";
  return %~scale;
}

riff u(scale = ) {
  "Obtain a undertonal reflection of the popped/given overtonal scale.";
  return reflect(scale);
};

riff o(scale = ) {
  "Obtain a copy of the popped/given scale in the default overtonal interpretation.";
  scale;
}

riff rotate(onto = 1, scale = ) {
  "Obtain a copy of the popped/given scale rotated onto the given degree.";
  scale;
  onto = real(onto mod length($));
  if (not onto)
    return $;
  const equave = $[-1];
  while (--onto)
    equave *~ shift();
  const root = shift();
   %~ root colorOf() labelOf();
  equave colorOf(root) labelOf(root);
}

riff repeat(times = 2, scale = ) {
  "Stack the popped/given scale on top of itself.";
  if (not times)
    return [];
  scale;
  const equave = scale[-1];
  for (const level of equave ~^ [1.. < times])
    scale ~* level;
}

riff repeatLinear(times = 2, scale = ) {
  "Repeat the popped/given scale shifted linearly each time.";
  if (not times)
    return [];
  scale;
  const total = (scale[-1] ~- 1);
  for (const level of total ~* [1.. < times])
    (scale ~- 1) ~+ level ~+ 1;
}

riff repeatFlat(times = 2, scale = ) {
  "Repeat the popped/given intervals as-is without accumulating equaves.";
  return arrayRepeat(times, scale);
}

riff ground(scale = ) {
  "Obtain a copy of the popped/given scale that uses the first interval as the implicit unison.";
  scale;
  const root = shift();
  return $ ~% root;
}

riff elevate(scale = ) {
  "Obtain a copy of the popped/given scale with denominators removed and the root made explicit.";
  scale;
  unshift(sanitize($[-1]~^0));
  const root = sanitize(%~gcd());
  return $ ~* root;
}

riff subset(degrees, scale = ) {
  "Obtain a copy of the popped/given scale with only the given degrees kept. Omitting the zero degree rotates the scale.";
  scale = scale[..];
  const equave = pop(scale);
  unshift(equave ~^ 0, scale);
  scale[degrees];
  ground();
  equave;
}

riff toHarmonics(fundamental, scale = ) {
  "Obtain a copy of the popped/given scale quantized to harmonics of the given fundamental.";
  return scale to~ %~fundamental colorOf(scale) labelOf(scale);
}

riff toSubharmonics(overtone, scale = ) {
  "Obtain a copy of the current/given scale quantized to subharmonics of the given overtone.";
  return %~(%~scale to~ %~overtone) colorOf(scale) labelOf(scale);
}

riff equalize(divisions, scale = ) {
  "Obtain a copy of the popped/given scale quantized to given equal divisions of its equave.";
  scale;
  let step = 1 \\ divisions;
  if ($[-1] ~<> 2)
    step ed= $[-1];
  return $ by~ step colorOf($) labelOf($);
}

riff mergeOffset(offsets, overflow = 'drop', scale = ) {
  "Obtain a copy of the popped/given scale with the given offset or polyoffset merged into it. \`overflow\` is one of 'keep', 'drop' or 'wrap' and controls what to do with offset intervals outside of current bounds.";
  if (not isArray(offsets))
    offsets = [offsets];
  scale;
  const equave = pop();

  unshift(equave ~^ 0);
  const copies = $ tns~ offsets;
  void(shift());

  if (overflow == 'drop') {
    remap(copy => copy[copy > 1 vand copy < equave], copies);
  } else if (overflow == 'wrap') {
    remap(copy => copy ~rdc equave, copies);
  } else {
    equave;
  }

  copies;
  sort();
  if (overflow <> 'keep') {
    equave;
  }
  return keepUnique();
}

riff stretch(amount, scale = ) {
  "Obtain a copy of the popped/given scale streched by the given amount. A value of \`1\` corresponds to no change.";
  return scale ~^ amount;
}

riff randomVariance(amount, varyEquave = false, scale = ) {
  "Obtain a copy of the popped/given scale with random variance added.";
  scale;
  let equave;
  if (not varyEquave)
    equave = pop();
  i => i ~* (amount ~^ (2 * random() - 1));
  if (not varyEquave)
    equave;
}

riff coalesce(tolerance = 3.5, action = 'simplest', preserveBoundary = false, scale = ) {
  "Obtain a copy of the popped/given scale where groups of intervals separated by \`tolerance\` are coalesced into one.\\
  \`action\` is one of 'simplest', 'wilson', 'lowest', 'highest', 'avg', 'havg' or 'geoavg'.\\
  If \`preserveBoundary\` is \`true\` intervals close to unison and the equave are not eliminated.";
  if (not scale)
    return [];

  let last;
  let group = [];
  for (const [i, interval] of enumerate(scale)) {
    if (group and (labs~(last %~ interval) > tolerance or i == length(scale)-1)) {
      if (action == 'lowest') {
        group[0];
      } else if (action == 'highest') {
        group[-1];
      } else if (action == 'avg') {
        avg(...group);
      } else if (action == 'havg') {
        havg(...group);
      } else if (action == 'geoavg') {
        geoavg(...group);
      } else if (action == 'wilson') {
        sort(group, (a, b) => wilsonHeight(a) - wilsonHeight(b))[0];
      } else {
        sort(group, (a, b) => tenneyHeight(a) - tenneyHeight(b))[0];
      }
      group = [];
    }
    last = interval;
    push(interval, group);
  }
  if (not preserveBoundary) {
    while ($$ and labs~$$[0] <= tolerance)
      void(shift($$));
    while ($$ and labs~($$[-1] %~ scale[-1]) <= tolerance)
      void(pop($$));
  }
  scale[-1];
  if (length($) <= 1)
    return $;
  while (length($) > 1 and $[-1] ~= $[-2])
    void(pop($, -2));
}

riff replace(interval, replacement, scale = ) {
  "Obtain a copy of the popped/given scale with occurences of \`interval\` replaced by \`replacement\`.";
  for (const existing of scale) {
    if (existing == interval) {
      replacement;
    } else {
      existing;
    }
  }
}

riff replaceStep(step, replacement, scale = ) {
  "Obtain a copy of the popped/given scale with relative occurences of \`step\` replaced by \`replacement\`.";
  unstack(scale);
  replace(step, replacement);
  return stack();
}

riff organize(tolerance = niente, action = 'simplest', preserveBoundary = false, scale = ) {
  "Obtain a copy of the popped/given scale reduced by its last interval, sorted and with duplicates filtered out.\\
  If \`tolerance\` is given near-duplicates are coalesced instead using the given \`action\`.\\
  If \`preserveBoundary\` is \`true\` intervals close to unison and the equave are not eliminated.";
  equaveReduce(scale);
  if (tolerance == niente)
    keepUnique();
  sort();
  if (tolerance <> niente)
    coalesce(tolerance, action, preserveBoundary);
}
`;
var Bf = {};
Object.defineProperty(Bf, "__esModule", {
    value: !0
});
Bf.RootContext = void 0;
const IE = hn
  , Iv = An
  , Fv = vr;
class ey {
    constructor(t) {
        this.title = "",
        this.C4_ = new Iv.TimeMonzo(Fv.ZERO,[]),
        this.up_ = new IE.Interval(new Iv.TimeMonzo(Fv.ZERO,[]),"logarithmic",1),
        this.lift_ = new IE.Interval(new Iv.TimeMonzo(Fv.ZERO,[]),"logarithmic",5),
        this.gas = t ?? 1 / 0,
        this.fragiles = [],
        this.trackingIndex = 0,
        this.templateArguments = []
    }
    get C4() {
        return this.C4_
    }
    set C4(t) {
        this.C4_ = t,
        this.breakFragiles()
    }
    get up() {
        return this.up_
    }
    set up(t) {
        this.up_ = t,
        this.breakFragiles()
    }
    get lift() {
        return this.lift_
    }
    set lift(t) {
        this.lift_ = t,
        this.breakFragiles()
    }
    get mosConfig() {
        return this.mosConfig_
    }
    set mosConfig(t) {
        this.mosConfig_ = t,
        this.breakFragiles()
    }
    clone() {
        const t = new ey(this.gas);
        return t.title = this.title,
        t.C4_ = this.C4.clone(),
        t.up_ = this.up.clone(),
        t.lift_ = this.lift.clone(),
        this.unisonFrequency && (t.unisonFrequency = this.unisonFrequency.clone()),
        t
    }
    spendGas(t=1) {
        if (!isNaN(t)) {
            if (t < 0)
                throw new Error("Cannot refill gas.");
            if (this.gas -= t,
            this.gas <= 0)
                throw new Error("Out of gas. (Infinite loop?)")
        }
    }
    breakFragiles() {
        for (const t of this.fragiles)
            t.break();
        this.fragiles = []
    }
    expand(t) {
        const e = [];
        return this.title && e.push(JSON.stringify(this.title)),
        this.C4.compare(t.C4) && e.push(`C4 = ${this.C4.toString()}`),
        this.unisonFrequency && (!t.unisonFrequency || this.unisonFrequency.compare(t.unisonFrequency)) && e.push(`1/1 = ${this.unisonFrequency.toString()}`),
        this.up.strictEquals(t.up) || e.push(`^ = ${this.up.toString()}`),
        this.lift.strictEquals(t.lift) || e.push(`/ = ${this.lift.toString()}`),
        this.mosConfig && e.push(`MOS {${this.mosConfig.pattern};L=${this.mosConfig.large};s=${this.mosConfig.small}}`),
        e.join(`
`)
    }
    nextTrackingId() {
        return this.trackingIndex++,
        this.trackingIndex
    }
}
Bf.RootContext = ey;
var Oi = {}
  , Xi = {};
Object.defineProperty(Xi, "__esModule", {
    value: !0
});
Xi.ExpressionVisitor = Xi.containerToArray = Xi.arrayRecordOrString = void 0;
const bl = Ie
  , FE = pt
  , Ce = hn
  , ln = An
  , yt = Df
  , Sn = vr
  , RE = xm
  , Rv = Gn
  , _o = Bm
  , PE = Mi;
function xl(n, t="Array, record or string expected.") {
    if (typeof n == "string")
        return n;
    if (typeof n != "object" || n instanceof Ce.Interval || n instanceof Ce.Val || n instanceof Ce.Color || n instanceof Ce.ValBasis || n instanceof Ce.Temperament)
        throw new Error(t);
    return n
}
Xi.arrayRecordOrString = xl;
function j0(n, t) {
    return n instanceof Ce.ValBasis ? n.toArray() : (n = xl(n, "Can only iterate over arrays, records or strings."),
    typeof n == "string" && (n = [...n]),
    Array.isArray(n) ? t === "in" && (n = n.map( (e, r) => Ce.Interval.fromInteger(r))) : t === "of" ? n = Object.values(n) : n = Object.keys(n),
    n)
}
Xi.containerToArray = j0;
function DE(n, t) {
    if (n instanceof Ce.Interval) {
        for (const e of t)
            if (e instanceof Ce.Interval && e.strictEquals(n))
                return !0;
        return !1
    }
    return t.includes(n)
}
function qE(n, t) {
    if (n instanceof Ce.Interval) {
        for (const e of t)
            if (e instanceof Ce.Interval && e.equals(n))
                return !0;
        return !1
    }
    return t.includes(n)
}
new ln.TimeMonzo(Sn.ZERO,[Sn.ONE]);
const BE = new ln.TimeMonzo(Sn.ZERO,[Sn.ONE, Sn.ZERO, Sn.ONE])
  , kE = new ln.TimeMonzo(Sn.ZERO,[(0,
Sn.F)(10)])
  , nz = new ln.TimeMonzo(Sn.ZERO,[(0,
Sn.F)(1, 1200)])
  , rz = new ln.TimeReal(0,1.0005777895065548)
  , sz = new ln.TimeMonzo(Sn.ZERO,[(0,
Sn.F)(1200)])
  , zE = new ln.TimeMonzo(Sn.NEGATIVE_ONE,[]);
function pS(n, t) {
    return (n == null ? void 0 : n.type) === (t == null ? void 0 : t.type) || (n == null ? void 0 : n.type) === "FJS" && (t == null ? void 0 : t.type) === "AspiringFJS" || (t == null ? void 0 : t.type) === "FJS" && (n == null ? void 0 : n.type) === "AspiringFJS"
}
function VE(n, t, e, r, i) {
    if (r.preferLeft && r.preferRight) {
        let a = t.domain;
        e.domain === "linear" && (a = "linear");
        let l;
        return pS(t.node, e.node) && (l = (0,
        Ce.intervalValueAs)(n, t.node, i)),
        new Ce.Interval(n,a,0,l,(0,
        Ce.infect)(t, e))
    }
    return r.preferLeft ? new Ce.Interval(n,t.domain,0,(0,
    Ce.intervalValueAs)(n, t.node, i),t) : new Ce.Interval(n,e.domain,0,(0,
    Ce.intervalValueAs)(n, e.node, i),e)
}
class iz {
    constructor(t, e) {
        this.mutables = e ?? new Map,
        this.parent = t
    }
    get rootContext() {
        return this.parent.rootContext
    }
    set rootContext(t) {
        this.parent.rootContext = t
    }
    get currentScale() {
        return this.parent.currentScale
    }
    set currentScale(t) {
        this.parent.currentScale = t
    }
    popScale(t) {
        if (t) {
            if (!this.mutables.has("")) {
                const e = this.get("$$");
                if (!Array.isArray(e))
                    throw new Error("Context corruption detected.");
                this.mutables.set("", [...e]),
                e.length = 0
            }
            return this.mutables.get("")
        }
        if (!this.mutables.has("")) {
            const e = this.currentScale;
            this.mutables.set("", [...e]),
            e.length = 0
        }
        return this.mutables.get("")
    }
    spendGas(t) {
        this.parent.spendGas(t)
    }
    visit(t) {
        switch (this.spendGas(),
        t.type) {
        case "BlockExpression":
            return this.visitBlockExpression(t);
        case "ConditionalExpression":
            return this.visitConditionalExpression(t);
        case "AccessExpression":
            return this.visitAccessExpression(t);
        case "ArraySlice":
            return this.visitArraySlice(t);
        case "UnaryExpression":
            return this.visitUnaryExpression(t);
        case "UpdateExpression":
            return this.visitUpdateExpression(t);
        case "BinaryExpression":
            return this.visitBinaryExpression(t);
        case "CallExpression":
            return this.visitCallExpression(t);
        case "ArrowFunction":
            return this.visitArrowFunction(t);
        case "IntegerLiteral":
            return this.visitIntegerLiteral(t);
        case "DecimalLiteral":
            return this.visitDecimalLiteral(t);
        case "FractionLiteral":
            return this.visitFractionLiteral(t);
        case "NedjiLiteral":
            return this.visitNedjiLiteral(t);
        case "CentsLiteral":
            return this.visitCentsLiteral(t);
        case "CentLiteral":
            return t.real ? new Ce.Interval(rz,"logarithmic",0,t) : new Ce.Interval(nz,"logarithmic",0,t);
        case "ReciprocalCentLiteral":
            return new Ce.Val(sz,new Ce.ValBasis(1),{
                type: "ReciprocalCentLiteral"
            });
        case "ReciprocalLogarithmicHertzLiteral":
            return new Ce.Val(zE,new Ce.ValBasis([zE]),{
                type: "ReciprocalLogarithmicHertzLiteral"
            });
        case "TrueLiteral":
            return !0;
        case "FalseLiteral":
            return !1;
        case "MonzoLiteral":
            return this.visitMonzoLiteral(t);
        case "ValLiteral":
            return this.visitValLiteral(t);
        case "FJS":
            return this.visitFJS(t);
        case "AbsoluteFJS":
            return this.visitAbsoluteFJS(t);
        case "MosStepLiteral":
            return this.visitMosStepLiteral(t);
        case "HertzLiteral":
            return this.visitHertzLiteral(t);
        case "SecondLiteral":
            return this.visitSecondLiteral(t);
        case "WartsLiteral":
            return this.visitWartsLiteral(t);
        case "SparseOffsetVal":
            return this.visitSparseOffsetVal(t);
        case "ColorLiteral":
            return new Ce.Color(t.value);
        case "Identifier":
            return this.visitIdentifier(t);
        case "PopScale":
            return this.popScale(t.parent);
        case "EnumeratedChord":
            return this.visitEnumeratedChord(t);
        case "Range":
            return this.visitRange(t);
        case "HarmonicSegment":
            return this.visitHarmonicSegment(t);
        case "ArrayLiteral":
            return this.visitArrayLiteral(t);
        case "RecordLiteral":
            return this.visitRecordLiteral(t);
        case "StringLiteral":
            return t.value;
        case "NoneLiteral":
            return;
        case "NotANumberLiteral":
            return new Ce.Interval(new ln.TimeReal(0,NaN),"linear",0,t);
        case "InfinityLiteral":
            return new Ce.Interval(new ln.TimeReal(0,1 / 0),"linear",0,t);
        case "DownExpression":
            return this.visitDownExpression(t);
        case "StepLiteral":
            return this.visitStepLiteral(t);
        case "RadicalLiteral":
            throw new Error("Unexpected radical literal.");
        case "AspiringFJS":
            throw new Error("Unexpected aspiring FJS.");
        case "AspiringAbsoluteFJS":
            throw new Error("Unexpected aspiring absolute FJS.");
        case "ArrayComprehension":
            return this.visitArrayComprehension(t);
        case "SquareSuperparticular":
            return this.visitSquareSuperparticular(t);
        case "TemplateArgument":
            return this.visitTemplateArgument(t);
        case "ValBasisLiteral":
            return this.visitValBasisLiteral(t);
        case "RangeRelation":
            return this.visitRangeRelation(t);
        case "SetLiteral":
            throw new Error("Set literals not implemented yet.")
        }
    }
    visitValBasisLiteral(t) {
        if (Array.isArray(t.basis)) {
            const {subgroup: r} = (0,
            _o.parseValSubgroup)(t.basis);
            return this.spendGas(r.length ** 2),
            new Ce.ValBasis(r,t)
        }
        const e = this.visit(t.basis);
        if (e instanceof Ce.ValBasis)
            return e;
        throw new Error(`The identifier ${t.basis.id} does not refer to a basis.`)
    }
    visitBlockExpression(t) {
        const e = this.parent._createStatementVisitor(this)
          , r = this.currentScale;
        e.mutables.set("$$", r);
        const i = e.executeStatements(t.body);
        if ((i == null ? void 0 : i.type) === "ReturnStatement")
            return i.value;
        if (i)
            throw new Error("Illegal interupt.");
        return e.currentScale
    }
    visitTemplateArgument(t) {
        if (!this.rootContext)
            throw new Error("Root context required to access template arguments.");
        return this.rootContext.templateArguments[t.index]
    }
    visitSquareSuperparticular(t) {
        if (t.end) {
            let r = 2n * t.end
              , i = t.end + 1n;
            return t.start !== 2n && (r *= t.start,
            i *= 2n * t.start - 2n),
            new Ce.Interval(ln.TimeMonzo.fromBigNumeratorDenominator(r, i),"logarithmic",0,t)
        }
        const e = t.start * t.start;
        return new Ce.Interval(ln.TimeMonzo.fromBigNumeratorDenominator(e, e - 1n),"logarithmic",0,t)
    }
    localAssign(t, e) {
        if (arguments.length < 2) {
            if (t.defaultValue)
                e = this.visit(t.defaultValue);
            else if (t.type === "Parameter")
                throw new Error(`Parameter '${t.id}' is required.`)
        }
        if (t.type === "Parameters") {
            if (!Array.isArray(e))
                throw new Error("Expected an array to destructure.");
            for (let r = 0; r < t.parameters.length; ++r)
                r < e.length ? this.localAssign(t.parameters[r], e[r]) : this.localAssign(t.parameters[r]);
            t.rest && this.localAssign(t.rest, e.slice(t.parameters.length))
        } else
            this.mutables.set(t.id, e)
    }
    comprehend(t, e, r) {
        if (r >= t.comprehensions.length) {
            if (t.test && !(0,
            yt.sonicTruth)(this.visit(t.test)))
                return;
            e.push(this.visit(t.expression));
            return
        }
        const i = t.comprehensions[r]
          , a = j0(this.visit(i.container), i.kind)
          , l = i.element;
        for (const f of a)
            this.localAssign(l, f),
            this.comprehend(t, e, r + 1)
    }
    visitArrayComprehension(t) {
        const e = [];
        return this.comprehend(t, e, 0),
        this.mutables.clear(),
        e
    }
    spread(t) {
        const e = [];
        for (const r of t)
            if (r.spread) {
                const i = j0(this.visit(r.expression), "of");
                e.push(...i)
            } else
                e.push(this.visit(r.expression));
        return e
    }
    visitArrayLiteral(t) {
        return this.spread(t.elements)
    }
    visitRecordLiteral(t) {
        const e = {};
        for (const [r,i] of t.properties)
            if (r === null) {
                const a = this.visit(i);
                if (typeof a != "object" || a instanceof Ce.Interval || a instanceof Ce.Val || a instanceof Ce.Color || a instanceof Ce.ValBasis || a instanceof Ce.Temperament || Array.isArray(a))
                    throw new Error("Spread argument must be a record.");
                for (const [l,f] of Object.entries(a))
                    e[l] = f
            } else
                e[r] = this.visit(i);
        return e
    }
    visitStepLiteral(t) {
        const e = new ln.TimeMonzo(Sn.ZERO,[]);
        return new Ce.Interval(e,"logarithmic",t.count,t)
    }
    down(t, e) {
        if (!this.rootContext)
            throw new Error("Root context required for down.");
        if (Array.isArray(t)) {
            const r = this.down.bind(this);
            return t.map(i => r(i, e))
        }
        return (0,
        yt.upcastBool)(t).down(this.rootContext, e)
    }
    visitDownExpression(t) {
        const e = this.visit(t.operand);
        return this.down(e, t.count)
    }
    visitConditionalExpression(t) {
        if (t.kind === "if") {
            const i = this.visit(t.test);
            return (0,
            yt.sonicTruth)(i) ? this.visit(t.consequent) : this.visit(t.alternate)
        }
        const e = yt.ternaryBroadcast.bind(this);
        function r(i, a, l) {
            return Array.isArray(i) || Array.isArray(a) || Array.isArray(l) ? e(i, a, l, r) : (0,
            yt.sonicTruth)(i) ? a : l
        }
        return r(this.visit(t.test), this.visit(t.consequent), this.visit(t.alternate))
    }
    visitRangeRelation(t) {
        const e = yt.ternaryBroadcast.bind(this)
          , r = yt.compare.bind(this)
          , i = t.leftOperator
          , a = t.rightOperator;
        function l(f, h, p) {
            if (Array.isArray(f) || Array.isArray(h) || Array.isArray(p))
                return e(f, h, p, l);
            const m = r(f, h);
            if (i === "<") {
                if (m >= 0)
                    return !1
            } else if (i === "<=") {
                if (m > 0)
                    return !1
            } else if (i === ">") {
                if (m <= 0)
                    return !1
            } else if (i === ">=" && m < 0)
                return !1;
            const g = r(h, p);
            switch (a) {
            case "<":
                return g < 0;
            case "<=":
                return g <= 0;
            case ">":
                return g > 0;
            case ">=":
                return g >= 0
            }
        }
        return l(this.visit(t.left), this.visit(t.middle), this.visit(t.right))
    }
    visitComponent(t) {
        const e = (0,
        FE.formatComponent)(t);
        try {
            return new bl.Fraction(e)
        } catch {
            return t.separator === "/" ? t.left / parseInt(t.right) * 10 ** (t.exponent ?? 0) : parseFloat(e)
        }
    }
    upLift(t, e) {
        if (!this.rootContext)
            throw new Error("Root context required for uplift.");
        return t = t.mul(this.rootContext.up.value.pow(e.ups)).mul(this.rootContext.lift.value.pow(e.lifts)),
        new Ce.Interval(t,"logarithmic",this.rootContext.up.steps * e.ups + this.rootContext.lift.steps * e.lifts,e)
    }
    visitMonzoLiteral(t) {
        const e = t.components.map(this.visitComponent);
        let r, i = Sn.ZERO;
        if (Array.isArray(t.basis))
            if (t.basis.length) {
                const {subgroup: l} = (0,
                _o.parseSubgroup)(t.basis, e.length);
                if (e.length > l.length)
                    throw new Error("Too many monzo components for given subgroup.");
                r = new ln.TimeMonzo(Sn.ZERO,[]);
                for (let f = 0; f < e.length; ++f) {
                    const h = l[f];
                    h === _o.STEP_ELEMENT ? i = i.add(e[f]) : r = r.mul(h.pow(e[f]))
                }
            } else {
                let l = !0;
                for (const f of e)
                    typeof f == "number" && (l = !1);
                if (l)
                    r = new ln.TimeMonzo(Sn.ZERO,e);
                else {
                    let f = 1;
                    for (let h = 0; h < e.length; ++h)
                        f *= bl.PRIMES[h] ** e[h].valueOf();
                    r = new ln.TimeReal(0,f)
                }
            }
        else {
            const l = this.visit(t.basis);
            if (!(l instanceof Ce.ValBasis))
                throw new Error(`The identifier ${t.basis.id} does not refer to a basis.`);
            r = l.dot(e)
        }
        const a = this.upLift(r, t);
        if (i.d !== 1)
            throw new Error("Cannot create fractional steps.");
        return a.steps += i.valueOf(),
        (t.ups || t.lifts) && this.rootContext.fragiles.push(a),
        Array.isArray(t.basis) || (a.node = void 0),
        a
    }
    visitValLiteral(t) {
        const e = t.components.map(this.visitComponent);
        for (const r of e)
            if (typeof r == "number")
                throw new Error("Invalid val literal.");
        if (Array.isArray(t.basis))
            if (t.basis.length) {
                const {subgroup: r} = (0,
                _o.parseValSubgroup)(t.basis, e.length);
                if (e.length !== r.length)
                    throw new Error("Val components must be given for the whole subgroup.");
                this.spendGas(r.length ** 2);
                const i = new Ce.ValBasis(r);
                return Ce.Val.fromBasisMap(e, i, t)
            } else {
                const r = new ln.TimeMonzo(Sn.ZERO,e)
                  , i = new Ce.ValBasis(e.length);
                return new Ce.Val(r,i,t)
            }
        else {
            const r = this.visit(t.basis);
            if (!(r instanceof Ce.ValBasis))
                throw new Error(`The identifier ${t.basis.id} does not refer to a basis.`);
            return Ce.Val.fromBasisMap(e, r)
        }
    }
    project(t, e) {
        if (typeof t == "boolean" && (t = (0,
        yt.upcastBool)(t)),
        t instanceof Ce.Interval)
            return t.project(e);
        const r = this.project.bind(this);
        return t.map(i => r(i, e))
    }
    visitWartsLiteral(t) {
        if (Array.isArray(t.basis))
            return this.spendGas((t.basis.length || (0,
            ln.getNumberOfComponents)()) ** 2),
            (0,
            _o.wartsToVal)(t);
        const e = this.visit(t.basis);
        if (e instanceof Ce.ValBasis)
            return this.spendGas(e.size ** 2),
            (0,
            _o.wartsToVal)(t, e);
        throw new Error(`The identifier ${t.basis.id} does not refer to a basis.`)
    }
    visitSparseOffsetVal(t) {
        if (Array.isArray(t.basis))
            return this.spendGas((t.basis.length || (0,
            ln.getNumberOfComponents)()) ** 2),
            (0,
            _o.sparseOffsetToVal)(t);
        const e = this.visit(t.basis);
        if (e instanceof Ce.ValBasis)
            return this.spendGas(e.size ** 2),
            (0,
            _o.sparseOffsetToVal)(t, e);
        throw new Error(`The identifier ${t.basis.id} does not refer to a basis.`)
    }
    visitFJS(t) {
        const e = (0,
        Rv.inflect)((0,
        RE.pythagoreanMonzo)(t.pythagorean), t.superscripts, t.subscripts)
          , r = this.upLift(e, t);
        return this.rootContext.fragiles.push(r),
        r
    }
    visitAbsoluteFJS(t) {
        if (!this.rootContext)
            throw new Error("Root context is required.");
        let e;
        if (/[J-Z]/.test(t.pitch.nominal)) {
            if (!this.rootContext.mosConfig)
                throw new Error("Missing MOS declaration.");
            e = (0,
            PE.absoluteMosMonzo)(t.pitch, this.rootContext.mosConfig)
        } else
            e = (0,
            RE.absoluteMonzo)(t.pitch);
        e = (0,
        Rv.inflect)(e, t.superscripts, t.subscripts);
        const r = this.upLift(e, t)
          , i = new Ce.Interval(this.rootContext.C4.mul(r.value),"logarithmic",r.steps,t);
        return this.rootContext.fragiles.push(i),
        i
    }
    visitMosStepLiteral(t) {
        if (!this.rootContext)
            throw new Error("Root context is required.");
        if (!this.rootContext.mosConfig)
            throw new Error("Missing MOS declaration.");
        const e = (0,
        Rv.inflect)((0,
        PE.mosMonzo)(t.mosStep, this.rootContext.mosConfig), t.superscripts, t.subscripts)
          , r = this.upLift(e, t);
        return this.rootContext.fragiles.push(r),
        r
    }
    visitAccessExpression(t) {
        const e = this.visit(t.object);
        if (e instanceof Ce.ValBasis) {
            const l = this.visit(t.key);
            if (!(l instanceof Ce.Interval))
                throw new Error("Basis index must be an integer.");
            let f = l.toInteger();
            if (f < 0 && (f += e.value.length),
            f < 0 || f >= e.value.length)
                throw new Error("Index out of range.");
            return new Ce.Interval(e.value[f],"linear")
        }
        const r = xl(e, "Can only access bases, arrays, records or strings.");
        if (!Array.isArray(r) && typeof r != "string") {
            const l = this.visit(t.key);
            if (typeof l != "string")
                throw new Error("Record keys must be strings.");
            if (!(0,
            Sn.hasOwn)(r, l)) {
                if (t.nullish)
                    return;
                throw new Error(`Key error: "${l}".`)
            }
            return r[l]
        }
        let i = this.visit(t.key);
        if (Array.isArray(i)) {
            i = i.flat(1 / 0);
            const l = [];
            for (let f = 0; f < i.length; ++f) {
                const h = i[f];
                if (!(typeof h == "boolean" || h instanceof Ce.Interval))
                    throw new Error("Only booleans and intervals can be used as indices.");
                if (h === !0) {
                    if (!t.nullish && f >= r.length)
                        throw new Error("Indexing boolean out of range.");
                    l.push(r[f]);
                    continue
                } else if (h === !1)
                    continue;
                let p = h.toInteger();
                if (p < 0 && (p += r.length),
                t.nullish) {
                    l.push(r[p]);
                    continue
                }
                if (p < 0 || p >= r.length)
                    throw new Error("Index out of range.");
                l.push(r[p])
            }
            return typeof r == "string" ? l.join("") : l
        }
        if (!(i instanceof Ce.Interval))
            throw new Error("Array access with a non-integer.");
        let a = i.toInteger();
        if (a < 0 && (a += r.length),
        t.nullish)
            return r[a];
        if (a < 0 || a >= r.length)
            throw new Error("Index out of range.");
        return r[a]
    }
    visitArraySlice(t) {
        const e = this.visit(t.object);
        if (!Array.isArray(e) && typeof e != "string")
            throw new Error("Array slice on non-array.");
        const r = typeof e == "string" ? "" : [];
        if (!e.length)
            return r;
        if (t.start === null && t.second === null && t.penultimate === !1 && t.end === null)
            return typeof e == "string" ? e : [...e];
        let i = 0
          , a = 1;
        const l = t.penultimate;
        let f = -1;
        if (t.start) {
            const h = this.visit(t.start);
            if (!(h instanceof Ce.Interval))
                throw new Error("Slice indices must consist of intervals.");
            i = h.toInteger()
        }
        if (t.end) {
            const h = this.visit(t.end);
            if (!(h instanceof Ce.Interval))
                throw new Error("Slice indices must consist of intervals.");
            f = h.toInteger()
        }
        if (t.second) {
            const h = this.visit(t.second);
            if (!(h instanceof Ce.Interval))
                throw new Error("Slice indices must consist of intervals.");
            a = h.toInteger() - i
        }
        if (i < 0 && (i += e.length),
        f < 0 && (f += e.length),
        a > 0) {
            if (i = Math.max(0, i),
            (l ? i >= f : i > f) || i >= e.length)
                return r;
            f = Math.min(e.length - 1, f);
            const h = [e[i]];
            let p = i + a;
            for (; l ? p < f : p <= f; )
                h.push(e[p]),
                p += a;
            return typeof e == "string" ? h.join("") : h
        } else if (a < 0) {
            if (i = Math.min(e.length - 1, i),
            (l ? i <= f : i < f) || i < 0)
                return r;
            f = Math.max(0, f);
            const h = [e[i]];
            let p = i + a;
            for (; l ? p > f : p >= f; )
                h.push(e[p]),
                p += a;
            return typeof e == "string" ? h.join("") : h
        }
        throw new Error("Slice step must not be zero.")
    }
    unaryOperate(t, e) {
        const r = e.operator;
        if (typeof t == "boolean") {
            if (r === "vnot")
                return !t;
            t = (0,
            yt.upcastBool)(t)
        }
        if (t instanceof Ce.Interval || t instanceof Ce.Val) {
            if (e.uniform) {
                let a, l = 0, f = t instanceof Ce.Interval ? t.node : void 0;
                switch (r) {
                case "-":
                    a = t.value.neg();
                    break;
                case "%":
                case "":
                    a = t.value.inverse(),
                    f = (0,
                    FE.uniformInvertNode)(f),
                    l = t instanceof Ce.Interval ? -t.steps : 0;
                    break;
                case "abs":
                    a = t.value.abs();
                    break;
                case "labs":
                    a = t.value.pitchAbs();
                    break;
                default:
                    throw new Error(`Uniform operation ${r}~ not supported.`)
                }
                if (t.domain === "cologarithmic") {
                    if (a instanceof ln.TimeMonzo)
                        return new Ce.Val(a,t.basis,void 0);
                    throw new Error("Val unary operation failed.")
                }
                return new Ce.Interval(a,t.domain,l,f,t)
            }
            switch (r) {
            case "vnot":
                return !(0,
                yt.sonicTruth)(t);
            case "+":
                return t;
            case "-":
                return t.neg();
            case "%":
            case "":
                return t.inverse();
            case "abs":
                return t.abs();
            case "":
                return t.sqrt()
            }
            if (t instanceof Ce.Val)
                throw new Error(`Unary operation '${r}' not supported on vals.`);
            if (!this.rootContext)
                throw new Error("Root context required.");
            switch (r) {
            case "^":
            case "":
                return t.up(this.rootContext);
            case "":
                return t.down(this.rootContext);
            case "/":
            case "lift":
                return t.lift(this.rootContext);
            case "\\":
            case "drop":
                return t.drop(this.rootContext);
            case "labs":
                return t.pitchAbs()
            }
            throw new Error(`Unexpected unary operation '${r}'.`)
        } else if (t instanceof Ce.ValBasis || t instanceof Ce.Color || t instanceof Ce.Temperament || typeof t == "string" || typeof t == "function" || t === void 0) {
            if (r === "vnot")
                return !(0,
                yt.sonicTruth)(t);
            throw new Error(`Unsupported unary operation '${r}'.`)
        }
        const i = this.unaryOperate.bind(this);
        return yt.unaryBroadcast.bind(this)(t, a => i(a, e))
    }
    visitUnaryExpression(t) {
        const e = this.visit(t.operand);
        return t.operator === "not" ? !(0,
        yt.sonicTruth)(e) : this.unaryOperate(e, t)
    }
    updateArgument(t, e) {
        if (Array.isArray(t)) {
            const r = this.updateArgument.bind(this);
            return t.map(i => r(i, e))
        }
        if (typeof t == "boolean" || t instanceof Ce.Interval) {
            if (t = (0,
            yt.upcastBool)(t),
            t.domain !== "linear")
                throw new Error("Only linear quantities may be incremented or decremented.");
            return t.value instanceof ln.TimeReal && !t.value.timeExponent ? e === "++" ? new Ce.Interval(ln.TimeReal.fromValue(t.value.value + 1),"linear") : new Ce.Interval(ln.TimeReal.fromValue(t.value.value - 1),"linear") : e === "++" ? t.add((0,
            yt.linearOne)()) : t.sub((0,
            yt.linearOne)())
        }
        throw new Error("Only intervals may be incremented or decremented.")
    }
    visitUpdateExpression(t) {
        const e = this.visit(t.argument)
          , r = this.updateArgument(e, t.operator);
        if (t.argument.type === "Identifier")
            this.set(t.argument.id, r);
        else if (t.argument.type === "AccessExpression") {
            const i = this.visit(t.argument.key)
              , a = xl(this.visit(t.argument.object), "Only array elements or record values may be incremented or decremented.");
            if (typeof a == "string")
                throw new Error("Strings are immutable.");
            if (Array.isArray(a))
                if (typeof i == "boolean" || i instanceof Ce.Interval) {
                    const l = (0,
                    yt.upcastBool)(i).toInteger();
                    a[l] = r
                } else
                    throw new Error("Array indices must be intervals.");
            else if (typeof i == "string")
                a[i] = r;
            else
                throw new Error("Record keys must be strings.")
        } else
            throw new Error("Only identifiers, array elements or record values may be incremented or decremented.");
        return r
    }
    tensor(t, e, r) {
        if (typeof t == "boolean" && (t = (0,
        yt.upcastBool)(t)),
        typeof e == "boolean" && (e = (0,
        yt.upcastBool)(e)),
        !(t instanceof Ce.Interval || Array.isArray(t)))
            throw new Error("Can only tensor intervals or arrays.");
        if (t instanceof Ce.Interval) {
            if (!(e instanceof Ce.Interval || Array.isArray(e)))
                throw new Error("Can only tensor intervals or arrays.");
            if (e instanceof Ce.Interval) {
                if (this.spendGas(),
                r.preferLeft || r.preferRight) {
                    const l = t.value.mul(e.value);
                    return VE(l, t, e, r, t.domain === "linear" && e.domain === "linear")
                }
                return t.mul(e)
            }
            const a = this.tensor.bind(this);
            return e.map(l => a(t, l, r))
        }
        const i = this.tensor.bind(this);
        return t.map(a => i(a, e, r))
    }
    binaryOperate(t, e, r) {
        if ((0,
        yt.isArrayOrRecord)(t) || (0,
        yt.isArrayOrRecord)(e)) {
            const a = this.binaryOperate.bind(this);
            return yt.binaryBroadcast.bind(this)(t, e, (l, f) => a(l, f, r))
        }
        const i = r.operator;
        if (i === "vor")
            return (0,
            yt.sonicTruth)(t) ? t : e;
        if (i === "vand")
            return (0,
            yt.sonicTruth)(t) ? e : t;
        if (typeof t == "boolean" && (t = (0,
        yt.upcastBool)(t)),
        typeof e == "boolean" && (e = (0,
        yt.upcastBool)(e)),
        t instanceof Ce.Interval) {
            if (e instanceof Ce.Interval) {
                if (r.preferLeft || r.preferRight) {
                    let a, l = !1, f = 0;
                    switch (i) {
                    case "+":
                        a = t.value.add(e.value);
                        break;
                    case "-":
                        a = t.value.sub(e.value);
                        break;
                    case "max":
                        a = yt.compare.bind(this)(t, e) >= 0 ? t.value : e.value;
                        break;
                    case "min":
                        a = yt.compare.bind(this)(t, e) <= 0 ? t.value : e.value;
                        break;
                    case "to":
                        a = t.value.roundTo(e.value);
                        break;
                    case "by":
                        a = t.value.pitchRoundTo(e.value);
                        break;
                    case "":
                    case "*":
                        a = t.value.mul(e.value),
                        f = t.steps + e.steps,
                        l = t.domain === "linear" && e.domain === "linear";
                        break;
                    case "":
                    case "%":
                    case "/":
                        a = t.value.div(e.value),
                        f = t.steps - e.steps,
                        l = t.domain === "linear" && e.domain === "linear";
                        break;
                    case "rd":
                        a = t.value.reduce(e.value);
                        break;
                    case "rdc":
                        a = t.value.reduce(e.value, !0);
                        break;
                    case "^":
                        a = t.value.pow(e.value),
                        f = Math.round(t.steps * e.valueOf()),
                        l = t.domain === "linear";
                        break;
                    case "/^":
                    case "^/":
                        a = t.value.pow(e.value.inverse()),
                        f = Math.round(t.steps / e.valueOf()),
                        l = t.domain === "linear";
                        break;
                    case "mod":
                        a = t.value.mmod(e.value);
                        break;
                    case "modc":
                        a = t.value.mmod(e.value, !0);
                        break;
                    case "":
                    case "dot":
                        a = t.dot(e).value,
                        l = !0;
                        break;
                    case "/_":
                        a = (0,
                        Ce.log)(t, e),
                        l = !0;
                        break;
                    case "/+":
                    case "":
                        a = t.value.lensAdd(e.value);
                        break;
                    case "/-":
                    case "":
                        a = t.value.lensSub(e.value);
                        break;
                    case "ed":
                        a = t.value.project(e.value);
                        break;
                    case "\\":
                    case "sof":
                        throw new Error("Preference not supported with backslashes.");
                    case "tmpr":
                        throw new Error("Tempering needs an interval and a val.");
                    case "lest":
                    case "al":
                    case "al~":
                    case "or":
                    case "and":
                    case "==":
                    case "<>":
                    case "~=":
                    case "~<>":
                    case "<=":
                    case ">=":
                    case "<":
                    case ">":
                    case "of":
                    case "not of":
                    case "~of":
                    case "not ~of":
                    case "in":
                    case "not in":
                    case "~in":
                    case "not ~in":
                    case " ":
                    case "":
                    case "tns":
                    case "vdot":
                    case "mdot":
                        throw new Error(`${r.preferLeft ? "~" : ""}${r.operator}${r.preferRight ? "~" : ""} unimplemented.`);
                    default:
                        throw new Error(`Unexpected code flow with operator ${i}.`)
                    }
                    const h = VE(a, t, e, r, l);
                    return f && (h.steps = f,
                    h.break()),
                    i === "/_" || i === "dot" || i === "" ? (h.domain = "linear",
                    h.node = void 0) : i === "ed" && (h.domain = "logarithmic",
                    h.node = void 0),
                    h
                }
                switch (i) {
                case "==":
                    return t.strictEquals(e);
                case "<>":
                    return !t.strictEquals(e);
                case "~=":
                    return t.equals(e);
                case "~<>":
                    return !t.equals(e);
                case "<=":
                    return yt.compare.bind(this)(t, e) <= 0;
                case ">=":
                    return yt.compare.bind(this)(t, e) >= 0;
                case "<":
                    return yt.compare.bind(this)(t, e) < 0;
                case ">":
                    return yt.compare.bind(this)(t, e) > 0;
                case "+":
                    return t.add(e);
                case "-":
                    return t.sub(e);
                case "":
                case "*":
                    return t.mul(e);
                case "":
                case "%":
                case "/":
                    return t.div(e);
                case "^":
                    return t.pow(e);
                case "/^":
                case "^/":
                    return t.ipow(e);
                case "/_":
                    return t.log(e);
                case "\\":
                case "sof":
                    return t.backslash(e);
                case "mod":
                    return t.mmod(e);
                case "modc":
                    return t.mmod(e, !0);
                case "":
                case "dot":
                    throw new Error("Dot product between intervals requires a tilde.");
                case "rd":
                    return t.reduce(e);
                case "rdc":
                    return t.reduce(e, !0);
                case "max":
                    return yt.compare.bind(this)(t, e) >= 0 ? t : e;
                case "min":
                    return yt.compare.bind(this)(t, e) <= 0 ? t : e;
                case "to":
                    return t.roundTo(e);
                case "by":
                    return t.pitchRoundTo(e);
                case "/+":
                case "":
                    return t.lensAdd(e);
                case "/-":
                case "":
                    return t.lensSub(e);
                case "ed":
                    return t.project(e);
                case "tmpr":
                    throw new Error("Tempering needs an interval and a val.");
                case "al~":
                    return new Ce.Interval(t.value,e.domain,0,(0,
                    Ce.intervalValueAs)(t.value, e.node, e.domain === "linear"),e);
                case "lest":
                case "al":
                case "or":
                case "and":
                case "of":
                case "not of":
                case "~of":
                case "not ~of":
                case "in":
                case "not in":
                case "~in":
                case "not ~in":
                case "":
                case "tns":
                case " ":
                case "vdot":
                case "mdot":
                    throw new Error("Unexpected code flow.")
                }
            } else if (e instanceof Ce.Val) {
                switch (i) {
                case "":
                case "*":
                    return t.mul(e);
                case "":
                case "dot":
                    if (r.preferLeft || r.preferRight)
                        return t.dot(e);
                    throw new Error("Dot product between a val and an interval must be in the correct order.");
                case "tmpr":
                    if (r.preferLeft) {
                        const a = yt.temper.bind(this)(e, t).value
                          , l = (0,
                        Ce.intervalValueAs)(a, t.node);
                        return new Ce.Interval(a,t.domain,0,l,t)
                    } else if (r.preferRight)
                        throw new Error("Cannot prefer the val operand when tempering.");
                    return yt.temper.bind(this)(e, t)
                }
                throw new Error(`Operator '${i}' not implemented between intervals and vals.`)
            } else if (typeof e == "string") {
                if (i === "*" || i === "")
                    return e.repeat(t.toInteger());
                throw new Error(`Operator '${i}' not implemented between intervals and strings.`)
            } else if (e instanceof Ce.Temperament) {
                if (i === "tmpr") {
                    const a = e.temper(t.value);
                    if (r.preferLeft)
                        return new Ce.Interval(a,t.domain,t.steps,(0,
                        Ce.intervalValueAs)(a, t.node),t);
                    if (r.preferRight)
                        throw new Error("Cannot prefer the temperament operand when tempering.");
                    return new Ce.Interval(a,"logarithmic",t.steps,void 0,t)
                } else if (i === "dot" || i === "") {
                    if (r.preferLeft || r.preferRight)
                        return e.dot(t);
                    throw new Error("Dot product between a temperament and an interval must be in the correct order.")
                }
                throw new Error(`Operator '${i}' not implemented between intervals and temperaments.`)
            }
        } else if (t instanceof Ce.Val) {
            if (e instanceof Ce.Val) {
                switch (i) {
                case "==":
                    return t.strictEquals(e);
                case "<>":
                    return !t.strictEquals(e);
                case "~=":
                    return t.equals(e);
                case "~<>":
                    return !t.equals(e);
                case "+":
                    return t.add(e);
                case "-":
                    return t.sub(e);
                case "":
                case "dot":
                    if (r.preferLeft || r.preferRight)
                        return t.dot(e);
                    throw new Error("Dot product between vals requires a tilde.")
                }
                throw new Error(`Operator '${i}' not implemented between vals.`)
            }
            if (e instanceof Ce.Interval) {
                switch (e = (0,
                yt.upcastBool)(e),
                i) {
                case "":
                case "*":
                    return t.mul(e);
                case "":
                case "%":
                case "/":
                    return t.div(e);
                case "":
                case "dot":
                    return t.dot(e);
                case "tmpr":
                    if (r.preferRight) {
                        const a = yt.temper.bind(this)(t, e).value
                          , l = (0,
                        Ce.intervalValueAs)(a, e.node);
                        return new Ce.Interval(a,e.domain,0,l,e)
                    } else if (r.preferLeft)
                        throw new Error("Cannot prefer the val operand when tempering.");
                    return yt.temper.bind(this)(t, e)
                }
                throw new Error(`Operator '${i}' not implemented between vals and intervals.`)
            }
        } else if (typeof t == "string") {
            if (e instanceof Ce.Interval) {
                if (i === "*" || i === "")
                    return t.repeat(e.toInteger());
                throw new Error(`Operator '${i}' not implemented between strings and intervals.`)
            }
        } else if (t instanceof Ce.Color) {
            if (e instanceof Ce.Color) {
                if (i === "==")
                    return t.strictEquals(e);
                if (i === "<>")
                    return !t.strictEquals(e)
            }
        } else if (t instanceof Ce.ValBasis) {
            if (e instanceof Ce.ValBasis) {
                if (i === "==")
                    return t.strictEquals(e);
                if (i === "<>")
                    return !t.strictEquals(e);
                if (i === "~=")
                    return t.equals(e);
                if (i === "~<>")
                    return !t.equals(e)
            }
        } else if (t instanceof Ce.Temperament) {
            if (e instanceof Ce.Temperament) {
                if (i === "==")
                    return t.strictEquals(e);
                if (i === "<>")
                    return !t.strictEquals(e);
                if (i === "~=")
                    return t.equals(e);
                if (i === "~<>")
                    return !t.equals(e)
            } else if (e instanceof Ce.Interval) {
                if (i === "tmpr") {
                    const a = t.temper(e.value);
                    if (r.preferRight)
                        return new Ce.Interval(a,e.domain,e.steps,(0,
                        Ce.intervalValueAs)(a, e.node),e);
                    if (r.preferLeft)
                        throw new Error("Cannot prefer the temperament operand when tempering.");
                    return new Ce.Interval(a,"logarithmic",e.steps,void 0,e)
                } else if (i === "dot" || i === "")
                    return t.dot(e);
                throw new Error(`Operator '${i}' not implemented between temperaments and intervals.`)
            }
        }
        switch (i) {
        case "==":
            return t === e;
        case "<>":
            return t !== e;
        case "~=":
            return t == e;
        case "~<>":
            return t != e;
        case "<=":
            return t <= e;
        case "<":
            return t < e;
        case ">=":
            return t >= e;
        case ">":
            return t > e;
        case "al~":
            return t ?? e
        }
        throw new Error(`Unsupported binary operation '${i}'.`)
    }
    implicitCall(t, e) {
        switch (typeof t) {
        case "string":
            return this.intrinsicStringCall(t, e);
        case "undefined":
            return this.intrinsicNoneCall(e);
        case "boolean":
            return this.intrinsicIntervalCall((0,
            yt.upcastBool)(t), e);
        case "function":
            return t.bind(this)(e)
        }
        if (typeof e == "function")
            return e.bind(this)(t);
        if (t instanceof Ce.Interval)
            return this.intrinsicIntervalCall(t, e);
        if (t instanceof Ce.Val)
            return this.intrinsicValCall(t, e);
        if (t instanceof Ce.Color)
            return this.intrinsicColorCall(t, e);
        if (t instanceof Ce.ValBasis)
            return this.intrinsicValBasisCall(t, e);
        if (t instanceof Ce.Temperament)
            throw new Error("Temperaments have no intrinsic behavior.");
        const r = this.implicitCall.bind(this);
        return yt.binaryBroadcast.bind(this)(t, e, r)
    }
    intrinsicValBasisCall(t, e) {
        if (typeof e == "boolean" || e instanceof Ce.Interval)
            return e = (0,
            yt.upcastBool)(e),
            t.intrinsicCall(e);
        const r = this.intrinsicValBasisCall.bind(this);
        return yt.unaryBroadcast.bind(this)(e, i => r(t, i))
    }
    intrinsicStringCall(t, e) {
        if (typeof e == "string")
            return t + e;
        if (typeof e == "boolean" || e instanceof Ce.Interval)
            return e = (0,
            yt.upcastBool)(e).shallowClone(),
            e.label = t,
            e;
        const r = this.intrinsicStringCall.bind(this);
        return yt.unaryBroadcast.bind(this)(e, i => r(t, i))
    }
    intrinsicColorCall(t, e) {
        if (typeof e == "boolean" || e instanceof Ce.Interval)
            return e = (0,
            yt.upcastBool)(e).shallowClone(),
            e.color = t,
            e;
        const r = this.intrinsicColorCall.bind(this);
        return yt.unaryBroadcast.bind(this)(e, i => r(t, i))
    }
    intrinsicNoneCall(t) {
        if (typeof t == "boolean" || t instanceof Ce.Interval)
            return t = (0,
            yt.upcastBool)(t).shallowClone(),
            t.color = void 0,
            t;
        const e = this.intrinsicNoneCall.bind(this);
        return yt.unaryBroadcast.bind(this)(t, e)
    }
    intrinsicIntervalCall(t, e) {
        switch (typeof e) {
        case "string":
            return t = t.shallowClone(),
            t.label = e,
            t;
        case "boolean":
            throw new Error("Undefined intrinsic call.");
        case "undefined":
            return t = t.shallowClone(),
            t.color = void 0,
            t
        }
        if (e instanceof Ce.Interval || e instanceof Ce.Val)
            throw new Error("Undefined intrinsic call.");
        if (e instanceof Ce.Color)
            return t = t.shallowClone(),
            t.color = e,
            t;
        if (e instanceof Ce.ValBasis)
            return e.intrinsicCall(t);
        const r = this.intrinsicIntervalCall.bind(this);
        return yt.unaryBroadcast.bind(this)(e, i => r(t, i))
    }
    intrinsicValCall(t, e) {
        if (typeof e == "boolean" || e instanceof Ce.Interval)
            throw new Error("Undefined intrinsic call.");
        if (e instanceof Ce.ValBasis)
            return e.intrinsicCall(t);
        const r = this.intrinsicValCall.bind(this);
        return yt.unaryBroadcast.bind(this)(e, i => r(t, i))
    }
    vectorDot(t, e, r) {
        if (!Array.isArray(t) || !Array.isArray(e))
            throw new Error("Operands must be arrays in vdot.");
        if (t.length > e.length)
            return this.vectorDot(e, t, r);
        if (this.spendGas(t.length),
        Array.isArray(t[0])) {
            const i = this.vectorDot.bind(this);
            return Array.isArray(e[0]) ? t.map( (a, l) => i(a, e[l], r)) : t.map(a => i(a, e, r))
        }
        if (Array.isArray(e[0])) {
            const i = this.vectorDot.bind(this);
            return e.map(a => i(t, a, r))
        }
        if (r.preferLeft || r.preferRight) {
            if (!t.length)
                return (0,
                yt.fromInteger)(0);
            const i = t.map( (a, l) => (0,
            yt.upcastBool)(a).value.mul((0,
            yt.upcastBool)(e[l]).value)).reduce( (a, l) => a.add(l));
            return new Ce.Interval(i,"linear")
        }
        if (!t.length)
            throw new Error("The domain of the empty vdot without preference is ambiguous.");
        return t.map( (i, a) => (0,
        yt.upcastBool)(i).mul((0,
        yt.upcastBool)(e[a]))).reduce( (i, a) => i.add(a))
    }
    matrixDot(t, e, r) {
        if (!Array.isArray(t) || !Array.isArray(e))
            throw new Error("Operands must be arrays of arrays in mdot.");
        if (!Array.isArray(t[0]) || !Array.isArray(e[0]))
            throw new Error("Operands must be arrays of arrays in mdot.");
        const i = t
          , a = e
          , l = this.vectorDot.bind(this)
          , f = []
          , h = a.reduce( (p, m) => Math.max(p, m.length), 0);
        for (let p = 0; p < i.length; ++p) {
            const m = [];
            for (let g = 0; g < h; ++g)
                m.push(l(i[p], a.map(b => b[g]) ?? (0,
                yt.fromInteger)(0), r));
            f.push(m)
        }
        return f
    }
    visitBinaryExpression(t) {
        const e = t.operator;
        if (e === "lest")
            try {
                return this.visit(t.left)
            } catch {
                return this.visit(t.right)
            }
        const r = this.visit(t.left);
        if (e === "al")
            return r !== void 0 ? r : this.visit(t.right);
        if (e === "or")
            return (0,
            yt.sonicTruth)(r) ? r : this.visit(t.right);
        if (e === "and")
            return (0,
            yt.sonicTruth)(r) ? this.visit(t.right) : r;
        let i = this.visit(t.right);
        if (e === " ")
            return this.implicitCall(r, i);
        if (e === "tns" || e === "")
            return this.tensor(r, i, t);
        if (e === "vdot")
            return this.vectorDot(r, i, t);
        if (e === "mdot")
            return this.matrixDot(r, i, t);
        if (e === "of" || e === "not of" || e === "~of" || e === "not ~of")
            switch (i instanceof Ce.ValBasis && (i = i.toArray()),
            i = xl(i, `Target of '${e}' must be an array, record or a string.`),
            typeof i == "string" ? i = [...i] : Array.isArray(i) || (i = Object.values(i)),
            e) {
            case "of":
                return DE(r, i);
            case "not of":
                return !DE(r, i);
            case "~of":
                return qE(r, i);
            case "not ~of":
                return !qE(r, i)
            }
        if (e === "in" || e === "not in" || e === "~in" || e === "not ~in") {
            if (i instanceof Ce.ValBasis && (i = i.toArray()),
            i = xl(i, `Target of '${e}' must be an array, record or a string.`),
            Array.isArray(i) || typeof i == "string") {
                if (!(r instanceof Ce.Interval && r.value.isIntegral()))
                    throw new Error("Can only test for integer keys.");
                const a = r.toInteger();
                switch (e) {
                case "in":
                    return a >= 0 && a < i.length;
                case "not in":
                    return a < 0 || a >= i.length;
                case "~in":
                    return a >= -i.length && a < i.length;
                case "not ~in":
                    return a < -i.length || a > i.length
                }
            }
            if (typeof r != "string")
                throw new Error("Can only test for string keys in records.");
            return e === "in" || e === "~in" ? (0,
            Sn.hasOwn)(i, r) : !(0,
            Sn.hasOwn)(i, r)
        }
        return this.binaryOperate(r, i, t)
    }
    visitCallExpression(t) {
        const e = this.spread(t.args);
        let r;
        if (t.callee.type === "Identifier" ? r = this.get(t.callee.id) : r = this.visit(t.callee),
        typeof r == "function")
            return r.bind(this)(...e);
        if (e.length !== 1)
            throw new Error("Intrinsic calls require exactly one argument.");
        return this.implicitCall(r, e[0])
    }
    visitArrowFunction(t) {
        const e = this.parent.createExpressionVisitor();
        function r(...i) {
            e.localAssign(t.parameters, i);
            const a = e.visit(t.expression);
            return e.mutables.clear(),
            a
        }
        return Object.defineProperty(r, "name", {
            value: "(lambda)",
            enumerable: !1
        }),
        r.__doc__ = void 0,
        r.__node__ = t,
        r
    }
    visitIntegerLiteral(t) {
        try {
            const e = ln.TimeMonzo.fromBigInt(t.value);
            return new Ce.Interval(e,"linear",0,t)
        } catch {
            const e = ln.TimeReal.fromValue(Number(t.value));
            return new Ce.Interval(e,"linear")
        }
    }
    visitDecimalLiteral(t) {
        if (t.flavor === "r") {
            const a = ln.TimeReal.fromValue(parseFloat(`${t.sign}${t.whole}.${t.fractional}e${t.exponent ?? "0"}`));
            return new Ce.Interval(a,"linear",0,t)
        }
        let e = t.whole
          , r = 1n;
        const i = BigInt(t.exponent || 0);
        i > 0 ? e *= 10n ** i : i < 0 && (r *= 10n ** -i);
        for (const a of t.fractional)
            e = 10n * e + BigInt(a),
            r *= 10n;
        try {
            const a = ln.TimeMonzo.fromBigNumeratorDenominator(e, r);
            return t.flavor === "z" && (a.timeExponent = Sn.NEGATIVE_ONE),
            new Ce.Interval(a,"linear",0,t)
        } catch {
            const a = ln.TimeReal.fromValue(parseFloat(`${t.sign}${t.whole}.${t.fractional}e${t.exponent ?? "0"}`));
            return t.flavor === "z" && (a.timeExponent = -1),
            new Ce.Interval(a,"linear")
        }
    }
    visitCentsLiteral(t) {
        if (t.real)
            throw new Error("Unexpected real cents.");
        let e = t.whole
          , r = 1200n;
        for (const f of t.fractional)
            e = 10n * e + BigInt(f),
            r *= 10n;
        const i = BigInt(t.exponent || 0);
        i > 0 ? e *= 10n ** i : i < 0 && (r *= 10n ** -i);
        const a = (0,
        bl.gcd)(e, r);
        e = Number(e / a),
        r = Number(r / a);
        let l;
        try {
            l = new ln.TimeMonzo(Sn.ZERO,[new bl.Fraction(e,r)])
        } catch {
            l = ln.TimeReal.fromCents(1200 * e / r),
            t = {
                ...t
            },
            t.real = !0
        }
        return new Ce.Interval(l,"logarithmic",0,t)
    }
    visitFractionLiteral(t) {
        try {
            const e = ln.TimeMonzo.fromBigNumeratorDenominator(t.numerator, t.denominator);
            return new Ce.Interval(e,"linear",0,t)
        } catch {
            const e = ln.TimeReal.fromValue(Number(t.numerator) / Number(t.denominator));
            return new Ce.Interval(e,"linear")
        }
    }
    visitNedjiLiteral(t) {
        try {
            let e;
            const r = new bl.Fraction(t.numerator,t.denominator);
            return t.equaveNumerator !== null ? e = ln.TimeMonzo.fromEqualTemperament(r, new bl.Fraction(t.equaveNumerator,t.equaveDenominator ?? void 0)) : e = ln.TimeMonzo.fromEqualTemperament(r),
            new Ce.Interval(e,"logarithmic",0,t)
        } catch {
            const e = (t.equaveNumerator ?? 2) / (t.equaveDenominator ?? 1)
              , r = ln.TimeReal.fromValue(e ** (t.numerator / t.denominator));
            return new Ce.Interval(r,"logarithmic")
        }
    }
    visitHertzLiteral(t) {
        let e;
        return t.prefix.endsWith("i") ? e = kE.pow((0,
        Sn.binaryExponent)(t.prefix)) : e = BE.pow((0,
        Sn.metricExponent)(t.prefix)),
        e.timeExponent = Sn.NEGATIVE_ONE,
        new Ce.Interval(e,"linear",0,t)
    }
    visitSecondLiteral(t) {
        let e;
        return t.prefix.endsWith("i") ? e = kE.pow((0,
        Sn.binaryExponent)(t.prefix)) : e = BE.pow((0,
        Sn.metricExponent)(t.prefix)),
        e.timeExponent = Sn.ONE,
        new Ce.Interval(e,"linear",0,t)
    }
    visitIdentifier(t) {
        return this.get(t.id)
    }
    visitEnumeratedChord(t) {
        const e = []
          , r = []
          , i = [];
        for (const p of t.enumerals)
            if (p.type === "HarmonicSegment") {
                const m = this.visitHarmonicSegment(p, !0);
                for (const g of m)
                    e.push(g),
                    i.push(g.value),
                    r.push(g.domain)
            } else {
                let m = this.visit(p);
                if (typeof m == "boolean" && (m = (0,
                yt.upcastBool)(m)),
                m instanceof Ce.Interval)
                    e.push(m),
                    i.push(m.value),
                    r.push(m.domain);
                else
                    throw new Error("Type error: Can only stack intervals in a chord.")
            }
        const a = e.shift()
          , l = r.shift()
          , f = i.shift()
          , h = [];
        for (let p = 0; p < i.length; ++p)
            if (l === "linear" && r[p] === "linear")
                h.push(t.mirror ? e[p].ldiv(a) : e[p].div(a));
            else if (pS(e[p].node, a.node))
                h.push(t.mirror ? e[p].lsub(a) : e[p].sub(a));
            else {
                const m = e[p].steps - a.steps;
                h.push(new Ce.Interval(t.mirror ? f.div(i[p]) : i[p].div(f),r[p],t.mirror ? -m : m,void 0,(0,
                Ce.infect)(e[p], a)))
            }
        return h
    }
    visitRange(t) {
        const e = this.visit(t.start)
          , r = this.visit(t.end)
          , i = t.penultimate;
        if (!(e instanceof Ce.Interval && r instanceof Ce.Interval))
            throw new Error("Ranges must consist of intervals.");
        let a = (0,
        yt.linearOne)();
        if (t.second) {
            const f = this.visit(t.second);
            if (!(f instanceof Ce.Interval))
                throw new Error("Ranges must consist of intervals.");
            a = f.sub(e)
        }
        const l = a.valueOf();
        if (l && this.spendGas(Math.abs((r.valueOf() - e.valueOf()) / l)),
        l > 0) {
            if (i ? e.compare(r) >= 0 : e.compare(r) > 0)
                return [];
            const f = [e];
            let h = e.add(a);
            for (; i ? h.compare(r) < 0 : h.compare(r) <= 0; )
                f.push(h),
                h = h.add(a);
            return f
        } else if (l < 0) {
            if (i ? e.compare(r) <= 0 : e.compare(r) < 0)
                return [];
            const f = [e];
            let h = e.add(a);
            for (; i ? h.compare(r) > 0 : h.compare(r) >= 0; )
                f.push(h),
                h = h.add(a);
            return f
        }
        throw new Error("Range step must not be zero.")
    }
    visitHarmonicSegment(t, e=!1) {
        let r = this.visit(t.root)
          , i = this.visit(t.end);
        if (typeof r == "boolean" && (r = (0,
        yt.upcastBool)(r)),
        typeof i == "boolean" && (i = (0,
        yt.upcastBool)(i)),
        !(r instanceof Ce.Interval && i instanceof Ce.Interval))
            throw new Error("Harmonic segments must be built from intervals.");
        this.spendGas(Math.abs(i.valueOf() - r.valueOf()));
        const a = (0,
        yt.linearOne)()
          , l = [];
        let f = r;
        if (r.compare(i) <= 0)
            for (; f.compare(i) <= 0; )
                l.push(f),
                f = f.add(a);
        else
            for (; f.compare(i) >= 0; )
                l.push(f),
                f = f.sub(a);
        return e ? l : l.slice(1).map(h => h.div(r))
    }
    get(t) {
        return this.mutables.has(t) ? this.mutables.get(t) : this.parent.get(t)
    }
    set(t, e) {
        this.mutables.has(t) && this.mutables.set(t, e),
        this.parent.set(t, e)
    }
}
Xi.ExpressionVisitor = iz;
var km = {};
Object.defineProperty(km, "__esModule", {
    value: !0
});
km.Tardigrade = void 0;
const Bu = Ie
  , pi = An
  , UE = Ms
  , oz = hn
  , Xp = vr
  , Od = new pi.TimeMonzo(Xp.ZERO,[Xp.ONE]);
function az(n, t, e) {
    return t.pow(n[0]).mul(e.pow(n[1]))
}
class lz {
    constructor(t) {
        this.subVisitor = t
    }
    spendGas(t) {
        this.subVisitor.spendGas(t)
    }
    createMosConfig() {
        if (!this.pattern)
            throw new Error("Mode must be given in MOS declaration.");
        this.spendGas(this.pattern.length);
        const t = (0,
        UE.generateNotation)(this.pattern)
          , e = new Bu.Fraction(this.pattern.length)
          , r = new Bu.Fraction((this.pattern.match(/L/g) ?? []).length)
          , i = e.sub(r);
        let a, l;
        if (this.equave)
            this.hardness ? this.hardness.valueOf() === 1 / 0 ? (a = this.equave.pow(0),
            l = this.equave.pow(r.inverse())) : (a = this.equave.pow(pi.TimeMonzo.fromFraction(r).mul(this.hardness).add(pi.TimeMonzo.fromFraction(i)).inverse()),
            l = a.pow(this.hardness)) : this.large ? (l = this.large,
            a = this.equave.div(l.pow(r)).pow(i.inverse())) : this.small ? (a = this.small,
            l = this.equave.div(a.pow(i)).pow(r.inverse())) : (a = this.equave.pow(r.mul(Xp.TWO).add(i).inverse()),
            l = a.pow(Xp.TWO));
        else if (this.hardness)
            if (this.hardness.valueOf() === 1 / 0) {
                if (this.large)
                    l = this.large;
                else {
                    if (this.small)
                        throw new Error("Small step may not be given with infinite hardness.");
                    l = Od.pow(r.inverse())
                }
                a = l.pow(0)
            } else
                this.large ? (l = this.large,
                a = l.pow(this.hardness.inverse())) : this.small ? (a = this.small,
                l = a.pow(this.hardness)) : (a = Od.pow(pi.TimeMonzo.fromFraction(r).mul(this.hardness).add(pi.TimeMonzo.fromFraction(i)).inverse()),
                l = a.pow(this.hardness));
        else if (this.large)
            l = this.large,
            this.small ? a = this.small : a = Od.div(l.pow(r)).pow(i.inverse());
        else if (this.small)
            a = this.small,
            l = Od.div(a.pow(i)).pow(r.inverse());
        else {
            const b = r.mul(2).add(i);
            a = pi.TimeMonzo.fromEqualTemperament(b.inverse()),
            l = pi.TimeMonzo.fromEqualTemperament(b.inverse().mul(2))
        }
        if (this.small && !this.small.equals(a))
            throw new Error("Inconsistent MOS declaration.");
        if (this.large && !this.large.equals(l))
            throw new Error("Inconsistent MOS declaration.");
        const f = l.div(a)
          , h = f.sqrt()
          , p = b => az(b, l, a)
          , m = t.scale;
        for (const [b,E] of t.scale)
            m.set(b, p(E));
        const g = [];
        for (const b of t.degrees)
            g.push({
                imperfect: !b.perfect,
                center: p(b.center),
                mid: b.mid ? p(b.mid) : void 0
            });
        return {
            am: f,
            semiam: h,
            equave: p(t.equave),
            period: p(t.period),
            scale: m,
            degrees: g,
            pattern: this.pattern,
            large: l,
            small: a
        }
    }
    visit(t) {
        switch (this.spendGas(),
        t.type) {
        case "AbstractStepPattern":
            return this.visitAbstractStepPattern(t);
        case "IntegerPattern":
            return this.visitIntegerPattern(t);
        case "PatternUpDownPeriod":
            return this.visitPatternUpDownPeriod(t);
        case "HardnessDeclaration":
        case "LargeDeclaration":
        case "SmallDeclaration":
        case "EquaveDeclaration":
            return this.visitDeclaration(t)
        }
    }
    visitRationalEquave(t) {
        return pi.TimeMonzo.fromFraction(new Bu.Fraction(t.numerator,t.denominator))
    }
    visitAbstractStepPattern(t) {
        this.spendGas(t.pattern.length),
        this.pattern = t.pattern.join(""),
        t.equave && (this.equave = this.visitRationalEquave(t.equave))
    }
    visitIntegerPattern(t) {
        this.spendGas(t.pattern.length);
        const e = Math.min(...t.pattern)
          , r = Math.max(...t.pattern);
        this.pattern = t.pattern.map(i => i === e ? "s" : "L").join(""),
        e ? this.hardness = pi.TimeMonzo.fromFraction(new Bu.Fraction(r,e)) : this.hardness = pi.TimeReal.fromValue(1 / 0),
        t.equave && (this.equave = this.visitRationalEquave(t.equave))
    }
    visitPatternUpDownPeriod(t) {
        this.spendGas(Math.abs(t.countLarge) + Math.abs(t.countSmall));
        const e = {};
        if (t.udp && (e.up = t.udp.up,
        e.down = t.udp.down,
        t.udp.period !== null && t.udp.period !== (0,
        Bu.gcd)(t.countLarge, t.countSmall)))
            throw new Error("Period must be consistent with counts if given.");
        this.pattern = (0,
        UE.stepString)(t.countLarge, t.countSmall, e),
        t.equave && (this.equave = this.visitRationalEquave(t.equave))
    }
    visitDeclaration(t) {
        const e = this.subVisitor.visit(t.value);
        if (!(e instanceof oz.Interval))
            throw new Error(`${t.type} must evaluate to an interval.`);
        if (t.type === "HardnessDeclaration" && e.valueOf() === 1 / 0)
            return this.hardness = e.value;
        switch (t.type) {
        case "HardnessDeclaration":
            return this.hardness = e.value;
        case "LargeDeclaration":
            return this.large = e.value;
        case "SmallDeclaration":
            return this.small = e.value;
        case "EquaveDeclaration":
            return this.equave = e.value
        }
    }
}
km.Tardigrade = lz;
Object.defineProperty(Oi, "__esModule", {
    value: !0
});
Oi.StatementVisitor = Oi.MODULE_DOCSTRING = Oi.Interrupt = void 0;
const Pn = hn
  , Nd = An
  , Hi = Df
  , ku = Xi
  , uz = km
  , cz = vr;
class Qd {
    constructor(t, e) {
        this.node = t,
        this.value = e
    }
    get type() {
        return this.node.type
    }
}
Oi.Interrupt = Qd;
Oi.MODULE_DOCSTRING = Symbol();
class vi {
    constructor(t) {
        this.parent = t,
        this.mutables = new Map,
        this.mutables.set("$", []),
        this.immutables = new Map,
        this.isUserRoot = !1,
        this.deferred = [],
        this.exports = new Map,
        this.modules = new Map,
        this.imported = new Set
    }
    get rootContext() {
        return this.parent ? this.parent.rootContext : this.rootContext_
    }
    set rootContext(t) {
        this.parent && (this.parent.rootContext = t),
        this.rootContext_ = t
    }
    spendGas(t) {
        const e = this.rootContext;
        e && e.spendGas(t)
    }
    clone() {
        const t = new vi;
        t.rootContext = this.rootContext,
        t.mutables = new Map(this.mutables),
        t.immutables = new Map(this.immutables);
        const e = this.currentScale;
        return t.mutables.set("$", [...e]),
        t.isUserRoot = this.isUserRoot,
        t
    }
    createExpressionVisitor(t=!1) {
        return t ? new ku.ExpressionVisitor(this,this.mutables) : new ku.ExpressionVisitor(this)
    }
    _createStatementVisitor(t) {
        return new vi(t)
    }
    expand(t) {
        if (!this.isUserRoot)
            throw new Error("Only the user root scope may be expanded.");
        if (!this.rootContext)
            throw new Error("Root context must be present during expansion.");
        let e = this.rootContext.expand(t);
        e && (e += `
`);
        const r = []
          , i = Hi.repr.bind(this.createExpressionVisitor());
        for (const f of this.mutables.keys()) {
            if (f === "$" || f === "$$")
                continue;
            const h = i(this.mutables.get(f));
            if (h.startsWith("riff") || h.startsWith("fn")) {
                const p = this.mutables.get(f).name;
                r.push(`let ${f} = ${p}`)
            } else
                r.push(`let ${f} = ${h}`)
        }
        for (const f of this.immutables.keys()) {
            if (this.imported.has(f))
                continue;
            const h = i(this.immutables.get(f));
            if (h.startsWith("riff") || h.startsWith("fn"))
                if (h.includes("[native riff]")) {
                    const p = this.immutables.get(f).name;
                    r.push(`const ${f} = ${p}`)
                } else
                    r.push(h);
            else
                r.push(`const ${f} = ${h}`)
        }
        r.length && (e += r.join(`
`) + `
`);
        const l = this.currentScale.map(f => f.toString(this.rootContext));
        for (let f = 0; f < l.length; ++f)
            l[f].startsWith("(") && l[f].endsWith(")") && (l[f] = l[f].slice(1, -1));
        return `${e}${l.join(`
`)}`
    }
    visit(t) {
        switch (this.spendGas(),
        t.type) {
        case "VariableDeclaration":
            return this.visitVariableDeclaration(t);
        case "AssignmentStatement":
            return this.visitAssignmentStatement(t);
        case "ExpressionStatement":
            return this.visitExpression(t);
        case "FunctionDeclaration":
            return this.visitFunctionDeclaration(t);
        case "PitchDeclaration":
            return this.visitPitchDeclaration(t);
        case "UpDeclaration":
            return this.visitUpDeclaration(t);
        case "LiftDeclaration":
            return this.visitLiftDeclaration(t);
        case "BlockStatement":
            return this.visitBlockStatement(t);
        case "WhileStatement":
            return this.visitWhileStatement(t);
        case "IfStatement":
            return this.visitIfStatement(t);
        case "IterationStatement":
            return this.visitIterationStatement(t);
        case "TryStatement":
            return this.visitTryStatement(t);
        case "ReturnStatement":
            return this.visitReturnStatement(t);
        case "BreakStatement":
            return this.visitBreakStatement(t);
        case "ContinueStatement":
            return this.visitContinueStatement(t);
        case "ThrowStatement":
            throw this.visitThrowStatement(t);
        case "DeferStatement":
            return this.visitDeferStatement(t);
        case "ModuleDeclaration":
            return this.visitModuleDeclaration(t);
        case "ExportConstantStatement":
            return this.visitExportConstantStatement(t);
        case "ExportFunctionStatement":
            return this.visitExportFunctionStatement(t);
        case "ExportAllStatement":
            return this.visitExportAllStatement(t);
        case "ImportStatement":
            return this.visitImportStatement(t);
        case "ImportAllStatement":
            return this.visitImportAllStatement(t);
        case "MosDeclaration":
            return this.visitMosDeclaration(t);
        case "DeleteStatement":
            return this.visitDeleteStatement(t);
        case "EmptyStatement":
            return
        }
    }
    visitDeleteStatement(t) {
        const e = this.createExpressionVisitor()
          , r = t.entry
          , i = (0,
        ku.arrayRecordOrString)(e.visit(r.object));
        if (typeof i == "string")
            throw new Error("Strings are immutable.");
        if (r.type === "AccessExpression") {
            if (!Array.isArray(i)) {
                const b = e.visit(r.key);
                if (typeof b != "string")
                    throw new Error("Record keys must be strings.");
                if (!(0,
                cz.hasOwn)(i, b) && !r.nullish)
                    throw new Error(`Key error: "${b}".`);
                delete i[b];
                return
            }
            let m = e.visit(r.key);
            if (Array.isArray(m)) {
                const b = new Set;
                m = m.flat(1 / 0);
                for (let E = 0; E < m.length; ++E) {
                    const S = m[E];
                    if (!(typeof S == "boolean" || S instanceof Pn.Interval))
                        throw new Error("Only booleans and intervals can be used as indices.");
                    if (S === !0) {
                        if (E >= i.length) {
                            if (!r.nullish)
                                throw new Error("Indexing boolean out of range.")
                        } else
                            b.add(E);
                        continue
                    } else if (S === !1)
                        continue;
                    let F = S.toInteger();
                    if (F < 0 && (F += i.length),
                    F < 0 || F >= i.length) {
                        if (!r.nullish)
                            throw new Error("Index out of range.")
                    } else
                        b.add(F)
                }
                for (const E of Array.from(b).sort( (S, F) => F - S))
                    i.splice(E, 1);
                return
            }
            if (!(m instanceof Pn.Interval))
                throw new Error("Array delete access with a non-integer.");
            let g = m.toInteger();
            if (g < 0 && (g += i.length),
            g < 0 || g >= i.length) {
                if (r.nullish)
                    return;
                throw new Error("Index out of range.")
            }
            i.splice(g, 1);
            return
        }
        if (r.type,
        !Array.isArray(i))
            throw new Error("Array slice delete on non-array.");
        if (r.start === null && r.second === null && r.penultimate === !1 && r.end === null) {
            i.length = 0;
            return
        }
        let a = 0
          , l = 1;
        const f = r.penultimate;
        let h = -1;
        if (r.start) {
            const m = e.visit(r.start);
            if (!(m instanceof Pn.Interval))
                throw new Error("Slice indices must consist of intervals.");
            a = m.toInteger()
        }
        if (r.end) {
            const m = e.visit(r.end);
            if (!(m instanceof Pn.Interval))
                throw new Error("Slice indices must consist of intervals.");
            h = m.toInteger()
        }
        if (r.second) {
            const m = e.visit(r.second);
            if (!(m instanceof Pn.Interval))
                throw new Error("Slice indices must consist of intervals.");
            l = m.toInteger() - a
        }
        a < 0 && (a += i.length),
        h < 0 && (h += i.length);
        const p = new Set;
        if (l > 0) {
            if (a = Math.max(0, a),
            (f ? a >= h : a > h) || a >= i.length)
                return;
            h = Math.min(i.length - 1, h),
            p.add(a);
            let m = a + l;
            for (; f ? m < h : m <= h; )
                p.add(m),
                m += l
        } else if (l < 0) {
            if (a = Math.min(i.length - 1, a),
            (f ? a <= h : a < h) || a < 0)
                return;
            h = Math.max(0, h),
            p.add(a);
            let m = a + l;
            for (; f ? m > h : m >= h; )
                p.add(m),
                m += l
        } else
            throw new Error("Slice step must not be zero.");
        for (const m of Array.from(p).sort( (g, b) => b - g))
            i.splice(m, 1)
    }
    visitMosDeclaration(t) {
        if (!this.rootContext)
            throw new Error("Root context is required.");
        if (!t.body.length) {
            this.rootContext.mosConfig = void 0;
            return
        }
        const e = this.createExpressionVisitor()
          , r = new uz.Tardigrade(e);
        for (const i of t.body)
            r.visit(i);
        this.rootContext.mosConfig = r.createMosConfig()
    }
    visitModuleDeclaration(t) {
        const e = new vi(this.parent)
          , r = [...t.body];
        let i = "";
        r.length && r[0].type === "ExpressionStatement" && r[0].expression.type === "StringLiteral" && (i = r[0].expression.value,
        r.shift());
        const a = e.executeStatements(r);
        if (a)
            throw new Error(`Illegal ${a.type}.`);
        const l = e.exports;
        l.set(l.MODULE_DOCSTRING, i),
        this.modules.set(t.name, l)
    }
    visitExportConstantStatement(t) {
        const e = t.parameter.id;
        if (this.immutables.has(e) || this.mutables.has(e))
            throw new Error(`Name ${e} already exists in current scope.`);
        if (this.exports.has(e))
            throw new Error(`Cannot re-export ${e}.`);
        if (!t.parameter.defaultValue)
            throw new Error("An exported value is required.");
        const i = this.createExpressionVisitor().visit(t.parameter.defaultValue);
        this.exports.set(e, i),
        this.immutables.set(e, i)
    }
    visitExportFunctionStatement(t) {
        const e = t.name.id;
        if (this.immutables.has(e) || this.mutables.has(e))
            throw new Error(`Name ${e} already exists in current scope.`);
        if (this.exports.has(e))
            throw new Error(`Cannot re-export ${e}.`);
        const r = this.realizeFunction(t);
        this.exports.set(t.name.id, r),
        this.immutables.set(e, r)
    }
    getModule(t) {
        if (this.modules.has(t))
            return this.modules.get(t);
        if (this.parent && this.parent instanceof vi)
            return this.parent.getModule(t);
        throw new Error(`Module ${t} not found.`)
    }
    visitExportAllStatement(t) {
        const e = this.getModule(t.module);
        for (const [r,i] of e)
            if (r !== e.MODULE_DOCSTRING) {
                if (this.exports.has(r))
                    throw new Error(`Export * would overwrite ${r}.`);
                this.exports.set(r, i)
            }
    }
    visitImportStatement(t) {
        const e = this.getModule(t.module);
        for (const r of t.elements) {
            const i = r.alias ?? r.id;
            if (this.immutables.has(i))
                throw new Error(`Name ${i} is already in use.`);
            if (!e.has(r.id))
                throw new Error(`Module does not export name ${r.id}.`);
            const a = e.get(r.id);
            this.immutables.set(i, a),
            this.imported.add(i)
        }
    }
    visitImportAllStatement(t) {
        const e = this.getModule(t.module);
        for (const [r,i] of e)
            if (r !== e.MODULE_DOCSTRING) {
                if (this.immutables.has(r))
                    throw new Error(`Import * would overwrite ${r}.`);
                this.immutables.set(r, i),
                this.imported.add(r)
            }
    }
    visitDeferStatement(t) {
        this.deferred.push(t.body)
    }
    visitReturnStatement(t) {
        let e;
        return t.argument && (e = this.createExpressionVisitor().visit(t.argument)),
        new Qd(t,e)
    }
    visitBreakStatement(t) {
        return new Qd(t)
    }
    visitContinueStatement(t) {
        return new Qd(t)
    }
    visitThrowStatement(t) {
        const r = this.createExpressionVisitor().visit(t.argument);
        throw typeof r == "string" ? new Error(r) : r
    }
    declareVariable(t, e, r, i) {
        if (arguments.length < 4) {
            if (e.defaultValue !== null)
                i = t.visit(e.defaultValue);
            else if (e.type === "Parameter" && !r)
                throw new Error("Missing declared value.")
        }
        if (e.type === "Parameters")
            if (i instanceof Pn.ValBasis && (i = i.toArray()),
            Array.isArray(i)) {
                for (let a = 0; a < e.parameters.length; ++a)
                    a < i.length ? this.declareVariable(t, e.parameters[a], r, i[a]) : this.declareVariable(t, e.parameters[a], r);
                e.rest && this.declareVariable(t, e.rest, r, i.slice(e.parameters.length))
            } else
                for (let a = 0; a < e.parameters.length; ++a)
                    this.declareVariable(t, e.parameters[a], r);
        else {
            const a = e.id;
            if (this.immutables.has(a) || this.mutables.has(a))
                throw new Error("Cannot redeclare variable.");
            r ? this.mutables.set(a, i) : this.immutables.set(a, i)
        }
    }
    visitVariableDeclaration(t) {
        const e = this.createExpressionVisitor();
        this.declareVariable(e, t.parameters, t.mutable)
    }
    assign(t, e) {
        if (t.type === "Identifiers") {
            if (!Array.isArray(e))
                throw new Error("Destructuring assignment must use an array.");
            for (let r = 0; r < t.identifiers.length; ++r)
                this.assign(t.identifiers[r], e[r]);
            t.rest && this.assign(t.rest, e.slice(t.identifiers.length))
        } else {
            const r = t.id;
            if (this.immutables.has(r))
                throw new Error("Assignment to a constant variable.");
            this.set(r, e)
        }
    }
    visitAssignmentStatement(t) {
        const e = this.createExpressionVisitor()
          , r = e.visit(t.value);
        if (t.name.type === "ArraySlice") {
            if (!Array.isArray(r))
                throw new Error("Slice assignment with a non-array.");
            const i = e.visit(t.name.object);
            if (!Array.isArray(i))
                throw new Error("Array slice on non-array.");
            let a = 0
              , l = 1
              , f = i.length - 1;
            if (t.name.start) {
                const p = e.visit(t.name.start);
                if (!(p instanceof Pn.Interval))
                    throw new Error("Slice indices must consist of intervals.");
                a = Number(p.value.toBigInteger())
            }
            if (t.name.end) {
                const p = e.visit(t.name.end);
                if (!(p instanceof Pn.Interval))
                    throw new Error("Slice indices must consist of intervals.");
                f = Number(p.value.toBigInteger())
            }
            if (t.name.second) {
                const p = e.visit(t.name.second);
                if (!(p instanceof Pn.Interval))
                    throw new Error("Slice indices must consist of intervals.");
                l = Number(p.value.toBigInteger()) - a
            }
            let h = 0;
            if (l > 0) {
                if (a > f)
                    throw new Error("Invalid slice assignment.");
                i[a] = r[h++] ?? null;
                let p = a + l;
                for (; p <= f; )
                    i[p] = r[h++] ?? null,
                    p += l;
                i.splice(f, 0, ...r.slice(h)),
                i.splice(0, i.length, ...i.filter(m => m !== void 0).map(m => m === null ? void 0 : m));
                return
            } else if (l < 0) {
                if (a < f)
                    throw new Error("Invalid slice assignment.");
                i[a] = r[h++] ?? null;
                let p = a + l;
                for (; p >= f; )
                    i[p] = r[h++] ?? null,
                    p += l;
                const m = r.slice(h);
                m.reverse(),
                i.splice(f, 0, ...m),
                i.splice(0, i.length, ...i.filter(g => g !== void 0).map(g => g === null ? void 0 : g));
                return
            }
            throw new Error("Slice step must not be zero.")
        } else if (t.name.type === "AccessExpression") {
            const i = (0,
            ku.arrayRecordOrString)(e.visit(t.name.object), "Can only assign elements of arrays or records.");
            if (typeof i == "string")
                throw new Error("Strings are immutable.");
            if (Array.isArray(i)) {
                const l = e.visit(t.name.key);
                if (Array.isArray(l)) {
                    if (!Array.isArray(r))
                        throw new Error("Unrecoverable error in array assignment.");
                    let h = 0;
                    for (let p = 0; p < l.length; ++p) {
                        const m = l[p];
                        if (!(typeof m == "boolean" || m instanceof Pn.Interval))
                            throw new Error("Only booleans and intervals can be used as indices.");
                        if (m === !0) {
                            i[p] = r[h++];
                            continue
                        } else if (m === !1)
                            continue;
                        let g = m.toInteger();
                        g < 0 && (g += i.length),
                        i[g] = r[h++]
                    }
                    return
                }
                if (!(l instanceof Pn.Interval))
                    throw new Error("Array access with a non-integer.");
                let f = l.toInteger();
                f < 0 && (f += i.length),
                i[f] = r;
                return
            }
            const a = e.visit(t.name.key);
            if (typeof a != "string")
                throw new Error("Record keys must be strings.");
            i[a] = r
        } else
            this.assign(t.name, r)
    }
    freezeScale() {
        const t = Hi.absolute.bind(this.createExpressionVisitor())
          , e = this.currentScale
          , r = e.map(i => t(i));
        e.length = 0,
        e.push(...r)
    }
    visitPitchDeclaration(t) {
        var f;
        if (!this.rootContext)
            throw new Error("Root context required for pitch declaration.");
        if (((f = t.middle) == null ? void 0 : f.type) === "AbsoluteFJS" || t.right.type === "AbsoluteFJS")
            throw new Error("Declared pitch must be on the left.");
        const e = this.createExpressionVisitor();
        if (t.left.type === "AbsoluteFJS") {
            const h = e.visit(t.middle ?? t.right);
            if (!(h instanceof Pn.Interval))
                throw new Error("Pitch declaration must evaluate to an interval.");
            const p = e.visit(t.left)
              , g = this.rootContext.C4.mul(h.value).div(p.value);
            if (g instanceof Nd.TimeReal)
                throw new Error("Cannot declare a non-algebraic pitch.");
            if (this.rootContext.C4 = g,
            this.rootContext.C4.timeExponent.n && (this.rootContext.C4 = this.rootContext.C4.pow(this.rootContext.C4.timeExponent.inverse().neg())),
            !t.middle) {
                if (h.value instanceof Nd.TimeReal)
                    throw new Error("Cannot declare non-algebraic unison.");
                if (h.value.timeExponent.n) {
                    this.freezeScale();
                    const b = h.value;
                    this.rootContext.unisonFrequency = b.pow(b.timeExponent.inverse().neg())
                }
                return
            }
        }
        const r = e.visit(t.middle ?? t.left)
          , i = e.visit(t.right);
        if (!(r instanceof Pn.Interval && i instanceof Pn.Interval))
            throw new Error("Pitch declaration must evaluate to an interval.");
        if (r.value instanceof Nd.TimeReal)
            throw new Error("Cannot declare non-algebraic pitch.");
        if (i.value instanceof Nd.TimeReal)
            throw new Error("Cannot declare non-algebraic reference frequency.");
        let a, l;
        if (r.value.timeExponent.n) {
            if (a = r.value,
            i.value.timeExponent.n)
                throw new Error("Cannot assign absolute pitch to absolute pitch.");
            l = i.value
        } else {
            if (!i.value.timeExponent.n)
                throw new Error("Cannot assign relative pitch to relative pitch.");
            a = i.value,
            l = r.value
        }
        this.freezeScale(),
        this.rootContext.unisonFrequency = a.pow(a.timeExponent.inverse().neg()).div(l)
    }
    visitUpDeclaration(t) {
        if (!this.rootContext)
            throw new Error("Root context required for up declaration.");
        const r = this.createExpressionVisitor().visit(t.value);
        if (!(r instanceof Pn.Interval))
            throw new Error("Up declaration must evaluate to an interval.");
        this.rootContext.up = r.shallowClone()
    }
    visitLiftDeclaration(t) {
        if (!this.rootContext)
            throw new Error("Root context required for lift declaration.");
        const r = this.createExpressionVisitor().visit(t.value);
        if (!(r instanceof Pn.Interval))
            throw new Error("Lift declaration must evaluate to an interval.");
        this.rootContext.lift = r.shallowClone()
    }
    visitExpression(t) {
        const e = this.createExpressionVisitor()
          , r = e.visit(t.expression);
        this.handleValue(r, e)
    }
    handleValue(t, e) {
        const r = this.currentScale;
        if (t instanceof Pn.Color)
            for (let i = 0; i < r.length; ++i)
                r[i].color === void 0 && (r[i] = r[i].shallowClone(),
                r[i].color = t);
        else if (t instanceof Pn.Interval)
            r.push(t);
        else if (t instanceof Pn.Val) {
            this.spendGas(r.length * t.value.numberOfComponents);
            const i = Hi.temper.bind(e)(t, r);
            r.length = 0,
            r.push(...i)
        } else if (Array.isArray(t))
            this.handleArray(t);
        else if (t !== void 0)
            if (typeof t == "string") {
                if (!this.rootContext)
                    throw new Error("No root context found for storing scale title.");
                if (!this.isUserRoot)
                    throw new Error("Scale title must be given at root level.");
                this.rootContext.title = t
            } else if (typeof t == "boolean")
                r.push((0,
                Hi.upcastBool)(t));
            else if (t instanceof Pn.ValBasis) {
                this.spendGas(r.length);
                const i = [];
                for (const a of r)
                    i.push(t.intrinsicCall(a));
                r.length = 0,
                r.push(...i)
            } else if (t instanceof Pn.Temperament) {
                this.spendGas(r.length);
                const i = [];
                for (const a of r) {
                    const l = t.temper(a.value);
                    i.push(new Pn.Interval(l,"logarithmic",a.steps,void 0,a))
                }
                r.length = 0,
                r.push(...i)
            } else if (typeof t == "object") {
                const i = Object.entries(t);
                for (const [l,f] of i)
                    this.handleValue(e.implicitCall(l, f), e);
                const a = r.slice(-i.length);
                r.length = r.length - a.length,
                Hi.sortInPlace.bind(e)(a),
                r.push(...a)
            } else {
                this.spendGas(r.length);
                const i = t.bind(e)
                  , a = r.map(l => i(l));
                r.length = 0,
                this.handleArray(a)
            }
    }
    handleArray(t) {
        const e = this.currentScale
          , r = [...this.currentScale];
        for (let i = 0; i < t.length; ++i) {
            const a = t[i];
            if (a instanceof Pn.Interval || typeof a == "boolean") {
                r.push((0,
                Hi.upcastBool)(a));
                continue
            } else if (Array.isArray(a)) {
                for (const l of a.flat(1 / 0))
                    if (l instanceof Pn.Interval || typeof l == "boolean")
                        r.push((0,
                        Hi.upcastBool)(l));
                    else
                        throw new Error("Nested pushed array elements must be intervals.");
                continue
            }
            if (!(i >= e.length))
                if (a instanceof Pn.Color)
                    r[i] = r[i].shallowClone(),
                    r[i].color = a;
                else if (a === void 0)
                    r[i] = r[i].shallowClone(),
                    r[i].color = void 0;
                else if (typeof a == "string")
                    r[i] = r[i].shallowClone(),
                    r[i].label = a;
                else
                    throw new Error("A pushed array element must be color, string, niente or interval.")
        }
        e.length = 0,
        e.push(...r)
    }
    executeProgram(t) {
        const e = this.executeStatements(t.body);
        if (e)
            throw new Error(`Illegal ${e.type}.`)
    }
    executeStatements(t) {
        let e;
        for (const r of t)
            if (e = this.visit(r),
            e)
                break;
        for (; this.deferred.length; ) {
            const r = this.visit(this.deferred.pop());
            if (r)
                throw new Error(`Illegal ${r.type} inside a deferred block.`)
        }
        return e
    }
    visitBlockStatement(t) {
        const e = new vi(this)
          , r = this.currentScale;
        e.mutables.set("$$", r);
        const i = e.executeStatements(t.body);
        if ((i == null ? void 0 : i.type) === "ReturnStatement")
            return i;
        const a = e.currentScale;
        return r.push(...a),
        i
    }
    visitWhileStatement(t) {
        const e = this.createExpressionVisitor();
        let r = !0;
        for (; (0,
        Hi.sonicTruth)(e.visit(t.test)); ) {
            const i = this.visit(t.body);
            if ((i == null ? void 0 : i.type) === "ReturnStatement")
                return i;
            if ((i == null ? void 0 : i.type) === "BreakStatement") {
                r = !1;
                break
            } else if ((i == null ? void 0 : i.type) === "ContinueStatement")
                continue
        }
        if (r && t.tail)
            return this.visit(t.tail)
    }
    declareLoopElement(t, e, r, i, a) {
        if (arguments.length < 5 && r.defaultValue && (a = e.visit(r.defaultValue)),
        r.type === "Parameters") {
            if (!Array.isArray(a))
                throw new Error("Must iterate over arrays when destructuring.");
            for (let l = 0; l < r.parameters.length; ++l)
                l < a.length ? this.declareLoopElement(t, e, r.parameters[l], i, a[l]) : this.declareLoopElement(t, e, r.parameters[l], i);
            r.rest && this.declareLoopElement(t, e, r.rest, i, a.slice(r.parameters.length))
        } else {
            const l = r.id;
            i ? t.mutables.set(l, a) : t.immutables.set(l, a)
        }
    }
    visitIterationStatement(t) {
        const e = this.createExpressionVisitor()
          , r = (0,
        ku.containerToArray)(e.visit(t.container), t.kind)
          , i = new vi(this);
        i.mutables.delete("$");
        const a = i.createExpressionVisitor();
        let l = !0;
        for (const f of r) {
            this.declareLoopElement(i, a, t.element, t.mutable, f);
            const h = i.visit(t.body);
            if ((h == null ? void 0 : h.type) === "ReturnStatement")
                return h;
            if ((h == null ? void 0 : h.type) === "BreakStatement") {
                l = !1;
                break
            } else if ((h == null ? void 0 : h.type) === "ContinueStatement")
                continue
        }
        if (l && t.tail)
            return this.visit(t.tail)
    }
    visitTryStatement(t) {
        try {
            const e = this.visit(t.body);
            if (e)
                return e
        } catch (e) {
            if (t.handler && t.handler.parameter) {
                e instanceof Error && (e = e.message);
                const r = new vi(this);
                r.mutables.delete("$"),
                r.immutables.set(t.handler.parameter.id, e);
                const i = r.visit(t.handler.body);
                if (i)
                    return i
            } else if (t.handler) {
                const r = this.visit(t.handler.body);
                if (r)
                    return r
            }
        } finally {
            if (t.finalizer) {
                const e = this.visit(t.finalizer);
                if (e)
                    return e
            }
        }
    }
    visitIfStatement(t) {
        const e = this.createExpressionVisitor();
        if ((0,
        Hi.sonicTruth)(e.visit(t.test)))
            return this.visit(t.consequent);
        if (t.alternate)
            return this.visit(t.alternate)
    }
    realizeFunction(t) {
        t = {
            ...t
        },
        t.body = [...t.body];
        let e;
        t.body.length && t.body[0].type === "ExpressionStatement" && t.body[0].expression.type === "StringLiteral" && (e = t.body[0].expression.value,
        t.body.shift());
        const r = this;
        function i(...a) {
            const l = new vi(r);
            l.mutables.set("$$", this.parent.currentScale),
            l.createExpressionVisitor(!0).localAssign(t.parameters, a);
            const h = l.executeStatements(t.body);
            if ((h == null ? void 0 : h.type) === "ReturnStatement")
                return h.value;
            if (h)
                throw new Error(`Illegal ${h.type}.`);
            return l.currentScale
        }
        return Object.defineProperty(i, "name", {
            value: t.name.id,
            enumerable: !1
        }),
        i.__doc__ = e,
        i.__node__ = t,
        i
    }
    visitFunctionDeclaration(t) {
        const e = t.name.id;
        if (this.immutables.has(e) || this.mutables.has(e))
            throw new Error(`The name ${e} is already in use.`);
        this.immutables.set(e, this.realizeFunction(t))
    }
    get(t) {
        if (this.immutables.has(t))
            return this.immutables.get(t);
        if (this.mutables.has(t))
            return this.mutables.get(t);
        if (this.parent)
            return this.parent.get(t);
        throw new Error(`Undeclared variable ${t}.`)
    }
    set(t, e) {
        if (this.immutables.has(t))
            throw new Error("Assignment to a constant variable.");
        if (this.mutables.has(t)) {
            this.mutables.set(t, e);
            return
        }
        if (this.parent)
            return this.parent.set(t, e);
        throw new Error(`Assignment to an undeclared variable ${t}.`)
    }
    get currentScale() {
        const t = this.get("$");
        if (!Array.isArray(t))
            throw new Error("Context corruption detected.");
        return t
    }
    set currentScale(t) {
        if (!Array.isArray(t))
            throw new Error("Context corruption not allowed.");
        this.set("$", t)
    }
}
Oi.StatementVisitor = vi;
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.sw$ = n.sw = n.sw$r = n.swr = n.createTag = n.evaluateExpression = n.evaluateSource = n.getSourceVisitor = n.getGlobalVisitor = n.parseAST = void 0;
    const t = Ie
      , e = hn
      , r = An
      , i = o9
      , a = Im
      , l = Hl
      , f = Xl
      , h = Bf
      , p = Oi;
    function m(z) {
        return (0,
        i.parse)(z)
    }
    n.parseAST = m;
    let g = null
      , b = null
      , E = null
      , S = null;
    function F(z=!0, Z) {
        Z ?? (Z = {});
        const re = new h.RootContext;
        if (z && g && b && S) {
            b.rootContext = re,
            g.rootContext = re;
            const C = g.clone();
            for (const D of S.body)
                C.visit(D);
            C.rootContext = re;
            for (const D in Z) {
                const R = Z[D];
                C.immutables.set(D, R)
            }
            return C
        } else if (!z && E) {
            E.rootContext = re;
            const C = E.clone();
            return C.rootContext = re,
            C
        } else {
            const C = new p.StatementVisitor;
            C.rootContext = re;
            for (const [D,R] of a.CSS_COLOR_CONTEXT)
                C.immutables.set(D, R);
            for (const D in l.BUILTIN_CONTEXT) {
                const R = l.BUILTIN_CONTEXT[D];
                C.immutables.set(D, R)
            }
            if (z) {
                const D = m(f.PRELUDE_SOURCE);
                for (const R of D.body)
                    C.visit(R);
                b = C,
                g = C.clone(),
                S = m(f.PRELUDE_VOLATILES);
                for (const R of S.body)
                    C.visit(R)
            } else
                E = C.clone();
            for (const D in Z) {
                const R = Z[D];
                C.immutables.set(D, R)
            }
            return C
        }
    }
    n.getGlobalVisitor = F;
    function B(z=!0, Z) {
        const re = F(z, Z)
          , C = new p.StatementVisitor(re);
        return C.isUserRoot = !0,
        C
    }
    n.getSourceVisitor = B;
    function Q(z, Z=!0, re) {
        const C = B(Z, re)
          , D = m(z);
        return C.executeProgram(D),
        C
    }
    n.evaluateSource = Q;
    function ae(z, Z=!0, re) {
        const C = B(Z, re)
          , D = m(z);
        for (const I of D.body.slice(0, -1)) {
            const N = C.visit(I);
            if (N)
                throw new Error(`Illegal ${N.type}.`)
        }
        if (C.deferred.length)
            throw new Error("Deferred actions not allowed when evaluating expressions.");
        const R = D.body[D.body.length - 1];
        if (R.type !== "ExpressionStatement")
            throw new Error(`Expected expression. Got ${R.type}.`);
        return C.createExpressionVisitor().visit(R.expression)
    }
    n.evaluateExpression = ae;
    function V(z) {
        switch (typeof z) {
        case "string":
        case "undefined":
        case "function":
        case "boolean":
            return z;
        case "number":
            return Number.isInteger(z) ? e.Interval.fromInteger(z) : e.Interval.fromValue(z);
        case "bigint":
            return e.Interval.fromInteger(z);
        case "symbol":
            throw new Error("Symbols cannot be converted.");
        case "object":
            if (z instanceof e.Interval || z instanceof e.Val || z instanceof e.Color || z instanceof e.ValBasis || z instanceof e.Temperament)
                return z;
            if (z instanceof t.Fraction)
                return e.Interval.fromFraction(z);
            if (z instanceof r.TimeMonzo)
                return new e.Interval(z,"linear");
            if (Array.isArray(z))
                return z.map(V);
            {
                const Z = {};
                for (const [re,C] of Object.entries(z))
                    Z[re] = V(C);
                return Z
            }
        }
        throw new Error("Value cannot be converted.")
    }
    function k(z=!0, Z=!0, re, C=!1) {
        function D(R, ...W) {
            const I = C ? R : R.raw
              , N = B(Z, re);
            if (!N.rootContext)
                throw new Error("Root context required for storing template arguments.");
            let P = I[0];
            for (let X = 0; X < W.length; ++X)
                N.rootContext.templateArguments[X] = V(W[X]),
                P += `${X}` + I[X + 1];
            const J = m(P);
            if (z) {
                for (const ce of J.body.slice(0, -1)) {
                    const Le = N.visit(ce);
                    if (Le)
                        throw new Error(`Illegal ${Le.type}.`)
                }
                if (N.deferred.length)
                    throw new Error("Deferred actions not allowed when evaluating tagged templates.");
                const X = J.body[J.body.length - 1];
                if (X.type !== "ExpressionStatement")
                    throw new Error(`Expected expression. Got ${X.type}.`);
                return N.createExpressionVisitor().visit(X.expression)
            } else
                return N.executeProgram(J),
                N.currentScale
        }
        return D
    }
    n.createTag = k,
    n.swr = k(),
    Object.defineProperty(n.swr, "name", {
        value: "swr",
        enumerable: !1
    }),
    n.sw$r = k(!1),
    Object.defineProperty(n.swr, "name", {
        value: "sw$r",
        enumerable: !1
    }),
    n.sw = k(!0, !0, void 0, !0),
    Object.defineProperty(n.sw, "name", {
        value: "sw",
        enumerable: !1
    }),
    n.sw$ = k(!1, !0, void 0, !0),
    Object.defineProperty(n.swr, "name", {
        value: "sw$",
        enumerable: !1
    })
}
)(Z1);
Object.defineProperty(ss, "__esModule", {
    value: !0
});
ss.temperamentFromVals = ss.rank2FromCommas = ss.temperamentFromCommas = ss.parseVals = ss.parseBasis = ss.parseChord = void 0;
const mS = JD
  , H0 = Z1
  , Ys = hn
  , jE = Bm
  , em = An
  , Xd = Ie
  , fz = Oi
  , ty = 5e3;
function ny(n, t=!0) {
    const e = (0,
    mS.parse)(n);
    return (0,
    H0.evaluateSource)(`[${e.join(", ")}]`, t).currentScale.filter(a => a instanceof Ys.Interval)
}
ss.parseChord = ny;
function zm(n) {
    if (n = n.trim(),
    !n.length)
        return new Ys.ValBasis((0,
        em.getNumberOfComponents)());
    if (n.includes(".") || n.startsWith("@")) {
        n.startsWith("@") && (n = n.slice(1));
        const e = [];
        for (let i of n.split(".")) {
            if (i = i.trim(),
            !i) {
                e.push(i);
                continue
            }
            let a = !1;
            i.startsWith("") && (i = i.slice(1),
            a = !0);
            const {s: l, n: f, d: h} = new Xd.Fraction(i);
            if (l <= 0)
                throw new Error("Basis elements may not be negative or zero.");
            e.push({
                radical: a,
                numerator: f,
                denominator: h === 1 ? null : h
            })
        }
        return new fz.StatementVisitor().createExpressionVisitor().visit({
            type: "ValBasisLiteral",
            basis: e
        })
    }
    const t = parseInt(n, 10);
    if (Xd.PRIMES.includes(t))
        return new Ys.ValBasis(Xd.PRIMES.indexOf(t) + 1);
    throw new Error(`Unrecognized prime limit ${n}.`)
}
ss.parseBasis = zm;
function G0(n, t, e=!0) {
    const r = (0,
    mS.parse)(n)
      , i = [];
    for (let a of r)
        if (a.includes("<")) {
            if (a.endsWith("@") && (a = a.slice(0, -1)),
            a.includes("@"))
                throw new Error("Explicit subgroups not supported.");
            const l = (0,
            H0.evaluateExpression)(a, e);
            i.push(Ys.Val.fromBasisMap(l.sval, t))
        } else {
            a.includes("@") ? a.endsWith("@") && (a = a + "S") : a = a + "@S";
            const l = (0,
            H0.parseAST)(a).body[0];
            if (l.type !== "ExpressionStatement")
                throw new Error("Invalid val literal.");
            const f = l.expression;
            let h;
            if (f.type === "WartsLiteral")
                h = (0,
                jE.wartsToVal)(f, t);
            else if (f.type === "SparseOffsetVal")
                h = (0,
                jE.sparseOffsetToVal)(f, t);
            else
                throw new Error("Invalid val literal.");
            i.push(h)
        }
    return i
}
ss.parseVals = G0;
function dz(n, t, e, r) {
    const i = ny(n)
      , a = [];
    for (const h of i) {
        if (h.value instanceof em.TimeReal)
            throw new Error("Tempering real values not supported.");
        a.push(h.value)
    }
    t = t.trim();
    let l;
    t.length && (l = zm(t)),
    r ?? (r = []),
    r = [...r],
    e === "CTE" && (r.shift(),
    r.unshift(ty));
    const f = e !== "TE";
    return Ys.Temperament.fromCommas(a, l, r, f)
}
ss.temperamentFromCommas = dz;
function hz(n, t, e, r) {
    const i = ny(n)
      , a = [];
    for (const b of i) {
        if (b.value instanceof em.TimeReal)
            throw new Error("Tempering real values not supported.");
        a.push(b.value)
    }
    t = t.trim();
    let l;
    t.length && (l = zm(t)),
    r ?? (r = []),
    r = [...r],
    e === "CTE" && (r.shift(),
    r.unshift(ty));
    const f = e !== "TE";
    let h = Ys.Temperament.fromCommas(a, l, r, f);
    if (h.rank === 2)
        return h;
    if (t)
        throw new Error("Given commas don't define a rank-2 temperament in the subgroup.");
    if (h.rank > 2)
        throw new Error("Failed to infer subgroup. Provide an explicit one.");
    const p = new Set;
    for (const b of a)
        for (const E of b.factorize().keys()) {
            if (E < 2)
                throw new Error("Negative or zero commas not supported.");
            p.add(E)
        }
    let m = h.rank;
    for (const b of Xd.PRIMES)
        if (!p.has(b) && (p.add(b),
        ++m >= 2))
            break;
    const g = Array.from(p);
    if (g.sort( (b, E) => b - E),
    l = new Ys.ValBasis(g.map(b => em.TimeMonzo.fromFraction(b))),
    h = Ys.Temperament.fromCommas(a, l, r, f),
    h.rank === 2)
        return h;
    throw new Error("Failed to infer subgroup. Provide an explicit one.")
}
ss.rank2FromCommas = hz;
function pz(n, t, e, r) {
    r ?? (r = []),
    r = [...r],
    e === "CTE" && (r.shift(),
    r.unshift(ty));
    const i = e !== "TE";
    if (t = t.trim(),
    !t)
        for (const f of [3, 4, 5, 6]) {
            const h = new Ys.ValBasis(f)
              , p = G0(n, h)
              , m = Ys.Temperament.fromVals(p, r, i);
            if (m.rank === p.length)
                return m
        }
    const a = zm(t)
      , l = G0(n, a);
    return Ys.Temperament.fromVals(l, r, i)
}
ss.temperamentFromVals = pz;
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(i, a, l, f) {
        f === void 0 && (f = l);
        var h = Object.getOwnPropertyDescriptor(a, l);
        (!h || ("get"in h ? !a.__esModule : h.writable || h.configurable)) && (h = {
            enumerable: !0,
            get: function() {
                return a[l]
            }
        }),
        Object.defineProperty(i, f, h)
    }
    : function(i, a, l, f) {
        f === void 0 && (f = l),
        i[f] = a[l]
    }
    )
      , e = Zt && Zt.__exportStar || function(i, a) {
        for (var l in i)
            l !== "default" && !Object.prototype.hasOwnProperty.call(a, l) && t(a, i, l)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.ExpressionVisitor = void 0,
    e(ss, n);
    var r = Xi;
    Object.defineProperty(n, "ExpressionVisitor", {
        enumerable: !0,
        get: function() {
            return r.ExpressionVisitor
        }
    }),
    e(Oi, n),
    e(Z1, n)
}
)(K1);
var qo = {};
const mz = /\p{Zs}/u
  , ga = {
    parens: 0,
    squares: 0,
    curlies: 0
};
function gz(n, t) {
    function e() {
        this.constructor = n
    }
    e.prototype = t.prototype,
    n.prototype = new e
}
function Bo(n, t, e, r) {
    var i = Error.call(this, n);
    return Object.setPrototypeOf && Object.setPrototypeOf(i, Bo.prototype),
    i.expected = t,
    i.found = e,
    i.location = r,
    i.name = "SyntaxError",
    i
}
gz(Bo, Error);
function Pv(n, t, e) {
    return e = e || " ",
    n.length > t ? n : (t -= n.length,
    e += e.repeat(t),
    n + e.slice(0, t))
}
Bo.prototype.format = function(n) {
    var t = "Error: " + this.message;
    if (this.location) {
        var e = null, r;
        for (r = 0; r < n.length; r++)
            if (n[r].source === this.location.source) {
                e = n[r].text.split(/\r\n|\n|\r/g);
                break
            }
        var i = this.location.start
          , a = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i
          , l = this.location.source + ":" + a.line + ":" + a.column;
        if (e) {
            var f = this.location.end
              , h = Pv("", a.line.toString().length, " ")
              , p = e[i.line - 1]
              , m = i.line === f.line ? f.column : p.length + 1
              , g = m - i.column || 1;
            t += `
 --> ` + l + `
` + h + ` |
` + a.line + " | " + p + `
` + h + " | " + Pv("", i.column - 1, " ") + Pv("", g, "^")
        } else
            t += `
 at ` + l
    }
    return t
}
;
Bo.buildMessage = function(n, t) {
    var e = {
        literal: function(p) {
            return '"' + i(p.text) + '"'
        },
        class: function(p) {
            var m = p.parts.map(function(g) {
                return Array.isArray(g) ? a(g[0]) + "-" + a(g[1]) : a(g)
            });
            return "[" + (p.inverted ? "^" : "") + m.join("") + "]"
        },
        any: function() {
            return "any character"
        },
        end: function() {
            return "end of input"
        },
        other: function(p) {
            return p.description
        }
    };
    function r(p) {
        return p.charCodeAt(0).toString(16).toUpperCase()
    }
    function i(p) {
        return p.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function a(p) {
        return p.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function l(p) {
        return e[p.type](p)
    }
    function f(p) {
        var m = p.map(l), g, b;
        if (m.sort(),
        m.length > 0) {
            for (g = 1,
            b = 1; g < m.length; g++)
                m[g - 1] !== m[g] && (m[b] = m[g],
                b++);
            m.length = b
        }
        switch (m.length) {
        case 1:
            return m[0];
        case 2:
            return m[0] + " or " + m[1];
        default:
            return m.slice(0, -1).join(", ") + ", or " + m[m.length - 1]
        }
    }
    function h(p) {
        return p ? '"' + i(p) + '"' : "end of input"
    }
    return "Expected " + f(n) + " but " + h(t) + " found."
}
;
function vz(n, t) {
    t = t !== void 0 ? t : {};
    var e = {}, r = t.grammarSource, i = {
        Start: Qo
    }, a = Qo, l = "(", f = ")", h = "[", p = "..", m = "]", g = '"', b = "'", E = "0", S = "e", F = ".", B = "\\", Q = "b", ae = "f", V = "n", k = "r", z = "t", Z = "v", re = "x", C = "u", D = `
`, R = "\r", W = `\r
`, I = "(*", N = "*)", P = "/", J = ",", X = /^[>\u27E9]/, ie = /^[<\u27E8]/, ce = /^[_0-9]/, Le = /^[0-9]/, he = /^[1-9]/, Fe = /^[+\-]/, Te = /^["\\]/, ye = /^[\u2028-\u2029]/, qe = /^['\\]/, Ge = /^["'\\]/, Se = /^[0-9ux]/, L = /^[0-9a-f]/i, K = /^[\t\v-\f \xA0\uFEFF]/, de = /^[\n\r\u2028-\u2029]/, $e = /^[\0-\uD7FF\uE000-\uFFFF]/, Re = /^[\uD800-\uDBFF]/, me = /^[\uDC00-\uDFFF]/, T = /^[\uD800-\uDFFF]/, j = tn("(", !1), ge = tn(")", !1), Me = tn("[", !1), Oe = tn("..", !1), Be = tn("<", !1), ze = tn("]", !1), Ye = tn('"', !1), He = tn("'", !1), Ue = qn([">", ""], !1, !1), at = qn(["<", ""], !1, !1), rt = qn(["_", ["0", "9"]], !1, !1), _e = qn([["0", "9"]], !1, !1), xe = qn([["1", "9"]], !1, !1), Ze = tn("0", !1), st = qn(["+", "-"], !1, !1), je = tn("e", !0), ct = tn(".", !1), Et = qn(['"', "\\"], !1, !1), It = qn([["\u2028", "\u2029"]], !1, !1), Bt = tn("\\", !1), yn = qn(["'", "\\"], !1, !1), qt = qn(['"', "'", "\\"], !1, !1), Nt = tn("b", !1), xt = tn("f", !1), Lt = tn("n", !1), pe = tn("r", !1), Pe = tn("t", !1), Xe = tn("v", !1), ft = qn([["0", "9"], "u", "x"], !1, !1), Ht = tn("x", !1), Yt = tn("u", !1), $r = qn([["0", "9"], ["a", "f"]], !1, !0), Ds = ai("whitespace"), xi = qi(), vs = qn(["	", ["\v", "\f"], " ", "", "\uFEFF"], !1, !1), ys = ai("line break"), as = qn([`
`, "\r", ["\u2028", "\u2029"]], !1, !1), ri = ai("line terminator"), Ii = tn(`
`, !1), qs = tn("\r", !1), Fi = tn(`\r
`, !1), Jo = ai("any character"), Ri = qn([["\0", ""], ["", ""]], !1, !1), Ko = qn([["\uD800", "\uDBFF"]], !1, !1), ro = qn([["\uDC00", "\uDFFF"]], !1, !1), Zo = qn([["\uD800", "\uDFFF"]], !1, !1), Mr = tn("(*", !1), bs = tn("*)", !1), so = tn("/", !1), Bs = tn(",", !1), io = function(A) {
        const H = {
            parens: 0,
            squares: 0,
            curlies: 0
        };
        for (const ne of A)
            H.parens += ne.parens,
            H.squares += ne.squares,
            H.curlies += ne.curlies;
        return H
    }, oo = function(A) {
        return A ? ga : {
            parens: 1,
            squares: 0,
            curlies: 0
        }
    }, ks = function(A) {
        return A ? ga : {
            parens: 0,
            squares: 1,
            curlies: 0
        }
    }, Pi = function(A) {
        return A ? ga : {
            parens: 0,
            squares: 1,
            curlies: 0
        }
    }, ls = function(A) {
        return ga
    }, ao = function(A) {
        return ga
    }, ts = function() {
        return ga
    }, x = function() {
        return ga
    }, De = function(A) {
        const H = {
            parens: 0,
            squares: 0,
            curlies: 0
        };
        for (const ne of A)
            H.parens += ne.parens,
            H.squares += ne.squares,
            H.curlies += ne.curlies;
        return H
    }, zt = function() {
        const A = fu()
          , H = (A.match(/\(/g) ?? []).length - (A.match(/\)/g) ?? []).length
          , ne = (A.match(/\[/g) ?? []).length - (A.match(/\]/g) ?? []).length
          , ue = (A.match(/{/g) ?? []).length - (A.match(/}/g) ?? []).length;
        return {
            parens: H,
            squares: ne,
            curlies: ue
        }
    }, kt = function(A) {
        return A.endsWith("_") && co("Numeric separators are not allowed at the end of numeric literals."),
        A.replace(/_/g, "")
    }, Zn = function(A) {
        return A
    }, be = function(A) {
        return parseInt(A, 10)
    }, jn = function(A) {
        return parseInt(A, 10)
    }, _n = function() {
        return ""
    }, ws = function() {
        return "\0"
    }, an = function() {
        return "\b"
    }, fn = function() {
        return "\f"
    }, lo = function() {
        return `
`
    }, si = function() {
        return "\r"
    }, Es = function() {
        return "	"
    }, Di = function() {
        return "\v"
    }, ii = function(A) {
        return String.fromCharCode(parseInt(A, 16))
    }, it = function(A) {
        return String.fromCharCode(parseInt(A, 16))
    }, uo = function(A) {
        return mz.test(A)
    }, cu = function(A, H, ne, ue) {
        return {
            sign: A,
            left: H,
            separator: ne,
            right: ue,
            exponent: null
        }
    }, Ba = function(A, H, ne, ue, We) {
        return {
            sign: A,
            left: H,
            separator: ne,
            right: ue,
            exponent: We
        }
    }, ka = function(A, H, ne) {
        return {
            sign: A,
            left: H,
            separator: "",
            right: "",
            exponent: ne
        }
    }, $ = t.peg$currPos | 0, en = $, _s = [{
        line: 1,
        column: 1
    }], Or = $, oi = t.peg$maxFailExpected || [], we = t.peg$silentFails | 0, Ls;
    if (t.startRule) {
        if (!(t.startRule in i))
            throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
        a = i[t.startRule]
    }
    function fu() {
        return n.substring(en, $)
    }
    function co(A, H) {
        throw H = H !== void 0 ? H : us(en, $),
        Ss(A, H)
    }
    function tn(A, H) {
        return {
            type: "literal",
            text: A,
            ignoreCase: H
        }
    }
    function qn(A, H, ne) {
        return {
            type: "class",
            parts: A,
            inverted: H,
            ignoreCase: ne
        }
    }
    function qi() {
        return {
            type: "any"
        }
    }
    function za() {
        return {
            type: "end"
        }
    }
    function ai(A) {
        return {
            type: "other",
            description: A
        }
    }
    function Yo(A) {
        var H = _s[A], ne;
        if (H)
            return H;
        if (A >= _s.length)
            ne = _s.length - 1;
        else
            for (ne = A; !_s[--ne]; )
                ;
        for (H = _s[ne],
        H = {
            line: H.line,
            column: H.column
        }; ne < A; )
            n.charCodeAt(ne) === 10 ? (H.line++,
            H.column = 1) : H.column++,
            ne++;
        return _s[A] = H,
        H
    }
    function us(A, H, ne) {
        var ue = Yo(A)
          , We = Yo(H)
          , lt = {
            source: r,
            start: {
                offset: A,
                line: ue.line,
                column: ue.column
            },
            end: {
                offset: H,
                line: We.line,
                column: We.column
            }
        };
        return ne && r && typeof r.offset == "function" && (lt.start = r.offset(lt.start),
        lt.end = r.offset(lt.end)),
        lt
    }
    function tt(A) {
        $ < Or || ($ > Or && (Or = $,
        oi = []),
        oi.push(A))
    }
    function Ss(A, H) {
        return new Bo(A,null,null,H)
    }
    function kr(A, H, ne) {
        return new Bo(Bo.buildMessage(A, H),A,H,ne)
    }
    function Qo() {
        var A, H, ne, ue;
        for (A = $,
        dn(),
        H = [],
        ne = Er(); ne !== e; )
            H.push(ne),
            ne = $,
            ue = dn(),
            ue = Er(),
            ue === e ? ($ = ne,
            ne = e) : ne = ue;
        return ne = dn(),
        ue = Kf(),
        ue !== e ? (en = A,
        A = io(H)) : ($ = A,
        A = e),
        A
    }
    function Er() {
        var A;
        return A = Va(),
        A === e && (A = Ua(),
        A === e && (A = ja(),
        A === e && (A = rr(),
        A === e && (A = Ha(),
        A === e && (A = Xo(),
        A === e && (A = Ga())))))),
        A
    }
    function Xo() {
        var A, H, ne, ue;
        return A = $,
        n.charCodeAt($) === 40 ? (H = l,
        $++) : (H = e,
        we === 0 && tt(j)),
        H !== e ? (dn(),
        ne = Er(),
        ne !== e ? (dn(),
        n.charCodeAt($) === 41 ? (ue = f,
        $++) : (ue = e,
        we === 0 && tt(ge)),
        ue === e && (ue = null),
        en = A,
        A = oo(ue)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function Va() {
        var A, H, ne, ue, We, lt;
        return A = $,
        n.charCodeAt($) === 91 ? (H = h,
        $++) : (H = e,
        we === 0 && tt(Me)),
        H !== e ? (dn(),
        ne = Er(),
        ne !== e ? (dn(),
        n.substr($, 2) === p ? (ue = p,
        $ += 2) : (ue = e,
        we === 0 && tt(Oe)),
        ue !== e ? (dn(),
        n.charCodeAt($) === 60 ? $++ : we === 0 && tt(Be),
        dn(),
        We = Er(),
        We !== e ? (dn(),
        n.charCodeAt($) === 93 ? (lt = m,
        $++) : (lt = e,
        we === 0 && tt(ze)),
        lt === e && (lt = null),
        en = A,
        A = ks(lt)) : ($ = A,
        A = e)) : ($ = A,
        A = e)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function rr() {
        var A, H, ne, ue, We;
        if (A = $,
        n.charCodeAt($) === 91 ? (H = h,
        $++) : (H = e,
        we === 0 && tt(Me)),
        H !== e) {
            for (dn(),
            ne = [],
            ue = Er(); ue !== e; )
                ne.push(ue),
                ue = $,
                We = dn(),
                We = Er(),
                We === e ? ($ = ue,
                ue = e) : ue = We;
            ue = dn(),
            n.charCodeAt($) === 93 ? (We = m,
            $++) : (We = e,
            we === 0 && tt(ze)),
            We === e && (We = null),
            en = A,
            A = Pi(We)
        } else
            $ = A,
            A = e;
        return A
    }
    function Ua() {
        var A, H, ne, ue;
        if (A = $,
        n.charCodeAt($) === 34 ? (H = g,
        $++) : (H = e,
        we === 0 && tt(Ye)),
        H !== e) {
            for (ne = [],
            ue = na(); ue !== e; )
                ne.push(ue),
                ue = na();
            n.charCodeAt($) === 34 ? (ue = g,
            $++) : (ue = e,
            we === 0 && tt(Ye)),
            ue !== e ? (en = A,
            A = ls()) : ($ = A,
            A = e)
        } else
            $ = A,
            A = e;
        if (A === e)
            if (A = $,
            n.charCodeAt($) === 39 ? (H = b,
            $++) : (H = e,
            we === 0 && tt(He)),
            H !== e) {
                for (ne = [],
                ue = ki(); ue !== e; )
                    ne.push(ue),
                    ue = ki();
                n.charCodeAt($) === 39 ? (ue = b,
                $++) : (ue = e,
                we === 0 && tt(He)),
                ue !== e ? (en = A,
                A = ao()) : ($ = A,
                A = e)
            } else
                $ = A,
                A = e;
        return A
    }
    function ja() {
        var A, H, ne;
        return A = $,
        n.charCodeAt($) === 91 ? (H = h,
        $++) : (H = e,
        we === 0 && tt(Me)),
        H !== e ? (dn(),
        mo(),
        dn(),
        ne = n.charAt($),
        X.test(ne) ? $++ : (ne = e,
        we === 0 && tt(Ue)),
        ne !== e ? (en = A,
        A = ts()) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function Ha() {
        var A, H, ne;
        return A = $,
        H = n.charAt($),
        ie.test(H) ? $++ : (H = e,
        we === 0 && tt(at)),
        H !== e ? (dn(),
        mo(),
        dn(),
        n.charCodeAt($) === 93 ? (ne = m,
        $++) : (ne = e,
        we === 0 && tt(ze)),
        ne !== e ? (en = A,
        A = x()) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function Ga() {
        var A, H, ne, ue, We;
        for (A = $,
        dn(),
        H = $,
        ne = [],
        ue = li(); ue !== e; )
            ne.push(ue),
            ue = $,
            We = dn(),
            We = li(),
            We === e ? ($ = ue,
            ue = e) : ue = We;
        return ne.length < 1 ? ($ = H,
        H = e) : H = ne,
        H !== e ? (ne = dn(),
        en = A,
        A = De(H)) : ($ = A,
        A = e),
        A
    }
    function li() {
        var A, H, ne, ue, We, lt, $n, Ln, Yn, pn, mn, sr, zr;
        if (A = $,
        H = [],
        ne = $,
        ue = $,
        we++,
        We = Ya(),
        we--,
        We === e ? ue = void 0 : ($ = ue,
        ue = e),
        ue !== e ? (We = $,
        we++,
        lt = po(),
        we--,
        lt === e ? We = void 0 : ($ = We,
        We = e),
        We !== e ? (lt = $,
        we++,
        $n = zi(),
        we--,
        $n === e ? lt = void 0 : ($ = lt,
        lt = e),
        lt !== e ? ($n = $,
        we++,
        n.charCodeAt($) === 34 ? (Ln = g,
        $++) : (Ln = e,
        we === 0 && tt(Ye)),
        we--,
        Ln === e ? $n = void 0 : ($ = $n,
        $n = e),
        $n !== e ? (Ln = $,
        we++,
        n.charCodeAt($) === 39 ? (Yn = b,
        $++) : (Yn = e,
        we === 0 && tt(He)),
        we--,
        Yn === e ? Ln = void 0 : ($ = Ln,
        Ln = e),
        Ln !== e ? (Yn = $,
        we++,
        n.charCodeAt($) === 91 ? (pn = h,
        $++) : (pn = e,
        we === 0 && tt(Me)),
        we--,
        pn === e ? Yn = void 0 : ($ = Yn,
        Yn = e),
        Yn !== e ? (pn = $,
        we++,
        n.charCodeAt($) === 93 ? (mn = m,
        $++) : (mn = e,
        we === 0 && tt(ze)),
        we--,
        mn === e ? pn = void 0 : ($ = pn,
        pn = e),
        pn !== e ? (mn = $,
        we++,
        n.charCodeAt($) === 40 ? (sr = l,
        $++) : (sr = e,
        we === 0 && tt(j)),
        we--,
        sr === e ? mn = void 0 : ($ = mn,
        mn = e),
        mn !== e ? (sr = $,
        we++,
        n.charCodeAt($) === 41 ? (zr = f,
        $++) : (zr = e,
        we === 0 && tt(ge)),
        we--,
        zr === e ? sr = void 0 : ($ = sr,
        sr = e),
        sr !== e ? (zr = ui(),
        zr !== e ? (ue = [ue, We, lt, $n, Ln, Yn, pn, mn, sr, zr],
        ne = ue) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e)) : ($ = ne,
        ne = e),
        ne !== e)
            for (; ne !== e; )
                H.push(ne),
                ne = $,
                ue = $,
                we++,
                We = Ya(),
                we--,
                We === e ? ue = void 0 : ($ = ue,
                ue = e),
                ue !== e ? (We = $,
                we++,
                lt = po(),
                we--,
                lt === e ? We = void 0 : ($ = We,
                We = e),
                We !== e ? (lt = $,
                we++,
                $n = zi(),
                we--,
                $n === e ? lt = void 0 : ($ = lt,
                lt = e),
                lt !== e ? ($n = $,
                we++,
                n.charCodeAt($) === 34 ? (Ln = g,
                $++) : (Ln = e,
                we === 0 && tt(Ye)),
                we--,
                Ln === e ? $n = void 0 : ($ = $n,
                $n = e),
                $n !== e ? (Ln = $,
                we++,
                n.charCodeAt($) === 39 ? (Yn = b,
                $++) : (Yn = e,
                we === 0 && tt(He)),
                we--,
                Yn === e ? Ln = void 0 : ($ = Ln,
                Ln = e),
                Ln !== e ? (Yn = $,
                we++,
                n.charCodeAt($) === 91 ? (pn = h,
                $++) : (pn = e,
                we === 0 && tt(Me)),
                we--,
                pn === e ? Yn = void 0 : ($ = Yn,
                Yn = e),
                Yn !== e ? (pn = $,
                we++,
                n.charCodeAt($) === 93 ? (mn = m,
                $++) : (mn = e,
                we === 0 && tt(ze)),
                we--,
                mn === e ? pn = void 0 : ($ = pn,
                pn = e),
                pn !== e ? (mn = $,
                we++,
                n.charCodeAt($) === 40 ? (sr = l,
                $++) : (sr = e,
                we === 0 && tt(j)),
                we--,
                sr === e ? mn = void 0 : ($ = mn,
                mn = e),
                mn !== e ? (sr = $,
                we++,
                n.charCodeAt($) === 41 ? (zr = f,
                $++) : (zr = e,
                we === 0 && tt(ge)),
                we--,
                zr === e ? sr = void 0 : ($ = sr,
                sr = e),
                sr !== e ? (zr = ui(),
                zr !== e ? (ue = [ue, We, lt, $n, Ln, Yn, pn, mn, sr, zr],
                ne = ue) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e)) : ($ = ne,
                ne = e);
        else
            H = e;
        return H !== e && (en = A,
        H = zt()),
        A = H,
        A
    }
    function ea() {
        var A, H, ne, ue;
        for (A = $,
        H = $,
        ne = [],
        ue = n.charAt($),
        ce.test(ue) ? $++ : (ue = e,
        we === 0 && tt(rt)); ue !== e; )
            ne.push(ue),
            ue = n.charAt($),
            ce.test(ue) ? $++ : (ue = e,
            we === 0 && tt(rt));
        return H = n.substring(H, $),
        en = A,
        H = kt(H),
        A = H,
        A
    }
    function Bi() {
        var A, H;
        return A = $,
        H = n.charAt($),
        Fe.test(H) ? $++ : (H = e,
        we === 0 && tt(st)),
        H === e && (H = null),
        A = n.substring(A, $),
        A
    }
    function Wa() {
        var A;
        return A = n.charAt($),
        A.toLowerCase() === S ? $++ : (A = e,
        we === 0 && tt(je)),
        A
    }
    function ta() {
        var A, H, ne;
        return A = $,
        H = Wa(),
        H !== e ? (ne = Ka(),
        ne !== e ? (en = A,
        A = Zn(ne)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function fo() {
        var A, H, ne, ue, We, lt;
        if (A = $,
        H = $,
        n.charCodeAt($) === 48 ? (ne = E,
        $++) : (ne = e,
        we === 0 && tt(Ze)),
        ne === e)
            if (ne = $,
            ue = n.charAt($),
            he.test(ue) ? $++ : (ue = e,
            we === 0 && tt(xe)),
            ue !== e) {
                for (We = [],
                lt = Ne(); lt !== e; )
                    We.push(lt),
                    lt = Ne();
                ue = [ue, We],
                ne = ue
            } else
                $ = ne,
                ne = e;
        return ne !== e ? H = n.substring(H, $) : H = ne,
        H !== e && (en = A,
        H = be(H)),
        A = H,
        A
    }
    function Ja() {
        var A, H, ne, ue, We;
        if (A = $,
        H = $,
        ne = n.charAt($),
        he.test(ne) ? $++ : (ne = e,
        we === 0 && tt(xe)),
        ne !== e) {
            for (ue = [],
            We = Ne(); We !== e; )
                ue.push(We),
                We = Ne();
            ne = [ne, ue],
            H = ne
        } else
            $ = H,
            H = e;
        return H !== e ? A = n.substring(A, $) : A = H,
        A
    }
    function Ka() {
        var A, H, ne, ue, We, lt, $n, Ln;
        if (A = $,
        H = $,
        ne = $,
        ue = n.charAt($),
        Fe.test(ue) ? $++ : (ue = e,
        we === 0 && tt(st)),
        ue === e && (ue = null),
        n.charCodeAt($) === 48 ? (We = E,
        $++) : (We = e,
        we === 0 && tt(Ze)),
        We === e)
            if (We = $,
            lt = n.charAt($),
            he.test(lt) ? $++ : (lt = e,
            we === 0 && tt(xe)),
            lt !== e) {
                for ($n = [],
                Ln = Ne(); Ln !== e; )
                    $n.push(Ln),
                    Ln = Ne();
                lt = [lt, $n],
                We = lt
            } else
                $ = We,
                We = e;
        return We !== e ? (ue = [ue, We],
        ne = ue) : ($ = ne,
        ne = e),
        ne !== e ? H = n.substring(H, $) : H = ne,
        H !== e && (en = A,
        H = jn(H)),
        A = H,
        A
    }
    function na() {
        var A, H, ne, ue;
        return A = $,
        H = $,
        ne = $,
        we++,
        ue = n.charAt($),
        Te.test(ue) ? $++ : (ue = e,
        we === 0 && tt(Et)),
        ue === e && (ue = Qa()),
        we--,
        ue === e ? ne = void 0 : ($ = ne,
        ne = e),
        ne !== e ? (ue = ui(),
        ue !== e ? (ne = [ne, ue],
        H = ne) : ($ = H,
        H = e)) : ($ = H,
        H = e),
        H !== e ? A = n.substring(A, $) : A = H,
        A === e && (A = n.charAt($),
        ye.test(A) ? $++ : (A = e,
        we === 0 && tt(It)),
        A === e && (A = $,
        n.charCodeAt($) === 92 ? (H = B,
        $++) : (H = e,
        we === 0 && tt(Bt)),
        H !== e ? (ne = ra(),
        ne !== e ? A = ne : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = ho()))),
        A
    }
    function ki() {
        var A, H, ne, ue;
        return A = $,
        H = $,
        ne = $,
        we++,
        ue = n.charAt($),
        qe.test(ue) ? $++ : (ue = e,
        we === 0 && tt(yn)),
        ue === e && (ue = Qa()),
        we--,
        ue === e ? ne = void 0 : ($ = ne,
        ne = e),
        ne !== e ? (ue = ui(),
        ue !== e ? (ne = [ne, ue],
        H = ne) : ($ = H,
        H = e)) : ($ = H,
        H = e),
        H !== e ? A = n.substring(A, $) : A = H,
        A === e && (A = n.charAt($),
        ye.test(A) ? $++ : (A = e,
        we === 0 && tt(It)),
        A === e && (A = $,
        n.charCodeAt($) === 92 ? (H = B,
        $++) : (H = e,
        we === 0 && tt(Bt)),
        H !== e ? (ne = ra(),
        ne !== e ? A = ne : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = ho()))),
        A
    }
    function ho() {
        var A, H, ne;
        return A = $,
        n.charCodeAt($) === 92 ? (H = B,
        $++) : (H = e,
        we === 0 && tt(Bt)),
        H !== e ? (ne = po(),
        ne !== e ? (en = A,
        A = _n()) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function ra() {
        var A, H, ne, ue;
        return A = Za(),
        A === e && (A = $,
        n.charCodeAt($) === 48 ? (H = E,
        $++) : (H = e,
        we === 0 && tt(Ze)),
        H !== e ? (ne = $,
        we++,
        ue = Ne(),
        we--,
        ue === e ? ne = void 0 : ($ = ne,
        ne = e),
        ne !== e ? (en = A,
        A = ws()) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = oe(),
        A === e && (A = ve()))),
        A
    }
    function Za() {
        var A;
        return A = O(),
        A === e && (A = U()),
        A
    }
    function O() {
        var A, H;
        return A = n.charAt($),
        Ge.test(A) ? $++ : (A = e,
        we === 0 && tt(qt)),
        A === e && (A = $,
        n.charCodeAt($) === 98 ? (H = Q,
        $++) : (H = e,
        we === 0 && tt(Nt)),
        H !== e && (en = A,
        H = an()),
        A = H,
        A === e && (A = $,
        n.charCodeAt($) === 102 ? (H = ae,
        $++) : (H = e,
        we === 0 && tt(xt)),
        H !== e && (en = A,
        H = fn()),
        A = H,
        A === e && (A = $,
        n.charCodeAt($) === 110 ? (H = V,
        $++) : (H = e,
        we === 0 && tt(Lt)),
        H !== e && (en = A,
        H = lo()),
        A = H,
        A === e && (A = $,
        n.charCodeAt($) === 114 ? (H = k,
        $++) : (H = e,
        we === 0 && tt(pe)),
        H !== e && (en = A,
        H = si()),
        A = H,
        A === e && (A = $,
        n.charCodeAt($) === 116 ? (H = z,
        $++) : (H = e,
        we === 0 && tt(Pe)),
        H !== e && (en = A,
        H = Es()),
        A = H,
        A === e && (A = $,
        n.charCodeAt($) === 118 ? (H = Z,
        $++) : (H = e,
        we === 0 && tt(Xe)),
        H !== e && (en = A,
        H = Di()),
        A = H)))))),
        A
    }
    function U() {
        var A, H, ne, ue;
        return A = $,
        H = $,
        ne = $,
        we++,
        ue = ee(),
        ue === e && (ue = Qa()),
        we--,
        ue === e ? ne = void 0 : ($ = ne,
        ne = e),
        ne !== e ? (ue = ui(),
        ue !== e ? (ne = [ne, ue],
        H = ne) : ($ = H,
        H = e)) : ($ = H,
        H = e),
        H !== e ? A = n.substring(A, $) : A = H,
        A
    }
    function ee() {
        var A;
        return A = O(),
        A === e && (A = n.charAt($),
        Se.test(A) ? $++ : (A = e,
        we === 0 && tt(ft))),
        A
    }
    function oe() {
        var A, H, ne, ue, We, lt;
        return A = $,
        n.charCodeAt($) === 120 ? (H = re,
        $++) : (H = e,
        we === 0 && tt(Ht)),
        H !== e ? (ne = $,
        ue = $,
        We = Tn(),
        We !== e ? (lt = Tn(),
        lt !== e ? (We = [We, lt],
        ue = We) : ($ = ue,
        ue = e)) : ($ = ue,
        ue = e),
        ue !== e ? ne = n.substring(ne, $) : ne = ue,
        ne !== e ? (en = A,
        A = ii(ne)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function ve() {
        var A, H, ne, ue, We, lt, $n, Ln;
        return A = $,
        n.charCodeAt($) === 117 ? (H = C,
        $++) : (H = e,
        we === 0 && tt(Yt)),
        H !== e ? (ne = $,
        ue = $,
        We = Tn(),
        We !== e ? (lt = Tn(),
        lt !== e ? ($n = Tn(),
        $n !== e ? (Ln = Tn(),
        Ln !== e ? (We = [We, lt, $n, Ln],
        ue = We) : ($ = ue,
        ue = e)) : ($ = ue,
        ue = e)) : ($ = ue,
        ue = e)) : ($ = ue,
        ue = e),
        ue !== e ? ne = n.substring(ne, $) : ne = ue,
        ne !== e ? (en = A,
        A = it(ne)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function Ne() {
        var A;
        return A = n.charAt($),
        Le.test(A) ? $++ : (A = e,
        we === 0 && tt(_e)),
        A
    }
    function Tn() {
        var A;
        return A = n.charAt($),
        L.test(A) ? $++ : (A = e,
        we === 0 && tt($r)),
        A
    }
    function dn() {
        var A, H;
        for (we++,
        A = [],
        H = Ya(),
        H === e && (H = po(),
        H === e && (H = zi())); H !== e; )
            A.push(H),
            H = Ya(),
            H === e && (H = po(),
            H === e && (H = zi()));
        return we--,
        H = e,
        we === 0 && tt(Ds),
        A
    }
    function Kf() {
        var A, H;
        return A = $,
        we++,
        n.length > $ ? (H = n.charAt($),
        $++) : (H = e,
        we === 0 && tt(xi)),
        we--,
        H === e ? A = void 0 : ($ = A,
        A = e),
        A
    }
    function Ya() {
        var A;
        return A = n.charAt($),
        K.test(A) ? $++ : (A = e,
        we === 0 && tt(vs)),
        A === e && (A = Zf()),
        A
    }
    function Qa() {
        var A;
        return we++,
        A = n.charAt($),
        de.test(A) ? $++ : (A = e,
        we === 0 && tt(as)),
        we--,
        A === e && we === 0 && tt(ys),
        A
    }
    function po() {
        var A, H, ne, ue;
        return we++,
        n.charCodeAt($) === 10 ? (A = D,
        $++) : (A = e,
        we === 0 && tt(Ii)),
        A === e && (A = $,
        n.charCodeAt($) === 13 ? (H = R,
        $++) : (H = e,
        we === 0 && tt(qs)),
        H !== e ? (ne = $,
        we++,
        n.charCodeAt($) === 10 ? (ue = D,
        $++) : (ue = e,
        we === 0 && tt(Ii)),
        we--,
        ue === e ? ne = void 0 : ($ = ne,
        ne = e),
        ne !== e ? (H = [H, ne],
        A = H) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = n.charAt($),
        ye.test(A) ? $++ : (A = e,
        we === 0 && tt(It)),
        A === e && (n.substr($, 2) === W ? (A = W,
        $ += 2) : (A = e,
        we === 0 && tt(Fi))))),
        we--,
        A === e && (H = e,
        we === 0 && tt(ri)),
        A
    }
    function Zf() {
        var A, H, ne;
        return A = $,
        H = ui(),
        H !== e ? (en = $,
        ne = uo(H),
        ne ? ne = void 0 : ne = e,
        ne !== e ? (H = [H, ne],
        A = H) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A
    }
    function ui() {
        var A;
        return we++,
        A = Yf(),
        A === e && (A = du()),
        we--,
        A === e && we === 0 && tt(Jo),
        A
    }
    function Yf() {
        var A;
        return A = n.charAt($),
        $e.test(A) ? $++ : (A = e,
        we === 0 && tt(Ri)),
        A
    }
    function du() {
        var A, H, ne, ue;
        return A = $,
        H = $,
        ne = n.charAt($),
        Re.test(ne) ? $++ : (ne = e,
        we === 0 && tt(Ko)),
        ne !== e ? (ue = n.charAt($),
        me.test(ue) ? $++ : (ue = e,
        we === 0 && tt(ro)),
        ue !== e ? (ne = [ne, ue],
        H = ne) : ($ = H,
        H = e)) : ($ = H,
        H = e),
        H !== e ? A = n.substring(A, $) : A = H,
        A === e && (A = n.charAt($),
        T.test(A) ? $++ : (A = e,
        we === 0 && tt(Zo))),
        A
    }
    function zi() {
        var A, H, ne, ue, We, lt;
        if (A = $,
        n.substr($, 2) === I ? (H = I,
        $ += 2) : (H = e,
        we === 0 && tt(Mr)),
        H !== e) {
            for (ne = [],
            ue = $,
            We = $,
            we++,
            n.substr($, 2) === I ? (lt = I,
            $ += 2) : (lt = e,
            we === 0 && tt(Mr)),
            lt === e && (n.substr($, 2) === N ? (lt = N,
            $ += 2) : (lt = e,
            we === 0 && tt(bs))),
            we--,
            lt === e ? We = void 0 : ($ = We,
            We = e),
            We !== e ? (lt = ui(),
            lt !== e ? (We = [We, lt],
            ue = We) : ($ = ue,
            ue = e)) : ($ = ue,
            ue = e),
            ue === e && (ue = zi()); ue !== e; )
                ne.push(ue),
                ue = $,
                We = $,
                we++,
                n.substr($, 2) === I ? (lt = I,
                $ += 2) : (lt = e,
                we === 0 && tt(Mr)),
                lt === e && (n.substr($, 2) === N ? (lt = N,
                $ += 2) : (lt = e,
                we === 0 && tt(bs))),
                we--,
                lt === e ? We = void 0 : ($ = We,
                We = e),
                We !== e ? (lt = ui(),
                lt !== e ? (We = [We, lt],
                ue = We) : ($ = ue,
                ue = e)) : ($ = ue,
                ue = e),
                ue === e && (ue = zi());
            n.substr($, 2) === N ? (ue = N,
            $ += 2) : (ue = e,
            we === 0 && tt(bs)),
            ue !== e ? (H = [H, ne, ue],
            A = H) : ($ = A,
            A = e)
        } else
            $ = A,
            A = e;
        return A
    }
    function hu() {
        var A, H, ne, ue, We, lt;
        return A = $,
        H = Bi(),
        ne = fo(),
        ne !== e ? (n.charCodeAt($) === 47 ? (ue = P,
        $++) : (ue = e,
        we === 0 && tt(so)),
        ue !== e ? (We = Ja(),
        We !== e ? (en = A,
        A = cu(H, ne, ue, We)) : ($ = A,
        A = e)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = $,
        H = Bi(),
        ne = fo(),
        ne !== e ? (n.charCodeAt($) === 46 ? (ue = F,
        $++) : (ue = e,
        we === 0 && tt(ct)),
        ue !== e ? (We = ea(),
        lt = ta(),
        lt === e && (lt = null),
        en = A,
        A = Ba(H, ne, ue, We, lt)) : ($ = A,
        A = e)) : ($ = A,
        A = e),
        A === e && (A = $,
        H = Bi(),
        ne = fo(),
        ne !== e ? (ue = ta(),
        ue === e && (ue = null),
        en = A,
        A = ka(H, ne, ue)) : ($ = A,
        A = e))),
        A
    }
    function mo() {
        var A, H, ne, ue, We, lt;
        for (A = [],
        H = hu(); H !== e; )
            A.push(H),
            H = $,
            ne = $,
            ue = dn(),
            n.charCodeAt($) === 44 ? (We = J,
            $++) : (We = e,
            we === 0 && tt(Bs)),
            We === e && (We = null),
            lt = dn(),
            ue = [ue, We, lt],
            ne = ue,
            ne = hu(),
            ne === e ? ($ = H,
            H = e) : H = ne;
        return A
    }
    if (Ls = a(),
    t.peg$library)
        return {
            peg$result: Ls,
            peg$currPos: $,
            peg$FAILED: e,
            peg$maxFailExpected: oi,
            peg$maxFailPos: Or
        };
    if (Ls !== e && $ === n.length)
        return Ls;
    throw Ls !== e && $ < n.length && tt(za()),
    kr(oi, Or < n.length ? n.charAt(Or) : null, Or < n.length ? us(Or, Or + 1) : us(Or, Or))
}
var yz = {
    StartRules: ["Start"],
    SyntaxError: Bo,
    parse: vz
};
Object.defineProperty(qo, "__esModule", {
    value: !0
});
qo.repl = qo.toSonicWeaveInterchange = qo.toScalaScl = void 0;
const gS = Df
  , ec = K1
  , bz = yz
  , wz = pt
  , {version: vS} = uS;
function Ez(n) {
    const t = (0,
    ec.evaluateSource)(n)
      , e = [];
    let r = !1;
    const i = [`!Created using SonicWeave ${vS}`, "!"];
    i.push(t.rootContext.title || "Untitled tuning");
    const a = t.mutables.get("$");
    i.push(` ${a.length}`),
    i.push("!");
    const l = gS.relative.bind(t);
    for (const f of a) {
        f.color ? (e.push(f.color.value),
        r = !0) : e.push("#808080");
        const p = l(f).value;
        let m;
        p.isFractional() ? m = p.toFraction().abs().toFraction() : m = p.totalCents(!0).toFixed(6);
        const g = f.label ? " " + f.label : "";
        i.push(` ${m}${g}`)
    }
    return r && (e.unshift(e.pop()),
    i.push("! A list of key colors, ascending from 1/1"),
    i.push("! " + e.join(" "))),
    i.push(""),
    i.join(`
`)
}
qo.toScalaScl = Ez;
function _z(n) {
    const t = (0,
    ec.evaluateSource)(n)
      , e = t.rootContext;
    if (!e)
        throw new Error("Missing root context.");
    const r = [`(* Created using SonicWeave ${vS} *)`, ""];
    if (r.push(JSON.stringify(e.title)),
    r.push(""),
    e.unisonFrequency) {
        const i = (0,
        wz.literalToString)(e.unisonFrequency.asInterchangeLiteral());
        r.push(`1 = ${i}`),
        r.push("")
    }
    for (const i of t.currentScale) {
        const a = i.shallowClone();
        a.node = a.asMonzoLiteral(!0);
        let l = a.toString(e, !0);
        l.startsWith("(") && l.endsWith(")") && (l = l.slice(1, -1)),
        r.push(l)
    }
    return r.push(""),
    r.join(`
`)
}
qo.toSonicWeaveInterchange = _z;
const HE = " ";
function Lz(n) {
    const t = (0,
    ec.getSourceVisitor)()
      , e = new ec.StatementVisitor(t);
    let r = "";
    function i(a, l, f, h) {
        r += a;
        let p;
        try {
            p = (0,
            bz.parse)(r)
        } catch (m) {
            if (m instanceof Error)
                h(m, void 0);
            else
                throw m;
            return
        }
        if (p.curlies < 0) {
            r = "",
            h(new Error("Unmatched closing curly bracket."), void 0);
            return
        }
        if (p.squares < 0) {
            r = "",
            h(new Error("Unmatched closing square bracket."), void 0);
            return
        }
        if (p.parens < 0) {
            r = "",
            h(new Error("Unmatched closing parenthesis."), void 0);
            return
        }
        if (p.parens || p.squares || p.curlies) {
            this.setPrompt("... "),
            this.displayPrompt();
            return
        }
        this.setPrompt(HE);
        try {
            const m = (0,
            ec.parseAST)(r);
            if (r = "",
            !m.body.length) {
                h(null, null);
                return
            }
            for (const b of m.body.slice(0, -1))
                if (e.visit(b))
                    throw new Error("Illegal statement.");
            const g = m.body[m.body.length - 1];
            if (g.type === "ExpressionStatement") {
                const b = e.createExpressionVisitor()
                  , E = b.visit(g.expression);
                e.handleValue(E, b),
                h(null, E)
            } else {
                if (e.visit(g))
                    throw new Error("Illegal statement.");
                h(null, null)
            }
        } catch (m) {
            if (r = "",
            typeof m == "string" && (m = new Error(m)),
            m instanceof Error)
                h(m, void 0);
            else
                throw m
        }
    }
    n({
        prompt: HE,
        eval: i,
        writer: gS.repr.bind(e.createExpressionVisitor()),
        terminal: !0,
        completer: () => []
    })
}
qo.repl = Lz;
var Vm = {};
function Sz(n) {
    return {
        type: "PlainLiteral",
        value: n
    }
}
function Az(n, t) {
    return {
        type: "CentsLiteral",
        whole: n,
        fractional: t
    }
}
function Cz(n, t) {
    return {
        type: "NumericLiteral",
        whole: n,
        fractional: t
    }
}
function $z(n, t) {
    return {
        type: "FractionLiteral",
        numerator: n,
        denominator: t
    }
}
function Mz(n, t, e) {
    return {
        type: "EdjiFraction",
        numerator: n,
        denominator: t,
        equave: e
    }
}
function Oz(n) {
    return {
        type: "Monzo",
        components: n
    }
}
function Nz(n, t, e) {
    return {
        type: "BinaryExpression",
        operator: n,
        left: t,
        right: e
    }
}
function Tz(n, t) {
    return {
        type: "UnaryExpression",
        operator: n,
        operand: t
    }
}
function xz(n, t) {
    const e = n
      , [r,i] = t;
    return Nz(r, e, i)
}
function Iz(n, t) {
    function e() {
        this.constructor = n
    }
    e.prototype = t.prototype,
    n.prototype = new e
}
function Pa(n, t, e, r) {
    var i = Error.call(this, n);
    return Object.setPrototypeOf && Object.setPrototypeOf(i, Pa.prototype),
    i.expected = t,
    i.found = e,
    i.location = r,
    i.name = "SyntaxError",
    i
}
Iz(Pa, Error);
function Dv(n, t, e) {
    return e = e || " ",
    n.length > t ? n : (t -= n.length,
    e += e.repeat(t),
    n + e.slice(0, t))
}
Pa.prototype.format = function(n) {
    var t = "Error: " + this.message;
    if (this.location) {
        var e = null, r;
        for (r = 0; r < n.length; r++)
            if (n[r].source === this.location.source) {
                e = n[r].text.split(/\r\n|\n|\r/g);
                break
            }
        var i = this.location.start
          , a = this.location.source && typeof this.location.source.offset == "function" ? this.location.source.offset(i) : i
          , l = this.location.source + ":" + a.line + ":" + a.column;
        if (e) {
            var f = this.location.end
              , h = Dv("", a.line.toString().length, " ")
              , p = e[i.line - 1]
              , m = i.line === f.line ? f.column : p.length + 1
              , g = m - i.column || 1;
            t += `
 --> ` + l + `
` + h + ` |
` + a.line + " | " + p + `
` + h + " | " + Dv("", i.column - 1, " ") + Dv("", g, "^")
        } else
            t += `
 at ` + l
    }
    return t
}
;
Pa.buildMessage = function(n, t) {
    var e = {
        literal: function(p) {
            return '"' + i(p.text) + '"'
        },
        class: function(p) {
            var m = p.parts.map(function(g) {
                return Array.isArray(g) ? a(g[0]) + "-" + a(g[1]) : a(g)
            });
            return "[" + (p.inverted ? "^" : "") + m.join("") + "]"
        },
        any: function() {
            return "any character"
        },
        end: function() {
            return "end of input"
        },
        other: function(p) {
            return p.description
        }
    };
    function r(p) {
        return p.charCodeAt(0).toString(16).toUpperCase()
    }
    function i(p) {
        return p.replace(/\\/g, "\\\\").replace(/"/g, '\\"').replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function a(p) {
        return p.replace(/\\/g, "\\\\").replace(/\]/g, "\\]").replace(/\^/g, "\\^").replace(/-/g, "\\-").replace(/\0/g, "\\0").replace(/\t/g, "\\t").replace(/\n/g, "\\n").replace(/\r/g, "\\r").replace(/[\x00-\x0F]/g, function(m) {
            return "\\x0" + r(m)
        }).replace(/[\x10-\x1F\x7F-\x9F]/g, function(m) {
            return "\\x" + r(m)
        })
    }
    function l(p) {
        return e[p.type](p)
    }
    function f(p) {
        var m = p.map(l), g, b;
        if (m.sort(),
        m.length > 0) {
            for (g = 1,
            b = 1; g < m.length; g++)
                m[g - 1] !== m[g] && (m[b] = m[g],
                b++);
            m.length = b
        }
        switch (m.length) {
        case 1:
            return m[0];
        case 2:
            return m[0] + " or " + m[1];
        default:
            return m.slice(0, -1).join(", ") + ", or " + m[m.length - 1]
        }
    }
    function h(p) {
        return p ? '"' + i(p) + '"' : "end of input"
    }
    return "Expected " + f(n) + " but " + h(t) + " found."
}
;
function Fz(n, t) {
    t = t !== void 0 ? t : {};
    var e = {}, r = t.grammarSource, i = {
        Start: He
    }, a = He, l = "0", f = "-", h = ".", p = ",", m = "/", g = "<", b = ">", E = "\\", S = "[", F = /^[\t-\r \xA0\u1680\u2000-\u200A\u2028-\u2029\u202F\u205F\u3000\uFEFF]/, B = /^[+\-]/, Q = /^[1-9]/, ae = /^[0-9]/, V = Me("whitespace"), k = j([["	", "\r"], " ", "", "", ["", ""], ["\u2028", "\u2029"], "", "", "", "\uFEFF"], !1, !1), z = j(["+", "-"], !1, !1), Z = T("0", !1), re = j([["1", "9"]], !1, !1), C = j([["0", "9"]], !1, !1), D = T("-", !1), R = T(".", !1), W = T(",", !1), I = T("/", !1), N = T("<", !1), P = T(">", !1), J = T("\\", !1), X = T("[", !1), ie = function(pe, Pe) {
        return Pe.reduce(xz, pe)
    }, ce = function(pe) {
        return BigInt(pe)
    }, Le = function(pe, Pe) {
        return pe ? -Pe : Pe
    }, he = function(pe, Pe) {
        return Az(pe, Pe)
    }, Fe = function(pe, Pe) {
        return Cz(pe, Pe)
    }, Te = function(pe, Pe) {
        return $z(pe, Pe)
    }, ye = function(pe) {
        return Sz(pe)
    }, qe = function(pe, Pe, Xe) {
        return Mz(pe, Pe, Xe)
    }, Ge = function(pe) {
        return Oz(pe)
    }, Se = function(pe, Pe) {
        return Tz(pe, Pe)
    }, L = t.peg$currPos | 0, K = [{
        line: 1,
        column: 1
    }], de = L, $e = t.peg$maxFailExpected || [], Re = t.peg$silentFails | 0, me;
    if (t.startRule) {
        if (!(t.startRule in i))
            throw new Error(`Can't start parsing from rule "` + t.startRule + '".');
        a = i[t.startRule]
    }
    function T(pe, Pe) {
        return {
            type: "literal",
            text: pe,
            ignoreCase: Pe
        }
    }
    function j(pe, Pe, Xe) {
        return {
            type: "class",
            parts: pe,
            inverted: Pe,
            ignoreCase: Xe
        }
    }
    function ge() {
        return {
            type: "end"
        }
    }
    function Me(pe) {
        return {
            type: "other",
            description: pe
        }
    }
    function Oe(pe) {
        var Pe = K[pe], Xe;
        if (Pe)
            return Pe;
        if (pe >= K.length)
            Xe = K.length - 1;
        else
            for (Xe = pe; !K[--Xe]; )
                ;
        for (Pe = K[Xe],
        Pe = {
            line: Pe.line,
            column: Pe.column
        }; Xe < pe; )
            n.charCodeAt(Xe) === 10 ? (Pe.line++,
            Pe.column = 1) : Pe.column++,
            Xe++;
        return K[pe] = Pe,
        Pe
    }
    function Be(pe, Pe, Xe) {
        var ft = Oe(pe)
          , Ht = Oe(Pe)
          , Yt = {
            source: r,
            start: {
                offset: pe,
                line: ft.line,
                column: ft.column
            },
            end: {
                offset: Pe,
                line: Ht.line,
                column: Ht.column
            }
        };
        return Xe && r && typeof r.offset == "function" && (Yt.start = r.offset(Yt.start),
        Yt.end = r.offset(Yt.end)),
        Yt
    }
    function ze(pe) {
        L < de || (L > de && (de = L,
        $e = []),
        $e.push(pe))
    }
    function Ye(pe, Pe, Xe) {
        return new Pa(Pa.buildMessage(pe, Pe),pe,Pe,Xe)
    }
    function He() {
        var pe;
        return pe = rt(),
        pe
    }
    function Ue() {
        var pe;
        return Re++,
        pe = n.charAt(L),
        F.test(pe) ? L++ : (pe = e,
        Re === 0 && ze(k)),
        Re--,
        pe === e && Re === 0 && ze(V),
        pe
    }
    function at() {
        var pe, Pe;
        for (pe = [],
        Pe = Ue(); Pe !== e; )
            pe.push(Pe),
            Pe = Ue();
        return pe
    }
    function rt() {
        var pe, Pe, Xe, ft, Ht, Yt;
        if (pe = L,
        Pe = _e(),
        Pe !== e) {
            for (Xe = [],
            ft = L,
            at(),
            Ht = n.charAt(L),
            B.test(Ht) ? L++ : (Ht = e,
            Re === 0 && ze(z)),
            Ht !== e ? (at(),
            Yt = _e(),
            Yt !== e ? ft = [Ht, Yt] : (L = ft,
            ft = e)) : (L = ft,
            ft = e); ft !== e; )
                Xe.push(ft),
                ft = L,
                at(),
                Ht = n.charAt(L),
                B.test(Ht) ? L++ : (Ht = e,
                Re === 0 && ze(z)),
                Ht !== e ? (at(),
                Yt = _e(),
                Yt !== e ? ft = [Ht, Yt] : (L = ft,
                ft = e)) : (L = ft,
                ft = e);
            pe = ie(Pe, Xe)
        } else
            L = pe,
            pe = e;
        return pe
    }
    function _e() {
        var pe, Pe;
        return pe = L,
        at(),
        Pe = Lt(),
        Pe === e && (Pe = xe()),
        Pe !== e ? (at(),
        pe = Pe) : (L = pe,
        pe = e),
        pe
    }
    function xe() {
        var pe;
        return pe = ct(),
        pe === e && (pe = Et(),
        pe === e && (pe = It(),
        pe === e && (pe = qt(),
        pe === e && (pe = xt(),
        pe === e && (pe = Bt()))))),
        pe
    }
    function Ze() {
        var pe, Pe, Xe, ft, Ht, Yt;
        if (pe = L,
        Pe = L,
        n.charCodeAt(L) === 48 ? (Xe = l,
        L++) : (Xe = e,
        Re === 0 && ze(Z)),
        Xe === e)
            if (Xe = L,
            ft = n.charAt(L),
            Q.test(ft) ? L++ : (ft = e,
            Re === 0 && ze(re)),
            ft !== e) {
                for (Ht = [],
                Yt = n.charAt(L),
                ae.test(Yt) ? L++ : (Yt = e,
                Re === 0 && ze(C)); Yt !== e; )
                    Ht.push(Yt),
                    Yt = n.charAt(L),
                    ae.test(Yt) ? L++ : (Yt = e,
                    Re === 0 && ze(C));
                ft = [ft, Ht],
                Xe = ft
            } else
                L = Xe,
                Xe = e;
        return Xe !== e ? Pe = n.substring(Pe, L) : Pe = Xe,
        Pe !== e && (Pe = ce(Pe)),
        pe = Pe,
        pe
    }
    function st() {
        var pe, Pe, Xe;
        for (pe = L,
        Pe = [],
        Xe = n.charAt(L),
        ae.test(Xe) ? L++ : (Xe = e,
        Re === 0 && ze(C)); Xe !== e; )
            Pe.push(Xe),
            Xe = n.charAt(L),
            ae.test(Xe) ? L++ : (Xe = e,
            Re === 0 && ze(C));
        return pe = n.substring(pe, L),
        pe
    }
    function je() {
        var pe, Pe, Xe;
        return pe = L,
        n.charCodeAt(L) === 45 ? (Pe = f,
        L++) : (Pe = e,
        Re === 0 && ze(D)),
        Pe === e && (Pe = null),
        Xe = Ze(),
        Xe !== e ? pe = Le(Pe, Xe) : (L = pe,
        pe = e),
        pe
    }
    function ct() {
        var pe, Pe, Xe, ft;
        return pe = L,
        Pe = Ze(),
        Pe === e && (Pe = null),
        n.charCodeAt(L) === 46 ? (Xe = h,
        L++) : (Xe = e,
        Re === 0 && ze(R)),
        Xe !== e ? (ft = st(),
        pe = he(Pe, ft)) : (L = pe,
        pe = e),
        pe
    }
    function Et() {
        var pe, Pe, Xe, ft;
        return pe = L,
        Pe = Ze(),
        Pe === e && (Pe = null),
        n.charCodeAt(L) === 44 ? (Xe = p,
        L++) : (Xe = e,
        Re === 0 && ze(W)),
        Xe !== e ? (ft = st(),
        pe = Fe(Pe, ft)) : (L = pe,
        pe = e),
        pe
    }
    function It() {
        var pe, Pe, Xe, ft;
        return pe = L,
        Pe = Ze(),
        Pe !== e ? (n.charCodeAt(L) === 47 ? (Xe = m,
        L++) : (Xe = e,
        Re === 0 && ze(I)),
        Xe !== e ? (ft = Ze(),
        ft !== e ? pe = Te(Pe, ft) : (L = pe,
        pe = e)) : (L = pe,
        pe = e)) : (L = pe,
        pe = e),
        pe
    }
    function Bt() {
        var pe, Pe;
        return pe = L,
        Pe = Ze(),
        Pe !== e && (Pe = ye(Pe)),
        pe = Pe,
        pe
    }
    function yn() {
        var pe, Pe, Xe, ft;
        return pe = L,
        n.charCodeAt(L) === 60 ? (Pe = g,
        L++) : (Pe = e,
        Re === 0 && ze(N)),
        Pe !== e ? (at(),
        Xe = It(),
        Xe === e && (Xe = Bt()),
        Xe !== e ? (at(),
        n.charCodeAt(L) === 62 ? (ft = b,
        L++) : (ft = e,
        Re === 0 && ze(P)),
        ft !== e ? pe = Xe : (L = pe,
        pe = e)) : (L = pe,
        pe = e)) : (L = pe,
        pe = e),
        pe
    }
    function qt() {
        var pe, Pe, Xe, ft, Ht;
        return pe = L,
        Pe = Ze(),
        Pe === e && (Pe = null),
        n.charCodeAt(L) === 92 ? (Xe = E,
        L++) : (Xe = e,
        Re === 0 && ze(J)),
        Xe !== e ? (ft = je(),
        ft !== e ? (Ht = yn(),
        Ht === e && (Ht = null),
        pe = qe(Pe, ft, Ht)) : (L = pe,
        pe = e)) : (L = pe,
        pe = e),
        pe
    }
    function Nt() {
        var pe, Pe, Xe, ft;
        return pe = L,
        Pe = L,
        Xe = n.charAt(L),
        B.test(Xe) ? L++ : (Xe = e,
        Re === 0 && ze(z)),
        Xe === e && (Xe = null),
        ft = It(),
        ft === e && (ft = Bt()),
        ft !== e ? (Xe = [Xe, ft],
        Pe = Xe) : (L = Pe,
        Pe = e),
        Pe !== e ? pe = n.substring(pe, L) : pe = Pe,
        pe
    }
    function xt() {
        var pe, Pe, Xe, ft, Ht, Yt, $r, Ds;
        if (pe = L,
        n.charCodeAt(L) === 91 ? (Pe = S,
        L++) : (Pe = e,
        Re === 0 && ze(X)),
        Pe !== e) {
            for (Xe = [],
            ft = Nt(); ft !== e; )
                Xe.push(ft),
                ft = L,
                Ht = L,
                Yt = at(),
                n.charCodeAt(L) === 44 ? ($r = p,
                L++) : ($r = e,
                Re === 0 && ze(W)),
                $r === e && ($r = null),
                Ds = at(),
                Yt = [Yt, $r, Ds],
                Ht = Yt,
                Ht = Nt(),
                Ht === e ? (L = ft,
                ft = e) : ft = Ht;
            n.charCodeAt(L) === 62 ? (ft = b,
            L++) : (ft = e,
            Re === 0 && ze(P)),
            ft !== e ? pe = Ge(Xe) : (L = pe,
            pe = e)
        } else
            L = pe,
            pe = e;
        return pe
    }
    function Lt() {
        var pe, Pe, Xe;
        return pe = L,
        n.charCodeAt(L) === 45 ? (Pe = f,
        L++) : (Pe = e,
        Re === 0 && ze(D)),
        Pe !== e ? (Xe = xe(),
        Xe !== e ? pe = Se(Pe, Xe) : (L = pe,
        pe = e)) : (L = pe,
        pe = e),
        pe
    }
    if (me = a(),
    t.peg$library)
        return {
            peg$result: me,
            peg$currPos: L,
            peg$FAILED: e,
            peg$maxFailExpected: $e,
            peg$maxFailPos: de
        };
    if (me !== e && L === n.length)
        return me;
    throw me !== e && L < n.length && ze(ge()),
    Ye($e, de < n.length ? n.charAt(de) : null, de < n.length ? Be(de, de + 1) : Be(de, de))
}
var Rz = {
    StartRules: ["Start"],
    SyntaxError: Pa,
    parse: Fz
};
Object.defineProperty(Vm, "__esModule", {
    value: !0
});
Vm.parseScaleWorkshop2Line = void 0;
const Ir = Ie
  , Qi = An
  , Pz = Rz
  , yi = hn
  , Dz = pt
  , yS = new Ir.Fraction(0);
function qz(n) {
    return (0,
    Pz.parse)(n)
}
function Bz(n, t) {
    const e = {
        type: "DecimalLiteral",
        sign: "",
        whole: n.whole ?? 0n,
        fractional: n.fractional ?? "",
        flavor: "e",
        exponent: null
    };
    let r = e.whole
      , i = 1n;
    for (const l of e.fractional)
        r = 10n * r + BigInt(l),
        i *= 10n;
    const a = Qi.TimeMonzo.fromBigNumeratorDenominator(r, i, t);
    return new yi.Interval(a,"linear",0,e)
}
function kz(n, t) {
    const e = {
        type: "CentsLiteral",
        sign: "",
        whole: n.whole ?? 0n,
        fractional: n.fractional ?? "",
        exponent: null,
        real: !1
    };
    let r = e.whole
      , i = 1200n;
    for (const f of e.fractional)
        r = 10n * r + BigInt(f),
        i *= 10n;
    const a = (0,
    Ir.gcd)(r, i);
    r = Number(r / a),
    i = Number(i / a);
    let l;
    try {
        l = new Qi.TimeMonzo(yS,[new Ir.Fraction(r,i)]),
        l.numberOfComponents = t
    } catch {
        l = Qi.TimeReal.fromCents(1200 * r / i)
    }
    return new yi.Interval(l,"logarithmic",0,e)
}
function zz(n, t, e=!1, r=!0) {
    const i = qz(n);
    if (!r && i.type === "UnaryExpression" && i.operand.type !== "CentsLiteral")
        throw new Error("Universal minus violation.");
    if (!e && (i.type === "PlainLiteral" || i.type === "UnaryExpression" && i.operand.type === "PlainLiteral"))
        throw new Error("Bare numbers not allowed.");
    return t ?? (t = (0,
    Qi.getNumberOfComponents)()),
    eh(i, t)
}
Vm.parseScaleWorkshop2Line = zz;
function eh(n, t) {
    var a, l;
    switch (n.type) {
    case "PlainLiteral":
        return new yi.Interval(Qi.TimeMonzo.fromBigInt(n.value, t),"linear",0,{
            type: "IntegerLiteral",
            value: n.value
        });
    case "CentsLiteral":
        return kz(n, t);
    case "NumericLiteral":
        return Bz(n, t);
    case "FractionLiteral":
        return new yi.Interval(Qi.TimeMonzo.fromBigNumeratorDenominator(n.numerator, n.denominator, t),"linear",0,{
            type: "FractionLiteral",
            numerator: n.numerator,
            denominator: n.denominator
        })
    }
    if (n.type === "EdjiFraction") {
        const f = {
            type: "NedjiLiteral",
            numerator: Number(n.numerator),
            denominator: Number(n.denominator),
            equaveNumerator: null,
            equaveDenominator: null
        }
          , h = new Ir.Fraction(f.numerator,f.denominator);
        let p;
        return ((a = n.equave) == null ? void 0 : a.type) === "PlainLiteral" ? (f.equaveNumerator = Number(n.equave.value),
        p = new Ir.Fraction(f.equaveNumerator)) : ((l = n.equave) == null ? void 0 : l.type) === "FractionLiteral" && (f.equaveNumerator = Number(n.equave.numerator),
        f.equaveDenominator = Number(n.equave.denominator),
        p = new Ir.Fraction(f.equaveNumerator,f.equaveDenominator)),
        new yi.Interval(Qi.TimeMonzo.fromEqualTemperament(h, p, t),"logarithmic",0,f)
    } else if (n.type === "Monzo") {
        const f = n.components.map(m => new Ir.Fraction(m));
        for (; f.length < t; )
            f.push(new Ir.Fraction(0));
        let h = new Ir.Fraction(1)
          , p = 0;
        for (; f.length > t; ) {
            const m = new Ir.Fraction(f.pop())
              , g = new Ir.Fraction(Ir.PRIMES[f.length]).pow(m);
            g === null ? p += m.valueOf() * Ir.PRIME_CENTS[f.length] : h = h.mul(g)
        }
        return p ? new yi.Interval(Qi.TimeReal.fromCents((0,
        Ir.dot)(Ir.PRIME_CENTS, f.map(m => m.valueOf())) + p + (0,
        Ir.valueToCents)(h.valueOf())),"logarithmic") : new yi.Interval(new Qi.TimeMonzo(yS,f,h),"logarithmic")
    } else if (n.type === "UnaryExpression") {
        const f = eh(n.operand, t);
        return new yi.Interval(f.value.inverse(),f.domain,0,(0,
        Dz.uniformInvertNode)(f.node),f)
    }
    const e = eh(n.left, t)
      , r = eh(n.right, t);
    let i = "linear";
    return (e.domain === "logarithmic" || r.domain === "logarithmic") && (i = "logarithmic"),
    n.operator === "+" ? new yi.Interval(e.value.mul(r.value),i) : new yi.Interval(e.value.div(r.value),i)
}
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(i, a, l, f) {
        f === void 0 && (f = l);
        var h = Object.getOwnPropertyDescriptor(a, l);
        (!h || ("get"in h ? !a.__esModule : h.writable || h.configurable)) && (h = {
            enumerable: !0,
            get: function() {
                return a[l]
            }
        }),
        Object.defineProperty(i, f, h)
    }
    : function(i, a, l, f) {
        f === void 0 && (f = l),
        i[f] = a[l]
    }
    )
      , e = Zt && Zt.__exportStar || function(i, a) {
        for (var l in i)
            l !== "default" && !Object.prototype.hasOwnProperty.call(a, l) && t(a, i, l)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.hasOwn = n.setUnion = n.binaryExponent = n.metricExponent = void 0,
    e(Rf, n),
    e(Df, n),
    e(K1, n),
    e(qo, n),
    e(Bf, n),
    e(pt, n),
    e(hn, n),
    e(An, n),
    e(Mi, n),
    e(Fa, n);
    var r = vr;
    Object.defineProperty(n, "metricExponent", {
        enumerable: !0,
        get: function() {
            return r.metricExponent
        }
    }),
    Object.defineProperty(n, "binaryExponent", {
        enumerable: !0,
        get: function() {
            return r.binaryExponent
        }
    }),
    Object.defineProperty(n, "setUnion", {
        enumerable: !0,
        get: function() {
            return r.setUnion
        }
    }),
    Object.defineProperty(n, "hasOwn", {
        enumerable: !0,
        get: function() {
            return r.hasOwn
        }
    }),
    e(vn, n),
    e(Vm, n),
    e($i, n)
}
)(ut);
const tc = "3.1.0"
  , GE = "https://scaleworkshop.plainsound.org/api/"
  , no = `Scale Workshop ${tc}`
  , Ps = 25
  , kf = /\r?\n/
  , bS = `
`
  , MW = `\r
`
  , WE = 128
  , OW = 0
  , Vz = navigator.vendor && navigator.vendor.indexOf("Apple") > -1 && navigator.userAgent && navigator.userAgent.indexOf("CriOS") == -1 && navigator.userAgent.indexOf("FxiOS") == -1
  , wl = 255
  , Uz = 2 ** (1 / 12)
  , JE = [...Array(12).keys()].map(n => Uz ** (n + 1))
  , jz = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
  , Hz = ["white", "black", "white", "black", "white", "white", "black", "white", "black", "white", "black", "white"]
  , Td = new ut.Interval(ut.TimeMonzo.fromFraction(2, Ps),"linear")
  , W0 = new ut.Interval(ut.TimeMonzo.fromFraction("3/2", Ps),"linear")
  , KE = new ut.Interval(ut.TimeMonzo.fromFraction("5/4", Ps),"linear")
  , Gz = new ut.Interval(ut.TimeMonzo.fromEqualTemperament("7/12", 2, Ps),"logarithmic")
  , NW = new ut.Interval(ut.TimeMonzo.fromFraction(1, Ps),"linear")
  , El = [...Array(12).keys()].map(n => new ut.Interval(ut.TimeMonzo.fromEqualTemperament(new Ie.Fraction(n + 1,12), 2, Ps),"logarithmic"))
  , Ml = 5407372813
  , wS = new ut.TimeMonzo(new Ie.Fraction(0),[]);
for (let n = 0; n < Ps; ++n)
    wS.primeExponents.push(new Ie.Fraction(Math.round(Ie.PRIME_CENTS[n] / 1200 * Ml)));
function Wz(n) {
    const t = new DOMParser().parseFromString(n, "text/html");
    if (t.documentElement.textContent === null)
        throw new Error("Failed to decode HTML");
    return t.documentElement.textContent
}
function Jz(n) {
    let t = Wz(n);
    t = t.replace(/[_ ]+/g, "");
    let e = t.split(kf);
    return e = e.filter(r => !r.startsWith("<") && !r.startsWith("{") && r.length),
    e = e.map(r => r.split("!")[0]),
    e = e.slice(2),
    e.join(bS)
}
class Kz {
    constructor(t) {
        St(this, "url");
        this.url = t
    }
    get(t, e) {
        return this.url.searchParams.has(t) ? this.url.searchParams.get(t) : e
    }
    getNumber(t, e) {
        if (!this.url.searchParams.has(t))
            return e;
        const r = parseFloat(this.url.searchParams.get(t));
        return isNaN(r) ? e : r
    }
}
class Zz {
    constructor(t) {
        St(this, "name");
        St(this, "data");
        St(this, "freq");
        St(this, "midi");
        St(this, "source");
        St(this, "vertical");
        St(this, "horizontal");
        St(this, "colors");
        St(this, "waveform");
        St(this, "ampenv");
        t === void 0 && (t = new URL(window.location.href));
        const e = new Kz(t);
        this.name = e.get("name", ""),
        this.data = e.get("data"),
        this.freq = e.getNumber("freq", 440),
        this.midi = e.getNumber("midi", 69),
        this.source = e.get("source", ""),
        this.vertical = e.getNumber("vert", 5),
        this.horizontal = e.getNumber("horiz", 1),
        this.colors = e.get("colors"),
        this.waveform = e.get("waveform"),
        this.ampenv = e.get("ampenv"),
        this.data !== void 0 && this.source === "wiki" && (this.data = Jz(this.data))
    }
    parseTuningData() {
        if (this.data === void 0)
            throw new Error("No data to parse");
        const t = this.data.split(kf)
          , e = [];
        return t.forEach(r => {
            r.length && e.push(ut.parseScaleWorkshop2Line(r, Ps))
        }
        ),
        e
    }
    get attackTime() {
        switch (this.ampenv) {
        case "organ":
            return .01;
        case "pad":
            return .5;
        case "perc-short":
            return .002;
        case "perc-medium":
            return .003;
        case "perc-long":
            return .005;
        default:
            return .01
        }
    }
    get decayTime() {
        switch (this.ampenv) {
        case "organ":
            return .15;
        case "pad":
            return 1.5;
        case "perc-short":
            return .125;
        case "perc-medium":
            return .5;
        case "perc-long":
            return 4;
        default:
            return .3
        }
    }
    get sustainLevel() {
        switch (this.ampenv) {
        case "organ":
            return .8;
        case "pad":
            return .5;
        case "perc-short":
            return 0;
        case "perc-medium":
            return 0;
        case "perc-long":
            return 0;
        default:
            return .8
        }
    }
    get releaseTime() {
        switch (this.ampenv) {
        case "organ":
            return .01;
        case "pad":
            return .7;
        case "perc-short":
            return .1;
        case "perc-medium":
            return .3;
        case "perc-long":
            return .8;
        default:
            return .01
        }
    }
}
var ql = {};
class Ws {
    constructor(t=!1) {
        this.eventMap = {},
        this.eventsSuspended = t == !0
    }
    addListener(t, e, r={}) {
        if (typeof t == "string" && t.length < 1 || t instanceof String && t.length < 1 || typeof t != "string" && !(t instanceof String) && t !== Ws.ANY_EVENT)
            throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
        if (typeof e != "function")
            throw new TypeError("The callback must be a function.");
        const i = new ZE(t,this,e,r);
        return this.eventMap[t] || (this.eventMap[t] = []),
        r.prepend ? this.eventMap[t].unshift(i) : this.eventMap[t].push(i),
        i
    }
    addOneTimeListener(t, e, r={}) {
        r.remaining = 1,
        this.addListener(t, e, r)
    }
    static get ANY_EVENT() {
        return Symbol.for("Any event")
    }
    hasListener(t, e) {
        return t === void 0 ? this.eventMap[Ws.ANY_EVENT] && this.eventMap[Ws.ANY_EVENT].length > 0 ? !0 : Object.entries(this.eventMap).some( ([,r]) => r.length > 0) : this.eventMap[t] && this.eventMap[t].length > 0 ? e instanceof ZE ? this.eventMap[t].filter(i => i === e).length > 0 : typeof e == "function" ? this.eventMap[t].filter(i => i.callback === e).length > 0 : e == null : !1
    }
    get eventNames() {
        return Object.keys(this.eventMap)
    }
    getListeners(t) {
        return this.eventMap[t] || []
    }
    suspendEvent(t) {
        this.getListeners(t).forEach(e => {
            e.suspended = !0
        }
        )
    }
    unsuspendEvent(t) {
        this.getListeners(t).forEach(e => {
            e.suspended = !1
        }
        )
    }
    getListenerCount(t) {
        return this.getListeners(t).length
    }
    emit(t, ...e) {
        if (typeof t != "string" && !(t instanceof String))
            throw new TypeError("The 'event' parameter must be a string.");
        if (this.eventsSuspended)
            return;
        let r = []
          , i = this.eventMap[Ws.ANY_EVENT] || [];
        return this.eventMap[t] && (i = i.concat(this.eventMap[t])),
        i.forEach(a => {
            if (a.suspended)
                return;
            let l = [...e];
            Array.isArray(a.arguments) && (l = l.concat(a.arguments)),
            a.remaining > 0 && (r.push(a.callback.apply(a.context, l)),
            a.count++),
            --a.remaining < 1 && a.remove()
        }
        ),
        r
    }
    removeListener(t, e, r={}) {
        if (t === void 0) {
            this.eventMap = {};
            return
        } else if (!this.eventMap[t])
            return;
        let i = this.eventMap[t].filter(a => e && a.callback !== e || r.remaining && r.remaining !== a.remaining || r.context && r.context !== a.context);
        i.length ? this.eventMap[t] = i : delete this.eventMap[t]
    }
    async waitFor(t, e={}) {
        return e.duration = parseInt(e.duration),
        (isNaN(e.duration) || e.duration <= 0) && (e.duration = 1 / 0),
        new Promise( (r, i) => {
            let a, l = this.addListener(t, () => {
                clearTimeout(a),
                r()
            }
            , {
                remaining: 1
            });
            e.duration !== 1 / 0 && (a = setTimeout( () => {
                l.remove(),
                i("The duration expired before the event was emitted.")
            }
            , e.duration))
        }
        )
    }
    get eventCount() {
        return Object.keys(this.eventMap).length
    }
}
class ZE {
    constructor(t, e, r, i={}) {
        if (typeof t != "string" && !(t instanceof String) && t !== Ws.ANY_EVENT)
            throw new TypeError("The 'event' parameter must be a string or EventEmitter.ANY_EVENT.");
        if (!e)
            throw new ReferenceError("The 'target' parameter is mandatory.");
        if (typeof r != "function")
            throw new TypeError("The 'callback' must be a function.");
        i.arguments !== void 0 && !Array.isArray(i.arguments) && (i.arguments = [i.arguments]),
        i = Object.assign({
            context: e,
            remaining: 1 / 0,
            arguments: void 0,
            duration: 1 / 0
        }, i),
        i.duration !== 1 / 0 && setTimeout( () => this.remove(), i.duration),
        this.arguments = i.arguments,
        this.callback = r,
        this.context = i.context,
        this.count = 0,
        this.event = t,
        this.remaining = parseInt(i.remaining) >= 1 ? parseInt(i.remaining) : 1 / 0,
        this.suspended = !1,
        this.target = e
    }
    remove() {
        this.target.removeListener(this.event, this.callback, {
            context: this.context,
            remaining: this.remaining
        })
    }
}
/**
 * The `Enumerations` class contains enumerations and arrays of elements used throughout the
 * library. All its properties are static and should be referenced using the class name. For
 * example: `Enumerations.CHANNEL_MESSAGES`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class ke {
    static get MIDI_CHANNEL_MESSAGES() {
        return this.validation && console.warn("The MIDI_CHANNEL_MESSAGES enum has been deprecated. Use the Enumerations.CHANNEL_MESSAGES enum instead."),
        ke.CHANNEL_MESSAGES
    }
    static get CHANNEL_MESSAGES() {
        return {
            noteoff: 8,
            noteon: 9,
            keyaftertouch: 10,
            controlchange: 11,
            programchange: 12,
            channelaftertouch: 13,
            pitchbend: 14
        }
    }
    static get CHANNEL_NUMBERS() {
        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    }
    static get MIDI_CHANNEL_NUMBERS() {
        return this.validation && console.warn("The MIDI_CHANNEL_NUMBERS array has been deprecated. Use the Enumerations.CHANNEL_NUMBERS array instead."),
        [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]
    }
    static get CHANNEL_MODE_MESSAGES() {
        return {
            allsoundoff: 120,
            resetallcontrollers: 121,
            localcontrol: 122,
            allnotesoff: 123,
            omnimodeoff: 124,
            omnimodeon: 125,
            monomodeon: 126,
            polymodeon: 127
        }
    }
    static get MIDI_CHANNEL_MODE_MESSAGES() {
        return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been deprecated. Use the Enumerations.CHANNEL_MODE_MESSAGES enum instead."),
        ke.CHANNEL_MODE_MESSAGES
    }
    static get MIDI_CONTROL_CHANGE_MESSAGES() {
        return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been deprecated. Use the Enumerations.CONTROL_CHANGE_MESSAGES array instead."),
        {
            bankselectcoarse: 0,
            modulationwheelcoarse: 1,
            breathcontrollercoarse: 2,
            controller3: 3,
            footcontrollercoarse: 4,
            portamentotimecoarse: 5,
            dataentrycoarse: 6,
            volumecoarse: 7,
            balancecoarse: 8,
            controller9: 9,
            pancoarse: 10,
            expressioncoarse: 11,
            effectcontrol1coarse: 12,
            effectcontrol2coarse: 13,
            controller14: 14,
            controller15: 15,
            generalpurposeslider1: 16,
            generalpurposeslider2: 17,
            generalpurposeslider3: 18,
            generalpurposeslider4: 19,
            controller20: 20,
            controller21: 21,
            controller22: 22,
            controller23: 23,
            controller24: 24,
            controller25: 25,
            controller26: 26,
            controller27: 27,
            controller28: 28,
            controller29: 29,
            controller30: 30,
            controller31: 31,
            bankselectfine: 32,
            modulationwheelfine: 33,
            breathcontrollerfine: 34,
            controller35: 35,
            footcontrollerfine: 36,
            portamentotimefine: 37,
            dataentryfine: 38,
            volumefine: 39,
            balancefine: 40,
            controller41: 41,
            panfine: 42,
            expressionfine: 43,
            effectcontrol1fine: 44,
            effectcontrol2fine: 45,
            controller46: 46,
            controller47: 47,
            controller48: 48,
            controller49: 49,
            controller50: 50,
            controller51: 51,
            controller52: 52,
            controller53: 53,
            controller54: 54,
            controller55: 55,
            controller56: 56,
            controller57: 57,
            controller58: 58,
            controller59: 59,
            controller60: 60,
            controller61: 61,
            controller62: 62,
            controller63: 63,
            holdpedal: 64,
            portamento: 65,
            sustenutopedal: 66,
            softpedal: 67,
            legatopedal: 68,
            hold2pedal: 69,
            soundvariation: 70,
            resonance: 71,
            soundreleasetime: 72,
            soundattacktime: 73,
            brightness: 74,
            soundcontrol6: 75,
            soundcontrol7: 76,
            soundcontrol8: 77,
            soundcontrol9: 78,
            soundcontrol10: 79,
            generalpurposebutton1: 80,
            generalpurposebutton2: 81,
            generalpurposebutton3: 82,
            generalpurposebutton4: 83,
            controller84: 84,
            controller85: 85,
            controller86: 86,
            controller87: 87,
            controller88: 88,
            controller89: 89,
            controller90: 90,
            reverblevel: 91,
            tremololevel: 92,
            choruslevel: 93,
            celestelevel: 94,
            phaserlevel: 95,
            databuttonincrement: 96,
            databuttondecrement: 97,
            nonregisteredparametercoarse: 98,
            nonregisteredparameterfine: 99,
            registeredparametercoarse: 100,
            registeredparameterfine: 101,
            controller102: 102,
            controller103: 103,
            controller104: 104,
            controller105: 105,
            controller106: 106,
            controller107: 107,
            controller108: 108,
            controller109: 109,
            controller110: 110,
            controller111: 111,
            controller112: 112,
            controller113: 113,
            controller114: 114,
            controller115: 115,
            controller116: 116,
            controller117: 117,
            controller118: 118,
            controller119: 119,
            allsoundoff: 120,
            resetallcontrollers: 121,
            localcontrol: 122,
            allnotesoff: 123,
            omnimodeoff: 124,
            omnimodeon: 125,
            monomodeon: 126,
            polymodeon: 127
        }
    }
    static get CONTROL_CHANGE_MESSAGES() {
        return [{
            number: 0,
            name: "bankselectcoarse",
            description: "Bank Select (Coarse)",
            position: "msb"
        }, {
            number: 1,
            name: "modulationwheelcoarse",
            description: "Modulation Wheel (Coarse)",
            position: "msb"
        }, {
            number: 2,
            name: "breathcontrollercoarse",
            description: "Breath Controller (Coarse)",
            position: "msb"
        }, {
            number: 3,
            name: "controller3",
            description: "Undefined",
            position: "msb"
        }, {
            number: 4,
            name: "footcontrollercoarse",
            description: "Foot Controller (Coarse)",
            position: "msb"
        }, {
            number: 5,
            name: "portamentotimecoarse",
            description: "Portamento Time (Coarse)",
            position: "msb"
        }, {
            number: 6,
            name: "dataentrycoarse",
            description: "Data Entry (Coarse)",
            position: "msb"
        }, {
            number: 7,
            name: "volumecoarse",
            description: "Channel Volume (Coarse)",
            position: "msb"
        }, {
            number: 8,
            name: "balancecoarse",
            description: "Balance (Coarse)",
            position: "msb"
        }, {
            number: 9,
            name: "controller9",
            description: "Controller 9 (Coarse)",
            position: "msb"
        }, {
            number: 10,
            name: "pancoarse",
            description: "Pan (Coarse)",
            position: "msb"
        }, {
            number: 11,
            name: "expressioncoarse",
            description: "Expression Controller (Coarse)",
            position: "msb"
        }, {
            number: 12,
            name: "effectcontrol1coarse",
            description: "Effect Control 1 (Coarse)",
            position: "msb"
        }, {
            number: 13,
            name: "effectcontrol2coarse",
            description: "Effect Control 2 (Coarse)",
            position: "msb"
        }, {
            number: 14,
            name: "controller14",
            description: "Undefined",
            position: "msb"
        }, {
            number: 15,
            name: "controller15",
            description: "Undefined",
            position: "msb"
        }, {
            number: 16,
            name: "generalpurposecontroller1",
            description: "General Purpose Controller 1 (Coarse)",
            position: "msb"
        }, {
            number: 17,
            name: "generalpurposecontroller2",
            description: "General Purpose Controller 2 (Coarse)",
            position: "msb"
        }, {
            number: 18,
            name: "generalpurposecontroller3",
            description: "General Purpose Controller 3 (Coarse)",
            position: "msb"
        }, {
            number: 19,
            name: "generalpurposecontroller4",
            description: "General Purpose Controller 4 (Coarse)",
            position: "msb"
        }, {
            number: 20,
            name: "controller20",
            description: "Undefined",
            position: "msb"
        }, {
            number: 21,
            name: "controller21",
            description: "Undefined",
            position: "msb"
        }, {
            number: 22,
            name: "controller22",
            description: "Undefined",
            position: "msb"
        }, {
            number: 23,
            name: "controller23",
            description: "Undefined",
            position: "msb"
        }, {
            number: 24,
            name: "controller24",
            description: "Undefined",
            position: "msb"
        }, {
            number: 25,
            name: "controller25",
            description: "Undefined",
            position: "msb"
        }, {
            number: 26,
            name: "controller26",
            description: "Undefined",
            position: "msb"
        }, {
            number: 27,
            name: "controller27",
            description: "Undefined",
            position: "msb"
        }, {
            number: 28,
            name: "controller28",
            description: "Undefined",
            position: "msb"
        }, {
            number: 29,
            name: "controller29",
            description: "Undefined",
            position: "msb"
        }, {
            number: 30,
            name: "controller30",
            description: "Undefined",
            position: "msb"
        }, {
            number: 31,
            name: "controller31",
            description: "Undefined",
            position: "msb"
        }, {
            number: 32,
            name: "bankselectfine",
            description: "Bank Select (Fine)",
            position: "lsb"
        }, {
            number: 33,
            name: "modulationwheelfine",
            description: "Modulation Wheel (Fine)",
            position: "lsb"
        }, {
            number: 34,
            name: "breathcontrollerfine",
            description: "Breath Controller (Fine)",
            position: "lsb"
        }, {
            number: 35,
            name: "controller35",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 36,
            name: "footcontrollerfine",
            description: "Foot Controller (Fine)",
            position: "lsb"
        }, {
            number: 37,
            name: "portamentotimefine",
            description: "Portamento Time (Fine)",
            position: "lsb"
        }, {
            number: 38,
            name: "dataentryfine",
            description: "Data Entry (Fine)",
            position: "lsb"
        }, {
            number: 39,
            name: "channelvolumefine",
            description: "Channel Volume (Fine)",
            position: "lsb"
        }, {
            number: 40,
            name: "balancefine",
            description: "Balance (Fine)",
            position: "lsb"
        }, {
            number: 41,
            name: "controller41",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 42,
            name: "panfine",
            description: "Pan (Fine)",
            position: "lsb"
        }, {
            number: 43,
            name: "expressionfine",
            description: "Expression Controller (Fine)",
            position: "lsb"
        }, {
            number: 44,
            name: "effectcontrol1fine",
            description: "Effect control 1 (Fine)",
            position: "lsb"
        }, {
            number: 45,
            name: "effectcontrol2fine",
            description: "Effect control 2 (Fine)",
            position: "lsb"
        }, {
            number: 46,
            name: "controller46",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 47,
            name: "controller47",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 48,
            name: "controller48",
            description: "General Purpose Controller 1 (Fine)",
            position: "lsb"
        }, {
            number: 49,
            name: "controller49",
            description: "General Purpose Controller 2 (Fine)",
            position: "lsb"
        }, {
            number: 50,
            name: "controller50",
            description: "General Purpose Controller 3 (Fine)",
            position: "lsb"
        }, {
            number: 51,
            name: "controller51",
            description: "General Purpose Controller 4 (Fine)",
            position: "lsb"
        }, {
            number: 52,
            name: "controller52",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 53,
            name: "controller53",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 54,
            name: "controller54",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 55,
            name: "controller55",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 56,
            name: "controller56",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 57,
            name: "controller57",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 58,
            name: "controller58",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 59,
            name: "controller59",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 60,
            name: "controller60",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 61,
            name: "controller61",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 62,
            name: "controller62",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 63,
            name: "controller63",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 64,
            name: "damperpedal",
            description: "Damper Pedal On/Off"
        }, {
            number: 65,
            name: "portamento",
            description: "Portamento On/Off"
        }, {
            number: 66,
            name: "sostenuto",
            description: "Sostenuto On/Off"
        }, {
            number: 67,
            name: "softpedal",
            description: "Soft Pedal On/Off"
        }, {
            number: 68,
            name: "legatopedal",
            description: "Legato Pedal On/Off"
        }, {
            number: 69,
            name: "hold2",
            description: "Hold 2 On/Off"
        }, {
            number: 70,
            name: "soundvariation",
            description: "Sound Variation",
            position: "lsb"
        }, {
            number: 71,
            name: "resonance",
            description: "Resonance",
            position: "lsb"
        }, {
            number: 72,
            name: "releasetime",
            description: "Release Time",
            position: "lsb"
        }, {
            number: 73,
            name: "attacktime",
            description: "Attack Time",
            position: "lsb"
        }, {
            number: 74,
            name: "brightness",
            description: "Brightness",
            position: "lsb"
        }, {
            number: 75,
            name: "decaytime",
            description: "Decay Time",
            position: "lsb"
        }, {
            number: 76,
            name: "vibratorate",
            description: "Vibrato Rate",
            position: "lsb"
        }, {
            number: 77,
            name: "vibratodepth",
            description: "Vibrato Depth",
            position: "lsb"
        }, {
            number: 78,
            name: "vibratodelay",
            description: "Vibrato Delay",
            position: "lsb"
        }, {
            number: 79,
            name: "controller79",
            description: "Undefined",
            position: "lsb"
        }, {
            number: 80,
            name: "generalpurposecontroller5",
            description: "General Purpose Controller 5",
            position: "lsb"
        }, {
            number: 81,
            name: "generalpurposecontroller6",
            description: "General Purpose Controller 6",
            position: "lsb"
        }, {
            number: 82,
            name: "generalpurposecontroller7",
            description: "General Purpose Controller 7",
            position: "lsb"
        }, {
            number: 83,
            name: "generalpurposecontroller8",
            description: "General Purpose Controller 8",
            position: "lsb"
        }, {
            number: 84,
            name: "portamentocontrol",
            description: "Portamento Control",
            position: "lsb"
        }, {
            number: 85,
            name: "controller85",
            description: "Undefined"
        }, {
            number: 86,
            name: "controller86",
            description: "Undefined"
        }, {
            number: 87,
            name: "controller87",
            description: "Undefined"
        }, {
            number: 88,
            name: "highresolutionvelocityprefix",
            description: "High Resolution Velocity Prefix",
            position: "lsb"
        }, {
            number: 89,
            name: "controller89",
            description: "Undefined"
        }, {
            number: 90,
            name: "controller90",
            description: "Undefined"
        }, {
            number: 91,
            name: "effect1depth",
            description: "Effects 1 Depth (Reverb Send Level)"
        }, {
            number: 92,
            name: "effect2depth",
            description: "Effects 2 Depth"
        }, {
            number: 93,
            name: "effect3depth",
            description: "Effects 3 Depth (Chorus Send Level)"
        }, {
            number: 94,
            name: "effect4depth",
            description: "Effects 4 Depth"
        }, {
            number: 95,
            name: "effect5depth",
            description: "Effects 5 Depth"
        }, {
            number: 96,
            name: "dataincrement",
            description: "Data Increment"
        }, {
            number: 97,
            name: "datadecrement",
            description: "Data Decrement"
        }, {
            number: 98,
            name: "nonregisteredparameterfine",
            description: "Non-Registered Parameter Number (Fine)",
            position: "lsb"
        }, {
            number: 99,
            name: "nonregisteredparametercoarse",
            description: "Non-Registered Parameter Number (Coarse)",
            position: "msb"
        }, {
            number: 100,
            name: "registeredparameterfine",
            description: "Registered Parameter Number (Fine)",
            position: "lsb"
        }, {
            number: 101,
            name: "registeredparametercoarse",
            description: "Registered Parameter Number (Coarse)",
            position: "msb"
        }, {
            number: 102,
            name: "controller102",
            description: "Undefined"
        }, {
            number: 103,
            name: "controller103",
            description: "Undefined"
        }, {
            number: 104,
            name: "controller104",
            description: "Undefined"
        }, {
            number: 105,
            name: "controller105",
            description: "Undefined"
        }, {
            number: 106,
            name: "controller106",
            description: "Undefined"
        }, {
            number: 107,
            name: "controller107",
            description: "Undefined"
        }, {
            number: 108,
            name: "controller108",
            description: "Undefined"
        }, {
            number: 109,
            name: "controller109",
            description: "Undefined"
        }, {
            number: 110,
            name: "controller110",
            description: "Undefined"
        }, {
            number: 111,
            name: "controller111",
            description: "Undefined"
        }, {
            number: 112,
            name: "controller112",
            description: "Undefined"
        }, {
            number: 113,
            name: "controller113",
            description: "Undefined"
        }, {
            number: 114,
            name: "controller114",
            description: "Undefined"
        }, {
            number: 115,
            name: "controller115",
            description: "Undefined"
        }, {
            number: 116,
            name: "controller116",
            description: "Undefined"
        }, {
            number: 117,
            name: "controller117",
            description: "Undefined"
        }, {
            number: 118,
            name: "controller118",
            description: "Undefined"
        }, {
            number: 119,
            name: "controller119",
            description: "Undefined"
        }, {
            number: 120,
            name: "allsoundoff",
            description: "All Sound Off"
        }, {
            number: 121,
            name: "resetallcontrollers",
            description: "Reset All Controllers"
        }, {
            number: 122,
            name: "localcontrol",
            description: "Local Control On/Off"
        }, {
            number: 123,
            name: "allnotesoff",
            description: "All Notes Off"
        }, {
            number: 124,
            name: "omnimodeoff",
            description: "Omni Mode Off"
        }, {
            number: 125,
            name: "omnimodeon",
            description: "Omni Mode On"
        }, {
            number: 126,
            name: "monomodeon",
            description: "Mono Mode On"
        }, {
            number: 127,
            name: "polymodeon",
            description: "Poly Mode On"
        }]
    }
    static get REGISTERED_PARAMETERS() {
        return {
            pitchbendrange: [0, 0],
            channelfinetuning: [0, 1],
            channelcoarsetuning: [0, 2],
            tuningprogram: [0, 3],
            tuningbank: [0, 4],
            modulationrange: [0, 5],
            azimuthangle: [61, 0],
            elevationangle: [61, 1],
            gain: [61, 2],
            distanceratio: [61, 3],
            maximumdistance: [61, 4],
            maximumdistancegain: [61, 5],
            referencedistanceratio: [61, 6],
            panspreadangle: [61, 7],
            rollangle: [61, 8]
        }
    }
    static get MIDI_REGISTERED_PARAMETERS() {
        return this.validation && console.warn("The MIDI_REGISTERED_PARAMETERS enum has been deprecated. Use the Enumerations.REGISTERED_PARAMETERS enum instead."),
        ke.MIDI_REGISTERED_PARAMETERS
    }
    static get SYSTEM_MESSAGES() {
        return {
            sysex: 240,
            timecode: 241,
            songposition: 242,
            songselect: 243,
            tunerequest: 246,
            tuningrequest: 246,
            sysexend: 247,
            clock: 248,
            start: 250,
            continue: 251,
            stop: 252,
            activesensing: 254,
            reset: 255,
            midimessage: 0,
            unknownsystemmessage: -1
        }
    }
    static get MIDI_SYSTEM_MESSAGES() {
        return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been deprecated. Use the Enumerations.SYSTEM_MESSAGES enum instead."),
        ke.SYSTEM_MESSAGES
    }
    static get CHANNEL_EVENTS() {
        return ["noteoff", "controlchange", "noteon", "keyaftertouch", "programchange", "channelaftertouch", "pitchbend", "allnotesoff", "allsoundoff", "localcontrol", "monomode", "omnimode", "resetallcontrollers", "nrpn", "nrpn-dataentrycoarse", "nrpn-dataentryfine", "nrpn-dataincrement", "nrpn-datadecrement", "rpn", "rpn-dataentrycoarse", "rpn-dataentryfine", "rpn-dataincrement", "rpn-datadecrement", "nrpn-databuttonincrement", "nrpn-databuttondecrement", "rpn-databuttonincrement", "rpn-databuttondecrement"]
    }
}
/**
 * The `Note` class represents a single musical note such as `"D3"`, `"G#4"`, `"F-1"`, `"Gb7"`, etc.
 *
 * `Note` objects can be played back on a single channel by calling
 * [`OutputChannel.playNote()`]{@link OutputChannel#playNote} or, on multiple channels of the same
 * output, by calling [`Output.playNote()`]{@link Output#playNote}.
 *
 * The note has [`attack`](#attack) and [`release`](#release) velocities set at `0.5` by default.
 * These can be changed by passing in the appropriate option. It is also possible to set a
 * system-wide default for attack and release velocities by using the
 * [`WebMidi.defaults`](WebMidi#defaults) property.
 *
 * If you prefer to work with raw MIDI values (`0` to `127`), you can use [`rawAttack`](#rawAttack) and
 * [`rawRelease`](#rawRelease) to both get and set the values.
 *
 * The note may have a [`duration`](#duration). If it does, playback will be automatically stopped
 * when the duration has elapsed by sending a `"noteoff"` event. By default, the duration is set to
 * `Infinity`. In this case, it will never stop playing unless explicitly stopped by calling a
 * method such as [`OutputChannel.stopNote()`]{@link OutputChannel#stopNote},
 * [`Output.stopNote()`]{@link Output#stopNote} or similar.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class La {
    constructor(t, e={}) {
        this.duration = ot.defaults.note.duration,
        this.attack = ot.defaults.note.attack,
        this.release = ot.defaults.note.release,
        e.duration != null && (this.duration = e.duration),
        e.attack != null && (this.attack = e.attack),
        e.rawAttack != null && (this.attack = nt.from7bitToFloat(e.rawAttack)),
        e.release != null && (this.release = e.release),
        e.rawRelease != null && (this.release = nt.from7bitToFloat(e.rawRelease)),
        Number.isInteger(t) ? this.identifier = nt.toNoteIdentifier(t) : this.identifier = t
    }
    get identifier() {
        return this._name + (this._accidental || "") + this._octave
    }
    set identifier(t) {
        const e = nt.getNoteDetails(t);
        if (ot.validation && !t)
            throw new Error("Invalid note identifier");
        this._name = e.name,
        this._accidental = e.accidental,
        this._octave = e.octave
    }
    get name() {
        return this._name
    }
    set name(t) {
        if (ot.validation && (t = t.toUpperCase(),
        !["C", "D", "E", "F", "G", "A", "B"].includes(t)))
            throw new Error("Invalid name value");
        this._name = t
    }
    get accidental() {
        return this._accidental
    }
    set accidental(t) {
        if (ot.validation && (t = t.toLowerCase(),
        !["#", "##", "b", "bb"].includes(t)))
            throw new Error("Invalid accidental value");
        this._accidental = t
    }
    get octave() {
        return this._octave
    }
    set octave(t) {
        if (ot.validation && (t = parseInt(t),
        isNaN(t)))
            throw new Error("Invalid octave value");
        this._octave = t
    }
    get duration() {
        return this._duration
    }
    set duration(t) {
        if (ot.validation && (t = parseFloat(t),
        isNaN(t) || t === null || t < 0))
            throw new RangeError("Invalid duration value.");
        this._duration = t
    }
    get attack() {
        return this._attack
    }
    set attack(t) {
        if (ot.validation && (t = parseFloat(t),
        isNaN(t) || !(t >= 0 && t <= 1)))
            throw new RangeError("Invalid attack value.");
        this._attack = t
    }
    get release() {
        return this._release
    }
    set release(t) {
        if (ot.validation && (t = parseFloat(t),
        isNaN(t) || !(t >= 0 && t <= 1)))
            throw new RangeError("Invalid release value.");
        this._release = t
    }
    get rawAttack() {
        return nt.fromFloatTo7Bit(this._attack)
    }
    set rawAttack(t) {
        this._attack = nt.from7bitToFloat(t)
    }
    get rawRelease() {
        return nt.fromFloatTo7Bit(this._release)
    }
    set rawRelease(t) {
        this._release = nt.from7bitToFloat(t)
    }
    get number() {
        return nt.toNoteNumber(this.identifier)
    }
    getOffsetNumber(t=0, e=0) {
        return ot.validation && (t = parseInt(t) || 0,
        e = parseInt(e) || 0),
        Math.min(Math.max(this.number + t * 12 + e, 0), 127)
    }
}
/**
 * The `Utilities` class contains general-purpose utility methods. All methods are static and
 * should be called using the class name. For example: `Utilities.getNoteDetails("C4")`.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class nt {
    static toNoteNumber(t, e=0) {
        if (e = e == null ? 0 : parseInt(e),
        isNaN(e))
            throw new RangeError("Invalid 'octaveOffset' value");
        typeof t != "string" && (t = "");
        const r = this.getNoteDetails(t);
        if (!r)
            throw new TypeError("Invalid note identifier");
        const i = {
            C: 0,
            D: 2,
            E: 4,
            F: 5,
            G: 7,
            A: 9,
            B: 11
        };
        let a = (r.octave + 1 + e) * 12;
        if (a += i[r.name],
        r.accidental && (r.accidental.startsWith("b") ? a -= r.accidental.length : a += r.accidental.length),
        a < 0 || a > 127)
            throw new RangeError("Invalid octaveOffset value");
        return a
    }
    static getNoteDetails(t) {
        Number.isInteger(t) && (t = this.toNoteIdentifier(t));
        const e = t.match(/^([CDEFGAB])(#{0,2}|b{0,2})(-?\d+)$/i);
        if (!e)
            throw new TypeError("Invalid note identifier");
        const r = e[1].toUpperCase()
          , i = parseInt(e[3]);
        let a = e[2].toLowerCase();
        return a = a === "" ? void 0 : a,
        {
            accidental: a,
            identifier: r + (a || "") + i,
            name: r,
            octave: i
        }
    }
    static sanitizeChannels(t) {
        let e;
        if (ot.validation) {
            if (t === "all")
                e = ["all"];
            else if (t === "none")
                return []
        }
        return Array.isArray(t) ? e = t : e = [t],
        e.indexOf("all") > -1 && (e = ke.MIDI_CHANNEL_NUMBERS),
        e.map(function(r) {
            return parseInt(r)
        }).filter(function(r) {
            return r >= 1 && r <= 16
        })
    }
    static toTimestamp(t) {
        let e = !1;
        const r = parseFloat(t);
        return isNaN(r) ? !1 : (typeof t == "string" && t.substring(0, 1) === "+" ? r >= 0 && (e = ot.time + r) : r >= 0 && (e = r),
        e)
    }
    static guessNoteNumber(t, e) {
        e = parseInt(e) || 0;
        let r = !1;
        if (Number.isInteger(t) && t >= 0 && t <= 127)
            r = parseInt(t);
        else if (parseInt(t) >= 0 && parseInt(t) <= 127)
            r = parseInt(t);
        else if (typeof t == "string" || t instanceof String)
            try {
                r = this.toNoteNumber(t.trim(), e)
            } catch {
                return !1
            }
        return r
    }
    static toNoteIdentifier(t, e) {
        if (t = parseInt(t),
        isNaN(t) || t < 0 || t > 127)
            throw new RangeError("Invalid note number");
        if (e = e == null ? 0 : parseInt(e),
        isNaN(e))
            throw new RangeError("Invalid octaveOffset value");
        const r = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
          , i = Math.floor(t / 12 - 1) + e;
        return r[t % 12] + i.toString()
    }
    static buildNote(t, e={}) {
        if (e.octaveOffset = parseInt(e.octaveOffset) || 0,
        t instanceof La)
            return t;
        let r = this.guessNoteNumber(t, e.octaveOffset);
        if (r === !1)
            throw new TypeError(`The input could not be parsed as a note (${t})`);
        return e.octaveOffset = void 0,
        new La(r,e)
    }
    static buildNoteArray(t, e={}) {
        let r = [];
        return Array.isArray(t) || (t = [t]),
        t.forEach(i => {
            r.push(this.buildNote(i, e))
        }
        ),
        r
    }
    static from7bitToFloat(t) {
        return t === 1 / 0 && (t = 127),
        t = parseInt(t) || 0,
        Math.min(Math.max(t / 127, 0), 1)
    }
    static fromFloatTo7Bit(t) {
        return t === 1 / 0 && (t = 1),
        t = parseFloat(t) || 0,
        Math.min(Math.max(Math.round(t * 127), 0), 127)
    }
    static fromMsbLsbToFloat(t, e=0) {
        ot.validation && (t = Math.min(Math.max(parseInt(t) || 0, 0), 127),
        e = Math.min(Math.max(parseInt(e) || 0, 0), 127));
        const r = ((t << 7) + e) / 16383;
        return Math.min(Math.max(r, 0), 1)
    }
    static fromFloatToMsbLsb(t) {
        ot.validation && (t = Math.min(Math.max(parseFloat(t) || 0, 0), 1));
        const e = Math.round(t * 16383);
        return {
            msb: e >> 7,
            lsb: e & 127
        }
    }
    static offsetNumber(t, e=0, r=0) {
        if (ot.validation) {
            if (t = parseInt(t),
            isNaN(t))
                throw new Error("Invalid note number");
            e = parseInt(e) || 0,
            r = parseInt(r) || 0
        }
        return Math.min(Math.max(t + e * 12 + r, 0), 127)
    }
    static getPropertyByValue(t, e) {
        return Object.keys(t).find(r => t[r] === e)
    }
    static getCcNameByNumber(t) {
        if (!(ot.validation && (t = parseInt(t),
        !(t >= 0 && t <= 127))))
            return ke.CONTROL_CHANGE_MESSAGES[t].name
    }
    static getCcNumberByName(t) {
        let e = ke.CONTROL_CHANGE_MESSAGES.find(r => r.name === t);
        return e ? e.number : ke.MIDI_CONTROL_CHANGE_MESSAGES[t]
    }
    static getChannelModeByNumber(t) {
        if (!(t >= 120 && t <= 127))
            return !1;
        for (let e in ke.CHANNEL_MODE_MESSAGES)
            if (ke.CHANNEL_MODE_MESSAGES.hasOwnProperty(e) && t === ke.CHANNEL_MODE_MESSAGES[e])
                return e;
        return !1
    }
    static get isNode() {
        return typeof process < "u" && process.versions != null && process.versions.node != null
    }
    static get isBrowser() {
        return typeof window < "u" && typeof window.document < "u"
    }
}
/**
 * The `OutputChannel` class represents a single output MIDI channel. `OutputChannel` objects are
 * provided by an [`Output`](Output) port which, itself, is made available by a device. The
 * `OutputChannel` object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `OutputChannel` objects can be found inside the parent output's
 * [`channels`]{@link Output#channels} property.
 *
 * @param {Output} output The [`Output`](Output) this channel belongs to.
 * @param {number} number The MIDI channel number (`1` - `16`).
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class ES extends Ws {
    constructor(t, e) {
        super(),
        this._output = t,
        this._number = e,
        this._octaveOffset = 0
    }
    destroy() {
        this._output = null,
        this._number = null,
        this._octaveOffset = 0,
        this.removeListener()
    }
    send(t, e={
        time: 0
    }) {
        return this.output.send(t, e),
        this
    }
    sendKeyAftertouch(t, e, r={}) {
        if (ot.validation) {
            if (r.useRawValue && (r.rawValue = r.useRawValue),
            isNaN(parseFloat(e)))
                throw new RangeError("Invalid key aftertouch value.");
            if (r.rawValue) {
                if (!(e >= 0 && e <= 127 && Number.isInteger(e)))
                    throw new RangeError("Key aftertouch raw value must be an integer between 0 and 127.")
            } else if (!(e >= 0 && e <= 1))
                throw new RangeError("Key aftertouch value must be a float between 0 and 1.")
        }
        r.rawValue || (e = nt.fromFloatTo7Bit(e));
        const i = ot.octaveOffset + this.output.octaveOffset + this.octaveOffset;
        return Array.isArray(t) || (t = [t]),
        nt.buildNoteArray(t).forEach(a => {
            this.send([(ke.CHANNEL_MESSAGES.keyaftertouch << 4) + (this.number - 1), a.getOffsetNumber(i), e], {
                time: nt.toTimestamp(r.time)
            })
        }
        ),
        this
    }
    sendControlChange(t, e, r={}) {
        if (typeof t == "string" && (t = nt.getCcNumberByName(t)),
        Array.isArray(e) || (e = [e]),
        ot.validation) {
            if (t === void 0)
                throw new TypeError("Control change must be identified with a valid name or an integer between 0 and 127.");
            if (!Number.isInteger(t) || !(t >= 0 && t <= 127))
                throw new TypeError("Control change number must be an integer between 0 and 127.");
            if (e = e.map(i => {
                const a = Math.min(Math.max(parseInt(i), 0), 127);
                if (isNaN(a))
                    throw new TypeError("Values must be integers between 0 and 127");
                return a
            }
            ),
            e.length === 2 && t >= 32)
                throw new TypeError("To use a value array, the controller must be between 0 and 31")
        }
        return e.forEach( (i, a) => {
            this.send([(ke.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), t + a * 32, e[a]], {
                time: nt.toTimestamp(r.time)
            })
        }
        ),
        this
    }
    _selectNonRegisteredParameter(t, e={}) {
        return this.sendControlChange(99, t[0], e),
        this.sendControlChange(98, t[1], e),
        this
    }
    _deselectRegisteredParameter(t={}) {
        return this.sendControlChange(101, 127, t),
        this.sendControlChange(100, 127, t),
        this
    }
    _deselectNonRegisteredParameter(t={}) {
        return this.sendControlChange(101, 127, t),
        this.sendControlChange(100, 127, t),
        this
    }
    _selectRegisteredParameter(t, e={}) {
        return this.sendControlChange(101, t[0], e),
        this.sendControlChange(100, t[1], e),
        this
    }
    _setCurrentParameter(t, e={}) {
        return t = [].concat(t),
        this.sendControlChange(6, t[0], e),
        t.length < 2 ? this : (this.sendControlChange(38, t[1], e),
        this)
    }
    sendRpnDecrement(t, e={}) {
        if (Array.isArray(t) || (t = ke.REGISTERED_PARAMETERS[t]),
        ot.validation) {
            if (t === void 0)
                throw new TypeError("The specified registered parameter is invalid.");
            let r = !1;
            if (Object.getOwnPropertyNames(ke.REGISTERED_PARAMETERS).forEach(i => {
                ke.REGISTERED_PARAMETERS[i][0] === t[0] && ke.REGISTERED_PARAMETERS[i][1] === t[1] && (r = !0)
            }
            ),
            !r)
                throw new TypeError("The specified registered parameter is invalid.")
        }
        return this._selectRegisteredParameter(t, e),
        this.sendControlChange(97, 0, e),
        this._deselectRegisteredParameter(e),
        this
    }
    sendRpnIncrement(t, e={}) {
        if (Array.isArray(t) || (t = ke.REGISTERED_PARAMETERS[t]),
        ot.validation) {
            if (t === void 0)
                throw new TypeError("The specified registered parameter is invalid.");
            let r = !1;
            if (Object.getOwnPropertyNames(ke.REGISTERED_PARAMETERS).forEach(i => {
                ke.REGISTERED_PARAMETERS[i][0] === t[0] && ke.REGISTERED_PARAMETERS[i][1] === t[1] && (r = !0)
            }
            ),
            !r)
                throw new TypeError("The specified registered parameter is invalid.")
        }
        return this._selectRegisteredParameter(t, e),
        this.sendControlChange(96, 0, e),
        this._deselectRegisteredParameter(e),
        this
    }
    playNote(t, e={}) {
        this.sendNoteOn(t, e);
        const r = Array.isArray(t) ? t : [t];
        for (let i of r)
            if (parseInt(i.duration) > 0) {
                const a = {
                    time: (nt.toTimestamp(e.time) || ot.time) + parseInt(i.duration),
                    release: i.release,
                    rawRelease: i.rawRelease
                };
                this.sendNoteOff(i, a)
            } else if (parseInt(e.duration) > 0) {
                const a = {
                    time: (nt.toTimestamp(e.time) || ot.time) + parseInt(e.duration),
                    release: e.release,
                    rawRelease: e.rawRelease
                };
                this.sendNoteOff(i, a)
            }
        return this
    }
    sendNoteOff(t, e={}) {
        if (ot.validation) {
            if (e.rawRelease != null && !(e.rawRelease >= 0 && e.rawRelease <= 127))
                throw new RangeError("The 'rawRelease' option must be an integer between 0 and 127");
            if (e.release != null && !(e.release >= 0 && e.release <= 1))
                throw new RangeError("The 'release' option must be an number between 0 and 1");
            e.rawVelocity && (e.rawRelease = e.velocity,
            console.warn("The 'rawVelocity' option is deprecated. Use 'rawRelease' instead.")),
            e.velocity && (e.release = e.velocity,
            console.warn("The 'velocity' option is deprecated. Use 'attack' instead."))
        }
        let r = 64;
        e.rawRelease != null ? r = e.rawRelease : isNaN(e.release) || (r = Math.round(e.release * 127));
        const i = ot.octaveOffset + this.output.octaveOffset + this.octaveOffset;
        return nt.buildNoteArray(t, {
            rawRelease: parseInt(r)
        }).forEach(a => {
            this.send([(ke.CHANNEL_MESSAGES.noteoff << 4) + (this.number - 1), a.getOffsetNumber(i), a.rawRelease], {
                time: nt.toTimestamp(e.time)
            })
        }
        ),
        this
    }
    stopNote(t, e={}) {
        return this.sendNoteOff(t, e)
    }
    sendNoteOn(t, e={}) {
        if (ot.validation) {
            if (e.rawAttack != null && !(e.rawAttack >= 0 && e.rawAttack <= 127))
                throw new RangeError("The 'rawAttack' option must be an integer between 0 and 127");
            if (e.attack != null && !(e.attack >= 0 && e.attack <= 1))
                throw new RangeError("The 'attack' option must be an number between 0 and 1");
            e.rawVelocity && (e.rawAttack = e.velocity,
            e.rawRelease = e.release,
            console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' or 'rawRelease'.")),
            e.velocity && (e.attack = e.velocity,
            console.warn("The 'velocity' option is deprecated. Use 'attack' instead."))
        }
        let r = 64;
        e.rawAttack != null ? r = e.rawAttack : isNaN(e.attack) || (r = Math.round(e.attack * 127));
        const i = ot.octaveOffset + this.output.octaveOffset + this.octaveOffset;
        return nt.buildNoteArray(t, {
            rawAttack: r
        }).forEach(a => {
            this.send([(ke.CHANNEL_MESSAGES.noteon << 4) + (this.number - 1), a.getOffsetNumber(i), a.rawAttack], {
                time: nt.toTimestamp(e.time)
            })
        }
        ),
        this
    }
    sendChannelMode(t, e=0, r={}) {
        if (typeof t == "string" && (t = ke.CHANNEL_MODE_MESSAGES[t]),
        ot.validation) {
            if (t === void 0)
                throw new TypeError("Invalid channel mode message name or number.");
            if (isNaN(t) || !(t >= 120 && t <= 127))
                throw new TypeError("Invalid channel mode message number.");
            if (isNaN(parseInt(e)) || e < 0 || e > 127)
                throw new RangeError("Value must be an integer between 0 and 127.")
        }
        return this.send([(ke.CHANNEL_MESSAGES.controlchange << 4) + (this.number - 1), t, e], {
            time: nt.toTimestamp(r.time)
        }),
        this
    }
    sendOmniMode(t, e={}) {
        return t === void 0 || t ? this.sendChannelMode("omnimodeon", 0, e) : this.sendChannelMode("omnimodeoff", 0, e),
        this
    }
    sendChannelAftertouch(t, e={}) {
        if (ot.validation) {
            if (isNaN(parseFloat(t)))
                throw new RangeError("Invalid channel aftertouch value.");
            if (e.rawValue) {
                if (!(t >= 0 && t <= 127 && Number.isInteger(t)))
                    throw new RangeError("Channel aftertouch raw value must be an integer between 0 and 127.")
            } else if (!(t >= 0 && t <= 1))
                throw new RangeError("Channel aftertouch value must be a float between 0 and 1.")
        }
        return e.rawValue || (t = nt.fromFloatTo7Bit(t)),
        this.send([(ke.CHANNEL_MESSAGES.channelaftertouch << 4) + (this.number - 1), Math.round(t)], {
            time: nt.toTimestamp(e.time)
        }),
        this
    }
    sendMasterTuning(t, e={}) {
        if (t = parseFloat(t) || 0,
        ot.validation && !(t > -65 && t < 64))
            throw new RangeError("The value must be a decimal number larger than -65 and smaller than 64.");
        let r = Math.floor(t) + 64
          , i = t - Math.floor(t);
        i = Math.round((i + 1) / 2 * 16383);
        let a = i >> 7 & 127
          , l = i & 127;
        return this.sendRpnValue("channelcoarsetuning", r, e),
        this.sendRpnValue("channelfinetuning", [a, l], e),
        this
    }
    sendModulationRange(t, e, r={}) {
        if (ot.validation) {
            if (!Number.isInteger(t) || !(t >= 0 && t <= 127))
                throw new RangeError("The semitones value must be an integer between 0 and 127.");
            if (e != null && (!Number.isInteger(e) || !(e >= 0 && e <= 127)))
                throw new RangeError("If specified, the cents value must be an integer between 0 and 127.")
        }
        return e >= 0 && e <= 127 || (e = 0),
        this.sendRpnValue("modulationrange", [t, e], r),
        this
    }
    sendNrpnValue(t, e, r={}) {
        if (e = [].concat(e),
        ot.validation) {
            if (!Array.isArray(t) || !Number.isInteger(t[0]) || !Number.isInteger(t[1]))
                throw new TypeError("The specified NRPN is invalid.");
            if (!(t[0] >= 0 && t[0] <= 127))
                throw new RangeError("The first byte of the NRPN must be between 0 and 127.");
            if (!(t[1] >= 0 && t[1] <= 127))
                throw new RangeError("The second byte of the NRPN must be between 0 and 127.");
            e.forEach(i => {
                if (!(i >= 0 && i <= 127))
                    throw new RangeError("The data bytes of the NRPN must be between 0 and 127.")
            }
            )
        }
        return this._selectNonRegisteredParameter(t, r),
        this._setCurrentParameter(e, r),
        this._deselectNonRegisteredParameter(r),
        this
    }
    sendPitchBend(t, e={}) {
        if (ot.validation)
            if (e.rawValue && Array.isArray(t)) {
                if (!(t[0] >= 0 && t[0] <= 127))
                    throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.");
                if (!(t[1] >= 0 && t[1] <= 127))
                    throw new RangeError("The pitch bend LSB must be an integer between 0 and 127.")
            } else if (e.rawValue && !Array.isArray(t)) {
                if (!(t >= 0 && t <= 127))
                    throw new RangeError("The pitch bend MSB must be an integer between 0 and 127.")
            } else {
                if (isNaN(t) || t === null)
                    throw new RangeError("Invalid pitch bend value.");
                if (!(t >= -1 && t <= 1))
                    throw new RangeError("The pitch bend value must be a float between -1 and 1.")
            }
        let r = 0
          , i = 0;
        if (e.rawValue && Array.isArray(t))
            r = t[0],
            i = t[1];
        else if (e.rawValue && !Array.isArray(t))
            r = t;
        else {
            const a = nt.fromFloatToMsbLsb((t + 1) / 2);
            r = a.msb,
            i = a.lsb
        }
        return this.send([(ke.CHANNEL_MESSAGES.pitchbend << 4) + (this.number - 1), i, r], {
            time: nt.toTimestamp(e.time)
        }),
        this
    }
    sendPitchBendRange(t, e, r={}) {
        if (ot.validation) {
            if (!Number.isInteger(t) || !(t >= 0 && t <= 127))
                throw new RangeError("The semitones value must be an integer between 0 and 127.");
            if (!Number.isInteger(e) || !(e >= 0 && e <= 127))
                throw new RangeError("The cents value must be an integer between 0 and 127.")
        }
        return this.sendRpnValue("pitchbendrange", [t, e], r),
        this
    }
    sendProgramChange(t, e={}) {
        if (t = parseInt(t) || 0,
        ot.validation && !(t >= 0 && t <= 127))
            throw new RangeError("The program number must be between 0 and 127.");
        return this.send([(ke.CHANNEL_MESSAGES.programchange << 4) + (this.number - 1), t], {
            time: nt.toTimestamp(e.time)
        }),
        this
    }
    sendRpnValue(t, e, r={}) {
        if (Array.isArray(t) || (t = ke.REGISTERED_PARAMETERS[t]),
        ot.validation) {
            if (!Number.isInteger(t[0]) || !Number.isInteger(t[1]))
                throw new TypeError("The specified NRPN is invalid.");
            if (!(t[0] >= 0 && t[0] <= 127))
                throw new RangeError("The first byte of the RPN must be between 0 and 127.");
            if (!(t[1] >= 0 && t[1] <= 127))
                throw new RangeError("The second byte of the RPN must be between 0 and 127.");
            [].concat(e).forEach(i => {
                if (!(i >= 0 && i <= 127))
                    throw new RangeError("The data bytes of the RPN must be between 0 and 127.")
            }
            )
        }
        return this._selectRegisteredParameter(t, r),
        this._setCurrentParameter(e, r),
        this._deselectRegisteredParameter(r),
        this
    }
    sendTuningBank(t, e={}) {
        if (ot.validation && (!Number.isInteger(t) || !(t >= 0 && t <= 127)))
            throw new RangeError("The tuning bank number must be between 0 and 127.");
        return this.sendRpnValue("tuningbank", t, e),
        this
    }
    sendTuningProgram(t, e={}) {
        if (ot.validation && (!Number.isInteger(t) || !(t >= 0 && t <= 127)))
            throw new RangeError("The tuning program number must be between 0 and 127.");
        return this.sendRpnValue("tuningprogram", t, e),
        this
    }
    sendLocalControl(t, e={}) {
        return t ? this.sendChannelMode("localcontrol", 127, e) : this.sendChannelMode("localcontrol", 0, e)
    }
    sendAllNotesOff(t={}) {
        return this.sendChannelMode("allnotesoff", 0, t)
    }
    sendAllSoundOff(t={}) {
        return this.sendChannelMode("allsoundoff", 0, t)
    }
    sendResetAllControllers(t={}) {
        return this.sendChannelMode("resetallcontrollers", 0, t)
    }
    sendPolyphonicMode(t, e={}) {
        return t === "mono" ? this.sendChannelMode("monomodeon", 0, e) : this.sendChannelMode("polymodeon", 0, e)
    }
    get octaveOffset() {
        return this._octaveOffset
    }
    set octaveOffset(t) {
        if (this.validation && (t = parseInt(t),
        isNaN(t)))
            throw new TypeError("The 'octaveOffset' property must be an integer.");
        this._octaveOffset = t
    }
    get output() {
        return this._output
    }
    get number() {
        return this._number
    }
}
/**
 * The `Output` class represents a single MIDI output port (not to be confused with a MIDI channel).
 * A port is made available by a MIDI device. A MIDI device can advertise several input and output
 * ports. Each port has 16 MIDI channels which can be accessed via the [`channels`](#channels)
 * property.
 *
 * The `Output` object is automatically instantiated by the library according to the host's MIDI
 * subsystem and should not be directly instantiated.
 *
 * You can access all available `Output` objects by referring to the
 * [`WebMidi.outputs`](WebMidi#outputs) array or by using methods such as
 * [`WebMidi.getOutputByName()`](WebMidi#getOutputByName) or
 * [`WebMidi.getOutputById()`](WebMidi#getOutputById).
 *
 * @fires Output#opened
 * @fires Output#disconnected
 * @fires Output#closed
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class tm extends Ws {
    constructor(t) {
        super(),
        this._midiOutput = t,
        this._octaveOffset = 0,
        this.channels = [];
        for (let e = 1; e <= 16; e++)
            this.channels[e] = new ES(this,e);
        this._midiOutput.onstatechange = this._onStateChange.bind(this)
    }
    async destroy() {
        this.removeListener(),
        this.channels.forEach(t => t.destroy()),
        this.channels = [],
        this._midiOutput && (this._midiOutput.onstatechange = null),
        await this.close(),
        this._midiOutput = null
    }
    _onStateChange(t) {
        let e = {
            timestamp: ot.time
        };
        t.port.connection === "open" ? (e.type = "opened",
        e.target = this,
        e.port = e.target,
        this.emit("opened", e)) : t.port.connection === "closed" && t.port.state === "connected" ? (e.type = "closed",
        e.target = this,
        e.port = e.target,
        this.emit("closed", e)) : t.port.connection === "closed" && t.port.state === "disconnected" ? (e.type = "disconnected",
        e.port = {
            connection: t.port.connection,
            id: t.port.id,
            manufacturer: t.port.manufacturer,
            name: t.port.name,
            state: t.port.state,
            type: t.port.type
        },
        this.emit("disconnected", e)) : t.port.connection === "pending" && t.port.state === "disconnected" || console.warn("This statechange event was not caught:", t.port.connection, t.port.state)
    }
    async open() {
        try {
            return await this._midiOutput.open(),
            Promise.resolve(this)
        } catch (t) {
            return Promise.reject(t)
        }
    }
    async close() {
        this._midiOutput ? await this._midiOutput.close() : await Promise.resolve()
    }
    send(t, e={
        time: 0
    }, r=0) {
        if (t instanceof ry && (t = nt.isNode ? t.data : t.rawData),
        t instanceof Uint8Array && nt.isNode && (t = Array.from(t)),
        ot.validation) {
            if (!Array.isArray(t) && !(t instanceof Uint8Array) && (t = [t],
            Array.isArray(e) && (t = t.concat(e)),
            e = isNaN(r) ? {
                time: 0
            } : {
                time: r
            }),
            !(parseInt(t[0]) >= 128 && parseInt(t[0]) <= 255))
                throw new RangeError("The first byte (status) must be an integer between 128 and 255.");
            t.slice(1).forEach(i => {
                if (i = parseInt(i),
                !(i >= 0 && i <= 255))
                    throw new RangeError("Data bytes must be integers between 0 and 255.")
            }
            ),
            e || (e = {
                time: 0
            })
        }
        return this._midiOutput.send(t, nt.toTimestamp(e.time)),
        this
    }
    sendSysex(t, e=[], r={}) {
        if (t = [].concat(t),
        e instanceof Uint8Array) {
            const i = new Uint8Array(1 + t.length + e.length + 1);
            i[0] = ke.SYSTEM_MESSAGES.sysex,
            i.set(Uint8Array.from(t), 1),
            i.set(e, 1 + t.length),
            i[i.length - 1] = ke.SYSTEM_MESSAGES.sysexend,
            this.send(i, {
                time: r.time
            })
        } else {
            const i = t.concat(e, ke.SYSTEM_MESSAGES.sysexend);
            this.send([ke.SYSTEM_MESSAGES.sysex].concat(i), {
                time: r.time
            })
        }
        return this
    }
    clear() {
        return this._midiOutput.clear ? this._midiOutput.clear() : ot.validation && console.warn("The 'clear()' method has not yet been implemented in your environment."),
        this
    }
    sendTimecodeQuarterFrame(t, e={}) {
        if (ot.validation && (t = parseInt(t),
        isNaN(t) || !(t >= 0 && t <= 127)))
            throw new RangeError("The value must be an integer between 0 and 127.");
        return this.send([ke.SYSTEM_MESSAGES.timecode, t], {
            time: e.time
        }),
        this
    }
    sendSongPosition(t=0, e={}) {
        t = Math.floor(t) || 0;
        var r = t >> 7 & 127
          , i = t & 127;
        return this.send([ke.SYSTEM_MESSAGES.songposition, r, i], {
            time: e.time
        }),
        this
    }
    sendSongSelect(t=0, e={}) {
        if (ot.validation && (t = parseInt(t),
        isNaN(t) || !(t >= 0 && t <= 127)))
            throw new RangeError("The program value must be between 0 and 127");
        return this.send([ke.SYSTEM_MESSAGES.songselect, t], {
            time: e.time
        }),
        this
    }
    sendTuneRequest(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.tunerequest], {
            time: t.time
        }),
        this
    }
    sendClock(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.clock], {
            time: t.time
        }),
        this
    }
    sendStart(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.start], {
            time: t.time
        }),
        this
    }
    sendContinue(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.continue], {
            time: t.time
        }),
        this
    }
    sendStop(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.stop], {
            time: t.time
        }),
        this
    }
    sendActiveSensing(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.activesensing], {
            time: t.time
        }),
        this
    }
    sendReset(t={}) {
        return this.send([ke.SYSTEM_MESSAGES.reset], {
            time: t.time
        }),
        this
    }
    sendTuningRequest(t={}) {
        return ot.validation && console.warn("The sendTuningRequest() method has been deprecated. Use sendTuningRequest() instead."),
        this.sendTuneRequest(t)
    }
    sendKeyAftertouch(t, e, r={}) {
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].sendKeyAftertouch(t, e, r)
        }
        ),
        this
    }
    sendControlChange(t, e, r={}, i={}) {
        if (ot.validation && (Array.isArray(r) || Number.isInteger(r) || r === "all")) {
            const a = r;
            r = i,
            r.channels = a,
            r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(a => {
            this.channels[a].sendControlChange(t, e, r)
        }
        ),
        this
    }
    sendPitchBendRange(t=0, e=0, r={}) {
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].sendPitchBendRange(t, e, r)
        }
        ),
        this
    }
    setPitchBendRange(t=0, e=0, r="all", i={}) {
        return ot.validation && (console.warn("The setPitchBendRange() method is deprecated. Use sendPitchBendRange() instead."),
        i.channels = r,
        i.channels === "all" && (i.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendPitchBendRange(t, e, i)
    }
    sendRpnValue(t, e, r={}) {
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].sendRpnValue(t, e, r)
        }
        ),
        this
    }
    setRegisteredParameter(t, e=[], r="all", i={}) {
        return ot.validation && (console.warn("The setRegisteredParameter() method is deprecated. Use sendRpnValue() instead."),
        i.channels = r,
        i.channels === "all" && (i.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendRpnValue(t, e, i)
    }
    sendChannelAftertouch(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendChannelAftertouch(t, e)
        }
        ),
        this
    }
    sendPitchBend(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendPitchBend(t, e)
        }
        ),
        this
    }
    sendProgramChange(t=0, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendProgramChange(t, e)
        }
        ),
        this
    }
    sendModulationRange(t, e, r={}) {
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].sendModulationRange(t, e, r)
        }
        ),
        this
    }
    setModulationRange(t=0, e=0, r="all", i={}) {
        return ot.validation && (console.warn("The setModulationRange() method is deprecated. Use sendModulationRange() instead."),
        i.channels = r,
        i.channels === "all" && (i.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendModulationRange(t, e, i)
    }
    sendMasterTuning(t, e={}) {
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(r => {
            this.channels[r].sendMasterTuning(t, e)
        }
        ),
        this
    }
    setMasterTuning(t, e={}, r={}) {
        return ot.validation && (console.warn("The setMasterTuning() method is deprecated. Use sendMasterTuning() instead."),
        r.channels = e,
        r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendMasterTuning(t, r)
    }
    sendTuningProgram(t, e={}) {
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(r => {
            this.channels[r].sendTuningProgram(t, e)
        }
        ),
        this
    }
    setTuningProgram(t, e="all", r={}) {
        return ot.validation && (console.warn("The setTuningProgram() method is deprecated. Use sendTuningProgram() instead."),
        r.channels = e,
        r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendTuningProgram(t, r)
    }
    sendTuningBank(t=0, e={}) {
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(r => {
            this.channels[r].sendTuningBank(t, e)
        }
        ),
        this
    }
    setTuningBank(t, e="all", r={}) {
        return ot.validation && (console.warn("The setTuningBank() method is deprecated. Use sendTuningBank() instead."),
        r.channels = e,
        r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendTuningBank(t, r)
    }
    sendChannelMode(t, e=0, r={}, i={}) {
        if (ot.validation && (Array.isArray(r) || Number.isInteger(r) || r === "all")) {
            const a = r;
            r = i,
            r.channels = a,
            r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(a => {
            this.channels[a].sendChannelMode(t, e, r)
        }
        ),
        this
    }
    sendAllSoundOff(t={}) {
        return t.channels == null && (t.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(t.channels).forEach(e => {
            this.channels[e].sendAllSoundOff(t)
        }
        ),
        this
    }
    sendAllNotesOff(t={}) {
        return t.channels == null && (t.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(t.channels).forEach(e => {
            this.channels[e].sendAllNotesOff(t)
        }
        ),
        this
    }
    sendResetAllControllers(t={}, e={}) {
        if (ot.validation && (Array.isArray(t) || Number.isInteger(t) || t === "all")) {
            const r = t;
            t = e,
            t.channels = r,
            t.channels === "all" && (t.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return t.channels == null && (t.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(t.channels).forEach(r => {
            this.channels[r].sendResetAllControllers(t)
        }
        ),
        this
    }
    sendPolyphonicMode(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendPolyphonicMode(t, e)
        }
        ),
        this
    }
    sendLocalControl(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendLocalControl(t, e)
        }
        ),
        this
    }
    sendOmniMode(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendOmniMode(t, e)
        }
        ),
        this
    }
    sendNrpnValue(t, e, r={}) {
        return r.channels == null && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].sendNrpnValue(t, e, r)
        }
        ),
        this
    }
    setNonRegisteredParameter(t, e=[], r="all", i={}) {
        return ot.validation && (console.warn("The setNonRegisteredParameter() method is deprecated. Use sendNrpnValue() instead."),
        i.channels = r,
        i.channels === "all" && (i.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendNrpnValue(t, e, i)
    }
    sendRpnIncrement(t, e={}) {
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(r => {
            this.channels[r].sendRpnIncrement(t, e)
        }
        ),
        this
    }
    incrementRegisteredParameter(t, e="all", r={}) {
        return ot.validation && (console.warn("The incrementRegisteredParameter() method is deprecated. Use sendRpnIncrement() instead."),
        r.channels = e,
        r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendRpnIncrement(t, r)
    }
    sendRpnDecrement(t, e={}) {
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(r => {
            this.channels[r].sendRpnDecrement(t, e)
        }
        ),
        this
    }
    decrementRegisteredParameter(t, e="all", r={}) {
        return ot.validation && (console.warn("The decrementRegisteredParameter() method is deprecated. Use sendRpnDecrement() instead."),
        r.channels = e,
        r.channels === "all" && (r.channels = ke.MIDI_CHANNEL_NUMBERS)),
        this.sendRpnDecrement(t, r)
    }
    sendNoteOff(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendNoteOff(t, e)
        }
        ),
        this
    }
    stopNote(t, e) {
        return this.sendNoteOff(t, e)
    }
    playNote(t, e={}, r={}) {
        if (ot.validation && (e.rawVelocity && console.warn("The 'rawVelocity' option is deprecated. Use 'rawAttack' instead."),
        e.velocity && console.warn("The 'velocity' option is deprecated. Use 'velocity' instead."),
        Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].playNote(t, e)
        }
        ),
        this
    }
    sendNoteOn(t, e={}, r={}) {
        if (ot.validation && (Array.isArray(e) || Number.isInteger(e) || e === "all")) {
            const i = e;
            e = r,
            e.channels = i,
            e.channels === "all" && (e.channels = ke.MIDI_CHANNEL_NUMBERS)
        }
        return e.channels == null && (e.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(e.channels).forEach(i => {
            this.channels[i].sendNoteOn(t, e)
        }
        ),
        this
    }
    get name() {
        return this._midiOutput.name
    }
    get id() {
        return this._midiOutput.id
    }
    get connection() {
        return this._midiOutput.connection
    }
    get manufacturer() {
        return this._midiOutput.manufacturer
    }
    get state() {
        return this._midiOutput.state
    }
    get type() {
        return this._midiOutput.type
    }
    get octaveOffset() {
        return this._octaveOffset
    }
    set octaveOffset(t) {
        if (this.validation && (t = parseInt(t),
        isNaN(t)))
            throw new TypeError("The 'octaveOffset' property must be an integer.");
        this._octaveOffset = t
    }
}
/**
 * The `Forwarder` class allows the forwarding of MIDI messages to predetermined outputs. When you
 * call its [`forward()`](#forward) method, it will send the specified [`Message`](Message) object
 * to all the outputs listed in its [`destinations`](#destinations) property.
 *
 * If specific channels or message types have been defined in the [`channels`](#channels) or
 * [`types`](#types) properties, only messages matching the channels/types will be forwarded.
 *
 * While it can be manually instantiated, you are more likely to come across a `Forwarder` object as
 * the return value of the [`Input.addForwarder()`](Input#addForwarder) method.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class J0 {
    constructor(t=[], e={}) {
        this.destinations = [],
        this.types = [...Object.keys(ke.SYSTEM_MESSAGES), ...Object.keys(ke.CHANNEL_MESSAGES)],
        this.channels = ke.MIDI_CHANNEL_NUMBERS,
        this.suspended = !1,
        Array.isArray(t) || (t = [t]),
        e.types && !Array.isArray(e.types) && (e.types = [e.types]),
        e.channels && !Array.isArray(e.channels) && (e.channels = [e.channels]),
        ot.validation && (t.forEach(r => {
            if (!(r instanceof tm))
                throw new TypeError("Destinations must be of type 'Output'.")
        }
        ),
        e.types !== void 0 && e.types.forEach(r => {
            if (!ke.SYSTEM_MESSAGES.hasOwnProperty(r) && !ke.CHANNEL_MESSAGES.hasOwnProperty(r))
                throw new TypeError("Type must be a valid message type.")
        }
        ),
        e.channels !== void 0 && e.channels.forEach(r => {
            if (!ke.MIDI_CHANNEL_NUMBERS.includes(r))
                throw new TypeError("MIDI channel must be between 1 and 16.")
        }
        )),
        this.destinations = t,
        e.types && (this.types = e.types),
        e.channels && (this.channels = e.channels)
    }
    forward(t) {
        this.suspended || this.types.includes(t.type) && (t.channel && !this.channels.includes(t.channel) || this.destinations.forEach(e => {
            ot.validation && !(e instanceof tm) || e.send(t)
        }
        ))
    }
}
/**
 * The `InputChannel` class represents a single MIDI input channel (1-16) from a single input
 * device. This object is derived from the host's MIDI subsystem and should not be instantiated
 * directly.
 *
 * All 16 `InputChannel` objects can be found inside the input's [`channels`](Input#channels)
 * property.
 *
 * @fires InputChannel#midimessage
 * @fires InputChannel#unknownmessage
 *
 * @fires InputChannel#noteoff
 * @fires InputChannel#noteon
 * @fires InputChannel#keyaftertouch
 * @fires InputChannel#programchange
 * @fires InputChannel#channelaftertouch
 * @fires InputChannel#pitchbend
 *
 * @fires InputChannel#allnotesoff
 * @fires InputChannel#allsoundoff
 * @fires InputChannel#localcontrol
 * @fires InputChannel#monomode
 * @fires InputChannel#omnimode
 * @fires InputChannel#resetallcontrollers
 *
 * @fires InputChannel#event:nrpn
 * @fires InputChannel#event:nrpn-dataentrycoarse
 * @fires InputChannel#event:nrpn-dataentryfine
 * @fires InputChannel#event:nrpn-dataincrement
 * @fires InputChannel#event:nrpn-datadecrement
 * @fires InputChannel#event:rpn
 * @fires InputChannel#event:rpn-dataentrycoarse
 * @fires InputChannel#event:rpn-dataentryfine
 * @fires InputChannel#event:rpn-dataincrement
 * @fires InputChannel#event:rpn-datadecrement
 *
 * @fires InputChannel#controlchange
 * @fires InputChannel#event:controlchange-controllerxxx
 * @fires InputChannel#event:controlchange-bankselectcoarse
 * @fires InputChannel#event:controlchange-modulationwheelcoarse
 * @fires InputChannel#event:controlchange-breathcontrollercoarse
 * @fires InputChannel#event:controlchange-footcontrollercoarse
 * @fires InputChannel#event:controlchange-portamentotimecoarse
 * @fires InputChannel#event:controlchange-dataentrycoarse
 * @fires InputChannel#event:controlchange-volumecoarse
 * @fires InputChannel#event:controlchange-balancecoarse
 * @fires InputChannel#event:controlchange-pancoarse
 * @fires InputChannel#event:controlchange-expressioncoarse
 * @fires InputChannel#event:controlchange-effectcontrol1coarse
 * @fires InputChannel#event:controlchange-effectcontrol2coarse
 * @fires InputChannel#event:controlchange-generalpurposecontroller1
 * @fires InputChannel#event:controlchange-generalpurposecontroller2
 * @fires InputChannel#event:controlchange-generalpurposecontroller3
 * @fires InputChannel#event:controlchange-generalpurposecontroller4
 * @fires InputChannel#event:controlchange-bankselectfine
 * @fires InputChannel#event:controlchange-modulationwheelfine
 * @fires InputChannel#event:controlchange-breathcontrollerfine
 * @fires InputChannel#event:controlchange-footcontrollerfine
 * @fires InputChannel#event:controlchange-portamentotimefine
 * @fires InputChannel#event:controlchange-dataentryfine
 * @fires InputChannel#event:controlchange-channelvolumefine
 * @fires InputChannel#event:controlchange-balancefine
 * @fires InputChannel#event:controlchange-panfine
 * @fires InputChannel#event:controlchange-expressionfine
 * @fires InputChannel#event:controlchange-effectcontrol1fine
 * @fires InputChannel#event:controlchange-effectcontrol2fine
 * @fires InputChannel#event:controlchange-damperpedal
 * @fires InputChannel#event:controlchange-portamento
 * @fires InputChannel#event:controlchange-sostenuto
 * @fires InputChannel#event:controlchange-softpedal
 * @fires InputChannel#event:controlchange-legatopedal
 * @fires InputChannel#event:controlchange-hold2
 * @fires InputChannel#event:controlchange-soundvariation
 * @fires InputChannel#event:controlchange-resonance
 * @fires InputChannel#event:controlchange-releasetime
 * @fires InputChannel#event:controlchange-attacktime
 * @fires InputChannel#event:controlchange-brightness
 * @fires InputChannel#event:controlchange-decaytime
 * @fires InputChannel#event:controlchange-vibratorate
 * @fires InputChannel#event:controlchange-vibratodepth
 * @fires InputChannel#event:controlchange-vibratodelay
 * @fires InputChannel#event:controlchange-generalpurposecontroller5
 * @fires InputChannel#event:controlchange-generalpurposecontroller6
 * @fires InputChannel#event:controlchange-generalpurposecontroller7
 * @fires InputChannel#event:controlchange-generalpurposecontroller8
 * @fires InputChannel#event:controlchange-portamentocontrol
 * @fires InputChannel#event:controlchange-highresolutionvelocityprefix
 * @fires InputChannel#event:controlchange-effect1depth
 * @fires InputChannel#event:controlchange-effect2depth
 * @fires InputChannel#event:controlchange-effect3depth
 * @fires InputChannel#event:controlchange-effect4depth
 * @fires InputChannel#event:controlchange-effect5depth
 * @fires InputChannel#event:controlchange-dataincrement
 * @fires InputChannel#event:controlchange-datadecrement
 * @fires InputChannel#event:controlchange-nonregisteredparameterfine
 * @fires InputChannel#event:controlchange-nonregisteredparametercoarse
 * @fires InputChannel#event:controlchange-registeredparameterfine
 * @fires InputChannel#event:controlchange-registeredparametercoarse
 * @fires InputChannel#event:controlchange-allsoundoff
 * @fires InputChannel#event:controlchange-resetallcontrollers
 * @fires InputChannel#event:controlchange-localcontrol
 * @fires InputChannel#event:controlchange-allnotesoff
 * @fires InputChannel#event:controlchange-omnimodeoff
 * @fires InputChannel#event:controlchange-omnimodeon
 * @fires InputChannel#event:controlchange-monomodeon
 * @fires InputChannel#event:controlchange-polymodeon
 * @fires InputChannel#event:
 *
 * @extends EventEmitter
 * @license Apache-2.0
 * @since 3.0.0
 */
class _S extends Ws {
    constructor(t, e) {
        super(),
        this._input = t,
        this._number = e,
        this._octaveOffset = 0,
        this._nrpnBuffer = [],
        this._rpnBuffer = [],
        this.parameterNumberEventsEnabled = !0,
        this.notesState = new Array(128).fill(!1)
    }
    destroy() {
        this._input = null,
        this._number = null,
        this._octaveOffset = 0,
        this._nrpnBuffer = [],
        this.notesState = new Array(128).fill(!1),
        this.parameterNumberEventsEnabled = !1,
        this.removeListener()
    }
    _processMidiMessageEvent(t) {
        const e = Object.assign({}, t);
        e.port = this.input,
        e.target = this,
        e.type = "midimessage",
        this.emit(e.type, e),
        this._parseEventForStandardMessages(e)
    }
    _parseEventForStandardMessages(t) {
        const e = Object.assign({}, t);
        e.type = e.message.type || "unknownmessage";
        const r = t.message.dataBytes[0]
          , i = t.message.dataBytes[1];
        if (e.type === "noteoff" || e.type === "noteon" && i === 0)
            this.notesState[r] = !1,
            e.type = "noteoff",
            e.note = new La(nt.offsetNumber(r, this.octaveOffset + this.input.octaveOffset + ot.octaveOffset),{
                rawAttack: 0,
                rawRelease: i
            }),
            e.value = nt.from7bitToFloat(i),
            e.rawValue = i,
            e.velocity = e.note.release,
            e.rawVelocity = e.note.rawRelease;
        else if (e.type === "noteon")
            this.notesState[r] = !0,
            e.note = new La(nt.offsetNumber(r, this.octaveOffset + this.input.octaveOffset + ot.octaveOffset),{
                rawAttack: i
            }),
            e.value = nt.from7bitToFloat(i),
            e.rawValue = i,
            e.velocity = e.note.attack,
            e.rawVelocity = e.note.rawAttack;
        else if (e.type === "keyaftertouch")
            e.note = new La(nt.offsetNumber(r, this.octaveOffset + this.input.octaveOffset + ot.octaveOffset)),
            e.value = nt.from7bitToFloat(i),
            e.rawValue = i,
            e.identifier = e.note.identifier,
            e.key = e.note.number,
            e.rawKey = r;
        else if (e.type === "controlchange") {
            e.controller = {
                number: r,
                name: ke.CONTROL_CHANGE_MESSAGES[r].name,
                description: ke.CONTROL_CHANGE_MESSAGES[r].description,
                position: ke.CONTROL_CHANGE_MESSAGES[r].position
            },
            e.subtype = e.controller.name || "controller" + r,
            e.value = nt.from7bitToFloat(i),
            e.rawValue = i;
            const a = Object.assign({}, e);
            a.type = `${e.type}-controller${r}`,
            delete a.subtype,
            this.emit(a.type, a);
            const l = Object.assign({}, e);
            l.type = `${e.type}-` + ke.CONTROL_CHANGE_MESSAGES[r].name,
            delete l.subtype,
            l.type.indexOf("controller") !== 0 && this.emit(l.type, l),
            e.message.dataBytes[0] >= 120 && this._parseChannelModeMessage(e),
            this.parameterNumberEventsEnabled && this._isRpnOrNrpnController(e.message.dataBytes[0]) && this._parseEventForParameterNumber(e)
        } else
            e.type === "programchange" ? (e.value = r,
            e.rawValue = e.value) : e.type === "channelaftertouch" ? (e.value = nt.from7bitToFloat(r),
            e.rawValue = r) : e.type === "pitchbend" ? (e.value = ((i << 7) + r - 8192) / 8192,
            e.rawValue = (i << 7) + r) : e.type = "unknownmessage";
        this.emit(e.type, e)
    }
    _parseChannelModeMessage(t) {
        const e = Object.assign({}, t);
        e.type = e.controller.name,
        e.type === "localcontrol" && (e.value = e.message.data[2] === 127,
        e.rawValue = e.message.data[2]),
        e.type === "omnimodeon" ? (e.type = "omnimode",
        e.value = !0,
        e.rawValue = e.message.data[2]) : e.type === "omnimodeoff" && (e.type = "omnimode",
        e.value = !1,
        e.rawValue = e.message.data[2]),
        e.type === "monomodeon" ? (e.type = "monomode",
        e.value = !0,
        e.rawValue = e.message.data[2]) : e.type === "polymodeon" && (e.type = "monomode",
        e.value = !1,
        e.rawValue = e.message.data[2]),
        this.emit(e.type, e)
    }
    _parseEventForParameterNumber(t) {
        const e = t.message.dataBytes[0]
          , r = t.message.dataBytes[1];
        e === 99 || e === 101 ? (this._nrpnBuffer = [],
        this._rpnBuffer = [],
        e === 99 ? this._nrpnBuffer = [t.message] : r !== 127 && (this._rpnBuffer = [t.message])) : e === 98 || e === 100 ? e === 98 ? (this._rpnBuffer = [],
        this._nrpnBuffer.length === 1 ? this._nrpnBuffer.push(t.message) : this._nrpnBuffer = []) : (this._nrpnBuffer = [],
        this._rpnBuffer.length === 1 && r !== 127 ? this._rpnBuffer.push(t.message) : this._rpnBuffer = []) : (e === 6 || e === 38 || e === 96 || e === 97) && (this._rpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("rpn", this._rpnBuffer[0].dataBytes[1], this._rpnBuffer[1].dataBytes[1], t) : this._nrpnBuffer.length === 2 ? this._dispatchParameterNumberEvent("nrpn", this._nrpnBuffer[0].dataBytes[1], this._nrpnBuffer[1].dataBytes[1], t) : (this._nrpnBuffer = [],
        this._rpnBuffer = []))
    }
    _isRpnOrNrpnController(t) {
        return t === 6 || t === 38 || t === 96 || t === 97 || t === 98 || t === 99 || t === 100 || t === 101
    }
    _dispatchParameterNumberEvent(t, e, r, i) {
        t = t === "nrpn" ? "nrpn" : "rpn";
        const a = {
            target: i.target,
            timestamp: i.timestamp,
            message: i.message,
            parameterMsb: e,
            parameterLsb: r,
            value: nt.from7bitToFloat(i.message.dataBytes[1]),
            rawValue: i.message.dataBytes[1]
        };
        t === "rpn" ? a.parameter = Object.keys(ke.REGISTERED_PARAMETERS).find(h => ke.REGISTERED_PARAMETERS[h][0] === e && ke.REGISTERED_PARAMETERS[h][1] === r) : a.parameter = (e << 7) + r;
        const l = ke.CONTROL_CHANGE_MESSAGES[i.message.dataBytes[0]].name;
        a.type = `${t}-${l}`,
        this.emit(a.type, a);
        const f = Object.assign({}, a);
        f.type === "nrpn-dataincrement" ? f.type = "nrpn-databuttonincrement" : f.type === "nrpn-datadecrement" ? f.type = "nrpn-databuttondecrement" : f.type === "rpn-dataincrement" ? f.type = "rpn-databuttonincrement" : f.type === "rpn-datadecrement" && (f.type = "rpn-databuttondecrement"),
        this.emit(f.type, f),
        a.type = t,
        a.subtype = l,
        this.emit(a.type, a)
    }
    getChannelModeByNumber(t) {
        return ot.validation && (console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class."),
        t = Math.floor(t)),
        nt.getChannelModeByNumber(t)
    }
    getCcNameByNumber(t) {
        if (ot.validation && (console.warn("The 'getCcNameByNumber()' method has been moved to the 'Utilities' class."),
        t = parseInt(t),
        !(t >= 0 && t <= 127)))
            throw new RangeError("Invalid control change number.");
        return nt.getCcNameByNumber(t)
    }
    getNoteState(t) {
        t instanceof La && (t = t.identifier);
        const e = nt.guessNoteNumber(t, ot.octaveOffset + this.input.octaveOffset + this.octaveOffset);
        return this.notesState[e]
    }
    get octaveOffset() {
        return this._octaveOffset
    }
    set octaveOffset(t) {
        if (this.validation && (t = parseInt(t),
        isNaN(t)))
            throw new TypeError("The 'octaveOffset' property must be an integer.");
        this._octaveOffset = t
    }
    get input() {
        return this._input
    }
    get number() {
        return this._number
    }
    get nrpnEventsEnabled() {
        return this.parameterNumberEventsEnabled
    }
    set nrpnEventsEnabled(t) {
        this.validation && (t = !!t),
        this.parameterNumberEventsEnabled = t
    }
}
/**
 * The `Message` class represents a single MIDI message. It has several properties that make it
 * easy to make sense of the binary data it contains.
 *
 * @license Apache-2.0
 * @since 3.0.0
 */
class ry {
    constructor(t) {
        this.rawData = t,
        this.data = Array.from(this.rawData),
        this.statusByte = this.rawData[0],
        this.rawDataBytes = this.rawData.slice(1),
        this.dataBytes = this.data.slice(1),
        this.isChannelMessage = !1,
        this.isSystemMessage = !1,
        this.command = void 0,
        this.channel = void 0,
        this.manufacturerId = void 0,
        this.type = void 0,
        this.statusByte < 240 ? (this.isChannelMessage = !0,
        this.command = this.statusByte >> 4,
        this.channel = (this.statusByte & 15) + 1) : (this.isSystemMessage = !0,
        this.command = this.statusByte),
        this.isChannelMessage ? this.type = nt.getPropertyByValue(ke.CHANNEL_MESSAGES, this.command) : this.isSystemMessage && (this.type = nt.getPropertyByValue(ke.SYSTEM_MESSAGES, this.command)),
        this.statusByte === ke.SYSTEM_MESSAGES.sysex && (this.dataBytes[0] === 0 ? (this.manufacturerId = this.dataBytes.slice(0, 3),
        this.dataBytes = this.dataBytes.slice(3, this.rawDataBytes.length - 1),
        this.rawDataBytes = this.rawDataBytes.slice(3, this.rawDataBytes.length - 1)) : (this.manufacturerId = [this.dataBytes[0]],
        this.dataBytes = this.dataBytes.slice(1, this.dataBytes.length - 1),
        this.rawDataBytes = this.rawDataBytes.slice(1, this.rawDataBytes.length - 1)))
    }
}
/**
 * The `Input` class represents a single MIDI input port. This object is automatically instantiated
 * by the library according to the host's MIDI subsystem and does not need to be directly
 * instantiated. Instead, you can access all `Input` objects by referring to the
 * [`WebMidi.inputs`](WebMidi#inputs) array. You can also retrieve inputs by using methods such as
 * [`WebMidi.getInputByName()`](WebMidi#getInputByName) and
 * [`WebMidi.getInputById()`](WebMidi#getInputById).
 *
 * Note that a single MIDI device may expose several inputs and/or outputs.
 *
 * **Important**: the `Input` class does not directly fire channel-specific MIDI messages
 * (such as [`noteon`](InputChannel#event:noteon) or
 * [`controlchange`](InputChannel#event:controlchange), etc.). The [`InputChannel`](InputChannel)
 * object does that. However, you can still use the
 * [`Input.addListener()`](#addListener) method to listen to channel-specific events on multiple
 * [`InputChannel`](InputChannel) objects at once.
 *
 * @fires Input#opened
 * @fires Input#disconnected
 * @fires Input#closed
 * @fires Input#midimessage
 *
 * @fires Input#sysex
 * @fires Input#timecode
 * @fires Input#songposition
 * @fires Input#songselect
 * @fires Input#tunerequest
 * @fires Input#clock
 * @fires Input#start
 * @fires Input#continue
 * @fires Input#stop
 * @fires Input#activesensing
 * @fires Input#reset
 *
 * @fires Input#unknownmidimessage
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class LS extends Ws {
    constructor(t) {
        super(),
        this._midiInput = t,
        this._octaveOffset = 0,
        this.channels = [];
        for (let e = 1; e <= 16; e++)
            this.channels[e] = new _S(this,e);
        this._forwarders = [],
        this._midiInput.onstatechange = this._onStateChange.bind(this),
        this._midiInput.onmidimessage = this._onMidiMessage.bind(this)
    }
    async destroy() {
        this.removeListener(),
        this.channels.forEach(t => t.destroy()),
        this.channels = [],
        this._forwarders = [],
        this._midiInput && (this._midiInput.onstatechange = null,
        this._midiInput.onmidimessage = null),
        await this.close(),
        this._midiInput = null
    }
    _onStateChange(t) {
        let e = {
            timestamp: ot.time,
            target: this,
            port: this
        };
        t.port.connection === "open" ? (e.type = "opened",
        this.emit("opened", e)) : t.port.connection === "closed" && t.port.state === "connected" ? (e.type = "closed",
        this.emit("closed", e)) : t.port.connection === "closed" && t.port.state === "disconnected" ? (e.type = "disconnected",
        e.port = {
            connection: t.port.connection,
            id: t.port.id,
            manufacturer: t.port.manufacturer,
            name: t.port.name,
            state: t.port.state,
            type: t.port.type
        },
        this.emit("disconnected", e)) : t.port.connection === "pending" && t.port.state === "disconnected" || console.warn("This statechange event was not caught: ", t.port.connection, t.port.state)
    }
    _onMidiMessage(t) {
        const e = new ry(t.data)
          , r = {
            port: this,
            target: this,
            message: e,
            timestamp: t.timeStamp,
            type: "midimessage",
            data: e.data,
            rawData: e.data,
            statusByte: e.data[0],
            dataBytes: e.dataBytes
        };
        this.emit("midimessage", r),
        e.isSystemMessage ? this._parseEvent(r) : e.isChannelMessage && this.channels[e.channel]._processMidiMessageEvent(r),
        this._forwarders.forEach(i => i.forward(e))
    }
    _parseEvent(t) {
        const e = Object.assign({}, t);
        e.type = e.message.type || "unknownmidimessage",
        e.type === "songselect" && (e.song = t.data[1] + 1,
        e.value = t.data[1],
        e.rawValue = e.value),
        this.emit(e.type, e)
    }
    async open() {
        try {
            await this._midiInput.open()
        } catch (t) {
            return Promise.reject(t)
        }
        return Promise.resolve(this)
    }
    async close() {
        if (!this._midiInput)
            return Promise.resolve(this);
        try {
            await this._midiInput.close()
        } catch (t) {
            return Promise.reject(t)
        }
        return Promise.resolve(this)
    }
    getChannelModeByNumber() {
        ot.validation && console.warn("The 'getChannelModeByNumber()' method has been moved to the 'Utilities' class.")
    }
    addListener(t, e, r={}) {
        if (ot.validation && typeof r == "function") {
            let i = e != null ? [].concat(e) : void 0;
            e = r,
            r = {
                channels: i
            }
        }
        if (ke.CHANNEL_EVENTS.includes(t)) {
            r.channels === void 0 && (r.channels = ke.MIDI_CHANNEL_NUMBERS);
            let i = [];
            return nt.sanitizeChannels(r.channels).forEach(a => {
                i.push(this.channels[a].addListener(t, e, r))
            }
            ),
            i
        } else
            return super.addListener(t, e, r)
    }
    addOneTimeListener(t, e, r={}) {
        return r.remaining = 1,
        this.addListener(t, e, r)
    }
    on(t, e, r, i) {
        return this.addListener(t, e, r, i)
    }
    hasListener(t, e, r={}) {
        if (ot.validation && typeof r == "function") {
            let i = [].concat(e);
            e = r,
            r = {
                channels: i
            }
        }
        return ke.CHANNEL_EVENTS.includes(t) ? (r.channels === void 0 && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        nt.sanitizeChannels(r.channels).every(i => this.channels[i].hasListener(t, e))) : super.hasListener(t, e)
    }
    removeListener(t, e, r={}) {
        if (ot.validation && typeof r == "function") {
            let i = [].concat(e);
            e = r,
            r = {
                channels: i
            }
        }
        if (r.channels === void 0 && (r.channels = ke.MIDI_CHANNEL_NUMBERS),
        t == null)
            return nt.sanitizeChannels(r.channels).forEach(i => {
                this.channels[i] && this.channels[i].removeListener()
            }
            ),
            super.removeListener();
        ke.CHANNEL_EVENTS.includes(t) ? nt.sanitizeChannels(r.channels).forEach(i => {
            this.channels[i].removeListener(t, e, r)
        }
        ) : super.removeListener(t, e, r)
    }
    addForwarder(t, e={}) {
        let r;
        return t instanceof J0 ? r = t : r = new J0(t,e),
        this._forwarders.push(r),
        r
    }
    removeForwarder(t) {
        this._forwarders = this._forwarders.filter(e => e !== t)
    }
    hasForwarder(t) {
        return this._forwarders.includes(t)
    }
    get name() {
        return this._midiInput.name
    }
    get id() {
        return this._midiInput.id
    }
    get connection() {
        return this._midiInput.connection
    }
    get manufacturer() {
        return this._midiInput.manufacturer
    }
    get octaveOffset() {
        return this._octaveOffset
    }
    set octaveOffset(t) {
        if (this.validation && (t = parseInt(t),
        isNaN(t)))
            throw new TypeError("The 'octaveOffset' property must be an integer.");
        this._octaveOffset = t
    }
    get state() {
        return this._midiInput.state
    }
    get type() {
        return this._midiInput.type
    }
    get nrpnEventsEnabled() {
        return ot.validation && console.warn("The 'nrpnEventsEnabled' property has been moved to the 'InputChannel' class."),
        !1
    }
}
/**
 * The `WebMidi` object makes it easier to work with the low-level Web MIDI API. Basically, it
 * simplifies sending outgoing MIDI messages and reacting to incoming MIDI messages.
 *
 * When using the WebMidi.js library, you should know that the `WebMidi` class has already been
 * instantiated. You cannot instantiate it yourself. If you use the **IIFE** version, you should
 * simply use the global object called `WebMidi`. If you use the **CJS** (CommonJS) or **ESM** (ES6
 * module) version, you get an already-instantiated object when you import the module.
 *
 * @fires WebMidi#connected
 * @fires WebMidi#disabled
 * @fires WebMidi#disconnected
 * @fires WebMidi#enabled
 * @fires WebMidi#error
 * @fires WebMidi#midiaccessgranted
 * @fires WebMidi#portschanged
 *
 * @extends EventEmitter
 * @license Apache-2.0
 */
class Yz extends Ws {
    constructor() {
        super(),
        this.defaults = {
            note: {
                attack: nt.from7bitToFloat(64),
                release: nt.from7bitToFloat(64),
                duration: 1 / 0
            }
        },
        this.interface = null,
        this.validation = !0,
        this._inputs = [],
        this._disconnectedInputs = [],
        this._outputs = [],
        this._disconnectedOutputs = [],
        this._stateChangeQueue = [],
        this._octaveOffset = 0
    }
    async enable(t={}, e=!1) {
        if (nt.isNode) {
            try {
                window.navigator
            } catch {
                let f = await Object.getPrototypeOf(async function() {}).constructor(`
        let jzz = await import("jzz");
        return jzz.default;
        `)();
                global.navigator || (global.navigator = {}),
                Object.assign(global.navigator, f)
            }
            try {} catch {
                global.performance = await Object.getPrototypeOf(async function() {}).constructor(`
        let perf_hooks = await import("perf_hooks");
        return perf_hooks.performance;
        `)()
            }
        }
        if (this.validation = t.validation !== !1,
        this.validation && (typeof t == "function" && (t = {
            callback: t,
            sysex: e
        }),
        e && (t.sysex = !0)),
        this.enabled)
            return typeof t.callback == "function" && t.callback(),
            Promise.resolve();
        const r = {
            timestamp: this.time,
            target: this,
            type: "error",
            error: void 0
        }
          , i = {
            timestamp: this.time,
            target: this,
            type: "midiaccessgranted"
        }
          , a = {
            timestamp: this.time,
            target: this,
            type: "enabled"
        };
        try {
            typeof t.requestMIDIAccessFunction == "function" ? this.interface = await t.requestMIDIAccessFunction({
                sysex: t.sysex,
                software: t.software
            }) : this.interface = await navigator.requestMIDIAccess({
                sysex: t.sysex,
                software: t.software
            })
        } catch (l) {
            return r.error = l,
            this.emit("error", r),
            typeof t.callback == "function" && t.callback(l),
            Promise.reject(l)
        }
        this.emit("midiaccessgranted", i),
        this.interface.onstatechange = this._onInterfaceStateChange.bind(this);
        try {
            await this._updateInputsAndOutputs()
        } catch (l) {
            return r.error = l,
            this.emit("error", r),
            typeof t.callback == "function" && t.callback(l),
            Promise.reject(l)
        }
        return this.emit("enabled", a),
        typeof t.callback == "function" && t.callback(),
        Promise.resolve(this)
    }
    async disable() {
        return this.interface && (this.interface.onstatechange = void 0),
        this._destroyInputsAndOutputs().then( () => {
            navigator && typeof navigator.close == "function" && navigator.close(),
            this.interface = null;
            let t = {
                timestamp: this.time,
                target: this,
                type: "disabled"
            };
            this.emit("disabled", t),
            this.removeListener()
        }
        )
    }
    getInputById(t, e={
        disconnected: !1
    }) {
        if (this.validation) {
            if (!this.enabled)
                throw new Error("WebMidi is not enabled.");
            if (!t)
                return
        }
        if (e.disconnected) {
            for (let r = 0; r < this._disconnectedInputs.length; r++)
                if (this._disconnectedInputs[r].id === t.toString())
                    return this._disconnectedInputs[r]
        } else
            for (let r = 0; r < this.inputs.length; r++)
                if (this.inputs[r].id === t.toString())
                    return this.inputs[r]
    }
    getInputByName(t, e={
        disconnected: !1
    }) {
        if (this.validation) {
            if (!this.enabled)
                throw new Error("WebMidi is not enabled.");
            if (!t)
                return;
            t = t.toString()
        }
        if (e.disconnected) {
            for (let r = 0; r < this._disconnectedInputs.length; r++)
                if (~this._disconnectedInputs[r].name.indexOf(t))
                    return this._disconnectedInputs[r]
        } else
            for (let r = 0; r < this.inputs.length; r++)
                if (~this.inputs[r].name.indexOf(t))
                    return this.inputs[r]
    }
    getOutputByName(t, e={
        disconnected: !1
    }) {
        if (this.validation) {
            if (!this.enabled)
                throw new Error("WebMidi is not enabled.");
            if (!t)
                return;
            t = t.toString()
        }
        if (e.disconnected) {
            for (let r = 0; r < this._disconnectedOutputs.length; r++)
                if (~this._disconnectedOutputs[r].name.indexOf(t))
                    return this._disconnectedOutputs[r]
        } else
            for (let r = 0; r < this.outputs.length; r++)
                if (~this.outputs[r].name.indexOf(t))
                    return this.outputs[r]
    }
    getOutputById(t, e={
        disconnected: !1
    }) {
        if (this.validation) {
            if (!this.enabled)
                throw new Error("WebMidi is not enabled.");
            if (!t)
                return
        }
        if (e.disconnected) {
            for (let r = 0; r < this._disconnectedOutputs.length; r++)
                if (this._disconnectedOutputs[r].id === t.toString())
                    return this._disconnectedOutputs[r]
        } else
            for (let r = 0; r < this.outputs.length; r++)
                if (this.outputs[r].id === t.toString())
                    return this.outputs[r]
    }
    noteNameToNumber(t) {
        return this.validation && console.warn("The noteNameToNumber() method is deprecated. Use Utilities.toNoteNumber() instead."),
        nt.toNoteNumber(t, this.octaveOffset)
    }
    getOctave(t) {
        return this.validation && (console.warn("The getOctave()is deprecated. Use Utilities.getNoteDetails() instead"),
        t = parseInt(t)),
        !isNaN(t) && t >= 0 && t <= 127 ? nt.getNoteDetails(nt.offsetNumber(t, this.octaveOffset)).octave : !1
    }
    sanitizeChannels(t) {
        return this.validation && console.warn("The sanitizeChannels() method has been moved to the utilities class."),
        nt.sanitizeChannels(t)
    }
    toMIDIChannels(t) {
        return this.validation && console.warn("The toMIDIChannels() method has been deprecated. Use Utilities.sanitizeChannels() instead."),
        nt.sanitizeChannels(t)
    }
    guessNoteNumber(t) {
        return this.validation && console.warn("The guessNoteNumber() method has been deprecated. Use Utilities.guessNoteNumber() instead."),
        nt.guessNoteNumber(t, this.octaveOffset)
    }
    getValidNoteArray(t, e={}) {
        return this.validation && console.warn("The getValidNoteArray() method has been moved to the Utilities.buildNoteArray()"),
        nt.buildNoteArray(t, e)
    }
    convertToTimestamp(t) {
        return this.validation && console.warn("The convertToTimestamp() method has been moved to Utilities.toTimestamp()."),
        nt.toTimestamp(t)
    }
    async _destroyInputsAndOutputs() {
        let t = [];
        return this.inputs.forEach(e => t.push(e.destroy())),
        this.outputs.forEach(e => t.push(e.destroy())),
        Promise.all(t).then( () => {
            this._inputs = [],
            this._outputs = []
        }
        )
    }
    _onInterfaceStateChange(t) {
        this._updateInputsAndOutputs();
        let e = {
            timestamp: t.timeStamp,
            type: t.port.state,
            target: this
        };
        if (t.port.state === "connected" && t.port.connection === "open") {
            t.port.type === "output" ? e.port = this.getOutputById(t.port.id) : t.port.type === "input" && (e.port = this.getInputById(t.port.id)),
            this.emit(t.port.state, e);
            const r = Object.assign({}, e);
            r.type = "portschanged",
            this.emit(r.type, r)
        } else if (t.port.state === "disconnected" && t.port.connection === "pending") {
            t.port.type === "input" ? e.port = this.getInputById(t.port.id, {
                disconnected: !0
            }) : t.port.type === "output" && (e.port = this.getOutputById(t.port.id, {
                disconnected: !0
            })),
            this.emit(t.port.state, e);
            const r = Object.assign({}, e);
            r.type = "portschanged",
            this.emit(r.type, r)
        }
    }
    async _updateInputsAndOutputs() {
        return Promise.all([this._updateInputs(), this._updateOutputs()])
    }
    async _updateInputs() {
        if (!this.interface)
            return;
        for (let e = this._inputs.length - 1; e >= 0; e--) {
            const r = this._inputs[e];
            Array.from(this.interface.inputs.values()).find(a => a === r._midiInput) || (this._disconnectedInputs.push(r),
            this._inputs.splice(e, 1))
        }
        let t = [];
        return this.interface.inputs.forEach(e => {
            if (!this._inputs.find(r => r._midiInput === e)) {
                let r = this._disconnectedInputs.find(i => i._midiInput === e);
                r || (r = new LS(e)),
                this._inputs.push(r),
                t.push(r.open())
            }
        }
        ),
        Promise.all(t)
    }
    async _updateOutputs() {
        if (!this.interface)
            return;
        for (let e = this._outputs.length - 1; e >= 0; e--) {
            const r = this._outputs[e];
            Array.from(this.interface.outputs.values()).find(a => a === r._midiOutput) || (this._disconnectedOutputs.push(r),
            this._outputs.splice(e, 1))
        }
        let t = [];
        return this.interface.outputs.forEach(e => {
            if (!this._outputs.find(r => r._midiOutput === e)) {
                let r = this._disconnectedOutputs.find(i => i._midiOutput === e);
                r || (r = new tm(e)),
                this._outputs.push(r),
                t.push(r.open())
            }
        }
        ),
        Promise.all(t)
    }
    get enabled() {
        return this.interface !== null
    }
    get inputs() {
        return this._inputs
    }
    get isNode() {
        return this.validation && console.warn("WebMidi.isNode has been deprecated. Use Utilities.isNode instead."),
        nt.isNode
    }
    get isBrowser() {
        return this.validation && console.warn("WebMidi.isBrowser has been deprecated. Use Utilities.isBrowser instead."),
        nt.isBrowser
    }
    get octaveOffset() {
        return this._octaveOffset
    }
    set octaveOffset(t) {
        if (this.validation && (t = parseInt(t),
        isNaN(t)))
            throw new TypeError("The 'octaveOffset' property must be an integer.");
        this._octaveOffset = t
    }
    get outputs() {
        return this._outputs
    }
    get supported() {
        return typeof navigator < "u" && !!navigator.requestMIDIAccess
    }
    get sysexEnabled() {
        return !!(this.interface && this.interface.sysexEnabled)
    }
    get time() {
        return performance.now()
    }
    get version() {
        return "3.1.12"
    }
    get flavour() {
        return "esm"
    }
    get CHANNEL_EVENTS() {
        return this.validation && console.warn("The CHANNEL_EVENTS enum has been moved to Enumerations.CHANNEL_EVENTS."),
        ke.CHANNEL_EVENTS
    }
    get MIDI_SYSTEM_MESSAGES() {
        return this.validation && console.warn("The MIDI_SYSTEM_MESSAGES enum has been moved to Enumerations.SYSTEM_MESSAGES."),
        ke.SYSTEM_MESSAGES
    }
    get MIDI_CHANNEL_MODE_MESSAGES() {
        return this.validation && console.warn("The MIDI_CHANNEL_MODE_MESSAGES enum has been moved to Enumerations.CHANNEL_MODE_MESSAGES."),
        ke.CHANNEL_MODE_MESSAGES
    }
    get MIDI_CONTROL_CHANGE_MESSAGES() {
        return this.validation && console.warn("The MIDI_CONTROL_CHANGE_MESSAGES enum has been replaced by the Enumerations.CONTROL_CHANGE_MESSAGES array."),
        ke.MIDI_CONTROL_CHANGE_MESSAGES
    }
    get MIDI_REGISTERED_PARAMETER() {
        return this.validation && console.warn("The MIDI_REGISTERED_PARAMETER enum has been moved to Enumerations.REGISTERED_PARAMETERS."),
        ke.REGISTERED_PARAMETERS
    }
    get NOTES() {
        return this.validation && console.warn("The NOTES enum has been deprecated."),
        ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"]
    }
}
const ot = new Yz;
ot.constructor = null;
const Qz = Object.freeze(Object.defineProperty({
    __proto__: null,
    Enumerations: ke,
    Forwarder: J0,
    Input: LS,
    InputChannel: _S,
    Message: ry,
    Note: La,
    Output: tm,
    OutputChannel: ES,
    Utilities: nt,
    WebMidi: ot
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Xz = w2(Qz);
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.midiKeyInfo = n.MidiIn = n.MidiOut = n.BEND_RANGE_IN_SEMITONES = void 0;
    const t = Xz
      , e = Ie;
    n.BEND_RANGE_IN_SEMITONES = 2;
    const r = 1e4
      , i = 1e-6;
    function a(g, b) {}
    class l {
        constructor(b, E, S) {
            this.output = b,
            this.channels = E,
            S === void 0 ? this.log = F => {}
            : this.log = S,
            this.voices = [],
            this.channels.forEach(F => {
                this.voices.push({
                    age: r,
                    centsOffset: NaN,
                    channel: F
                })
            }
            ),
            this.lastEventTime = t.WebMidi.time,
            this.sendPitchBendRange()
        }
        sendPitchBendRange() {
            this.output !== null && this.channels.forEach(b => {
                this.output.channels[b].sendPitchBendRange(n.BEND_RANGE_IN_SEMITONES, 0)
            }
            )
        }
        selectVoice(b) {
            this.voices.forEach(S => S.age++);
            for (let S = 0; S < this.voices.length; ++S)
                if (Math.abs(this.voices[S].centsOffset - b) < i)
                    return this.log(`Re-using channel ${this.voices[S].channel}`),
                    this.voices[S].age = 0,
                    this.voices[S];
            let E = this.voices[0];
            return this.voices.forEach(S => {
                S.age > E.age && (E = S)
            }
            ),
            E.age = 0,
            E.centsOffset = b,
            E
        }
        sendNoteOn(b, E, S) {
            if (S === void 0 && (S = t.WebMidi.time),
            S < this.lastEventTime)
                throw new Error(`Events must be triggered in causal order: ${S} < ${this.lastEventTime} (note on)`);
            if (this.lastEventTime = S,
            this.output === null || !this.channels.size)
                return a;
            const [F,B] = (0,
            e.ftom)(b);
            if (F < 0 || F >= 128)
                return a;
            const Q = this.selectVoice(B);
            this.log(`Sending note on ${F} at velocity ${(E || 64) / 127} on channel ${Q.channel} with bend ${B} resulting from frequency ${b}`);
            const ae = n.BEND_RANGE_IN_SEMITONES * 100;
            return this.output.channels[Q.channel].sendPitchBend(B / ae),
            this.output.channels[Q.channel].sendNoteOn(F, {
                rawAttack: E,
                time: S
            }),
            (k, z) => {
                if (z === void 0 && (z = t.WebMidi.time),
                z < this.lastEventTime)
                    throw new Error(`Events must be triggered in causal order: ${z} < ${this.lastEventTime} (note off)`);
                this.lastEventTime = z,
                this.log(`Sending note off ${F} at velocity ${(k || 64) / 127} on channel ${Q.channel}`),
                Q.age = r,
                this.output.channels[Q.channel].sendNoteOff(F, {
                    rawRelease: k,
                    time: z
                })
            }
        }
        playNotes(b) {
            const E = t.WebMidi.time
              , S = [];
            for (const F of b) {
                let B;
                typeof F.time == "string" ? F.time.startsWith("+") ? B = E + parseFloat(F.time.slice(1)) : B = parseFloat(F.time) : B = F.time;
                const Q = {
                    type: "off",
                    rawRelease: F.rawRelease,
                    time: B + F.duration,
                    callback: a
                };
                S.push({
                    type: "on",
                    frequency: F.frequency,
                    rawAttack: F.rawAttack,
                    time: B,
                    off: Q
                }),
                S.push(Q)
            }
            S.sort( (F, B) => F.time - B.time);
            for (const F of S)
                F.type === "on" ? F.off.callback = this.sendNoteOn(F.frequency, F.rawAttack, F.time) : F.type === "off" && F.callback(F.rawRelease, F.time)
        }
        clear() {
            this.output !== null && (this.output.clear(),
            this.output.sendAllNotesOff()),
            this.lastEventTime = t.WebMidi.time
        }
    }
    n.MidiOut = l;
    function f(g) {
        return g.note.number + 128 * (g.message.channel - 1)
    }
    class h {
        constructor(b, E, S) {
            this.callback = b,
            this.channels = E,
            this.noteOffMap = new Map,
            this._noteOn = this.noteOn.bind(this),
            this._noteOff = this.noteOff.bind(this),
            S === void 0 ? this.log = F => {}
            : this.log = S
        }
        listen(b) {
            b.addListener("noteon", this._noteOn),
            b.addListener("noteoff", this._noteOff)
        }
        unlisten(b) {
            b.removeListener("noteon", this._noteOn),
            b.removeListener("noteoff", this._noteOff)
        }
        noteOn(b) {
            const E = b.message.channel;
            if (!this.channels.has(E))
                return;
            const S = b.note.number
              , F = b.note.attack
              , B = b.note.rawAttack;
            this.log(`Midi note on ${S} at velocity ${F} on channel ${E}`);
            const Q = this.callback(S, B, E);
            this.noteOffMap.set(f(b), Q)
        }
        noteOff(b) {
            const E = b.message.channel;
            if (!this.channels.has(E))
                return;
            const S = b.note.number
              , F = b.note.release
              , B = b.note.rawRelease;
            this.log(`Midi note off ${S} at velocity ${F} on channel ${E}`);
            const Q = f(b)
              , ae = this.noteOffMap.get(Q);
            ae !== void 0 && (this.noteOffMap.delete(Q),
            ae(B))
        }
        deactivate() {
            for (const [b,E] of this.noteOffMap)
                this.noteOffMap.delete(b),
                E(80)
        }
    }
    n.MidiIn = h;
    const p = [0, 2, 4, 5, 7, 9, 11];
    function m(g) {
        const b = Math.floor(g / 12)
          , E = g - 12 * b;
        return p.includes(E) ? {
            whiteNumber: Math.floor((E + 1) / 2) + 7 * b
        } : E === 1 || E === 3 ? {
            sharpOf: (E - 1) / 2 + 7 * b,
            flatOf: (E + 1) / 2 + 7 * b
        } : {
            sharpOf: E / 2 + 7 * b,
            flatOf: (E + 2) / 2 + 7 * b
        }
    }
    n.midiKeyInfo = m
}
)(ql);
var Ns = {}
  , Um = {};
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.codeByCoords = n.COORDS_BY_CODE = n.CODES_LAYER_3 = n.CODES_LAYER_2 = n.CODES_LAYER_1 = n.CODES_LAYER_0 = void 0;
    const t = 0;
    n.CODES_LAYER_0 = [["Escape", "F1", "F2", "F3", "F4", "F5", "F6", "F7", "F8", "F9", "F10", "F11", "F12"]];
    const e = -1;
    n.CODES_LAYER_1 = [["Backquote", "Digit1", "Digit2", "Digit3", "Digit4", "Digit5", "Digit6", "Digit7", "Digit8", "Digit9", "Digit0", "Minus", "Equal"], [null, "KeyQ", "KeyW", "KeyE", "KeyR", "KeyT", "KeyY", "KeyU", "KeyI", "KeyO", "KeyP", "BracketLeft", "BracketRight"], [null, "KeyA", "KeyS", "KeyD", "KeyF", "KeyG", "KeyH", "KeyJ", "KeyK", "KeyL", "Semicolon", "Quote", "Backslash"], ["IntlBackslash", "KeyZ", "KeyX", "KeyC", "KeyV", "KeyB", "KeyN", "KeyM", "Comma", "Period", "Slash"]];
    const r = 0;
    n.CODES_LAYER_2 = [["Insert", "Home", "PageUp"], ["Delete", "End", "PageDown"]];
    const i = 0;
    n.CODES_LAYER_3 = [["NumLock", "NumpadDivide", "NumpadMultiply", "NumpadSubtract"], ["Numpad7", "Numpad8", "Numpad9", "NumpadAdd"], ["Numpad4", "Numpad5", "Numpad6"], ["Numpad1", "Numpad2", "Numpad3", "NumpadEnter"], ["Numpad0", null, "NumpadDecimal"]],
    n.COORDS_BY_CODE = new Map,
    n.CODES_LAYER_0.forEach( (f, h) => f.forEach( (p, m) => n.COORDS_BY_CODE.set(p, [t + m, h, 0]))),
    n.CODES_LAYER_1.forEach( (f, h) => {
        f.forEach( (p, m) => {
            p !== null && n.COORDS_BY_CODE.set(p, [e + m, h, 1])
        }
        )
    }
    ),
    n.CODES_LAYER_2.forEach( (f, h) => f.forEach( (p, m) => n.COORDS_BY_CODE.set(p, [r + m, h, 2]))),
    n.CODES_LAYER_3.forEach( (f, h) => {
        f.forEach( (p, m) => {
            p !== null && n.COORDS_BY_CODE.set(p, [i + m, h, 3])
        }
        )
    }
    );
    const a = {};
    for (const [f,h] of n.COORDS_BY_CODE) {
        const p = h.join(",");
        a[p] = f
    }
    function l(f) {
        const h = f.join(",");
        return a[h]
    }
    n.codeByCoords = l
}
)(Um);
var jm = {};
Object.defineProperty(jm, "__esModule", {
    value: !0
});
jm.Keyboard = void 0;
const YE = Um;
class eV {
    constructor(t=!1, e) {
        this.keydownCallbacks = [],
        this.keyupCallbacks = new Map,
        this.activeKeys = new Set,
        this.pendingKeys = new Set,
        this.stickyKeys = new Set,
        t && (this._keydown = r => this.keydown(r),
        this._keyup = r => this.keyup(r),
        window.addEventListener("keydown", this._keydown),
        window.addEventListener("keyup", this._keyup)),
        e === void 0 ? this.log = r => {}
        : this.log = e
    }
    dispose() {
        this._keydown && window.removeEventListener("keydown", this._keydown),
        this._keyup && window.removeEventListener("keyup", this._keyup)
    }
    addKeydownListener(t) {
        this.keydownCallbacks.push(t)
    }
    removeEventListener(t) {
        this.keydownCallbacks.splice(this.keydownCallbacks.indexOf(t), 1)
    }
    fireKeydown(t) {
        t.coordinates = YE.COORDS_BY_CODE.get(t.code);
        const e = this.keyupCallbacks.get(t.code) || [];
        for (const r of e)
            console.warn("Unresolved keyup detected"),
            r();
        this.log(`Firing keydown listeners with ${t.code} @ ${t.coordinates}`),
        this.keydownCallbacks.forEach(r => e.push(r(t))),
        this.keyupCallbacks.set(t.code, e)
    }
    fireKeyup(t) {
        this.log(`Firing keyup listeners with ${t.code}`);
        for (const e of this.keyupCallbacks.get(t.code) || [])
            e();
        this.keyupCallbacks.delete(t.code)
    }
    keydown(t) {
        if (this.log(`${t.code} keydown received`),
        t.ctrlKey || t.altKey || t.metaKey || t.repeat) {
            this.log(`${t.code} keydown filtered out`);
            return
        }
        if (t.key === "Shift") {
            for (const e of this.activeKeys)
                this.log(`Adding ${e} to pending state due to a 'Shift' press`),
                this.pendingKeys.add(e);
            return
        }
        if (this.stickyKeys.has(t.code)) {
            this.log(`Stricky toggle for ${t.code}`),
            this.activeKeys.delete(t.code),
            this.stickyKeys.delete(t.code),
            this.pendingKeys.delete(t.code),
            this.fireKeyup(t);
            return
        }
        if (this.pendingKeys.has(t.code)) {
            this.log(`${t.code} is pending`);
            return
        }
        if (this.activeKeys.has(t.code)) {
            this.log(`${t.code} is already active`);
            return
        }
        if (YE.COORDS_BY_CODE.has(t.code)) {
            this.log(`Adding ${t.code} to active state`),
            this.activeKeys.add(t.code),
            t.shiftKey && (this.log(`Adding ${t.code} to pending state due to being pressed with 'Shift'`),
            this.pendingKeys.add(t.code)),
            this.fireKeydown(t);
            return
        }
    }
    keyup(t) {
        if (this.log(`${t.code} keyup received`),
        t.shiftKey && this.activeKeys.has(t.code) && (this.log(`Sticking ${t.code} due being released while 'Shift' is pressed`),
        this.stickyKeys.add(t.code)),
        this.pendingKeys.has(t.code) && (this.log(`Promoting ${t.code} from pending to sticky`),
        this.pendingKeys.delete(t.code),
        this.stickyKeys.add(t.code)),
        this.stickyKeys.has(t.code)) {
            this.log(`Not firing keyup due to ${t.code} being sticky`);
            return
        }
        if (this.activeKeys.has(t.code)) {
            this.activeKeys.delete(t.code),
            this.fireKeyup(t);
            return
        }
        this.log(`${t.code} keyup fell through`)
    }
    deactivate() {
        this.log("Releasing all sustained and active keys"),
        this.pendingKeys.clear(),
        this.stickyKeys.clear();
        for (const t of this.activeKeys.keys())
            this.fireKeyup({
                code: t
            });
        this.activeKeys.clear()
    }
}
jm.Keyboard = eV;
var Hm = {};
Object.defineProperty(Hm, "__esModule", {
    value: !0
});
Hm.pianoMap = void 0;
const tV = Um;
function nV(n, t) {
    var e, r, i;
    const a = [0, 0, 0, -1];
    t ?? (t = [0, 0, 0]),
    (e = t[0]) !== null && e !== void 0 || (t[0] = 0),
    (r = t[1]) !== null && r !== void 0 || (t[1] = 0),
    (i = t[2]) !== null && i !== void 0 || (t[2] = 0);
    const l = [];
    for (const m of n) {
        const g = a[m];
        l.push([g, m, 1]),
        a[m]++,
        a[2] = Math.max(a[2], a[3] - t[2]),
        a[1] = Math.max(a[1], a[2] - t[1]),
        a[0] = Math.max(a[0], a[1] - t[0]),
        a[1] = Math.max(a[1], a[0] + t[0] - 1),
        a[2] = Math.max(a[2], a[1] + t[1] - 1),
        a[3] = Math.max(a[3], a[2] + t[1] - 1)
    }
    const f = new Map
      , h = [];
    let p = 0;
    for (const m of l) {
        const g = (0,
        tV.codeByCoords)(m);
        g === void 0 ? h.push(void 0) : (f.set(g, p),
        h.push(m)),
        p++
    }
    return {
        coordsByIndex: h,
        indexByCode: f
    }
}
Hm.pianoMap = nV;
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(r, i, a, l) {
        l === void 0 && (l = a);
        var f = Object.getOwnPropertyDescriptor(i, a);
        (!f || ("get"in f ? !i.__esModule : f.writable || f.configurable)) && (f = {
            enumerable: !0,
            get: function() {
                return i[a]
            }
        }),
        Object.defineProperty(r, l, f)
    }
    : function(r, i, a, l) {
        l === void 0 && (l = a),
        r[l] = i[a]
    }
    )
      , e = Zt && Zt.__exportStar || function(r, i) {
        for (var a in r)
            a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, r, a)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    e(Um, n),
    e(jm, n),
    e(Hm, n)
}
)(Ns);
Ns.CODES_LAYER_1[0].slice(1);
Ns.CODES_LAYER_1[1].slice(1);
Ns.CODES_LAYER_1[2].slice(1);
Ns.CODES_LAYER_1[3];
const rV = "_"
  , sV = "F"
  , iV = "C"
  , oV = "B"
  , aV = "S"
  , lV = "L"
  , uV = "R"
  , cV = "Q"
  , fV = "P"
  , dV = "E"
  , hV = "-"
  , pV = "~"
  , mV = "_";
function gV(n) {
    return /\d/.test(n)
}
function vV(n) {
    return gV(n) || /[a-z]/.test(n)
}
function QE(n) {
    if (!n.length)
        return "";
    let t = "";
    const e = parseInt(n, 36);
    return [...n].every(r => r === "0" ? (t += "0",
    !0) : !1),
    e ? t + e.toString() : t
}
function yV(n) {
    let t = ""
      , e = ""
      , r = !1;
    return [...n].forEach(i => {
        if (r) {
            t += i,
            r = !1;
            return
        }
        if (i === dV) {
            r = !0;
            return
        }
        vV(i) ? e += i : (t += QE(e),
        e = "",
        i === sV ? t += "/" : i === iV ? t += "," : i === oV ? t += "\\" : i === aV ? t += " " : i === lV ? t += "<" : i === uV ? t += ">" : i === cV ? t += "[" : i === fV ? t += "+" : t += i)
    }
    ),
    t += QE(e),
    t
}
function bV(n) {
    return n.split(rV).map(yV)
}
function wV(n) {
    const t = [];
    let e = "";
    function r() {
        e.length && t.push(e),
        e = ""
    }
    return [...n].forEach(i => {
        i === hV ? (r(),
        t.push("black")) : i === pV ? (r(),
        t.push("white")) : i === mV ? r() : e += i
    }
    ),
    r(),
    t
}
function EV(n) {
    const [t,e] = n.split(".");
    return parseInt(t, 36) + parseInt(e || "0", 36) / 36 ** ((e == null ? void 0 : e.length) || 0)
}
function _V(n, t, e) {
    const r = n[t];
    if (Array.isArray(r))
        throw new Error(`Failed to decode key '${t}'`);
    return r ?? e
}
const LV = {
    s: "sine",
    q: "square",
    w: "sawtooth",
    t: "triangle",
    e: "semisine",
    1: "warm1",
    2: "warm2",
    3: "warm3",
    4: "warm4",
    o: "octaver",
    b: "brightness",
    h: "harmonicbell",
    r: "rich",
    n: "slender",
    d: "didacus",
    l: "bohlen",
    g: "glass",
    i: "boethius"
};
function Lo(n) {
    return parseInt(n, 36) / 1e3
}
function SV(n) {
    let t;
    n instanceof URLSearchParams ? t = (r, i) => {
        const a = n.get(r);
        return a === null ? i : a
    }
    : t = (r, i) => _V(n, r, i);
    let e = "Asdf";
    return t("p", "a") === "0" ? e = "QweZxc0" : t("p", "a") === "1" && (e = "QweZxc1"),
    {
        scaleLines: bV(t("l", "")),
        keyColors: wV(t("c", "~-~~-~-~~-~-")),
        scaleName: t("n", ""),
        baseFrequency: EV(t("f", "c8")),
        baseMidiNote: parseInt(t("m", "1x"), 36),
        isomorphicHorizontal: parseInt(t("h", "1"), 36),
        isomorphicVertical: parseInt(t("v", "5"), 36),
        keyboardMode: t("k", "i") === "i" ? "isomorphic" : "piano",
        pianoMode: e,
        equaveShift: parseInt(t("e", "0"), 36),
        degreeShift: parseInt(t("d", "0"), 36),
        waveform: LV[t("w", "e")] || "semisine",
        attackTime: Lo(t("a", "a")),
        decayTime: Lo(t("y", "8c")),
        sustainLevel: Lo(t("s", "m8")),
        releaseTime: Lo(t("r", "a")),
        pingPongDelayTime: Lo(t("t", "8c")),
        pingPongFeedback: Lo(t("b", "m8")),
        pingPongSeparation: Lo(t("i", "rs")),
        pingPongGain: Lo(t("g", "0"))
    }
}
class Ca {
    constructor(t, e, r, i) {
        St(this, "intervalRatios");
        St(this, "baseFrequency");
        St(this, "baseMidiNote");
        St(this, "title");
        this.intervalRatios = t,
        this.baseFrequency = e,
        this.baseMidiNote = r,
        this.title = i
    }
    get size() {
        return this.intervalRatios.length
    }
    get equaveRatio() {
        return this.intervalRatios[this.intervalRatios.length - 1]
    }
    get equaveCents() {
        return Ie.valueToCents(this.equaveRatio)
    }
    clone() {
        return new Ca([...this.intervalRatios],this.baseFrequency,this.baseMidiNote,this.title)
    }
    toJSON() {
        return {
            type: "ScaleWorkshopScale",
            intervalRatios: this.intervalRatios,
            baseFrequency: this.baseFrequency,
            baseMidiNote: this.baseMidiNote,
            title: this.title
        }
    }
    static reviver(t, e) {
        return typeof e == "object" && e !== null && e.type === "ScaleWorkshopScale" ? new Ca(e.intervalRatios,e.baseFrequency,e.baseMidiNote,e.title) : e
    }
    getRatio(t) {
        t -= 1,
        t -= this.baseMidiNote;
        const e = Ie.mmod(t, this.size)
          , r = (t - e) / this.size;
        return this.intervalRatios[e] * this.equaveRatio ** r
    }
    getFrequency(t) {
        return this.baseFrequency * this.getRatio(t)
    }
    getCents(t) {
        t -= 1,
        t -= this.baseMidiNote;
        const e = Ie.mmod(t, this.size)
          , r = (t - e) / this.size;
        return Ie.valueToCents(this.intervalRatios[e]) + Ie.valueToCents(this.equaveRatio) * r
    }
    getFrequencyRange(t, e) {
        const r = t - 1 - this.baseMidiNote
          , i = e - 1 - this.baseMidiNote
          , a = Math.floor(r / this.size);
        let l = this.baseFrequency * this.equaveRatio ** a;
        const f = [];
        if (!l || !isFinite(l)) {
            for (let p = t; p < e; ++p)
                f.push(this.getFrequency(p));
            return f
        }
        let h = r - a * this.size;
        for (let p = r; p < i; ++p)
            f.push(l * this.intervalRatios[h]),
            h++,
            h >= this.size && (h -= this.size,
            l *= this.equaveRatio);
        return f
    }
    getCentsRange(t, e) {
        t -= 1,
        e -= 1,
        t -= this.baseMidiNote,
        e -= this.baseMidiNote;
        const r = this.equaveCents
          , i = this.intervalRatios.map(Ie.valueToCents)
          , a = Math.floor(t / this.size);
        let l = this.equaveCents * a
          , f = t - a * this.size;
        const h = [];
        for (let p = t; p < e; ++p)
            h.push(l + i[f]),
            f++,
            f >= this.size && (f -= this.size,
            l += r);
        return h
    }
}
const nm = 2 * Math.PI
  , AV = ut.evaluateExpression("12@", !1);
function CV(n) {
    return n.length ? n[0].toUpperCase() + n.slice(1) : n
}
function $V(n) {
    return 1 << 32 - Math.clz32(n - 1)
}
function MV(n) {
    if (!n.trim())
        throw new Error("No input");
    const t = ut.evaluateExpression(n);
    if (t instanceof ut.Interval)
        return t;
    throw new Error("Must evaluate to an interval")
}
function SS(n) {
    try {
        const t = ut.evaluateExpression(n);
        if (t instanceof ut.Val)
            return t
    } catch {}
    try {
        const t = ut.evaluateExpression(n.trim() + "@");
        if (t instanceof ut.Val)
            return t
    } catch {}
    return AV
}
function OV(n, t, e=!1) {
    const r = t === void 0 ? n.toString() : n.toFixed(t);
    return e ? r + "r" : r.includes("e") ? r : r + "e"
}
function AS(n, t, e=!1) {
    const r = t === void 0 ? n.toString() : n.toFixed(t);
    return e ? r + " rc" : r.includes("e") ? r + " c" : r.includes(".") ? r : r + "."
}
function TW(n, t) {
    return MV(AS(n, t))
}
const NV = /\s|\||&|:|;|,/;
function XE(n) {
    return n.split(NV).filter(t => t.length)
}
function xW(n) {
    const t = ut.getSourceVisitor()
      , e = t.rootContext.clone()
      , r = ut.parseAST(n);
    return t.executeProgram(r),
    t.expand(e)
}
function IW(n) {
    if (!n.length)
        return "[]";
    if (typeof n[0] == "number")
        return `[${n.map(e => e.toString()).join(", ")}]`;
    if (typeof n[0] == "string")
        return `[${n.map(e => JSON.stringify(e)).join(", ")}]`;
    const t = ut.getSourceVisitor().createExpressionVisitor();
    return ut.repr.bind(t)(n)
}
function nc(n, t=300) {
    let e;
    return (...r) => {
        window.clearTimeout(e),
        e = window.setTimeout( () => {
            n(...r)
        }
        , t)
    }
}
const TV = ["C", "C", "D", "D", "E", "F", "F", "G", "G", "A", "A", "B"];
function Af(n, t=-1, e="ASCII") {
    const r = Ie.mmod(n, 12)
      , i = (n - r) / 12 + t
      , a = TV[r] + i.toString();
    return e === "ASCII" ? a.replace("", "").replace("", "#") : a
}
function e_(n) {
    return n = n.trim(),
    n.length ? n.replace(/[|&;$%@"<>()+,?]/g, "").replace(/\//g, "_").replace(/\\/g, "_") : "untitled scale"
}
function rm(n, t=3) {
    if (isNaN(n) || !isFinite(n))
        return n.toString();
    if (Math.abs(n) < 1e4)
        return n.toFixed(t);
    const e = Math.floor(Math.log10(Math.abs(n)))
      , r = 10 ** (t - e);
    return (.1 ** t * Math.round(n * r)).toFixed(t) + "e+" + e.toString()
}
function xV(n, t=3) {
    const e = Math.abs(n);
    return 1 <= e && e < 1e5 ? n.toFixed(t) + "Hz" : e < 1e-27 ? (n * 1e30).toFixed(t) + "qHz" : e < 1e-24 ? (n * 1e27).toFixed(t) + "rHz" : e < 1e-21 ? (n * 1e24).toFixed(t) + "yHz" : e < 1e-18 ? (n * 1e21).toFixed(t) + "zHz" : e < 1e-15 ? (n * 1e18).toFixed(t) + "aHz" : e < 1e-12 ? (n * 1e15).toFixed(t) + "fHz" : e < 1e-9 ? (n * 1e12).toFixed(t) + "pHz" : e < 1e-6 ? (n * 1e9).toFixed(t) + "nHz" : e < .001 ? (n * 1e6).toFixed(t) + "Hz" : e < 1 ? (n * 1e3).toFixed(t) + "mHz" : e > 1e34 || isNaN(e) ? rm(n) + "Hz" : e > 1e30 ? (n * 1e-30).toFixed(t) + "QHz" : e > 1e27 ? (n * 1e-27).toFixed(t) + "RHz" : e > 1e24 ? (n * 1e-24).toFixed(t) + "YHz" : e > 1e21 ? (n * 1e-21).toFixed(t) + "ZHz" : e > 1e18 ? (n * 1e-18).toFixed(t) + "EHz" : e > 1e15 ? (n * 1e-15).toFixed(t) + "PHz" : e > 1e12 ? (n * 1e-12).toFixed(t) + "THz" : e > 1e9 ? (n * 1e-9).toFixed(t) + "GHz" : e > 1e6 ? (n * 1e-6).toFixed(t) + "MHz" : (n * .001).toFixed(t) + "kHz"
}
function FW(n, t=3) {
    return rm(n, t) + ""
}
function RW(n, t, e, r=!0) {
    const i = [...Array(t).keys()].map(h => Ie.mmod(n * (h - e), 1));
    i.sort( (h, p) => h - p);
    const a = Array(t).fill("white");
    let l = t - e
      , f = 1;
    for (r && (l = -e - 1,
    f = -1); Math.abs(l) < 1e3; ) {
        const h = Ie.mmod(n * l, 1);
        let p = !1;
        for (let m = 1; m < i.length; ++m)
            if (i[m] > h) {
                if (a[m] === "black" || a[m - 1] === "black")
                    return a;
                i.splice(m, 0, h),
                a.splice(m, 0, "black"),
                p = !0;
                break
            }
        if (!p) {
            if (a[a.length - 1] === "black" || a[0] === "black")
                return a;
            i.push(h),
            a.push("black")
        }
        l += f
    }
    return a
}
function rc(n, t) {
    const e = Ve( () => {
        try {
            return [n(), ""]
        } catch (a) {
            return a instanceof Error ? [t, a.message || " "] : [t, "" + a || " "]
        }
    }
    )
      , r = Ve( () => e.value[0])
      , i = Ve( () => e.value[1]);
    return [r, i]
}
function PW(n, t) {
    n && (n.setCustomValidity(t),
    n.reportValidity())
}
const qv = ["F", "C", "G", "D", "A", "E", "B"];
function t_(n, t) {
    return t === "double" || (n = n.replaceAll("", "").replaceAll("", ""),
    t === "single") ? n : n.replaceAll("", "#").replaceAll("", "b")
}
function DW(n, t="double") {
    let e = qv[Ie.mmod(n + 1, qv.length)]
      , r = Math.floor((n + 1) / qv.length);
    const i = t === "ASCII" ? "b" : ""
      , a = t === "ASCII" ? "#" : "";
    for (; r <= -2; )
        t === "double" ? e += "" : e += i + i,
        r += 2;
    for (; r >= 2; )
        t === "double" ? e += "" : e += a + a,
        r -= 2;
    return r > 0 && (e += a),
    r < 0 && (e += i),
    e
}
const IV = [["C=", "B#", "Dbb"], ["C#", "Db"], ["D=", "C##", "Ebb"], ["Eb", "D#"], ["E=", "Fb", "D##"], ["F=", "E#", "Gbb"], ["F#", "Gb"], ["G=", "F##", "Abb"], ["G#", "Ab"], ["A=", "G##", "Bbb"], ["Bb", "A#"], ["B=", "Cb", "A##"]];
function FV(n, t="double", e=-1) {
    const r = Ie.mmod(n, 12)
      , i = (n - r) / 12 + e
      , a = IV[r]
      , l = [];
    for (let f of a) {
        t === "double" && (f = f.replace("bb", ""),
        f = f.replace("##", "")),
        (t === "single" || t === "double") && (f = f.replace(/b/g, ""),
        f = f.replace(/#/g, ""),
        f = f.replace("=", ""));
        let h = i.toString();
        f.startsWith("B") && a[0].startsWith("C") && (h = (i - 1).toString()),
        f.startsWith("C") && a[0].startsWith("B") && (h = (i + 1).toString()),
        l.push(f + h)
    }
    return l
}
const RV = [!1, !0, !1, !0, !1, !1, !0, !1, !0, !1, !0, !1];
function PV(n) {
    return RV[Ie.mmod(n, 12)]
}
function n_(n, t) {
    if (t.length)
        for (let e = 0; e < n.length; ++e)
            n[e] += " " + t[Ie.mmod(e + 1, t.length)].replace(/%/g, "")
}
function CS(n) {
    for (const [t,e] of Object.entries(n))
        Jt(e, r => window.localStorage.setItem(t, String(r)))
}
function qW(n, t, e) {
    for (; n.length < t; )
        n.push(e);
    n.length = t
}
const $S = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_";
function DV(n) {
    if (n < 0 || n >= 64 || !Number.isInteger(n))
        throw new Error("Number outside integer range 0-63");
    return $S[n]
}
function qV() {
    const n = new Date().valueOf()
      , t = Math.floor(n / (1e3 * 60 * 60))
      , e = t & 63
      , r = t >> 5 & 63
      , i = t >> 10 & 63
      , a = [e, r, i]
      , l = new Uint32Array(1);
    crypto.getRandomValues(l);
    for (let f = 0; f < 6; ++f)
        a.push(l[0] & 63),
        l[0] >>>= 5;
    return a.map(DV).join("")
}
function BW(n) {
    if (n.length !== 9)
        return !1;
    for (const t of n)
        if (!$S.includes(t))
            return !1;
    return !0
}
function BV(n=!1) {
    const t = ut.evaluateExpression("VERSION")
      , e = new Date().valueOf();
    let r = null
      , i = null;
    return n && (r = {
        userAgent: navigator.userAgent,
        language: navigator.language,
        languages: navigator.languages
    },
    i = localStorage.getItem("uuid")),
    {
        version: tc,
        sonicWeaveVersion: t,
        msSince1970: e,
        navigator: r,
        userUUID: i
    }
}
function kW(n, t) {
    const e = JSON.parse(n, (r, i) => ut.Interval.reviver(r, Ca.reviver(r, i)));
    return e.scale.id = t,
    e
}
function zW(n, t) {
    return t < 3 ? 0 : t & 1 ? Math.cos(nm * n / t) : 1.5 * Math.sin(nm * n / t)
}
function VW(n, t) {
    return t === 1 ? -1 : t & 1 ? Math.sin(nm * n / t) : -Math.cos(nm * n / t)
}
var Kr = {}
  , sy = {}
  , Js = {}
  , eu = {};
Object.defineProperty(eu, "__esModule", {
    value: !0
});
eu.allocateVoices = eu.centsError = void 0;
function MS(n) {
    return Math.log2(n) * 1200
}
function sm(n, t) {
    return Math.abs(MS(n / t))
}
eu.centsError = sm;
function kV(n, t, e) {
    const r = [];
    e: for (const i of n) {
        for (let a = 0; a < r.length; ++a) {
            const l = Math.round(i / r[a]);
            if (sm(l * r[a], i) < e)
                continue e;
            let f = 2;
            for (; r[a] > .1 * f; ) {
                const h = Math.round(i * f / r[a]);
                if (sm(h * r[a], i * f) < e) {
                    r[a] /= f;
                    continue e
                }
                f++
            }
        }
        r.length < t && r.push(i)
    }
    return r
}
function zV(n, t, e, r) {
    var i, a;
    const l = kV(n, e, r)
      , f = l.map( () => []);
    for (let h = 0; h < n.length; ++h) {
        const p = n[h];
        let m = 1 / 0
          , g = 0
          , b = 1;
        for (let S = 0; S < l.length; ++S) {
            const F = Math.round(p / l[S])
              , B = sm(F * l[S], p);
            B < m && (m = B,
            g = S,
            b = F)
        }
        const E = (i = f[g][b]) !== null && i !== void 0 ? i : 0;
        f[g][b] = E + t[h]
    }
    for (const h of f)
        for (let p = 0; p < h.length; ++p)
            (a = h[p]) !== null && a !== void 0 || (h[p] = 0);
    return [l.map(MS), f.map(h => new Float32Array(h))]
}
eu.allocateVoices = zV;
Object.defineProperty(Js, "__esModule", {
    value: !0
});
Js.AperiodicOscillator = Js.UnisonOscillator = Js.MultiOscillator = Js.AperiodicWave = void 0;
const VV = eu;
class UV {
    constructor(t, e, r, i, a) {
        const [l,f] = (0,
        VV.allocateVoices)(e, r, i, a);
        this.detunings = l,
        this.periodicWaves = [];
        for (const h of f) {
            const p = t.createPeriodicWave(h.map( () => 0), h, {
                disableNormalization: !0
            });
            this.periodicWaves.push(p)
        }
    }
}
Js.AperiodicWave = UV;
class iy {
    constructor(t, e) {
        var r, i;
        this.context = t,
        this._options = {
            ...e,
            detune: 0,
            frequency: 0
        };
        const a = new ConstantSourceNode(t,{
            offset: (r = e == null ? void 0 : e.detune) !== null && r !== void 0 ? r : 0
        })
          , l = new ConstantSourceNode(t,{
            offset: (i = e == null ? void 0 : e.frequency) !== null && i !== void 0 ? i : 440
        })
          , f = t.createGain()
          , h = new OscillatorNode(t,this._options);
        h.connect(f),
        a.connect(h.detune),
        l.connect(h.frequency),
        h.addEventListener("ended", () => {
            h.disconnect(f),
            a.disconnect(h.detune),
            l.disconnect(h.frequency)
        }
        ),
        this.voices = [h],
        this._detune = a,
        this._frequency = l,
        this._gain = f,
        this._started = !1,
        this._stopped = !1
    }
    dispose() {
        for (const t of this.voices)
            t.stop();
        this._detune.stop(),
        this._frequency.stop(),
        this._gain.disconnect()
    }
    get numberOfVoices() {
        return this.voices.length
    }
    set numberOfVoices(t) {
        if (t < 1)
            throw new Error("At least one voice must be present");
        for (; this.voices.length > t; )
            this.voices.pop().stop();
        for (; this.voices.length < t; ) {
            const e = new OscillatorNode(this.context,this._options);
            if (this.type === "custom") {
                if (!this._periodicWave)
                    throw new Error("Periodic wave must be set when type = 'custom'");
                e.setPeriodicWave(this._periodicWave)
            } else
                e.type = this.type;
            e.connect(this._gain),
            this._detune.connect(e.detune),
            this._frequency.connect(e.frequency),
            e.addEventListener("ended", () => {
                e.disconnect(this._gain),
                this._detune.disconnect(e.detune),
                this._frequency.disconnect(e.frequency)
            }
            ),
            this._started && (e.start(this._startTime),
            this._stopped && e.stop(this._stopTime)),
            this.voices.push(e)
        }
    }
    get detune() {
        return this._detune.offset
    }
    get frequency() {
        return this._frequency.offset
    }
    get type() {
        return this.voices[0].type
    }
    set type(t) {
        for (const e of this.voices)
            e.type = t
    }
    get onended() {
        return this.voices[0].onended
    }
    get channelCount() {
        return this.voices[0].channelCount
    }
    get channelInterpretation() {
        return this.voices[0].channelInterpretation
    }
    get channelCountMode() {
        return this.voices[0].channelCountMode
    }
    get numberOfInputs() {
        return this.voices[0].numberOfInputs
    }
    get numberOfOutputs() {
        return this.voices[0].numberOfOutputs
    }
    setPeriodicWave(t) {
        this._periodicWave = t;
        for (const e of this.voices)
            e.setPeriodicWave(t)
    }
    addEventListener(t, e, r) {
        this.voices[0].addEventListener(t, e, r)
    }
    removeEventListener(t, e, r) {
        this.voices[0].removeEventListener(t, e, r)
    }
    start(t) {
        this._started = !0,
        this._startTime = t;
        for (const e of this.voices)
            e.start(t);
        this._detune.start(t),
        this._frequency.start(t)
    }
    stop(t) {
        this._stopped = !0,
        this._stopTime = t;
        for (const e of this.voices)
            e.stop(t);
        this._detune.stop(t),
        this._frequency.stop(t)
    }
    connect(t, e, r) {
        return this._gain.connect(t, e, r)
    }
    disconnect(t, e, r) {
        t === void 0 ? this._gain.disconnect() : this._gain.disconnect(t, e, r)
    }
    dispatchEvent(t) {
        for (const e of this.voices)
            e.dispatchEvent(t);
        return this._detune.dispatchEvent(t),
        this._frequency.dispatchEvent(t),
        this._gain.dispatchEvent(t)
    }
}
Js.MultiOscillator = iy;
class jV extends iy {
    constructor(t, e, r="detune") {
        var i, a;
        super(t, e),
        this.mode = r;
        const l = new ConstantSourceNode(t,{
            offset: (i = e == null ? void 0 : e.spread) !== null && i !== void 0 ? i : 0
        })
          , f = this.voices[0]
          , h = new GainNode(t,{
            gain: 0
        });
        l.connect(h).connect(r === "frequency" ? f.frequency : f.detune),
        f.addEventListener("ended", () => {
            l.disconnect(h),
            h.disconnect(r === "frequency" ? f.frequency : f.detune)
        }
        ),
        this._spread = l,
        this._mus = [h],
        this.numberOfVoices = (a = e == null ? void 0 : e.numberOfVoices) !== null && a !== void 0 ? a : 1
    }
    set numberOfVoices(t) {
        super.numberOfVoices = t;
        const e = this.mode;
        for (; this._mus.length > t; )
            this._mus.pop();
        for (; this._mus.length < t; ) {
            const r = this.voices[this._mus.length]
              , i = this.context.createGain();
            this._spread.connect(i).connect(e === "frequency" ? r.frequency : r.detune),
            r.addEventListener("ended", () => {
                this._spread.disconnect(i),
                i.disconnect(e === "frequency" ? r.frequency : r.detune)
            }
            ),
            this._mus.push(i)
        }
        if (this._gain.gain.setValueAtTime(1 / Math.sqrt(t), this.context.currentTime),
        t === 1) {
            this._mus[0].gain.setValueAtTime(0, this.context.currentTime);
            return
        }
        for (let r = 0; r < t; ++r) {
            const i = 2 * r / (t - 1) - 1;
            this._mus[r].gain.setValueAtTime(i, this.context.currentTime)
        }
    }
    get spread() {
        return this._spread.offset
    }
    start(t) {
        super.start(t),
        this._spread.start(t)
    }
    stop(t) {
        super.stop(t),
        this._spread.stop(t)
    }
    dispatchEvent(t) {
        this._spread.dispatchEvent(t);
        for (const e of this._mus)
            e.dispatchEvent(t);
        return super.dispatchEvent(t)
    }
}
Js.UnisonOscillator = jV;
class HV extends iy {
    constructor(t, e) {
        super(t, e),
        (e == null ? void 0 : e.aperiodicWave) !== void 0 && this.setAperiodicWave(e.aperiodicWave)
    }
    setAperiodicWave(t) {
        const e = t.detunings;
        this.type = "sine",
        this.numberOfVoices = e.length;
        for (let r = 0; r < e.length; ++r)
            this.voices[r].detune.setValueAtTime(e[r], this.context.currentTime),
            this.voices[r].setPeriodicWave(t.periodicWaves[r])
    }
}
Js.AperiodicOscillator = HV;
var au = {};
Object.defineProperty(au, "__esModule", {
    value: !0
});
au.VoiceBase = void 0;
const r_ = .5
  , s_ = 1e4;
let GV = 1;
class WV {
    constructor(t, e, r) {
        this.age = s_,
        this.context = t,
        this.envelope = new GainNode(t,{
            gain: 0
        }),
        this.envelope.connect(e),
        this.log = r,
        this.noteId = 0,
        this.voiceId = GV++
    }
    noteOn(t, e, r, i) {
        this.log(`Voice ${this.voiceId}: Age = ${this.age}, note = ${r}, frequency = ${t}`),
        this.age = 0,
        this.noteId = r;
        const a = this.context.currentTime + i.audioDelay;
        this.log(`Voice ${this.voiceId}: On time = ${a}, sustain time = ${a + i.attackTime}`),
        this.envelope.gain.setValueAtTime(0, a),
        this.envelope.gain.linearRampToValueAtTime(e, a + i.attackTime),
        this.envelope.gain.setTargetAtTime(e * i.sustainLevel, a + i.attackTime, i.decayTime * r_);
        const l = () => {
            if (this.noteId !== r) {
                this.log(`Voice ${this.voiceId} had been stolen. Ignoring note off`);
                return
            }
            this.age = s_;
            const f = this.context.currentTime;
            this.log(`Voice ${this.voiceId}: Off time = ${f}`),
            this.envelope.gain.cancelScheduledValues(f),
            f < a + i.attackTime && this.envelope.gain.setValueAtTime(e * (f - a) / i.attackTime, f),
            this.envelope.gain.setTargetAtTime(0, f, i.releaseTime * r_),
            this.noteId = -1
        }
        ;
        return this.lastNoteOff = l,
        l
    }
    dispose() {}
}
au.VoiceBase = WV;
(function(n) {
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.AperiodicVoice = n.UnisonVoice = n.OscillatorVoice = n.OscillatorVoiceBase = n.defaultUnisonParams = n.defaultParams = n.AperiodicWave = void 0;
    const t = Js
      , e = au;
    var r = Js;
    Object.defineProperty(n, "AperiodicWave", {
        enumerable: !0,
        get: function() {
            return r.AperiodicWave
        }
    });
    function i() {
        return {
            audioDelay: .001,
            type: "triangle",
            attackTime: .01,
            decayTime: .3,
            sustainLevel: .8,
            releaseTime: .01
        }
    }
    n.defaultParams = i;
    function a() {
        const m = i();
        return m.type = "sawtooth",
        m.stackSize = 3,
        m.spread = 1.5,
        m
    }
    n.defaultUnisonParams = a;
    class l extends e.VoiceBase {
        constructor(g, b, E, S) {
            super(g, b, E),
            this.oscillator = new S(this.context),
            this.oscillator.connect(this.envelope);
            const F = this.context.currentTime;
            this.oscillator.start(F),
            this.oscillator.addEventListener("ended", () => {
                this.envelope.disconnect(),
                this.oscillator.disconnect()
            }
            )
        }
        noteOn(g, b, E, S) {
            const F = this.context.currentTime + S.audioDelay;
            return this.oscillator.frequency.setValueAtTime(g, F),
            super.noteOn(g, b, E, S)
        }
        dispose() {
            this.oscillator.stop(),
            (this.oscillator instanceof t.UnisonOscillator || this.oscillator instanceof t.AperiodicOscillator) && this.oscillator.dispose()
        }
    }
    n.OscillatorVoiceBase = l;
    class f extends l {
        constructor(g, b, E) {
            super(g, b, E, OscillatorNode)
        }
        noteOn(g, b, E, S) {
            if (S.periodicWave) {
                if (S.type !== "custom")
                    throw new Error("Oscillator type must be set to 'custom' when periodic wave is used.");
                this.oscillator.setPeriodicWave(S.periodicWave)
            } else {
                if (S.type === "custom")
                    throw new Error("Periodic wave must be given when oscillator type is set to 'custom'");
                this.oscillator.type = S.type
            }
            return super.noteOn(g, b, E, S)
        }
    }
    n.OscillatorVoice = f;
    class h extends l {
        constructor(g, b, E) {
            super(g, b, E, t.UnisonOscillator)
        }
        noteOn(g, b, E, S) {
            this.oscillator.numberOfVoices = S.stackSize;
            const F = this.context.currentTime + S.audioDelay;
            if (this.oscillator.spread.setValueAtTime(S.spread, F),
            S.periodicWave) {
                if (S.type !== "custom")
                    throw new Error("Oscillator type must be set to 'custom' when periodic wave is used.");
                this.oscillator.setPeriodicWave(S.periodicWave)
            } else {
                if (S.type === "custom")
                    throw new Error("Periodic wave must be given when oscillator type is set to 'custom'");
                this.oscillator.type = S.type
            }
            return super.noteOn(g, b, E, S)
        }
    }
    n.UnisonVoice = h;
    class p extends l {
        constructor(g, b, E) {
            super(g, b, E, t.AperiodicOscillator)
        }
        noteOn(g, b, E, S) {
            return this.oscillator.setAperiodicWave(S.aperiodicWave),
            super.noteOn(g, b, E, S)
        }
    }
    n.AperiodicVoice = p
}
)(sy);
var zf = {};
Object.defineProperty(zf, "__esModule", {
    value: !0
});
zf.BufferVoice = void 0;
const JV = au;
class KV extends JV.VoiceBase {
    noteOn(t, e, r, i) {
        this.node && this.node.stop();
        const a = i.factory(this.context, t, e);
        a.connect(this.envelope),
        a.addEventListener("ended", () => {
            a.disconnect(this.envelope)
        }
        );
        const l = this.context.currentTime + i.audioDelay;
        a.start(l),
        this.node = a;
        const f = super.noteOn(t, e, r, i);
        return () => {
            f();
            const h = this.context.currentTime + i.audioDelay;
            a.stop(h + i.releaseTime * 3)
        }
    }
    dispose() {
        this.node && this.node.stop(),
        this.envelope.disconnect()
    }
}
zf.BufferVoice = KV;
var OS = {};
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(r, i, a, l) {
        l === void 0 && (l = a);
        var f = Object.getOwnPropertyDescriptor(i, a);
        (!f || ("get"in f ? !i.__esModule : f.writable || f.configurable)) && (f = {
            enumerable: !0,
            get: function() {
                return i[a]
            }
        }),
        Object.defineProperty(r, l, f)
    }
    : function(r, i, a, l) {
        l === void 0 && (l = a),
        r[l] = i[a]
    }
    )
      , e = Zt && Zt.__exportStar || function(r, i) {
        for (var a in r)
            a !== "default" && !Object.prototype.hasOwnProperty.call(i, a) && t(i, r, a)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    e(au, n),
    e(zf, n),
    e(sy, n)
}
)(OS);
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(m, g, b, E) {
        E === void 0 && (E = b);
        var S = Object.getOwnPropertyDescriptor(g, b);
        (!S || ("get"in S ? !g.__esModule : S.writable || S.configurable)) && (S = {
            enumerable: !0,
            get: function() {
                return g[b]
            }
        }),
        Object.defineProperty(m, E, S)
    }
    : function(m, g, b, E) {
        E === void 0 && (E = b),
        m[E] = g[b]
    }
    )
      , e = Zt && Zt.__exportStar || function(m, g) {
        for (var b in m)
            b !== "default" && !Object.prototype.hasOwnProperty.call(g, b) && t(g, m, b)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.BufferSynth = n.AperiodicSynth = n.UnisonSynth = n.Synth = void 0;
    const r = sy
      , i = zf;
    e(OS, n);
    let a = 1;
    class l {
        constructor(g, b, E) {
            this.audioContext = g,
            this.destination = b,
            E === void 0 ? this.log = S => {}
            : this.log = E,
            this.voices = []
        }
        _newVoice() {
            return new r.OscillatorVoice(this.audioContext,this.destination,this.log)
        }
        setPolyphony(g) {
            if (g < 0 || g === 1 / 0 || isNaN(g))
                throw new Error("Invalid max polyphony");
            for (; this.voices.length > g; )
                this.voices.pop().dispose();
            for (; this.voices.length < g; )
                this.voices.push(this._newVoice())
        }
        get maxPolyphony() {
            return this.voices.length
        }
        set maxPolyphony(g) {
            this.setPolyphony(g)
        }
        _allocateVoice() {
            let g;
            for (const b of this.voices)
                b.age++,
                (g === void 0 || b.age > g.age) && (g = b);
            return g
        }
        noteOn(g, b) {
            const E = this._allocateVoice();
            if (E === void 0)
                return () => {}
                ;
            if (this.voiceParams === void 0)
                throw new Error("Synth.voiceParams must be set before calling Synth.noteOn");
            return E.noteOn(g, b, a++, this.voiceParams)
        }
        allNotesOff() {
            for (const g of this.voices)
                g.lastNoteOff !== void 0 && g.lastNoteOff()
        }
    }
    n.Synth = l;
    class f extends l {
        _newVoice() {
            return new r.UnisonVoice(this.audioContext,this.destination,this.log)
        }
    }
    n.UnisonSynth = f;
    class h extends l {
        _newVoice() {
            return new r.AperiodicVoice(this.audioContext,this.destination,this.log)
        }
    }
    n.AperiodicSynth = h;
    class p extends l {
        _newVoice() {
            return new i.BufferVoice(this.audioContext,this.destination,this.log)
        }
    }
    n.BufferSynth = p
}
)(Kr);
const NS = ["sine", "square", "sawtooth", "triangle"]
  , TS = ["warm1", "warm2", "warm3", "warm4", "octaver", "brightness", "harmonicbell", "semisine", "rich", "slender", "didacus", "bohlen", "glass", "boethius", "gold", "rich-classic", "slender-classic", "didacus-classic", "bohlen-classic", "glass-classic", "boethius-classic"]
  , UW = NS.concat(TS)
  , Vn = {}
  , ZV = ["jegogan", "jublag", "ugal", "gender", "piano", "tin", "bronze", "steel", "silver", "platinum", "12-TET"]
  , fs = {};
function YV(n) {
    Vn.warm1 = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 2, 2, 2, 1, 1, .5]), new Float32Array([0, 0, 0, 0, 0, 0, 0, 0]))),
    Vn.warm2 = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 5, 3.33, 2, 1]), new Float32Array([0, 0, 0, 0, 0, 0]))),
    Vn.warm3 = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 5, 5, 3]), new Float32Array([0, 0, 0, 0, 0]))),
    Vn.warm4 = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 2, 2, 1]), new Float32Array([0, 0, 0, 0, 0]))),
    Vn.octaver = Ve( () => n.createPeriodicWave(new Float32Array([0, 1e3, 500, 0, 333, 0, 0, 0, 250, 0, 0, 0, 0, 0, 0, 0, 166]), new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))),
    Vn.brightness = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 1, 1, 1, 1, 1, .75, .5, .2, .1]), new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))),
    Vn.harmonicbell = Ve( () => n.createPeriodicWave(new Float32Array([0, 10, 2, 2, 2, 2, 0, 0, 0, 0, 0, 7]), new Float32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]))),
    Vn.semisine = Ve( () => {
        const r = new Float32Array(64)
          , i = new Float32Array(64);
        for (let a = 1; a < 64; ++a)
            i[a] = 1 / (1 - 4 * a * a);
        return n.createPeriodicWave(i, r)
    }
    );
    const t = new Float32Array(101);
    Vn.gold = Ve( () => {
        const r = new Float32Array(101);
        for (let i = 1; i <= 10; ++i)
            r[i * i] = i ** -.75;
        return n.createPeriodicWave(t, r)
    }
    );
    const e = Ve( () => {
        const r = new Float32Array(101)
          , i = new Float32Array(101)
          , a = new Float32Array(101)
          , l = new Float32Array(101)
          , f = new Float32Array(101)
          , h = new Float32Array(101)
          , p = new Float32Array(101)
          , m = new Float32Array(101)
          , g = new Float32Array(101)
          , b = new Float32Array(101)
          , E = new Float32Array(101)
          , S = new Float32Array(101);
        return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 15, 16, 18, 19, 20, 21, 22, 24, 25, 27, 28, 30, 32, 33, 35, 36, 38, 40, 42, 44, 45, 48, 49, 50, 54, 55, 56, 57, 60, 63, 64, 66, 70, 72, 75, 76, 77, 80, 81, 84, 88, 90, 95, 96, 98, 99, 100].forEach(B => {
            const Q = 1 / B
              , ae = B ** -1.5;
            B % 11 && B % 19 && (B % 7 && (i[B] = Q,
            r[B] = ae),
            B % 5 && (l[B] = Q,
            a[B] = ae),
            B % 3 && (h[B] = Q,
            f[B] = ae),
            B % 2 && (m[B] = Q,
            p[B] = ae)),
            B % 3 && B % 5 && B % 19 && (B % 7 && B % 11 ? (b[B] = Q,
            g[B] = ae) : (b[B] = 2 * Q,
            g[B] = 2 * ae)),
            B % 5 && B % 7 && B % 11 && (B % 19 ? (S[B] = Q,
            E[B] = ae) : (S[B] = 2 * Q,
            E[B] = 2 * ae))
        }
        ),
        {
            richClassic: i,
            rich: r,
            slenderClassic: l,
            slender: a,
            didacusClassic: h,
            didacus: f,
            bohlenClassic: m,
            bohlen: p,
            glassClassic: b,
            glass: g,
            boethiusClassic: S,
            boethius: E
        }
    }
    );
    Vn["rich-classic"] = Ve( () => n.createPeriodicWave(t, e.value.richClassic)),
    Vn.rich = Ve( () => n.createPeriodicWave(t, e.value.rich)),
    Vn["slender-classic"] = Ve( () => n.createPeriodicWave(t, e.value.slenderClassic)),
    Vn.slender = Ve( () => n.createPeriodicWave(t, e.value.slender)),
    Vn["didacus-classic"] = Ve( () => n.createPeriodicWave(t, e.value.didacusClassic)),
    Vn.didacus = Ve( () => n.createPeriodicWave(t, e.value.didacus)),
    Vn["bohlen-classic"] = Ve( () => n.createPeriodicWave(t, e.value.bohlenClassic)),
    Vn.bohlen = Ve( () => n.createPeriodicWave(t, e.value.bohlen)),
    Vn["glass-classic"] = Ve( () => n.createPeriodicWave(t, e.value.glassClassic)),
    Vn.glass = Ve( () => n.createPeriodicWave(t, e.value.glass)),
    Vn["boethius-classic"] = Ve( () => n.createPeriodicWave(t, e.value.boethiusClassic)),
    Vn.boethius = Ve( () => n.createPeriodicWave(t, e.value.boethius))
}
function QV(n) {
    const t = [...Array(129).keys()];
    t.shift();
    const e = t.map(a => .3 * a ** -1.5)
      , r = 7
      , i = .1;
    fs.tin = Ve( () => new Kr.AperiodicWave(n,t.map(a => a ** (8 / 9)),e,r,i)),
    fs.steel = Ve( () => new Kr.AperiodicWave(n,t.map(a => a ** 1.5),e,r,i)),
    fs.bronze = Ve( () => new Kr.AperiodicWave(n,t.map(a => a ** (4 / 3)),e,r,i)),
    fs.silver = Ve( () => new Kr.AperiodicWave(n,t.map(a => a ** (5 / 3)),e,r,i)),
    fs.platinum = Ve( () => new Kr.AperiodicWave(n,t.slice(0, 32).map(a => a ** 2.5),e.slice(0, 32),r,i)),
    fs.gender = Ve( () => {
        const a = [1, 2.26, 3.358, 3.973, 7.365, 13, 29, 31, 37]
          , l = [1, .6, .3, .4, .2, .05, .04, .01, .006].map(p => .4 * p)
          , f = []
          , h = [];
        for (let p = 0; p < a.length; ++p)
            f.push(a[p] * 1.004),
            f.push(a[p] / 1.004),
            h.push(l[p]),
            h.push(.6 * l[p]);
        return new Kr.AperiodicWave(n,f,h,r,i)
    }
    ),
    fs.jublag = Ve( () => {
        const a = [1, 2.77, 5.18, 5.33];
        a.push(9.1, 18.9, 23),
        a[0] = 1.01,
        a.unshift(1 / a[0]),
        a.push(2.76);
        const l = [1, .5, .5, .3, .2, .15, .1, .09, .2].map(f => .45 * f);
        return new Kr.AperiodicWave(n,a,l,r,i)
    }
    ),
    fs.ugal = Ve( () => {
        const a = [1, 2.61, 4.8, 4.94, 6.32];
        a.push(9.9, 17, 24.1),
        a[0] = 1.008,
        a.unshift(1 / a[0]),
        a.push(2.605),
        a.push(4.81);
        const l = [.6, 1, .45, .3, .15, .2, .07, .08, .05, .1, .1].map(f => .45 * f);
        return new Kr.AperiodicWave(n,a,l,r,i)
    }
    ),
    fs.jegogan = Ve( () => {
        const a = [1, 2.8, 5.5, 9, 16.7, 17.8, 20.5, 22.9, 24.9, 27, 28.1, 29.2, 29.5, 30, 31.8, 33.3, 36, 36.9, 40.6, 41.4]
          , l = a.map(f => .7 * (Math.cos(.3 * f * f) + 1.6) / (f ** 1.4 + 1.6));
        return new Kr.AperiodicWave(n,a,l,r,i)
    }
    ),
    fs["12-TET"] = Ve( () => {
        const a = []
          , l = [];
        for (let f = 1; f <= 128; ++f) {
            const h = Ie.valueToCents(f)
              , p = Math.round(h / 100) * 100;
            Math.abs(h - p) < 15 && (a.push((3 * p + h) / 4),
            f === $V(f) ? l.push(.3 * f ** -2) : l.push(.6 * f ** -1.5))
        }
        return new Kr.AperiodicWave(n,a.map(Ie.centsToValue),l,r,i)
    }
    ),
    fs.piano = Ve( () => {
        const a = [.998711340392508, 1.0012886596074921, 2.000000001915048, 3.0077319605175252, 4.024484537329971, 4.028350517109971, 5.052835053482418, 6.0953608281898495, 6.100515466619817, 7.149484540322233, 7.158505158532202, 8.221649488874554, 9.326030932401801, 9.3298969121818, 9.33891753039177, 10.449742272914, 10.457474232474, 10.466494850683969, 11.597938150756168]
          , l = [.9123120265773679, .7281477301038842, .5078045641543809, .8061314224800064, .3177244232370868, .15135058363038334, .12440135191000032, .045007651288955175, .050804443667738106, .029671376885221354, .023841125287306208, .01853341284211317, .02380292893502422, .024761095205029133, .020866326567241505, .0017670624571622458, .0024893662658642206, .0012043792096897129, .0014228119365412375].map(f => f * .38);
        return new Kr.AperiodicWave(n,a,l,r,i)
    }
    )
}
function XV(n) {
    YV(n),
    QV(n)
}
class eU {
    constructor(t, e=5) {
        St(this, "audioContext");
        St(this, "delayL");
        St(this, "delayR");
        St(this, "gainL");
        St(this, "gainR");
        St(this, "panL");
        St(this, "panR");
        St(this, "destination");
        this.audioContext = t,
        this.delayL = t.createDelay(e),
        this.delayR = t.createDelay(e),
        this.gainL = t.createGain(),
        this.gainR = t.createGain(),
        this.panL = t.createStereoPanner(),
        this.panR = t.createStereoPanner(),
        this.delayL.connect(this.gainL).connect(this.delayR).connect(this.gainR).connect(this.delayL),
        this.gainL.connect(this.panL),
        this.gainR.connect(this.panR),
        this.destination = this.delayL
    }
    set delayTime(t) {
        const e = this.audioContext.currentTime;
        this.delayL.delayTime.setValueAtTime(t, e),
        this.delayR.delayTime.setValueAtTime(t, e)
    }
    set feedback(t) {
        const e = this.audioContext.currentTime;
        this.gainL.gain.setValueAtTime(t, e),
        this.gainR.gain.setValueAtTime(t, e)
    }
    set separation(t) {
        const e = this.audioContext.currentTime;
        this.panL.pan.setValueAtTime(-t, e),
        this.panR.pan.setValueAtTime(t, e)
    }
    connect(t) {
        return this.panL.connect(t),
        this.panR.connect(t),
        t
    }
    disconnect(t) {
        return this.panL.disconnect(t),
        this.panR.disconnect(t),
        t
    }
}
function tU(n) {
    const t = Math.sin(2 * Math.PI * n);
    return t * t * t
}
class nU {
    constructor(t) {
        St(this, "audioContext");
        St(this, "voices");
        St(this, "numPlayed");
        this.audioContext = t,
        this.voices = [],
        this.numPlayed = 0
    }
    voiceOn(t, e=tU) {
        const r = this.audioContext.currentTime
          , i = this.numPlayed++;
        return this.voices.push({
            id: i,
            start: r,
            frequency: t,
            waveform: e
        }),
        this.voices.sort( (l, f) => Math.abs(l.frequency) - Math.abs(f.frequency)),
        () => {
            for (let l = 0; l < this.voices.length; ++l)
                this.voices[l].id === i && this.voices.splice(l, 1)
        }
    }
    getTimeDomainData(t, e, r) {
        if (!r.length)
            return;
        const i = (e - t) / r[0].length;
        for (let a = 0; a < r[0].length; ++a) {
            const l = t + i * a;
            this.voices.forEach( (f, h) => {
                if (h >= r.length)
                    return;
                const p = (l - f.start) * f.frequency;
                p >= 0 ? r[h][a] = f.waveform(p) : r[h][a] = 0
            }
            )
        }
        for (let a = this.voices.length; a < r.length; ++a)
            r[a][0] = NaN
    }
}
const Bv = "semisine"
  , i_ = "jegogan"
  , xS = Ti("audio", () => {
    const n = te(null)
      , t = te(.18)
      , e = te(null)
      , r = te(null)
      , i = te(null)
      , a = te(null)
      , l = te("none");
    let f, h, p;
    const m = te(Bv)
      , g = te(.01)
      , b = te(.3)
      , E = te(.8)
      , S = te(.01)
      , F = te(3)
      , B = te(2.5)
      , Q = te(i_)
      , ae = te(.001)
      , V = te(null)
      , k = te(null)
      , z = te(null)
      , Z = te(.3)
      , re = te(.8)
      , C = te(1)
      , D = te(0);
    if ("audioDelay"in window.localStorage) {
        const he = window.localStorage.getItem("audioDelay");
        he !== null && (ae.value = parseFloat(he),
        isNaN(ae.value) && (ae.value = .001))
    }
    const R = {
        audioDelay: ae.value,
        attackTime: g.value,
        decayTime: b.value,
        sustainLevel: E.value,
        releaseTime: S.value
    }
      , W = {
        ...R,
        type: "triangle",
        periodicWave: void 0
    }
      , I = {
        ...W,
        spread: B.value,
        stackSize: F.value
    }
      , N = {
        ...R,
        aperiodicWave: null
    }
      , P = Ve({
        get() {
            return a.value === null ? "maxPolyphony"in window.localStorage ? parseInt(window.localStorage.getItem("maxPolyphony")) : 6 : a.value.maxPolyphony
        },
        set(he) {
            he < 1 && (he = 1),
            he > 128 && (he = 128),
            isNaN(he) || (he = Math.round(he),
            window.localStorage.setItem("maxPolyphony", he.toString()),
            a.value !== null && a.value.setPolyphony(he))
        }
    });
    function J() {
        if (n.value) {
            n.value.resume();
            return
        }
        n.value = new AudioContext({
            latencyHint: "interactive"
        }),
        k.value = new eU(n.value),
        z.value = n.value.createGain(),
        k.value.delayTime = Z.value,
        k.value.feedback = re.value,
        k.value.separation = re.value,
        z.value.gain.setValueAtTime(D.value, n.value.currentTime);
        const he = n.value.createGain();
        he.gain.setValueAtTime(t.value, n.value.currentTime),
        he.connect(n.value.destination),
        he.connect(k.value.destination),
        k.value.connect(z.value).connect(n.value.destination),
        e.value = he;
        const Fe = n.value.createBiquadFilter();
        Fe.frequency.setValueAtTime(5e3, n.value.currentTime),
        Fe.Q.setValueAtTime(Math.sqrt(.5), n.value.currentTime),
        Fe.type = "lowpass",
        Fe.connect(he),
        r.value = Fe;
        const Te = n.value.createBiquadFilter();
        Te.frequency.setValueAtTime(30, n.value.currentTime),
        Te.Q.setValueAtTime(Math.sqrt(.5), n.value.currentTime),
        Te.type = "highpass",
        Te.connect(Fe),
        i.value = Te;
        const ye = Te;
        XV(n.value),
        W.type = "custom",
        W.periodicWave = Vn[Bv].value,
        I.type = "custom",
        I.periodicWave = Vn[Bv].value,
        N.aperiodicWave = fs[i_].value,
        f = new Kr.Synth(n.value,ye),
        h = new Kr.UnisonSynth(n.value,ye),
        p = new Kr.AperiodicSynth(n.value,ye),
        f.voiceParams = W,
        h.voiceParams = I,
        p.voiceParams = N;
        const qe = P.value;
        l.value = "oscillator",
        a.value = f,
        a.value.maxPolyphony = qe,
        V.value = new nU(n.value)
    }
    async function X() {
        n.value && (e.value && e.value.disconnect(),
        r.value && r.value.disconnect(),
        i.value && i.value.disconnect(),
        a.value && a.value.setPolyphony(0),
        await n.value.close(),
        n.value = null)
    }
    Jt(t, he => {
        !n.value || !e.value || e.value.gain.setValueAtTime(he, n.value.currentTime)
    }
    ),
    Jt(ae, he => {
        window.localStorage.setItem("audioDelay", he.toString()),
        W.audioDelay = he,
        I.audioDelay = he,
        N.audioDelay = he
    }
    ),
    Jt(l, he => {
        const Fe = P.value;
        switch (he) {
        case "none":
            a.value = null,
            f.maxPolyphony = 0,
            h.maxPolyphony = 0,
            p.maxPolyphony = 0;
            break;
        case "oscillator":
            a.value = f,
            f.maxPolyphony = Fe,
            h.maxPolyphony = 0,
            p.maxPolyphony = 0;
            break;
        case "unison":
            a.value = h,
            f.maxPolyphony = 0,
            h.maxPolyphony = Fe,
            p.maxPolyphony = 0;
            break;
        case "aperiodic":
            a.value = p,
            f.maxPolyphony = 0,
            h.maxPolyphony = 0,
            p.maxPolyphony = Fe;
            break
        }
    }
    ),
    Jt(m, he => {
        NS.includes(he) ? (W.type = I.type = he,
        W.periodicWave = I.periodicWave = void 0) : TS.includes(he) && (W.type = I.type = "custom",
        W.periodicWave = I.periodicWave = Vn[he].value)
    }
    ),
    Jt(Q, he => {
        ZV.includes(he) && (N.aperiodicWave = fs[he].value)
    }
    ),
    Jt(g, he => {
        W.attackTime = I.attackTime = N.attackTime = he
    }
    ),
    Jt(b, he => {
        W.decayTime = I.decayTime = N.decayTime = he
    }
    ),
    Jt(E, he => {
        W.sustainLevel = I.sustainLevel = N.sustainLevel = he
    }
    ),
    Jt(S, he => {
        W.releaseTime = I.releaseTime = N.releaseTime = he
    }
    ),
    Jt(F, he => {
        I.stackSize = he
    }
    ),
    Jt(B, he => {
        I.spread = he
    }
    ),
    Jt(Z, he => {
        k.value && (k.value.delayTime = he)
    }
    ),
    Jt(re, he => {
        k.value && (k.value.feedback = he)
    }
    ),
    Jt(C, he => {
        k.value && (k.value.separation = he)
    }
    ),
    Jt(D, he => {
        !z.value || !n.value || z.value.gain.setValueAtTime(he, n.value.currentTime)
    }
    );
    const ie = {
        mainVolume: t,
        waveform: m,
        attackTime: g,
        decayTime: b,
        sustainLevel: E,
        releaseTime: S,
        stackSize: F,
        spread: B,
        aperiodicWaveform: Q,
        synthType: l,
        pingPongDelayTime: Z,
        pingPongFeedback: re,
        pingPongGain: D,
        pingPongSeparation: C
    };
    function ce() {
        const he = {};
        for (const [Fe,Te] of Object.entries(ie))
            he[Fe] = Te.value;
        return he
    }
    function Le(he) {
        for (const Fe in ie)
            ie[Fe].value = he[Fe]
    }
    return {
        initialize: J,
        unintialize: X,
        toJSON: ce,
        fromJSON: Le,
        ...ie,
        audioDelay: ae,
        context: n,
        maxPolyphony: P,
        synth: a,
        virtualSynth: V,
        pingPongDelay: k,
        mainGain: e,
        mainLowpass: r,
        mainHighpass: i
    }
}
)
  , oy = Ti("state", () => {
    const n = Cr(new Map)
      , t = te(!0)
      , e = te("auto")
      , r = window.localStorage
      , i = te(r.getItem("newline") ?? bS)
      , a = r.getItem("colorScheme")
      , l = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light"
      , f = te((a ?? l) === "dark" ? "dark" : "light")
      , h = te(r.getItem("showVirtualQwerty") === "true")
      , p = te(r.getItem("showMosTab") === "true")
      , m = te(r.getItem("showKeyboardLabel") !== "false")
      , g = te(r.getItem("showKeyboardCents") !== "false")
      , b = te(r.getItem("showKeyboardRatio") !== "false")
      , E = te(r.getItem("showKeyboardFrequency") !== "false")
      , S = te(parseInt(r.getItem("intervalMatrixIndexing") ?? "0", 10))
      , F = te(parseInt(r.getItem("maxMatrixWidth") ?? "100", 10))
      , B = te(r.getItem("calculateConstantStructureViolations") === "true")
      , Q = te(r.getItem("calculateVariety") === "true")
      , ae = te(r.getItem("calculateBrightness") === "true")
      , V = te(parseInt(r.getItem("constantStructureMargin") ?? "0", 10))
      , k = te(r.getItem("deactivationCode") ?? "Backquote")
      , z = te(r.getItem("equaveUpCode") ?? "NumpadMultiply")
      , Z = te(r.getItem("equaveDownCode") ?? "NumpadDivide")
      , re = te(r.getItem("degreeUpCode") ?? "NumpadAdd")
      , C = te(r.getItem("degreeDownCode") ?? "NumpadSubtract")
      , D = te(r.getItem("shareStatistics") === "true")
      , R = te(r.getItem("showSafariWarning") !== "false")
      , W = te(r.getItem("debug") === "true");
    function I() {
        return {
            latticeType: e.value
        }
    }
    function N(P) {
        e.value = P.latticeType
    }
    return CS({
        newline: i,
        showVirtualQwerty: h,
        showMosTab: p,
        showKeyboardLabel: m,
        showKeyboardCents: g,
        showKeyboardRatio: b,
        showKeyboardFrequency: E,
        intervalMatrixIndexing: S,
        maxMatrixWidth: F,
        calculateConstantStructureViolations: B,
        calculateVariety: Q,
        calculateBrightness: ae,
        constantStructureMargin: V,
        deactivationCode: k,
        equaveUpCode: z,
        equaveDownCode: Z,
        degreeUpCode: re,
        degreeDownCode: C,
        shareStatistics: D,
        showSafariWarning: R,
        debug: W
    }),
    Jt(f, P => {
        r.setItem("colorScheme", P),
        document.documentElement.setAttribute("data-theme", P)
    }
    , {
        immediate: !0
    }),
    {
        heldNotes: n,
        typingActive: t,
        latticeType: e,
        newline: i,
        colorScheme: f,
        showVirtualQwerty: h,
        showMosTab: p,
        showKeyboardLabel: m,
        showKeyboardCents: g,
        showKeyboardRatio: b,
        showKeyboardFrequency: E,
        intervalMatrixIndexing: S,
        maxMatrixWidth: F,
        calculateConstantStructureViolations: B,
        calculateVariety: Q,
        calculateBrightness: ae,
        constantStructureMargin: V,
        deactivationCode: k,
        equaveUpCode: z,
        equaveDownCode: Z,
        degreeUpCode: re,
        degreeDownCode: C,
        shareStatistics: D,
        showSafariWarning: R,
        debug: W,
        toJSON: I,
        fromJSON: N
    }
}
)
  , rU = Ti("midi", () => {
    const n = te(null)
      , t = te(null)
      , e = te(new Set([1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16]))
      , r = te(!0)
      , i = te(!1)
      , a = te(3)
      , l = te(8)
      , f = te(4)
      , h = te("off");
    return {
        input: n,
        output: t,
        outputChannels: e,
        multichannelToEquave: i,
        multichannelCenter: a,
        multichannelNumEquaves: l,
        multichannelEquavesDown: f,
        velocityOn: r,
        whiteMode: h
    }
}
);
function sU(n, t) {
    const e = ql.midiKeyInfo(n);
    t = t.map(f => f.toLowerCase());
    let r = n
      , i = e.whiteNumber === void 0 ? e.sharpOf + 1 : e.whiteNumber
      , a = -1;
    const l = [];
    for (; i >= 0 && r > -1024; )
        t[Ie.mmod(a--, t.length)] !== "black" && (l[i--] = r),
        r--;
    for (r = n,
    i = e.whiteNumber === void 0 ? e.sharpOf + 1 : e.whiteNumber,
    a = -1; i < 75 && r < 1024; )
        t[Ie.mmod(a++, t.length)] !== "black" && (l[i++] = r),
        r++;
    return l
}
function iU(n, t, e=10) {
    const r = Cr([])
      , i = te(-1);
    a();
    function a() {
        for (; r.length > i.value + 1; )
            r.pop();
        const g = n();
        if (!(r.length && g === r[r.length - 1])) {
            for (r.push(g); r.length > e; )
                r.shift();
            i.value = r.length - 1
        }
    }
    function l() {
        if (i.value--,
        i.value < 0) {
            i.value = -1;
            return
        }
        t(r[i.value])
    }
    function f() {
        if (i.value++,
        i.value >= r.length) {
            i.value = r.length - 1;
            return
        }
        t(r[i.value])
    }
    function h() {
        const g = r.pop();
        g !== void 0 && (r.length = 0,
        r.push(g),
        i.value = r.length - 1)
    }
    const p = Ve( () => i.value <= 0)
      , m = Ve( () => i.value >= r.length - 1);
    return {
        states: r,
        pointer: i,
        pushState: a,
        undo: l,
        redo: f,
        truncate: h,
        undoDisabled: p,
        redoDisabled: m
    }
}
const oU = "/assets/harmonic-entropy.ydata-04a719b7.raw";
function aU() {
    return new Worker("/assets/harmonic-entropy-worker-533f8378.js")
}
var $a = {}
  , tu = {}
  , Os = {};
Object.defineProperty(Os, "__esModule", {
    value: !0
});
Os.ifftReal = Os.ifft = Os.fft = Os.ceilPow2 = Os._resetTables = void 0;
const im = []
  , om = [];
im[2] = [NaN, 0];
om[2] = [NaN, 1];
function lU() {
    im.length = 0,
    om.length = 0,
    im[2] = [NaN, 0],
    om[2] = [NaN, 1]
}
Os._resetTables = lU;
function Vf(n) {
    var t, e;
    const r = (t = im[n]) !== null && t !== void 0 ? t : []
      , i = (e = om[n]) !== null && e !== void 0 ? e : [];
    if (r.length)
        return [r, i];
    r.length = n,
    i.length = n;
    const a = n >>> 1
      , [l,f] = Vf(a);
    for (let p = 1; p < a; ++p)
        r[p << 1] = l[p],
        i[p << 1] = f[p];
    const h = Math.PI / n;
    for (let p = 1; p < a; p += 2)
        i[p] = i[n - p] = r[a - p] = Math.sin(p * h),
        r[a + p] = -r[a - p];
    return [r, i]
}
function Gm(n) {
    return 1 << 32 - Math.clz32(n - 1)
}
Os.ceilPow2 = Gm;
function uU(n, t) {
    const e = n.length;
    if (e !== Gm(e))
        throw new Error("Length must be a power of two.");
    if (t === void 0)
        return cU(n);
    if (t.length !== e)
        throw new Error("Must have an equal number of real and imaginary components");
    const r = new Float64Array(e)
      , i = new Float64Array(e);
    return e === 4 ? (r[0] = n[0] + n[1] + n[2] + n[3],
    r[1] = n[0] + t[1] - n[2] - t[3],
    r[2] = n[0] - n[1] + n[2] - n[3],
    r[3] = n[0] - t[1] - n[2] + t[3],
    i[0] = t[0] + t[1] + t[2] + t[3],
    i[1] = t[0] - n[1] - t[2] + n[3],
    i[2] = t[0] - t[1] + t[2] - t[3],
    i[3] = t[0] + n[1] - t[2] - n[3],
    [r, i]) : e === 2 ? (r[0] = n[0] + n[1],
    r[1] = n[0] - n[1],
    i[0] = t[0] + t[1],
    i[1] = t[0] - t[1],
    [r, i]) : e === 1 ? (r[0] = n[0],
    i[0] = t[0],
    [r, i]) : K0(n, t)
}
Os.fft = uU;
function K0(n, t) {
    const e = n.length
      , r = new Float64Array(e)
      , i = new Float64Array(e);
    if (e === 8) {
        const b = n[0] + n[2] + n[4] + n[6]
          , E = t[0] + t[2] + t[4] + t[6]
          , S = n[1] + n[3] + n[5] + n[7]
          , F = t[1] + t[3] + t[5] + t[7];
        r[0] = b + S,
        i[0] = E + F,
        r[4] = b - S,
        i[4] = E - F;
        const B = n[0] + t[2] - n[4] - t[6]
          , Q = t[0] - n[2] - t[4] + n[6]
          , ae = n[1] + t[3] - n[5] - t[7]
          , V = t[1] - n[3] - t[5] + n[7]
          , k = (ae + V) * .7071067811865475
          , z = (ae - V) * .7071067811865475;
        r[1] = B + k,
        i[1] = Q - z,
        r[5] = B - k,
        i[5] = Q + z;
        const Z = n[0] - n[2] + n[4] - n[6]
          , re = t[0] - t[2] + t[4] - t[6]
          , C = n[1] - n[3] + n[5] - n[7]
          , D = t[1] - t[3] + t[5] - t[7];
        r[2] = Z + D,
        i[2] = re - C,
        r[6] = Z - D,
        i[6] = re + C;
        const R = n[0] - t[2] - n[4] + t[6]
          , W = t[0] + n[2] - t[4] - n[6]
          , I = n[1] - t[3] - n[5] + t[7]
          , N = t[1] + n[3] - t[5] - n[7]
          , P = (I - N) * .7071067811865475
          , J = (I + N) * .7071067811865475;
        return r[3] = R - P,
        i[3] = W - J,
        r[7] = R + P,
        i[7] = W + J,
        [r, i]
    }
    const [a,l] = K0(n.filter( (b, E) => !(E & 1)), t.filter( (b, E) => !(E & 1)))
      , [f,h] = K0(n.filter( (b, E) => E & 1), t.filter( (b, E) => E & 1))
      , p = e >>> 1;
    r[0] = a[0] + f[0],
    r[p] = a[0] - f[0],
    i[0] = l[0] + h[0],
    i[p] = l[0] - h[0];
    const [m,g] = Vf(p);
    for (let b = 1; b < p; ++b) {
        const E = m[b]
          , S = -g[b]
          , F = f[b] * E - h[b] * S
          , B = f[b] * S + h[b] * E;
        r[b] = a[b] + F,
        i[b] = l[b] + B,
        r[b + p] = a[b] - F,
        i[b + p] = l[b] - B
    }
    return [r, i]
}
function cU(n) {
    const t = n.length
      , e = new Float64Array(t)
      , r = new Float64Array(t);
    return t === 4 ? (e[0] = n[0] + n[1] + n[2] + n[3],
    e[1] = n[0] - n[2],
    e[2] = n[0] - n[1] + n[2] - n[3],
    e[3] = n[0] - n[2],
    r[1] = n[3] - n[1],
    r[3] = n[1] - n[3],
    [e, r]) : t === 2 ? (e[0] = n[0] + n[1],
    e[1] = n[0] - n[1],
    [e, r]) : t === 1 ? (e[0] = n[0],
    [e, r]) : Z0(n)
}
function Z0(n) {
    const t = n.length
      , e = new Float64Array(t)
      , r = new Float64Array(t);
    if (t === 8) {
        const g = n[0] + n[2] + n[4] + n[6]
          , b = n[1] + n[3] + n[5] + n[7];
        e[0] = g + b,
        e[4] = g - b;
        const E = n[0] - n[4]
          , S = n[6] - n[2]
          , F = n[1] - n[5]
          , B = n[7] - n[3]
          , Q = (F + B) * .7071067811865475
          , ae = (F - B) * .7071067811865475;
        e[1] = E + Q,
        r[1] = S - ae,
        e[5] = E - Q,
        r[5] = S + ae;
        const V = n[0] - n[2] + n[4] - n[6]
          , k = n[1] - n[3] + n[5] - n[7];
        e[2] = V,
        r[2] = -k,
        e[6] = V,
        r[6] = k;
        const z = n[0] - n[4]
          , Z = n[2] - n[6]
          , re = n[1] - n[5]
          , C = n[3] - n[7]
          , D = (re - C) * .7071067811865475
          , R = (re + C) * .7071067811865475;
        return e[3] = z - D,
        r[3] = Z - R,
        e[7] = z + D,
        r[7] = Z + R,
        [e, r]
    }
    const [i,a] = Z0(n.filter( (g, b) => !(b & 1)))
      , [l,f] = Z0(n.filter( (g, b) => b & 1))
      , h = t >>> 1;
    e[0] = i[0] + l[0],
    e[h] = i[0] - l[0],
    r[0] = a[0] + f[0],
    r[h] = a[0] - f[0];
    const [p,m] = Vf(h);
    for (let g = 1; g < h; ++g) {
        const b = p[g]
          , E = -m[g]
          , S = l[g] * b - f[g] * E
          , F = l[g] * E + f[g] * b;
        e[g] = i[g] + S,
        r[g] = a[g] + F,
        e[g + h] = i[g] - S,
        r[g + h] = a[g] - F
    }
    return [e, r]
}
function fU(n, t) {
    const e = n.length;
    if (e !== Gm(e))
        throw new Error("Length must be a power of two.");
    if (t.length !== e)
        throw new Error("Must have an equal number of real and imaginary components");
    const r = new Float64Array(e)
      , i = new Float64Array(e);
    return e === 4 ? (r[0] = n[0] + n[1] + n[2] + n[3],
    r[1] = n[0] - t[1] - n[2] + t[3],
    r[2] = n[0] - n[1] + n[2] - n[3],
    r[3] = n[0] + t[1] - n[2] - t[3],
    i[0] = t[0] + t[1] + t[2] + t[3],
    i[1] = t[0] + n[1] - t[2] - n[3],
    i[2] = t[0] - t[1] + t[2] - t[3],
    i[3] = t[0] - n[1] - t[2] + n[3],
    [r, i]) : e === 2 ? (r[0] = n[0] + n[1],
    r[1] = n[0] - n[1],
    i[0] = t[0] + t[1],
    i[1] = t[0] - t[1],
    [r, i]) : e === 1 ? (r[0] = n[0],
    i[0] = t[0],
    [r, i]) : am(n, t)
}
Os.ifft = fU;
function am(n, t) {
    const e = n.length
      , r = new Float64Array(e)
      , i = new Float64Array(e);
    if (e === 8) {
        const b = n[0] + n[2] + n[4] + n[6]
          , E = t[0] + t[2] + t[4] + t[6]
          , S = n[1] + n[3] + n[5] + n[7]
          , F = t[1] + t[3] + t[5] + t[7];
        r[0] = b + S,
        i[0] = E + F,
        r[4] = b - S,
        i[4] = E - F;
        const B = n[0] - t[2] - n[4] + t[6]
          , Q = t[0] + n[2] - t[4] - n[6]
          , ae = n[1] - t[3] - n[5] + t[7]
          , V = t[1] + n[3] - t[5] - n[7]
          , k = (ae - V) * .7071067811865475
          , z = (ae + V) * .7071067811865475;
        r[1] = B + k,
        i[1] = Q + z,
        r[5] = B - k,
        i[5] = Q - z;
        const Z = n[0] - n[2] + n[4] - n[6]
          , re = t[0] - t[2] + t[4] - t[6]
          , C = n[1] - n[3] + n[5] - n[7]
          , D = t[1] - t[3] + t[5] - t[7];
        r[2] = Z - D,
        i[2] = re + C,
        r[6] = Z + D,
        i[6] = re - C;
        const R = n[0] + t[2] - n[4] - t[6]
          , W = t[0] - n[2] - t[4] + n[6]
          , I = n[1] + t[3] - n[5] - t[7]
          , N = t[1] - n[3] - t[5] + n[7]
          , P = (I + N) * .7071067811865475
          , J = (I - N) * .7071067811865475;
        return r[3] = R - P,
        i[3] = W + J,
        r[7] = R + P,
        i[7] = W - J,
        [r, i]
    }
    const [a,l] = am(n.filter( (b, E) => !(E & 1)), t.filter( (b, E) => !(E & 1)))
      , [f,h] = am(n.filter( (b, E) => E & 1), t.filter( (b, E) => E & 1))
      , p = e >>> 1;
    r[0] = a[0] + f[0],
    r[p] = a[0] - f[0],
    i[0] = l[0] + h[0],
    i[p] = l[0] - h[0];
    const [m,g] = Vf(p);
    for (let b = 1; b < p; ++b) {
        const E = m[b]
          , S = g[b]
          , F = f[b] * E - h[b] * S
          , B = f[b] * S + h[b] * E;
        r[b] = a[b] + F,
        i[b] = l[b] + B,
        r[b + p] = a[b] - F,
        i[b + p] = l[b] - B
    }
    return [r, i]
}
function dU(n, t) {
    const e = n.length;
    if (e !== Gm(e))
        throw new Error("Length must be a power of two.");
    if (t.length !== e)
        throw new Error("Must have an equal number of real and imaginary components");
    const r = new Float64Array(e);
    return e === 4 ? (r[0] = n[0] + n[1] + n[2] + n[3],
    r[1] = n[0] - t[1] - n[2] + t[3],
    r[2] = n[0] - n[1] + n[2] - n[3],
    r[3] = n[0] + t[1] - n[2] - t[3],
    r) : e === 2 ? (r[0] = n[0] + n[1],
    r[1] = n[0] - n[1],
    r) : e === 1 ? (r[0] = n[0],
    r) : IS(n, t)
}
Os.ifftReal = dU;
function IS(n, t) {
    const e = n.length
      , r = new Float64Array(e);
    if (e === 8) {
        const m = n[0] + n[2] + n[4] + n[6]
          , g = n[1] + n[3] + n[5] + n[7];
        r[0] = m + g,
        r[4] = m - g;
        const b = n[0] - t[2] - n[4] + t[6]
          , E = n[1] - t[3] - n[5] + t[7]
          , S = t[1] + n[3] - t[5] - n[7]
          , F = (E - S) * .7071067811865475;
        r[1] = b + F,
        r[5] = b - F;
        const B = n[0] - n[2] + n[4] - n[6]
          , Q = t[1] - t[3] + t[5] - t[7];
        r[2] = B - Q,
        r[6] = B + Q;
        const ae = n[0] + t[2] - n[4] - t[6]
          , V = n[1] + t[3] - n[5] - t[7]
          , k = t[1] - n[3] - t[5] + n[7]
          , z = (V + k) * .7071067811865475;
        return r[3] = ae - z,
        r[7] = ae + z,
        r
    }
    const i = IS(n.filter( (m, g) => !(g & 1)), t.filter( (m, g) => !(g & 1)))
      , [a,l] = am(n.filter( (m, g) => g & 1), t.filter( (m, g) => g & 1))
      , f = e >>> 1;
    r[0] = i[0] + a[0],
    r[f] = i[0] - a[0];
    const [h,p] = Vf(f);
    for (let m = 1; m < f; ++m) {
        const g = a[m] * h[m] - l[m] * p[m];
        r[m] = i[m] + g,
        r[m + f] = i[m] - g
    }
    return r
}
Object.defineProperty(tu, "__esModule", {
    value: !0
});
tu.conv = tu.padded64 = void 0;
const th = Os;
function hU(n) {
    const t = (0,
    th.ceilPow2)(n);
    return t === n ? new Float64Array(t * 2) : new Float64Array(t)
}
tu.padded64 = hU;
function pU(n, t) {
    const [e,r] = (0,
    th.fft)(n)
      , [i,a] = (0,
    th.fft)(t)
      , l = 1 / n.length;
    for (let f = n.length - 1; f >= 0; f--) {
        const h = e[f];
        e[f] = (e[f] * i[f] - r[f] * a[f]) * l,
        r[f] = (h * a[f] + r[f] * i[f]) * l
    }
    return (0,
    th.ifftReal)(e, r)
}
tu.conv = pU;
Object.defineProperty($a, "__esModule", {
    value: !0
});
$a.EntropyCalculator = $a.precalculateRatios = $a.harmonicEntropy = void 0;
const Ma = Ie
  , _l = tu;
function Y0(n, t) {
    var e, r, i, a, l, f;
    const h = (0,
    Ma.valueToCents)(((e = n.s) !== null && e !== void 0 ? e : .01) + 1);
    let p = (r = n.a) !== null && r !== void 0 ? r : 1;
    const m = (i = n.res) !== null && i !== void 0 ? i : 1
      , g = (a = n.series) !== null && a !== void 0 ? a : "tenney"
      , b = !!n.normalize;
    let E = (l = n.minCents) !== null && l !== void 0 ? l : 0
      , S = (f = n.maxCents) !== null && f !== void 0 ? f : 2400;
    const F = Math.ceil((S - E) / m) + 1
      , B = Math.ceil(100 * h / m)
      , Q = B * m;
    E -= Q,
    S += Q,
    p = p === 1 ? p = 1.0000000001 : p;
    let ae = 0;
    const V = Math.ceil((S - E) / m) + 1
      , k = (0,
    _l.padded64)(V)
      , z = (0,
    _l.padded64)(V);
    for (let P = t.length - 1; P >= 0; P--) {
        let J;
        const X = (0,
        Ma.valueToCents)(t[P][0] / t[P][1]);
        if (g === "tenney")
            J = Math.sqrt(t[P][0] * t[P][1]);
        else if (g === "farey")
            J = t[P][1];
        else
            throw new Error(`Unsupported series ${g}`);
        if (X < E || X > S)
            continue;
        ae++;
        let ie = (X - E) / m;
        const ce = Math.floor(ie);
        ie -= ce;
        const Le = 1 / J
          , he = Math.pow(J, -p);
        ie ? (k[ce] += Le * (1 - ie),
        k[ce + 1] += Le * ie,
        z[ce] += he * (1 - ie),
        z[ce + 1] += he * ie) : (k[ce] += Le,
        z[ce] += he)
    }
    const Z = (0,
    _l.padded64)(V)
      , re = (0,
    _l.padded64)(V);
    let C = 0;
    const D = -1 / (2 * h * h);
    for (let P = Z.length - 1; P >= 0; P--) {
        const J = P * m + E
          , X = 1 / (h * 2 * Math.PI) * Math.exp(Math.pow(J - E, 2) * D) + 1 / (h * 2 * Math.PI) * Math.exp(Math.pow(J - (Z.length * m + E), 2) * D);
        Z[P] = X,
        C += X
    }
    for (let P = Z.length - 1; P >= 0; P--)
        Z[P] /= C,
        re[P] = Math.pow(Z[P], p);
    const R = (0,
    _l.conv)(z, re)
      , W = (0,
    _l.conv)(k, Z);
    let I;
    b ? I = Math.log(ae) : I = 1;
    const N = new Array;
    for (let P = F - 1; P >= 0; P--) {
        const J = P + B
          , X = 1 / (1 - p) * Math.log(R[J] / Math.pow(W[J], p)) / I;
        N[P] = [J * m + E, X]
    }
    return N
}
$a.harmonicEntropy = Y0;
function Q0(n) {
    var t;
    const e = new Array;
    let r = n.N;
    const i = (t = n.series) !== null && t !== void 0 ? t : "tenney";
    if (i === "tenney") {
        r ?? (r = 1e4);
        do {
            const a = Math.floor(Math.sqrt(r));
            for (let l = 1; l <= a; l++) {
                const f = r / l;
                Number.isInteger(f) && (0,
                Ma.gcd)(l, f) === 1 && (e.push([l, f]),
                f !== l && e.push([f, l]))
            }
        } while (--r >= 0)
    } else if (i === "farey") {
        r ?? (r = 1e3);
        do
            for (let a = 0; a <= r; a++)
                (0,
                Ma.gcd)(a, r) === 1 && (e.push([r, a]),
                r !== a && e.push([a, r]));
        while (--r >= 0)
    }
    return e
}
$a.precalculateRatios = Q0;
class ay {
    constructor(t) {
        this.options_ = {
            ...t
        };
        const e = this.options_.series;
        e === void 0 || e === "tenney" || e === "farey" ? (this.ratios = Q0(this.options_),
        this.table = Y0(this.options_, this.ratios)) : this.table = []
    }
    static reviver(t, e) {
        if (typeof e == "object" && e !== null && e.type === "EntropyCalculator") {
            const r = e.options.series
              , i = {
                ...e.options
            };
            i.series = "__revived";
            const a = new ay(i);
            a.options_.series = r;
            const l = a.minCents
              , f = a.res;
            return a.table = e.tableY.map( (h, p) => [l + p * f, h]),
            a
        }
        return e
    }
    toJSON() {
        return {
            type: "EntropyCalculator",
            options: this.options_,
            tableY: this.table.map(t => t[1])
        }
    }
    recalculate() {
        this.ratios || (this.ratios = Q0(this.options_)),
        this.table = Y0(this.options_, this.ratios)
    }
    get options() {
        return {
            ...this.options_
        }
    }
    set options(t) {
        const e = this.N
          , r = this.series;
        this.options_ = {
            ...t
        },
        (this.N !== e || this.series !== r) && (this.ratios = void 0),
        this.recalculate()
    }
    get N() {
        return this.options_.N === void 0 ? this.series === "tenney" ? 1e4 : 1e3 : this.options_.N
    }
    set N(t) {
        this.options_.N = t,
        this.ratios = void 0,
        this.recalculate()
    }
    get s() {
        var t;
        return (t = this.options_.s) !== null && t !== void 0 ? t : .01
    }
    set s(t) {
        this.options_.s = t,
        this.recalculate()
    }
    get a() {
        var t;
        return (t = this.options_.a) !== null && t !== void 0 ? t : 1
    }
    set a(t) {
        this.options_.a = t,
        this.recalculate()
    }
    get series() {
        var t;
        return (t = this.options_.series) !== null && t !== void 0 ? t : "tenney"
    }
    set series(t) {
        this.options_.series = t,
        this.ratios = void 0,
        this.recalculate()
    }
    get minCents() {
        var t;
        return (t = this.options_.minCents) !== null && t !== void 0 ? t : 0
    }
    set minCents(t) {
        this.options_.minCents = t,
        this.recalculate()
    }
    get maxCents() {
        var t;
        return (t = this.options_.maxCents) !== null && t !== void 0 ? t : 2400
    }
    set maxCents(t) {
        this.options_.maxCents = t,
        this.recalculate()
    }
    get res() {
        var t;
        return (t = this.options_.res) !== null && t !== void 0 ? t : 1
    }
    set res(t) {
        this.options_.res = t,
        this.recalculate()
    }
    get normalize() {
        return !!this.options_.normalize
    }
    set normalize(t) {
        this.options_.normalize = t,
        this.recalculate()
    }
    ofFraction(t) {
        let e;
        return typeof t == "number" ? e = (0,
        Ma.valueToCents)(t) : e = (0,
        Ma.valueToCents)(new Ma.Fraction(t).valueOf()),
        this.ofCents(e)
    }
    ofCents(t) {
        if (isNaN(t))
            throw new Error("Invalid input");
        if (t = Math.abs(t),
        t < this.minCents || t > this.maxCents)
            throw new Error("Value out of tabulated range");
        let e = (t - this.minCents) / this.res;
        const r = Math.floor(e);
        return e -= r,
        e ? this.table[r][1] * (1 - e) + this.table[r + 1][1] * e : this.table[r][1]
    }
}
$a.EntropyCalculator = ay;
let Ll, xd = 0;
const mU = 0
  , Id = 6e3
  , Fd = .5
  , gU = "tenney"
  , vU = !0
  , FS = Ti("harmonic-entropy", () => {
    Ll === void 0 && (Ll = new aU);
    const n = Cr([])
      , t = te(1e4)
      , e = te(1)
      , r = te(.01)
      , i = Ve( () => Math.min(...n.map(p => p[1])))
      , a = Ve( () => Math.max(...n.map(p => p[1])));
    async function l(p=!1) {
        if (n.length && !p)
            return;
        const g = await (await fetch(oU)).arrayBuffer()
          , b = Array.from(new Float32Array(g));
        n.length = 0;
        let E = 0;
        for (let S = 0; S <= Id; S += Fd)
            n.push([S, b[E++]])
    }
    Ll.onmessage = p => {
        if (p.data.jobId === xd) {
            const m = p.data.json.tableY;
            n.length = 0;
            let g = 0;
            for (let b = 0; b <= Id; b += Fd)
                n.push([b, m[g++]])
        }
    }
    ;
    function f(p) {
        if (!n.length)
            return 0;
        if (p = Math.abs(p),
        p >= Id)
            return (n[n.length - 1][1] - i.value) / (a.value - i.value);
        let m = p / Fd;
        const g = Math.floor(m);
        return m -= g,
        (n[g][1] * (1 - m) + n[g + 1][1] * m - i.value) / (a.value - i.value)
    }
    Jt(t, nc(p => {
        const m = {
            ...h.value
        };
        m.N = p,
        Ll.postMessage({
            options: m,
            jobId: ++xd
        })
    }
    )),
    Jt(e, nc(p => {
        const m = {
            ...h.value
        };
        m.a = p,
        Ll.postMessage({
            options: m,
            jobId: ++xd
        })
    }
    )),
    Jt(r, nc(p => {
        const m = {
            ...h.value
        };
        m.s = p,
        Ll.postMessage({
            options: m,
            jobId: ++xd
        })
    }
    ));
    const h = Ve( () => ({
        N: t.value,
        a: e.value,
        s: r.value,
        minCents: mU,
        maxCents: Id,
        res: Fd,
        series: gU,
        normalize: vU
    }));
    return {
        table: n,
        N: t,
        a: e,
        s: r,
        minY: i,
        maxY: a,
        options: h,
        fetchTable: l,
        entropyPercentage: f
    }
}
)
  , o_ = 20
  , kv = 1e4
  , Rd = 1e-6;
function a_(n) {
    return [...Array(12).keys()].map(t => Hz[Ie.mmod(n + 1 + t, 12)])
}
function l_(n, t) {
    const e = [...Array(12).keys()].map(r => jz[Ie.mmod(n + 1 + r, 12)]);
    return t === "ASCII" ? e : e.map(r => r.replace("#", ""))
}
function Cf(n) {
    if (typeof n == "boolean" || n instanceof ut.Interval) {
        const r = FS().entropyPercentage(ut.relative.bind(this)(ut.upcastBool(n)).totalCents());
        return ut.Interval.fromValue(r)
    }
    const t = Cf.bind(this);
    return ut.unaryBroadcast.bind(this)(n, t)
}
Cf.__doc__ = "Compute the harmonic entropy as a percentage of the range of observed values.";
Cf.__node__ = ut.builtinNode(Cf);
const lu = Ti("scale", () => {
    const n = te(parseInt(localStorage.getItem("centsFractionDigits") ?? "3", 10))
      , t = te(parseInt(localStorage.getItem("decimalFractionDigits") ?? "5", 10))
      , e = te(localStorage.getItem("accidentalPreference") ?? "double")
      , r = te(localStorage.getItem("hasLeftOfZ") === "true")
      , i = te(parseInt(localStorage.getItem("gas") ?? "10000", 10))
      , a = te("")
      , l = te(60)
      , f = te(261.63)
      , h = te(!0)
      , p = Ve({
        get() {
            return h.value ? Ie.mtof(l.value) : f.value
        },
        set(_e) {
            f.value = _e
        }
    })
      , m = te(new Ca(JE,p.value,l.value,a.value))
      , g = te("silver")
      , b = te("")
      , E = te(El)
      , S = te(El)
      , F = te(void 0)
      , B = te(a_(l.value))
      , Q = te(l_(l.value, e.value))
      , ae = te("")
      , V = te("")
      , k = te(5)
      , z = te(1)
      , Z = te("isomorphic")
      , re = te(0)
      , C = te(0)
      , D = te("Asdf")
      , R = te("black")
      , W = te("maroon")
      , I = te("navy")
      , N = te("indigo")
      , P = te("000000000")
      , J = te("000000000")
      , X = Ve( () => {
        const _e = `numComponents(${Ps})
`
          , xe = Af(l.value);
        return h.value ? `${_e}${xe} = mtof(_) = 1/1` : `${_e}${xe} = baseFrequency = 1/1`
    }
    )
      , ie = Ve( () => m.value.getFrequencyRange(0, WE))
      , ce = Ve( () => m.value.getCentsRange(0, WE))
      , Le = Ve( () => {
        const _e = E.value
          , xe = [];
        e: for (let Ze = 0; Ze < _e.length; ++Ze) {
            for (const st of _e[Ze].trackingIds)
                if (st < 1) {
                    xe.push(-st);
                    continue e
                }
            xe.push(Ze)
        }
        return xe
    }
    )
      , he = Ve( () => {
        const _e = [];
        for (let xe = 0; xe < Le.value.length; ++xe)
            _e[Le.value[xe]] = xe;
        return _e
    }
    )
      , Fe = Ve( () => he.value.map(_e => Q.value[_e]))
      , Te = Ve( () => he.value.map(_e => B.value[_e]));
    function ye(_e) {
        return B.value[Ie.mmod(_e - l.value - 1, B.value.length)].toLowerCase()
    }
    function qe(_e) {
        return Q.value[Ie.mmod(_e - l.value - 1, Q.value.length)]
    }
    const Ge = Ve( () => {
        const _e = R.value.toLowerCase();
        let xe = l.value + C.value + m.value.size * re.value;
        if (D.value === "Asdf") {
            ye(xe - 1) === _e && xe--;
            const Ze = [];
            for (let je = xe; je < xe + 30; ++je)
                Ze.push(ye(je) === _e ? 1 : 2);
            const {indexByCode: st} = Ns.pianoMap(Ze);
            for (const [je,ct] of st)
                st.set(je, ct + xe);
            return st
        } else if (D.value === "QweZxc") {
            const Ze = [];
            r.value || (ye(xe - 1) === _e && xe--,
            Ze.push(3));
            for (let ct = xe; ct < xe + 30; ++ct)
                Ze.push(ye(ct) === _e ? 2 : 3);
            const {indexByCode: st} = Ns.pianoMap(Ze);
            r.value || xe--;
            for (const [ct,Et] of st)
                st.set(ct, Et + xe);
            xe = l.value + C.value + m.value.size * (re.value + 1),
            ye(xe - 1) === _e && xe--,
            Ze.length = 0;
            for (let ct = xe; ct < xe + 30; ++ct)
                Ze.push(ye(ct) === _e ? 0 : 1);
            const {indexByCode: je} = Ns.pianoMap(Ze);
            for (const [ct,Et] of je)
                st.set(ct, Et + xe);
            return st
        } else if (D.value === "Zxc") {
            const Ze = W.value.toLowerCase()
              , st = I.value.toLowerCase()
              , je = N.value.toLowerCase()
              , ct = [];
            r.value || ([Ze, st, je].includes(ye(xe - 1)) && xe--,
            ct.push(3));
            for (let It = xe; It < xe + 60; ++It) {
                const Bt = ye(It);
                Bt === Ze ? ct.push(2) : Bt === st ? ct.push(1) : Bt === je ? ct.push(0) : ct.push(3)
            }
            const {indexByCode: Et} = Ns.pianoMap(ct);
            r.value || xe--;
            for (const [It,Bt] of Et)
                Et.set(It, Bt + xe);
            return Et
        } else
            throw D.value,
            new Error(`Unknown piano mode ${D.value}`)
    }
    )
      , Se = Ve( () => D.value === "Zxc")
      , L = Ve( () => sU(l.value, B.value))
      , K = Ve( () => {
        const _e = ql.midiKeyInfo(l.value);
        return _e.whiteNumber === void 0 ? l.value - _e.sharpOf - 1 : l.value - _e.whiteNumber
    }
    )
      , de = Ve( () => {
        const _e = m.value.equaveRatio;
        return Math.abs(_e - 2) < Rd ? "octave" : Math.abs(_e - 3) < Rd ? "tritave" : Math.abs(_e - 4) < Rd ? "tetrave" : Math.abs(_e - 5) < Rd ? "pentave" : "equave"
    }
    );
    Jt(l, _e => {
        isNaN(_e) ? l.value = 60 : Math.round(_e) != _e && (l.value = Math.round(_e))
    }
    ),
    CS({
        centsFractionDigits: n,
        decimalFractionDigits: t,
        accidentalPreference: e,
        hasLeftOfZ: r,
        gas: i
    });
    function $e(_e) {
        const xe = this.currentScale;
        for (let st = 0; st < xe.length; ++st)
            xe[st] = xe[st].shallowClone(),
            xe[st].trackingIds.add(-st);
        const Ze = ut.relative.bind(this);
        S.value = xe.map(st => Ze(st)),
        F.value = _e
    }
    $e.__doc__ = "Store the current scale to be displayed in the lattice tab. Optionally with an explicit equave.",
    $e.__node__ = ut.builtinNode($e);
    function Re(..._e) {
        const xe = ut.repr.bind(this)
          , Ze = _e.map(st => typeof st == "string" ? st : xe(st)).join(", ");
        V.value = Ze.slice(0, kv)
    }
    Re.__doc__ = "Issue a warning to the user and continue execution.",
    Re.__node__ = ut.builtinNode(Re);
    function me() {
        const _e = ut.Interval.fromInteger(l.value)
          , xe = new ut.Interval(ut.TimeMonzo.fromFractionalFrequency(new Ie.Fraction(p.value).simplify(1e-8)),"linear")
          , Ze = {
            APP_TITLE: no,
            scaleName: a.value,
            _: _e,
            baseMidiNote: _e,
            baseFrequency: xe,
            latticeView: $e,
            warn: Re,
            harmonicEntropy: Cf
        }
          , st = ut.getGlobalVisitor(!0, Ze);
        st.rootContext.gas = i.value;
        const je = ut.parseAST(X.value);
        return st.executeProgram(je),
        st
    }
    function T() {
        P.value = qV()
    }
    function j() {
        const _e = me()
          , xe = new ut.StatementVisitor(_e);
        xe.isUserRoot = !0;
        const Ze = xe.rootContext.clone();
        Ze.gas = i.value;
        const st = ut.parseAST(b.value);
        return xe.executeProgram(st),
        {
            defaults: Ze,
            visitor: xe
        }
    }
    function ge(_e=!0) {
        try {
            ae.value = "",
            V.value = "",
            S.value = [],
            F.value = void 0;
            const xe = me()
              , Ze = new ut.StatementVisitor(xe);
            Ze.isUserRoot = !0;
            const st = ut.parseAST(b.value);
            Ze.executeProgram(st);
            let je = !1;
            for (const Nt of st.body)
                if (Nt.type === "PitchDeclaration") {
                    je = !0;
                    break
                }
            const ct = Ze.currentScale
              , Et = Ze.createExpressionVisitor()
              , It = ut.relative.bind(Et);
            E.value = ct.map(Nt => It(Nt)),
            S.value.length || (S.value = E.value);
            const Bt = E.value.map(Nt => Nt.value.valueOf());
            let yn = Ie.mtof(l.value);
            if (Ze.rootContext.unisonFrequency && (yn = Ze.rootContext.unisonFrequency.valueOf()),
            Bt.length) {
                let Nt = function(Lt) {
                    if (Lt.label.length)
                        return t_(Lt.label, e.value);
                    if (Lt = Lt.shallowClone(),
                    Lt.node = Lt.realizeNode(Et.rootContext),
                    !Lt.node && Lt.value instanceof ut.TimeReal && !Lt.value.timeExponent) {
                        let pe = "";
                        if (Lt.domain === "linear" ? pe = OV(Lt.valueOf(), t.value, !0) : pe = AS(Lt.totalCents(), n.value, !0),
                        pe.length <= o_)
                            return pe
                    }
                    return t_(xt(Lt, o_), e.value)
                };
                const xt = ut.lstr.bind(Et);
                m.value = new Ca(Bt,yn,l.value,Et.rootContext.title || a.value),
                g.value === "silver" ? B.value = ct.map( (Lt, pe) => {
                    var Pe;
                    return ((Pe = Lt.color) == null ? void 0 : Pe.value) ?? (pe === ct.length - 1 ? "gray" : "silver")
                }
                ) : g.value === "cents" ? B.value = ct.map(Lt => {
                    var pe;
                    return ((pe = Lt.color) == null ? void 0 : pe.value) ?? ut.centsColor.bind(Et)(Lt).value
                }
                ) : B.value = ct.map(Lt => {
                    var pe;
                    return ((pe = Lt.color) == null ? void 0 : pe.value) ?? ut.factorColor.bind(Et)(Lt).value
                }
                ),
                Q.value = ct.map(Nt)
            } else
                E.value = El,
                S.value = El,
                m.value = new Ca(JE,yn,l.value,a.value),
                g.value === "silver" ? B.value = a_(l.value) : g.value === "cents" ? B.value = El.map(Nt => {
                    var xt;
                    return ((xt = Nt.color) == null ? void 0 : xt.value) ?? ut.centsColor.bind(Et)(Nt).value
                }
                ) : B.value = El.map(Nt => {
                    var xt;
                    return ((xt = Nt.color) == null ? void 0 : xt.value) ?? ut.factorColor.bind(Et)(Nt).value
                }
                ),
                Q.value = l_(l.value, e.value),
                V.value || (V.value = "Empty scale defaults to 12-tone equal temperament.");
            const qt = l.value;
            if (!V.value && PV(qt) && !je) {
                const Nt = Af(qt)
                  , xt = FV(qt)
                  , Lt = h.value ? "mtof(_)" : "baseFrequency";
                V.value = `Base MIDI note ${qt} defaults to ${Nt}. Use an explicit ${xt[0]} = ${Lt} or ${xt[1]} = ${Lt} to get rid of this warning.`
            }
            _e && at.pushState()
        } catch (xe) {
            xe instanceof Error ? ae.value = xe.message.slice(0, kv) : typeof xe == "string" && (ae.value = xe.slice(0, kv))
        }
    }
    function Me(_e) {
        return _e >= 0 && _e < ie.value.length ? ie.value[_e] : m.value.getFrequency(_e)
    }
    const Oe = {
        name: a,
        baseMidiNote: l,
        userBaseFrequency: f,
        autoFrequency: h,
        autoColors: g,
        sourceText: b,
        scale: m,
        relativeIntervals: E,
        latticeIntervals: S,
        latticeEquave: F,
        colors: B,
        labels: Q,
        error: ae,
        warning: V,
        isomorphicVertical: k,
        isomorphicHorizontal: z,
        keyboardMode: Z,
        equaveShift: re,
        degreeShift: C,
        pianoMode: D,
        accidentalColor: R,
        lowAccidentalColor: W,
        middleAccidentalColor: I,
        highAccidentalColor: N
    };
    let Be = !1;
    Jt(Object.values(Oe), () => {
        if (Be) {
            Be = !1;
            return
        }
        J.value === P.value && T()
    }
    );
    function ze() {
        let _e = m.value
          , xe = E.value
          , Ze = B.value
          , st = Q.value;
        if (_e.intervalRatios.length > wl) {
            _e = _e.clone(),
            xe = [...xe],
            Ze = [...Ze],
            st = [...st];
            const ct = _e.intervalRatios.pop()
              , Et = xe.pop()
              , It = Ze.pop()
              , Bt = st.pop();
            _e.intervalRatios = _e.intervalRatios.slice(0, wl - 1),
            _e.intervalRatios.push(ct),
            xe = xe.slice(0, wl - 1),
            xe.push(Et),
            Ze = Ze.slice(0, wl - 1),
            Ze.push(It),
            st = st.slice(0, wl - 1),
            st.push(Bt)
        }
        const je = {
            scale: _e.toJSON(),
            relativeIntervals: xe.map(ct => ct.toJSON()),
            colors: Ze,
            labels: st
        };
        je.colors.length && (je.colors[je.colors.length - 1] = B.value[B.value.length - 1]),
        je.labels.length && (je.labels[je.labels.length - 1] = Q.value[Q.value.length - 1]),
        E.value === S.value ? je.latticeIntervals = null : S.value.length <= wl ? je.latticeIntervals = S.value.map(ct => ct.toJSON()) : je.latticeIntervals = null;
        for (const [ct,Et] of Object.entries(Oe))
            ct in je || (je[ct] = Et.value);
        return je
    }
    function Ye(_e) {
        Be = !0;
        for (const xe in Oe)
            xe === "latticeIntervals" && !_e[xe] ? S.value = _e.relativeIntervals : Oe[xe].value = _e[xe];
        P.value = _e.id,
        J.value = _e.id,
        at.pushState(),
        at.truncate()
    }
    function He() {
        return b.value
    }
    function Ue(_e) {
        b.value = _e,
        ge(!1)
    }
    const at = iU(He, Ue);
    function rt() {
        const _e = me()
          , xe = new ut.StatementVisitor(_e);
        xe.isUserRoot = !0;
        const Ze = ut.parseAST(b.value);
        return xe.executeProgram(Ze),
        {
            rawIntervals: xe.currentScale,
            unisonFrequency: xe.rootContext.unisonFrequency
        }
    }
    return {
        ...Oe,
        id: P,
        uploadedId: J,
        centsFractionDigits: n,
        decimalFractionDigits: t,
        accidentalPreference: e,
        hasLeftOfZ: r,
        gas: i,
        baseFrequencyDisplay: p,
        sourcePrefix: X,
        latticePermutation: Le,
        inverseLatticePermutation: he,
        latticeColors: Te,
        latticeLabels: Fe,
        frequencies: ie,
        centss: ce,
        qwertyMapping: Ge,
        splitAccidentals: Se,
        whiteIndices: L,
        whiteModeOffset: K,
        nameOfEquave: de,
        rerollId: T,
        getUserScopeVisitor: j,
        computeScale: ge,
        getFrequency: Me,
        colorForIndex: ye,
        labelForIndex: qe,
        toJSON: ze,
        fromJSON: Ye,
        computeRawScale: rt,
        history: at
    }
}
)
  , yU = {
    id: "app-navigation"
}
  , bU = {
    id: "app-tabs"
}
  , wU = {
    key: 0
}
  , EU = {
    key: 1
}
  , _U = {
    id: "app-tray",
    class: "hidden-sm"
}
  , LU = {
    key: 0,
    title: "Type on your computer keyboard to hear the synth"
}
  , SU = {
    key: 1,
    title: "Synth will not respond to keypresses until you click outside the input field"
}
  , AU = {
    id: "app-footer"
}
  , CU = gs({
    __name: "App",
    setup(n) {
        const t = oy()
          , e = lu()
          , r = rU()
          , i = xS()
          , a = FS();
        function l(C) {
            return C.pathname.slice(1)
        }
        const f = U7();
        function h(C) {
            t.heldNotes.set(C, (t.heldNotes.get(C) ?? 0) + 1)
        }
        function p(C) {
            t.heldNotes.set(C, Math.max(0, (t.heldNotes.get(C) ?? 0) - 1))
        }
        const m = Ve( () => new ql.MidiOut(r.output,r.outputChannels));
        function g(C, D) {
            C = Ie.clamp(-24e3, 24e3, C),
            isNaN(C) && (C = 0);
            const R = m.value.sendNoteOn(C, D);
            if (i.synth === null || i.virtualSynth === null)
                return R;
            const W = i.synth.noteOn(C, D / 127)
              , I = i.virtualSynth.voiceOn(C);
            return P => {
                R(P),
                W(),
                I()
            }
        }
        function b(C, D, R) {
            const W = r.multichannelToEquave;
            if (W && R !== void 0) {
                let ie = Ie.mmod(R - r.multichannelCenter + r.multichannelEquavesDown, r.multichannelNumEquaves) - r.multichannelEquavesDown;
                ie = ie * e.scale.size,
                C = C + ie
            }
            D === void 0 && (D = 80),
            r.velocityOn || (D = 80);
            let I = e.getFrequency(C);
            const N = ql.midiKeyInfo(C)
              , P = r.whiteMode
              , J = e.whiteIndices;
            if (P === "off" || W ? h(C) : P === "simple" ? N.whiteNumber === void 0 ? I = NaN : (N.whiteNumber += e.whiteModeOffset,
            I = e.getFrequency(N.whiteNumber),
            h(N.whiteNumber)) : P === "blackAverage" ? N.whiteNumber === void 0 ? (N.flatOf += e.whiteModeOffset,
            N.sharpOf += e.whiteModeOffset,
            I = Math.sqrt(e.getFrequency(N.flatOf) * e.getFrequency(N.sharpOf)),
            h(N.flatOf),
            h(N.sharpOf)) : (N.whiteNumber += e.whiteModeOffset,
            I = e.getFrequency(N.whiteNumber),
            h(N.whiteNumber)) : P === "keyColors" && (J.length ? N.whiteNumber === void 0 ? (C = J[N.sharpOf] + 1,
            C === J[N.sharpOf + 1] ? I = NaN : (I = e.getFrequency(C),
            h(C))) : (C = J[N.whiteNumber],
            I = e.getFrequency(C),
            h(C)) : I = NaN),
            isNaN(I))
                return ie => {}
                ;
            const X = g(I, D);
            return ie => {
                ie === void 0 && (ie = 80),
                r.velocityOn || (ie = 80),
                P === "off" || P === "keyColors" || W ? p(C) : P === "simple" ? N.whiteNumber !== void 0 && p(N.whiteNumber) : P === "blackAverage" && (N.whiteNumber === void 0 ? (p(N.flatOf),
                p(N.sharpOf)) : p(N.whiteNumber)),
                X(ie)
            }
        }
        const E = Cr(new Set([1]))
          , S = new ql.MidiIn(b,E)
          , F = ["noteon", "noteoff", "pitchbend"];
        Jt( () => r.input, (C, D) => {
            D !== null && S.unlisten(D),
            C !== null && (S.listen(C),
            C.addListener("midimessage", R => {
                if (!F.includes(R.message.type) && r.output !== null)
                    if (R.message.isChannelMessage) {
                        if (E.has(R.message.channel)) {
                            const W = R.message.statusByte & 240;
                            for (const I of r.outputChannels) {
                                const N = [...R.message.data];
                                N[0] = W | I - 1,
                                r.output.send(N)
                            }
                        }
                    } else
                        r.output.send(R.message)
            }
            ))
        }
        );
        function B(C) {
            h(C);
            const D = g(e.getFrequency(C), 80);
            function R() {
                return p(C),
                D(80)
            }
            return R
        }
        function Q(C) {
            setTimeout( () => i.initialize(), 1);
            const D = C.target;
            if (D instanceof HTMLInputElement && ["range", "radio", "checkbox"].includes(D.type)) {
                t.typingActive = !0;
                return
            }
            D instanceof HTMLTextAreaElement || D instanceof HTMLInputElement || D instanceof HTMLSelectElement ? t.typingActive = !1 : t.typingActive = !0
        }
        function ae(C) {
            if (t.typingActive && !C.ctrlKey) {
                {
                    if (C.altKey || C.metaKey)
                        return;
                    ([t.deactivationCode, t.equaveUpCode, t.equaveDownCode, t.degreeUpCode, t.degreeDownCode].includes(C.code) || Ns.COORDS_BY_CODE.has(C.code) && Ns.COORDS_BY_CODE.get(C.code)[2] === 1 || C.key === "/") && C.preventDefault()
                }
                if (C.code === t.deactivationCode) {
                    k.deactivate();
                    return
                }
                if (C.code === t.equaveUpCode) {
                    e.equaveShift++;
                    return
                }
                if (C.code === t.equaveDownCode) {
                    e.equaveShift--;
                    return
                }
                if (C.code === t.degreeUpCode) {
                    e.degreeShift++;
                    return
                }
                if (C.code === t.degreeDownCode) {
                    e.degreeShift--;
                    return
                }
                k.keydown(C)
            }
        }
        function V(C) {
            k.keyup(C)
        }
        const k = new Ns.Keyboard;
        function z() {}
        function Z(C) {
            if (C.coordinates === void 0)
                return z;
            const [D,R,W] = C.coordinates;
            if (W !== 1)
                return z;
            let I = e.scale.baseMidiNote + e.scale.size * e.equaveShift + e.degreeShift;
            if (e.keyboardMode === "isomorphic")
                I += D * e.isomorphicHorizontal + (2 - R) * e.isomorphicVertical;
            else if (e.qwertyMapping.has(C.code))
                I = e.qwertyMapping.get(C.code);
            else
                return z;
            return B(I)
        }
        If(async () => {
            window.addEventListener("keyup", V),
            window.addEventListener("keydown", Q),
            window.addEventListener("keyup", Q),
            window.addEventListener("mousedown", Q),
            window.addEventListener("keydown", ae),
            window.addEventListener("touchstart", i.initialize),
            k.addKeydownListener(Z);
            const C = new URL(window.location.href)
              , D = C.searchParams;
            if (ut.setNumberOfComponents(Ps),
            ![...D.keys()].length)
                await f.push({
                    path: l(C),
                    query: {
                        version: tc
                    }
                });
            else if (D.has("version")) {
                if (D.get("version").startsWith("2."))
                    try {
                        const R = SV(D);
                        i.initialize();
                        let W = "Asdf";
                        (R.pianoMode === "QweZxc0" || R.pianoMode === "QweZxc1") && (W = "QweZxc"),
                        e.name = R.scaleName,
                        e.userBaseFrequency = R.baseFrequency,
                        e.autoFrequency = !1,
                        e.baseMidiNote = R.baseMidiNote,
                        e.isomorphicHorizontal = R.isomorphicHorizontal,
                        e.isomorphicVertical = R.isomorphicVertical,
                        e.keyboardMode = R.keyboardMode,
                        e.pianoMode = W,
                        e.equaveShift = R.equaveShift,
                        e.degreeShift = R.degreeShift,
                        i.waveform = R.waveform,
                        i.attackTime = R.attackTime,
                        i.decayTime = R.decayTime,
                        i.sustainLevel = R.sustainLevel,
                        i.releaseTime = R.releaseTime,
                        i.pingPongDelayTime = R.pingPongDelayTime,
                        i.pingPongFeedback = R.pingPongFeedback,
                        i.pingPongSeparation = R.pingPongSeparation,
                        i.pingPongGain = R.pingPongGain;
                        const I = []
                          , N = [];
                        for (let P = 0; P < R.scaleLines.length; ++P) {
                            const J = R.scaleLines[P];
                            try {
                                const X = ut.parseScaleWorkshop2Line(J, Ps).toString();
                                I.push(X)
                            } catch {
                                N.push([J, P])
                            }
                        }
                        n_(I, R.keyColors);
                        for (const [P,J] of N)
                            P.trim().length ? I.splice(J, 0, "(* " + P.replaceAll("(*", "(").replaceAll("*)", ")") + " *)") : I.splice(J, 0, "");
                        e.sourceText = I.join(`
`),
                        e.computeScale(),
                        e.history.truncate(),
                        await f.push({
                            path: l(C),
                            query: {
                                version: tc
                            }
                        })
                    } catch (R) {
                        console.error(`Error parsing version ${D.get("version")} URL`, R)
                    }
            } else
                try {
                    const R = new Zz;
                    if (i.initialize(),
                    e.name = R.name,
                    e.userBaseFrequency = R.freq,
                    e.autoFrequency = !1,
                    e.baseMidiNote = R.midi,
                    e.isomorphicHorizontal = R.horizontal,
                    e.isomorphicVertical = R.vertical,
                    R.data !== void 0) {
                        const W = R.colors ?? ""
                          , N = R.parseTuningData().map(P => P.toString());
                        n_(N, W.split(" ")),
                        e.sourceText = N.join(`
`),
                        e.computeScale(),
                        e.history.truncate()
                    }
                    i.waveform = R.waveform || "semisine",
                    i.attackTime = R.attackTime,
                    i.decayTime = R.decayTime,
                    i.sustainLevel = R.sustainLevel,
                    i.releaseTime = R.releaseTime,
                    await f.push({
                        path: l(C),
                        query: {
                            version: tc
                        }
                    })
                } catch (R) {
                    console.error("Error parsing version 1 URL", R)
                }
            await a.fetchTable()
        }
        ),
        Sm( () => {
            window.removeEventListener("keydown", ae),
            window.removeEventListener("keyup", V),
            window.removeEventListener("keydown", Q),
            window.removeEventListener("keyup", Q),
            window.removeEventListener("mousedown", Q),
            window.removeEventListener("touchstart", i.initialize),
            k.removeEventListener(Z),
            r.input !== null && r.input.removeListener(),
            i.unintialize()
        }
        );
        function re() {
            console.log("Firing global key off."),
            k.deactivate(),
            S.deactivate(),
            r.output !== null && r.output.sendAllNotesOff({
                channels: [...r.outputChannels]
            }),
            i.synth !== null && i.synth.allNotesOff()
        }
        return (C, D) => (gt(),
        Fn(Jn, null, [se("nav", yU, [se("ul", bU, [se("li", null, [jt(Ee(cs), {
            to: "/about"
        }, {
            default: Wr( () => D[0] || (D[0] = [se("strong", null, "Sw", -1)])),
            _: 1
        })]), se("li", null, [jt(Ee(cs), {
            to: "/"
        }, {
            default: Wr( () => D[1] || (D[1] = [dr("Build Scale")])),
            _: 1
        })]), Ee(t).showMosTab ? (gt(),
        Fn("li", wU, [jt(Ee(cs), {
            to: "/mos"
        }, {
            default: Wr( () => D[2] || (D[2] = [dr("MOS")])),
            _: 1
        })])) : Kt("", !0), se("li", null, [jt(Ee(cs), {
            to: "/analysis"
        }, {
            default: Wr( () => D[3] || (D[3] = [dr("Analysis")])),
            _: 1
        })]), se("li", null, [jt(Ee(cs), {
            to: "/lattice"
        }, {
            default: Wr( () => D[4] || (D[4] = [dr("Lattice")])),
            _: 1
        })]), se("li", null, [jt(Ee(cs), {
            to: "/vk"
        }, {
            default: Wr( () => D[5] || (D[5] = [dr("Virtual Keyboard")])),
            _: 1
        })]), Ee(t).showVirtualQwerty ? (gt(),
        Fn("li", EU, [jt(Ee(cs), {
            to: "/qwerty"
        }, {
            default: Wr( () => D[6] || (D[6] = [dr("Virtual QWERTY")])),
            _: 1
        })])) : Kt("", !0), se("li", null, [jt(Ee(cs), {
            to: "/synth"
        }, {
            default: Wr( () => D[7] || (D[7] = [dr("Synth")])),
            _: 1
        })]), se("li", null, [jt(Ee(cs), {
            to: "/midi"
        }, {
            default: Wr( () => D[8] || (D[8] = [dr("MIDI I/O")])),
            _: 1
        })]), se("li", null, [jt(Ee(cs), {
            to: "/prefs"
        }, {
            default: Wr( () => D[9] || (D[9] = [dr("Preferences")])),
            _: 1
        })])]), se("div", _U, [se("ul", null, [Ee(t).typingActive ? (gt(),
        Fn("li", LU, D[10] || (D[10] = [se("span", {
            class: "typing-info active"
        }, "Key", -1)]))) : (gt(),
        Fn("li", SU, D[11] || (D[11] = [se("span", {
            class: "typing-info"
        }, "Key", -1)])))])])]), jt(Ee(b2), {
            noteOn: B,
            midiInputChannels: E,
            typingKeyboard: Ee(k),
            onPanic: re
        }, null, 8, ["midiInputChannels", "typingKeyboard"]), se("footer", AU, [jt(Ee(cs), {
            to: "/privacy-policy"
        }, {
            default: Wr( () => D[12] || (D[12] = [dr("Privacy policy")])),
            _: 1
        }), D[14] || (D[14] = dr(", ")), jt(Ee(cs), {
            to: "/terms-of-service"
        }, {
            default: Wr( () => D[13] || (D[13] = [dr("Terms of service")])),
            _: 1
        })])], 64))
    }
});
const $U = "modulepreload"
  , MU = function(n) {
    return "/" + n
}
  , u_ = {}
  , Pt = function(t, e, r) {
    if (!e || e.length === 0)
        return t();
    const i = document.getElementsByTagName("link");
    return Promise.all(e.map(a => {
        if (a = MU(a),
        a in u_)
            return;
        u_[a] = !0;
        const l = a.endsWith(".css")
          , f = l ? '[rel="stylesheet"]' : "";
        if (!!r)
            for (let m = i.length - 1; m >= 0; m--) {
                const g = i[m];
                if (g.href === a && (!l || g.rel === "stylesheet"))
                    return
            }
        else if (document.querySelector(`link[href="${a}"]${f}`))
            return;
        const p = document.createElement("link");
        if (p.rel = l ? "stylesheet" : $U,
        l || (p.as = "script",
        p.crossOrigin = ""),
        p.href = a,
        document.head.appendChild(p),
        l)
            return new Promise( (m, g) => {
                p.addEventListener("load", m),
                p.addEventListener("error", () => g(new Error(`Unable to preload CSS for ${a}`)))
            }
            )
    }
    )).then( () => t()).catch(a => {
        const l = new Event("vite:preloadError",{
            cancelable: !0
        });
        if (l.payload = a,
        window.dispatchEvent(l),
        !l.defaultPrevented)
            throw a
    }
    )
};
var OU = Error
  , NU = EvalError
  , TU = RangeError
  , xU = ReferenceError
  , RS = SyntaxError
  , Uf = TypeError
  , IU = URIError
  , FU = Object.getOwnPropertyDescriptor
  , nh = FU;
if (nh)
    try {
        nh([], "length")
    } catch {
        nh = null
    }
var Wm = nh
  , rh = Object.defineProperty || !1;
if (rh)
    try {
        rh({}, "a", {
            value: 1
        })
    } catch {
        rh = !1
    }
var Jm = rh, zv, c_;
function RU() {
    return c_ || (c_ = 1,
    zv = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
            return !1;
        if (typeof Symbol.iterator == "symbol")
            return !0;
        var t = {}
          , e = Symbol("test")
          , r = Object(e);
        if (typeof e == "string" || Object.prototype.toString.call(e) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
            return !1;
        var i = 42;
        t[e] = i;
        for (var a in t)
            return !1;
        if (typeof Object.keys == "function" && Object.keys(t).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(t).length !== 0)
            return !1;
        var l = Object.getOwnPropertySymbols(t);
        if (l.length !== 1 || l[0] !== e || !Object.prototype.propertyIsEnumerable.call(t, e))
            return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
            var f = Object.getOwnPropertyDescriptor(t, e);
            if (f.value !== i || f.enumerable !== !0)
                return !1
        }
        return !0
    }
    ),
    zv
}
var Vv, f_;
function PU() {
    if (f_)
        return Vv;
    f_ = 1;
    var n = typeof Symbol < "u" && Symbol
      , t = RU();
    return Vv = function() {
        return typeof n != "function" || typeof Symbol != "function" || typeof n("foo") != "symbol" || typeof Symbol("bar") != "symbol" ? !1 : t()
    }
    ,
    Vv
}
var Uv, d_;
function DU() {
    if (d_)
        return Uv;
    d_ = 1;
    var n = "Function.prototype.bind called on incompatible "
      , t = Object.prototype.toString
      , e = Math.max
      , r = "[object Function]"
      , i = function(h, p) {
        for (var m = [], g = 0; g < h.length; g += 1)
            m[g] = h[g];
        for (var b = 0; b < p.length; b += 1)
            m[b + h.length] = p[b];
        return m
    }
      , a = function(h, p) {
        for (var m = [], g = p || 0, b = 0; g < h.length; g += 1,
        b += 1)
            m[b] = h[g];
        return m
    }
      , l = function(f, h) {
        for (var p = "", m = 0; m < f.length; m += 1)
            p += f[m],
            m + 1 < f.length && (p += h);
        return p
    };
    return Uv = function(h) {
        var p = this;
        if (typeof p != "function" || t.apply(p) !== r)
            throw new TypeError(n + p);
        for (var m = a(arguments, 1), g, b = function() {
            if (this instanceof g) {
                var Q = p.apply(this, i(m, arguments));
                return Object(Q) === Q ? Q : this
            }
            return p.apply(h, i(m, arguments))
        }, E = e(0, p.length - m.length), S = [], F = 0; F < E; F++)
            S[F] = "$" + F;
        if (g = Function("binder", "return function (" + l(S, ",") + "){ return binder.apply(this,arguments); }")(b),
        p.prototype) {
            var B = function() {};
            B.prototype = p.prototype,
            g.prototype = new B,
            B.prototype = null
        }
        return g
    }
    ,
    Uv
}
var jv, h_;
function jf() {
    if (h_)
        return jv;
    h_ = 1;
    var n = DU();
    return jv = Function.prototype.bind || n,
    jv
}
var Hv, p_;
function ly() {
    return p_ || (p_ = 1,
    Hv = Function.prototype.call),
    Hv
}
var Gv, m_;
function uy() {
    return m_ || (m_ = 1,
    Gv = Function.prototype.apply),
    Gv
}
var qU = typeof Reflect == "function" && Reflect.apply, BU = jf(), kU = uy(), zU = ly(), VU = qU, PS = VU || BU.call(zU, kU), UU = jf(), jU = Uf, HU = ly(), GU = PS, DS = function(t) {
    if (t.length < 1 || typeof t[0] != "function")
        throw new jU("a function is required");
    return GU(UU, HU, t)
}, Wv, g_;
function WU() {
    if (g_)
        return Wv;
    g_ = 1;
    var n = DS
      , t = Wm
      , e = [].__proto__ === Array.prototype
      , r = e && t && t(Object.prototype, "__proto__")
      , i = Object
      , a = i.getPrototypeOf;
    return Wv = r && typeof r.get == "function" ? n([r.get]) : typeof a == "function" ? function(f) {
        return a(f == null ? f : i(f))
    }
    : !1,
    Wv
}
var Jv, v_;
function JU() {
    if (v_)
        return Jv;
    v_ = 1;
    var n = Function.prototype.call
      , t = Object.prototype.hasOwnProperty
      , e = jf();
    return Jv = e.call(n, t),
    Jv
}
var rn, KU = OU, ZU = NU, YU = TU, QU = xU, nu = RS, Bl = Uf, XU = IU, qS = Function, Kv = function(n) {
    try {
        return qS('"use strict"; return (' + n + ").constructor;")()
    } catch {}
}, $f = Wm, ej = Jm, Zv = function() {
    throw new Bl
}, tj = $f ? function() {
    try {
        return arguments.callee,
        Zv
    } catch {
        try {
            return $f(arguments, "callee").get
        } catch {
            return Zv
        }
    }
}() : Zv, Sl = PU()(), nj = WU(), br = typeof Reflect == "function" && Reflect.getPrototypeOf || Object.getPrototypeOf || nj, BS = uy(), Hf = ly(), Ol = {}, rj = typeof Uint8Array > "u" || !br ? rn : br(Uint8Array), Oa = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError > "u" ? rn : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer > "u" ? rn : ArrayBuffer,
    "%ArrayIteratorPrototype%": Sl && br ? br([][Symbol.iterator]()) : rn,
    "%AsyncFromSyncIteratorPrototype%": rn,
    "%AsyncFunction%": Ol,
    "%AsyncGenerator%": Ol,
    "%AsyncGeneratorFunction%": Ol,
    "%AsyncIteratorPrototype%": Ol,
    "%Atomics%": typeof Atomics > "u" ? rn : Atomics,
    "%BigInt%": typeof BigInt > "u" ? rn : BigInt,
    "%BigInt64Array%": typeof BigInt64Array > "u" ? rn : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array > "u" ? rn : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView > "u" ? rn : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": KU,
    "%eval%": eval,
    "%EvalError%": ZU,
    "%Float32Array%": typeof Float32Array > "u" ? rn : Float32Array,
    "%Float64Array%": typeof Float64Array > "u" ? rn : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry > "u" ? rn : FinalizationRegistry,
    "%Function%": qS,
    "%GeneratorFunction%": Ol,
    "%Int8Array%": typeof Int8Array > "u" ? rn : Int8Array,
    "%Int16Array%": typeof Int16Array > "u" ? rn : Int16Array,
    "%Int32Array%": typeof Int32Array > "u" ? rn : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": Sl && br ? br(br([][Symbol.iterator]())) : rn,
    "%JSON%": typeof JSON == "object" ? JSON : rn,
    "%Map%": typeof Map > "u" ? rn : Map,
    "%MapIteratorPrototype%": typeof Map > "u" || !Sl || !br ? rn : br(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%Object.getOwnPropertyDescriptor%": $f,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise > "u" ? rn : Promise,
    "%Proxy%": typeof Proxy > "u" ? rn : Proxy,
    "%RangeError%": YU,
    "%ReferenceError%": QU,
    "%Reflect%": typeof Reflect > "u" ? rn : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set > "u" ? rn : Set,
    "%SetIteratorPrototype%": typeof Set > "u" || !Sl || !br ? rn : br(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? rn : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": Sl && br ? br(""[Symbol.iterator]()) : rn,
    "%Symbol%": Sl ? Symbol : rn,
    "%SyntaxError%": nu,
    "%ThrowTypeError%": tj,
    "%TypedArray%": rj,
    "%TypeError%": Bl,
    "%Uint8Array%": typeof Uint8Array > "u" ? rn : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? rn : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array > "u" ? rn : Uint16Array,
    "%Uint32Array%": typeof Uint32Array > "u" ? rn : Uint32Array,
    "%URIError%": XU,
    "%WeakMap%": typeof WeakMap > "u" ? rn : WeakMap,
    "%WeakRef%": typeof WeakRef > "u" ? rn : WeakRef,
    "%WeakSet%": typeof WeakSet > "u" ? rn : WeakSet,
    "%Function.prototype.call%": Hf,
    "%Function.prototype.apply%": BS,
    "%Object.defineProperty%": ej
};
if (br)
    try {
        null.error
    } catch (n) {
        var sj = br(br(n));
        Oa["%Error.prototype%"] = sj
    }
var ij = function n(t) {
    var e;
    if (t === "%AsyncFunction%")
        e = Kv("async function () {}");
    else if (t === "%GeneratorFunction%")
        e = Kv("function* () {}");
    else if (t === "%AsyncGeneratorFunction%")
        e = Kv("async function* () {}");
    else if (t === "%AsyncGenerator%") {
        var r = n("%AsyncGeneratorFunction%");
        r && (e = r.prototype)
    } else if (t === "%AsyncIteratorPrototype%") {
        var i = n("%AsyncGenerator%");
        i && br && (e = br(i.prototype))
    }
    return Oa[t] = e,
    e
}
  , y_ = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
}
  , Gf = jf()
  , lm = JU()
  , oj = Gf.call(Hf, Array.prototype.concat)
  , aj = Gf.call(BS, Array.prototype.splice)
  , b_ = Gf.call(Hf, String.prototype.replace)
  , um = Gf.call(Hf, String.prototype.slice)
  , lj = Gf.call(Hf, RegExp.prototype.exec)
  , uj = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g
  , cj = /\\(\\)?/g
  , fj = function(t) {
    var e = um(t, 0, 1)
      , r = um(t, -1);
    if (e === "%" && r !== "%")
        throw new nu("invalid intrinsic syntax, expected closing `%`");
    if (r === "%" && e !== "%")
        throw new nu("invalid intrinsic syntax, expected opening `%`");
    var i = [];
    return b_(t, uj, function(a, l, f, h) {
        i[i.length] = f ? b_(h, cj, "$1") : l || a
    }),
    i
}
  , dj = function(t, e) {
    var r = t, i;
    if (lm(y_, r) && (i = y_[r],
    r = "%" + i[0] + "%"),
    lm(Oa, r)) {
        var a = Oa[r];
        if (a === Ol && (a = ij(r)),
        typeof a > "u" && !e)
            throw new Bl("intrinsic " + t + " exists, but is not available. Please file an issue!");
        return {
            alias: i,
            name: r,
            value: a
        }
    }
    throw new nu("intrinsic " + t + " does not exist!")
}
  , cy = function(t, e) {
    if (typeof t != "string" || t.length === 0)
        throw new Bl("intrinsic name must be a non-empty string");
    if (arguments.length > 1 && typeof e != "boolean")
        throw new Bl('"allowMissing" argument must be a boolean');
    if (lj(/^%?[^%]*%?$/, t) === null)
        throw new nu("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    var r = fj(t)
      , i = r.length > 0 ? r[0] : ""
      , a = dj("%" + i + "%", e)
      , l = a.name
      , f = a.value
      , h = !1
      , p = a.alias;
    p && (i = p[0],
    aj(r, oj([0, 1], p)));
    for (var m = 1, g = !0; m < r.length; m += 1) {
        var b = r[m]
          , E = um(b, 0, 1)
          , S = um(b, -1);
        if ((E === '"' || E === "'" || E === "`" || S === '"' || S === "'" || S === "`") && E !== S)
            throw new nu("property names with quotes must have matching quotes");
        if ((b === "constructor" || !g) && (h = !0),
        i += "." + b,
        l = "%" + i + "%",
        lm(Oa, l))
            f = Oa[l];
        else if (f != null) {
            if (!(b in f)) {
                if (!e)
                    throw new Bl("base intrinsic for " + t + " exists, but the property is not available.");
                return
            }
            if ($f && m + 1 >= r.length) {
                var F = $f(f, b);
                g = !!F,
                g && "get"in F && !("originalValue"in F.get) ? f = F.get : f = f[b]
            } else
                g = lm(f, b),
                f = f[b];
            g && !h && (Oa[l] = f)
        }
    }
    return f
}
  , kS = {
    exports: {}
}
  , w_ = Jm
  , hj = RS
  , Al = Uf
  , E_ = Wm
  , pj = function(t, e, r) {
    if (!t || typeof t != "object" && typeof t != "function")
        throw new Al("`obj` must be an object or a function`");
    if (typeof e != "string" && typeof e != "symbol")
        throw new Al("`property` must be a string or a symbol`");
    if (arguments.length > 3 && typeof arguments[3] != "boolean" && arguments[3] !== null)
        throw new Al("`nonEnumerable`, if provided, must be a boolean or null");
    if (arguments.length > 4 && typeof arguments[4] != "boolean" && arguments[4] !== null)
        throw new Al("`nonWritable`, if provided, must be a boolean or null");
    if (arguments.length > 5 && typeof arguments[5] != "boolean" && arguments[5] !== null)
        throw new Al("`nonConfigurable`, if provided, must be a boolean or null");
    if (arguments.length > 6 && typeof arguments[6] != "boolean")
        throw new Al("`loose`, if provided, must be a boolean");
    var i = arguments.length > 3 ? arguments[3] : null
      , a = arguments.length > 4 ? arguments[4] : null
      , l = arguments.length > 5 ? arguments[5] : null
      , f = arguments.length > 6 ? arguments[6] : !1
      , h = !!E_ && E_(t, e);
    if (w_)
        w_(t, e, {
            configurable: l === null && h ? h.configurable : !l,
            enumerable: i === null && h ? h.enumerable : !i,
            value: r,
            writable: a === null && h ? h.writable : !a
        });
    else if (f || !i && !a && !l)
        t[e] = r;
    else
        throw new hj("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.")
}
  , X0 = Jm
  , zS = function() {
    return !!X0
};
zS.hasArrayLengthDefineBug = function() {
    if (!X0)
        return null;
    try {
        return X0([], "length", {
            value: 1
        }).length !== 1
    } catch {
        return !0
    }
}
;
var mj = zS
  , gj = cy
  , __ = pj
  , vj = mj()
  , L_ = Wm
  , S_ = Uf
  , yj = gj("%Math.floor%")
  , bj = function(t, e) {
    if (typeof t != "function")
        throw new S_("`fn` is not a function");
    if (typeof e != "number" || e < 0 || e > 4294967295 || yj(e) !== e)
        throw new S_("`length` must be a positive 32-bit integer");
    var r = arguments.length > 2 && !!arguments[2]
      , i = !0
      , a = !0;
    if ("length"in t && L_) {
        var l = L_(t, "length");
        l && !l.configurable && (i = !1),
        l && !l.writable && (a = !1)
    }
    return (i || a || !r) && (vj ? __(t, "length", e, !0, !0) : __(t, "length", e)),
    t
}
  , wj = jf()
  , Ej = uy()
  , _j = PS
  , Lj = function() {
    return _j(wj, Ej, arguments)
};
(function(n) {
    var t = bj
      , e = Jm
      , r = DS
      , i = Lj;
    n.exports = function(l) {
        var f = r(arguments)
          , h = l.length - (arguments.length - 1);
        return t(f, 1 + (h > 0 ? h : 0), !0)
    }
    ,
    e ? e(n.exports, "apply", {
        value: i
    }) : n.exports.apply = i
}
)(kS);
var Sj = kS.exports
  , VS = cy
  , US = Sj
  , Aj = US(VS("String.prototype.indexOf"))
  , Cj = function(t, e) {
    var r = VS(t, !!e);
    return typeof r == "function" && Aj(t, ".prototype.") > -1 ? US(r) : r
};
const $j = {}
  , Mj = Object.freeze(Object.defineProperty({
    __proto__: null,
    default: $j
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Oj = w2(Mj);
var fy = typeof Map == "function" && Map.prototype
  , Yv = Object.getOwnPropertyDescriptor && fy ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null
  , cm = fy && Yv && typeof Yv.get == "function" ? Yv.get : null
  , A_ = fy && Map.prototype.forEach
  , dy = typeof Set == "function" && Set.prototype
  , Qv = Object.getOwnPropertyDescriptor && dy ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null
  , fm = dy && Qv && typeof Qv.get == "function" ? Qv.get : null
  , C_ = dy && Set.prototype.forEach
  , Nj = typeof WeakMap == "function" && WeakMap.prototype
  , sc = Nj ? WeakMap.prototype.has : null
  , Tj = typeof WeakSet == "function" && WeakSet.prototype
  , ic = Tj ? WeakSet.prototype.has : null
  , xj = typeof WeakRef == "function" && WeakRef.prototype
  , $_ = xj ? WeakRef.prototype.deref : null
  , Ij = Boolean.prototype.valueOf
  , Fj = Object.prototype.toString
  , Rj = Function.prototype.toString
  , Pj = String.prototype.match
  , hy = String.prototype.slice
  , Io = String.prototype.replace
  , Dj = String.prototype.toUpperCase
  , M_ = String.prototype.toLowerCase
  , jS = RegExp.prototype.test
  , O_ = Array.prototype.concat
  , Ei = Array.prototype.join
  , qj = Array.prototype.slice
  , N_ = Math.floor
  , e1 = typeof BigInt == "function" ? BigInt.prototype.valueOf : null
  , Xv = Object.getOwnPropertySymbols
  , t1 = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? Symbol.prototype.toString : null
  , ru = typeof Symbol == "function" && typeof Symbol.iterator == "object"
  , Br = typeof Symbol == "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === ru || "symbol") ? Symbol.toStringTag : null
  , HS = Object.prototype.propertyIsEnumerable
  , T_ = (typeof Reflect == "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(n) {
    return n.__proto__
}
: null);
function x_(n, t) {
    if (n === 1 / 0 || n === -1 / 0 || n !== n || n && n > -1e3 && n < 1e3 || jS.call(/e/, t))
        return t;
    var e = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof n == "number") {
        var r = n < 0 ? -N_(-n) : N_(n);
        if (r !== n) {
            var i = String(r)
              , a = hy.call(t, i.length + 1);
            return Io.call(i, e, "$&_") + "." + Io.call(Io.call(a, /([0-9]{3})/g, "$&_"), /_$/, "")
        }
    }
    return Io.call(t, e, "$&_")
}
var n1 = Oj
  , I_ = n1.custom
  , F_ = JS(I_) ? I_ : null
  , GS = {
    __proto__: null,
    double: '"',
    single: "'"
}
  , Bj = {
    __proto__: null,
    double: /(["\\])/g,
    single: /(['\\])/g
}
  , kj = function n(t, e, r, i) {
    var a = e || {};
    if (Ji(a, "quoteStyle") && !Ji(GS, a.quoteStyle))
        throw new TypeError('option "quoteStyle" must be "single" or "double"');
    if (Ji(a, "maxStringLength") && (typeof a.maxStringLength == "number" ? a.maxStringLength < 0 && a.maxStringLength !== 1 / 0 : a.maxStringLength !== null))
        throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    var l = Ji(a, "customInspect") ? a.customInspect : !0;
    if (typeof l != "boolean" && l !== "symbol")
        throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    if (Ji(a, "indent") && a.indent !== null && a.indent !== "	" && !(parseInt(a.indent, 10) === a.indent && a.indent > 0))
        throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    if (Ji(a, "numericSeparator") && typeof a.numericSeparator != "boolean")
        throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    var f = a.numericSeparator;
    if (typeof t > "u")
        return "undefined";
    if (t === null)
        return "null";
    if (typeof t == "boolean")
        return t ? "true" : "false";
    if (typeof t == "string")
        return ZS(t, a);
    if (typeof t == "number") {
        if (t === 0)
            return 1 / 0 / t > 0 ? "0" : "-0";
        var h = String(t);
        return f ? x_(t, h) : h
    }
    if (typeof t == "bigint") {
        var p = String(t) + "n";
        return f ? x_(t, p) : p
    }
    var m = typeof a.depth > "u" ? 5 : a.depth;
    if (typeof r > "u" && (r = 0),
    r >= m && m > 0 && typeof t == "object")
        return r1(t) ? "[Array]" : "[Object]";
    var g = sH(a, r);
    if (typeof i > "u")
        i = [];
    else if (KS(i, t) >= 0)
        return "[Circular]";
    function b(N, P, J) {
        if (P && (i = qj.call(i),
        i.push(P)),
        J) {
            var X = {
                depth: a.depth
            };
            return Ji(a, "quoteStyle") && (X.quoteStyle = a.quoteStyle),
            n(N, X, r + 1, i)
        }
        return n(N, a, r + 1, i)
    }
    if (typeof t == "function" && !R_(t)) {
        var E = Kj(t)
          , S = Pd(t, b);
        return "[Function" + (E ? ": " + E : " (anonymous)") + "]" + (S.length > 0 ? " { " + Ei.call(S, ", ") + " }" : "")
    }
    if (JS(t)) {
        var F = ru ? Io.call(String(t), /^(Symbol\(.*\))_[^)]*$/, "$1") : t1.call(t);
        return typeof t == "object" && !ru ? zu(F) : F
    }
    if (tH(t)) {
        for (var B = "<" + M_.call(String(t.nodeName)), Q = t.attributes || [], ae = 0; ae < Q.length; ae++)
            B += " " + Q[ae].name + "=" + WS(zj(Q[ae].value), "double", a);
        return B += ">",
        t.childNodes && t.childNodes.length && (B += "..."),
        B += "</" + M_.call(String(t.nodeName)) + ">",
        B
    }
    if (r1(t)) {
        if (t.length === 0)
            return "[]";
        var V = Pd(t, b);
        return g && !rH(V) ? "[" + s1(V, g) + "]" : "[ " + Ei.call(V, ", ") + " ]"
    }
    if (Uj(t)) {
        var k = Pd(t, b);
        return !("cause"in Error.prototype) && "cause"in t && !HS.call(t, "cause") ? "{ [" + String(t) + "] " + Ei.call(O_.call("[cause]: " + b(t.cause), k), ", ") + " }" : k.length === 0 ? "[" + String(t) + "]" : "{ [" + String(t) + "] " + Ei.call(k, ", ") + " }"
    }
    if (typeof t == "object" && l) {
        if (F_ && typeof t[F_] == "function" && n1)
            return n1(t, {
                depth: m - r
            });
        if (l !== "symbol" && typeof t.inspect == "function")
            return t.inspect()
    }
    if (Zj(t)) {
        var z = [];
        return A_ && A_.call(t, function(N, P) {
            z.push(b(P, t, !0) + " => " + b(N, t))
        }),
        P_("Map", cm.call(t), z, g)
    }
    if (Xj(t)) {
        var Z = [];
        return C_ && C_.call(t, function(N) {
            Z.push(b(N, t))
        }),
        P_("Set", fm.call(t), Z, g)
    }
    if (Yj(t))
        return e0("WeakMap");
    if (eH(t))
        return e0("WeakSet");
    if (Qj(t))
        return e0("WeakRef");
    if (Hj(t))
        return zu(b(Number(t)));
    if (Wj(t))
        return zu(b(e1.call(t)));
    if (Gj(t))
        return zu(Ij.call(t));
    if (jj(t))
        return zu(b(String(t)));
    if (typeof window < "u" && t === window)
        return "{ [object Window] }";
    if (typeof globalThis < "u" && t === globalThis || typeof Zt < "u" && t === Zt)
        return "{ [object globalThis] }";
    if (!Vj(t) && !R_(t)) {
        var re = Pd(t, b)
          , C = T_ ? T_(t) === Object.prototype : t instanceof Object || t.constructor === Object
          , D = t instanceof Object ? "" : "null prototype"
          , R = !C && Br && Object(t) === t && Br in t ? hy.call(Wo(t), 8, -1) : D ? "Object" : ""
          , W = C || typeof t.constructor != "function" ? "" : t.constructor.name ? t.constructor.name + " " : ""
          , I = W + (R || D ? "[" + Ei.call(O_.call([], R || [], D || []), ": ") + "] " : "");
        return re.length === 0 ? I + "{}" : g ? I + "{" + s1(re, g) + "}" : I + "{ " + Ei.call(re, ", ") + " }"
    }
    return String(t)
};
function WS(n, t, e) {
    var r = e.quoteStyle || t
      , i = GS[r];
    return i + n + i
}
function zj(n) {
    return Io.call(String(n), /"/g, "&quot;")
}
function r1(n) {
    return Wo(n) === "[object Array]" && (!Br || !(typeof n == "object" && Br in n))
}
function Vj(n) {
    return Wo(n) === "[object Date]" && (!Br || !(typeof n == "object" && Br in n))
}
function R_(n) {
    return Wo(n) === "[object RegExp]" && (!Br || !(typeof n == "object" && Br in n))
}
function Uj(n) {
    return Wo(n) === "[object Error]" && (!Br || !(typeof n == "object" && Br in n))
}
function jj(n) {
    return Wo(n) === "[object String]" && (!Br || !(typeof n == "object" && Br in n))
}
function Hj(n) {
    return Wo(n) === "[object Number]" && (!Br || !(typeof n == "object" && Br in n))
}
function Gj(n) {
    return Wo(n) === "[object Boolean]" && (!Br || !(typeof n == "object" && Br in n))
}
function JS(n) {
    if (ru)
        return n && typeof n == "object" && n instanceof Symbol;
    if (typeof n == "symbol")
        return !0;
    if (!n || typeof n != "object" || !t1)
        return !1;
    try {
        return t1.call(n),
        !0
    } catch {}
    return !1
}
function Wj(n) {
    if (!n || typeof n != "object" || !e1)
        return !1;
    try {
        return e1.call(n),
        !0
    } catch {}
    return !1
}
var Jj = Object.prototype.hasOwnProperty || function(n) {
    return n in this
}
;
function Ji(n, t) {
    return Jj.call(n, t)
}
function Wo(n) {
    return Fj.call(n)
}
function Kj(n) {
    if (n.name)
        return n.name;
    var t = Pj.call(Rj.call(n), /^function\s*([\w$]+)/);
    return t ? t[1] : null
}
function KS(n, t) {
    if (n.indexOf)
        return n.indexOf(t);
    for (var e = 0, r = n.length; e < r; e++)
        if (n[e] === t)
            return e;
    return -1
}
function Zj(n) {
    if (!cm || !n || typeof n != "object")
        return !1;
    try {
        cm.call(n);
        try {
            fm.call(n)
        } catch {
            return !0
        }
        return n instanceof Map
    } catch {}
    return !1
}
function Yj(n) {
    if (!sc || !n || typeof n != "object")
        return !1;
    try {
        sc.call(n, sc);
        try {
            ic.call(n, ic)
        } catch {
            return !0
        }
        return n instanceof WeakMap
    } catch {}
    return !1
}
function Qj(n) {
    if (!$_ || !n || typeof n != "object")
        return !1;
    try {
        return $_.call(n),
        !0
    } catch {}
    return !1
}
function Xj(n) {
    if (!fm || !n || typeof n != "object")
        return !1;
    try {
        fm.call(n);
        try {
            cm.call(n)
        } catch {
            return !0
        }
        return n instanceof Set
    } catch {}
    return !1
}
function eH(n) {
    if (!ic || !n || typeof n != "object")
        return !1;
    try {
        ic.call(n, ic);
        try {
            sc.call(n, sc)
        } catch {
            return !0
        }
        return n instanceof WeakSet
    } catch {}
    return !1
}
function tH(n) {
    return !n || typeof n != "object" ? !1 : typeof HTMLElement < "u" && n instanceof HTMLElement ? !0 : typeof n.nodeName == "string" && typeof n.getAttribute == "function"
}
function ZS(n, t) {
    if (n.length > t.maxStringLength) {
        var e = n.length - t.maxStringLength
          , r = "... " + e + " more character" + (e > 1 ? "s" : "");
        return ZS(hy.call(n, 0, t.maxStringLength), t) + r
    }
    var i = Bj[t.quoteStyle || "single"];
    i.lastIndex = 0;
    var a = Io.call(Io.call(n, i, "\\$1"), /[\x00-\x1f]/g, nH);
    return WS(a, "single", t)
}
function nH(n) {
    var t = n.charCodeAt(0)
      , e = {
        8: "b",
        9: "t",
        10: "n",
        12: "f",
        13: "r"
    }[t];
    return e ? "\\" + e : "\\x" + (t < 16 ? "0" : "") + Dj.call(t.toString(16))
}
function zu(n) {
    return "Object(" + n + ")"
}
function e0(n) {
    return n + " { ? }"
}
function P_(n, t, e, r) {
    var i = r ? s1(e, r) : Ei.call(e, ", ");
    return n + " (" + t + ") {" + i + "}"
}
function rH(n) {
    for (var t = 0; t < n.length; t++)
        if (KS(n[t], `
`) >= 0)
            return !1;
    return !0
}
function sH(n, t) {
    var e;
    if (n.indent === "	")
        e = "	";
    else if (typeof n.indent == "number" && n.indent > 0)
        e = Ei.call(Array(n.indent + 1), " ");
    else
        return null;
    return {
        base: e,
        prev: Ei.call(Array(t + 1), e)
    }
}
function s1(n, t) {
    if (n.length === 0)
        return "";
    var e = `
` + t.prev + t.base;
    return e + Ei.call(n, "," + e) + `
` + t.prev
}
function Pd(n, t) {
    var e = r1(n)
      , r = [];
    if (e) {
        r.length = n.length;
        for (var i = 0; i < n.length; i++)
            r[i] = Ji(n, i) ? t(n[i], n) : ""
    }
    var a = typeof Xv == "function" ? Xv(n) : [], l;
    if (ru) {
        l = {};
        for (var f = 0; f < a.length; f++)
            l["$" + a[f]] = a[f]
    }
    for (var h in n)
        Ji(n, h) && (e && String(Number(h)) === h && h < n.length || ru && l["$" + h]instanceof Symbol || (jS.call(/[^\w$]/, h) ? r.push(t(h, n) + ": " + t(n[h], n)) : r.push(h + ": " + t(n[h], n))));
    if (typeof Xv == "function")
        for (var p = 0; p < a.length; p++)
            HS.call(n, a[p]) && r.push("[" + t(a[p]) + "]: " + t(n[a[p]], n));
    return r
}
var YS = cy
  , uu = Cj
  , iH = kj
  , oH = Uf
  , Dd = YS("%WeakMap%", !0)
  , qd = YS("%Map%", !0)
  , aH = uu("WeakMap.prototype.get", !0)
  , lH = uu("WeakMap.prototype.set", !0)
  , uH = uu("WeakMap.prototype.has", !0)
  , cH = uu("Map.prototype.get", !0)
  , fH = uu("Map.prototype.set", !0)
  , dH = uu("Map.prototype.has", !0)
  , py = function(n, t) {
    for (var e = n, r; (r = e.next) !== null; e = r)
        if (r.key === t)
            return e.next = r.next,
            r.next = n.next,
            n.next = r,
            r
}
  , hH = function(n, t) {
    var e = py(n, t);
    return e && e.value
}
  , pH = function(n, t, e) {
    var r = py(n, t);
    r ? r.value = e : n.next = {
        key: t,
        next: n.next,
        value: e
    }
}
  , mH = function(n, t) {
    return !!py(n, t)
}
  , gH = function() {
    var t, e, r, i = {
        assert: function(a) {
            if (!i.has(a))
                throw new oH("Side channel does not contain " + iH(a))
        },
        get: function(a) {
            if (Dd && a && (typeof a == "object" || typeof a == "function")) {
                if (t)
                    return aH(t, a)
            } else if (qd) {
                if (e)
                    return cH(e, a)
            } else if (r)
                return hH(r, a)
        },
        has: function(a) {
            if (Dd && a && (typeof a == "object" || typeof a == "function")) {
                if (t)
                    return uH(t, a)
            } else if (qd) {
                if (e)
                    return dH(e, a)
            } else if (r)
                return mH(r, a);
            return !1
        },
        set: function(a, l) {
            Dd && a && (typeof a == "object" || typeof a == "function") ? (t || (t = new Dd),
            lH(t, a, l)) : qd ? (e || (e = new qd),
            fH(e, a, l)) : (r || (r = {
                key: {},
                next: null
            }),
            pH(r, a, l))
        }
    };
    return i
}
  , vH = String.prototype.replace
  , yH = /%20/g
  , t0 = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
}
  , my = {
    default: t0.RFC3986,
    formatters: {
        RFC1738: function(n) {
            return vH.call(n, yH, "+")
        },
        RFC3986: function(n) {
            return String(n)
        }
    },
    RFC1738: t0.RFC1738,
    RFC3986: t0.RFC3986
}
  , bH = my
  , n0 = Object.prototype.hasOwnProperty
  , _a = Array.isArray
  , hi = function() {
    for (var n = [], t = 0; t < 256; ++t)
        n.push("%" + ((t < 16 ? "0" : "") + t.toString(16)).toUpperCase());
    return n
}()
  , wH = function(t) {
    for (; t.length > 1; ) {
        var e = t.pop()
          , r = e.obj[e.prop];
        if (_a(r)) {
            for (var i = [], a = 0; a < r.length; ++a)
                typeof r[a] < "u" && i.push(r[a]);
            e.obj[e.prop] = i
        }
    }
}
  , QS = function(t, e) {
    for (var r = e && e.plainObjects ? {
        __proto__: null
    } : {}, i = 0; i < t.length; ++i)
        typeof t[i] < "u" && (r[i] = t[i]);
    return r
}
  , EH = function n(t, e, r) {
    if (!e)
        return t;
    if (typeof e != "object" && typeof e != "function") {
        if (_a(t))
            t.push(e);
        else if (t && typeof t == "object")
            (r && (r.plainObjects || r.allowPrototypes) || !n0.call(Object.prototype, e)) && (t[e] = !0);
        else
            return [t, e];
        return t
    }
    if (!t || typeof t != "object")
        return [t].concat(e);
    var i = t;
    return _a(t) && !_a(e) && (i = QS(t, r)),
    _a(t) && _a(e) ? (e.forEach(function(a, l) {
        if (n0.call(t, l)) {
            var f = t[l];
            f && typeof f == "object" && a && typeof a == "object" ? t[l] = n(f, a, r) : t.push(a)
        } else
            t[l] = a
    }),
    t) : Object.keys(e).reduce(function(a, l) {
        var f = e[l];
        return n0.call(a, l) ? a[l] = n(a[l], f, r) : a[l] = f,
        a
    }, i)
}
  , _H = function(t, e) {
    return Object.keys(e).reduce(function(r, i) {
        return r[i] = e[i],
        r
    }, t)
}
  , LH = function(n, t, e) {
    var r = n.replace(/\+/g, " ");
    if (e === "iso-8859-1")
        return r.replace(/%[0-9a-f]{2}/gi, unescape);
    try {
        return decodeURIComponent(r)
    } catch {
        return r
    }
}
  , r0 = 1024
  , SH = function(t, e, r, i, a) {
    if (t.length === 0)
        return t;
    var l = t;
    if (typeof t == "symbol" ? l = Symbol.prototype.toString.call(t) : typeof t != "string" && (l = String(t)),
    r === "iso-8859-1")
        return escape(l).replace(/%u[0-9a-f]{4}/gi, function(E) {
            return "%26%23" + parseInt(E.slice(2), 16) + "%3B"
        });
    for (var f = "", h = 0; h < l.length; h += r0) {
        for (var p = l.length >= r0 ? l.slice(h, h + r0) : l, m = [], g = 0; g < p.length; ++g) {
            var b = p.charCodeAt(g);
            if (b === 45 || b === 46 || b === 95 || b === 126 || b >= 48 && b <= 57 || b >= 65 && b <= 90 || b >= 97 && b <= 122 || a === bH.RFC1738 && (b === 40 || b === 41)) {
                m[m.length] = p.charAt(g);
                continue
            }
            if (b < 128) {
                m[m.length] = hi[b];
                continue
            }
            if (b < 2048) {
                m[m.length] = hi[192 | b >> 6] + hi[128 | b & 63];
                continue
            }
            if (b < 55296 || b >= 57344) {
                m[m.length] = hi[224 | b >> 12] + hi[128 | b >> 6 & 63] + hi[128 | b & 63];
                continue
            }
            g += 1,
            b = 65536 + ((b & 1023) << 10 | p.charCodeAt(g) & 1023),
            m[m.length] = hi[240 | b >> 18] + hi[128 | b >> 12 & 63] + hi[128 | b >> 6 & 63] + hi[128 | b & 63]
        }
        f += m.join("")
    }
    return f
}
  , AH = function(t) {
    for (var e = [{
        obj: {
            o: t
        },
        prop: "o"
    }], r = [], i = 0; i < e.length; ++i)
        for (var a = e[i], l = a.obj[a.prop], f = Object.keys(l), h = 0; h < f.length; ++h) {
            var p = f[h]
              , m = l[p];
            typeof m == "object" && m !== null && r.indexOf(m) === -1 && (e.push({
                obj: l,
                prop: p
            }),
            r.push(m))
        }
    return wH(e),
    t
}
  , CH = function(t) {
    return Object.prototype.toString.call(t) === "[object RegExp]"
}
  , $H = function(t) {
    return !t || typeof t != "object" ? !1 : !!(t.constructor && t.constructor.isBuffer && t.constructor.isBuffer(t))
}
  , MH = function(t, e) {
    return [].concat(t, e)
}
  , OH = function(t, e) {
    if (_a(t)) {
        for (var r = [], i = 0; i < t.length; i += 1)
            r.push(e(t[i]));
        return r
    }
    return e(t)
}
  , XS = {
    arrayToObject: QS,
    assign: _H,
    combine: MH,
    compact: AH,
    decode: LH,
    encode: SH,
    isBuffer: $H,
    isRegExp: CH,
    maybeMap: OH,
    merge: EH
}
  , eA = gH
  , sh = XS
  , oc = my
  , NH = Object.prototype.hasOwnProperty
  , tA = {
    brackets: function(t) {
        return t + "[]"
    },
    comma: "comma",
    indices: function(t, e) {
        return t + "[" + e + "]"
    },
    repeat: function(t) {
        return t
    }
}
  , bi = Array.isArray
  , TH = Array.prototype.push
  , nA = function(n, t) {
    TH.apply(n, bi(t) ? t : [t])
}
  , xH = Date.prototype.toISOString
  , D_ = oc.default
  , fr = {
    addQueryPrefix: !1,
    allowDots: !1,
    allowEmptyArrays: !1,
    arrayFormat: "indices",
    charset: "utf-8",
    charsetSentinel: !1,
    commaRoundTrip: !1,
    delimiter: "&",
    encode: !0,
    encodeDotInKeys: !1,
    encoder: sh.encode,
    encodeValuesOnly: !1,
    filter: void 0,
    format: D_,
    formatter: oc.formatters[D_],
    indices: !1,
    serializeDate: function(t) {
        return xH.call(t)
    },
    skipNulls: !1,
    strictNullHandling: !1
}
  , IH = function(t) {
    return typeof t == "string" || typeof t == "number" || typeof t == "boolean" || typeof t == "symbol" || typeof t == "bigint"
}
  , s0 = {}
  , FH = function n(t, e, r, i, a, l, f, h, p, m, g, b, E, S, F, B, Q, ae) {
    for (var V = t, k = ae, z = 0, Z = !1; (k = k.get(s0)) !== void 0 && !Z; ) {
        var re = k.get(t);
        if (z += 1,
        typeof re < "u") {
            if (re === z)
                throw new RangeError("Cyclic object value");
            Z = !0
        }
        typeof k.get(s0) > "u" && (z = 0)
    }
    if (typeof m == "function" ? V = m(e, V) : V instanceof Date ? V = E(V) : r === "comma" && bi(V) && (V = sh.maybeMap(V, function(he) {
        return he instanceof Date ? E(he) : he
    })),
    V === null) {
        if (l)
            return p && !B ? p(e, fr.encoder, Q, "key", S) : e;
        V = ""
    }
    if (IH(V) || sh.isBuffer(V)) {
        if (p) {
            var C = B ? e : p(e, fr.encoder, Q, "key", S);
            return [F(C) + "=" + F(p(V, fr.encoder, Q, "value", S))]
        }
        return [F(e) + "=" + F(String(V))]
    }
    var D = [];
    if (typeof V > "u")
        return D;
    var R;
    if (r === "comma" && bi(V))
        B && p && (V = sh.maybeMap(V, p)),
        R = [{
            value: V.length > 0 ? V.join(",") || null : void 0
        }];
    else if (bi(m))
        R = m;
    else {
        var W = Object.keys(V);
        R = g ? W.sort(g) : W
    }
    var I = h ? String(e).replace(/\./g, "%2E") : String(e)
      , N = i && bi(V) && V.length === 1 ? I + "[]" : I;
    if (a && bi(V) && V.length === 0)
        return N + "[]";
    for (var P = 0; P < R.length; ++P) {
        var J = R[P]
          , X = typeof J == "object" && J && typeof J.value < "u" ? J.value : V[J];
        if (!(f && X === null)) {
            var ie = b && h ? String(J).replace(/\./g, "%2E") : String(J)
              , ce = bi(V) ? typeof r == "function" ? r(N, ie) : N : N + (b ? "." + ie : "[" + ie + "]");
            ae.set(t, z);
            var Le = eA();
            Le.set(s0, ae),
            nA(D, n(X, ce, r, i, a, l, f, h, r === "comma" && B && bi(V) ? null : p, m, g, b, E, S, F, B, Q, Le))
        }
    }
    return D
}
  , RH = function(t) {
    if (!t)
        return fr;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.encodeDotInKeys < "u" && typeof t.encodeDotInKeys != "boolean")
        throw new TypeError("`encodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.encoder !== null && typeof t.encoder < "u" && typeof t.encoder != "function")
        throw new TypeError("Encoder has to be a function.");
    var e = t.charset || fr.charset;
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var r = oc.default;
    if (typeof t.format < "u") {
        if (!NH.call(oc.formatters, t.format))
            throw new TypeError("Unknown format option provided.");
        r = t.format
    }
    var i = oc.formatters[r]
      , a = fr.filter;
    (typeof t.filter == "function" || bi(t.filter)) && (a = t.filter);
    var l;
    if (t.arrayFormat in tA ? l = t.arrayFormat : "indices"in t ? l = t.indices ? "indices" : "repeat" : l = fr.arrayFormat,
    "commaRoundTrip"in t && typeof t.commaRoundTrip != "boolean")
        throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    var f = typeof t.allowDots > "u" ? t.encodeDotInKeys === !0 ? !0 : fr.allowDots : !!t.allowDots;
    return {
        addQueryPrefix: typeof t.addQueryPrefix == "boolean" ? t.addQueryPrefix : fr.addQueryPrefix,
        allowDots: f,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : fr.allowEmptyArrays,
        arrayFormat: l,
        charset: e,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : fr.charsetSentinel,
        commaRoundTrip: !!t.commaRoundTrip,
        delimiter: typeof t.delimiter > "u" ? fr.delimiter : t.delimiter,
        encode: typeof t.encode == "boolean" ? t.encode : fr.encode,
        encodeDotInKeys: typeof t.encodeDotInKeys == "boolean" ? t.encodeDotInKeys : fr.encodeDotInKeys,
        encoder: typeof t.encoder == "function" ? t.encoder : fr.encoder,
        encodeValuesOnly: typeof t.encodeValuesOnly == "boolean" ? t.encodeValuesOnly : fr.encodeValuesOnly,
        filter: a,
        format: r,
        formatter: i,
        serializeDate: typeof t.serializeDate == "function" ? t.serializeDate : fr.serializeDate,
        skipNulls: typeof t.skipNulls == "boolean" ? t.skipNulls : fr.skipNulls,
        sort: typeof t.sort == "function" ? t.sort : null,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : fr.strictNullHandling
    }
}
  , PH = function(n, t) {
    var e = n, r = RH(t), i, a;
    typeof r.filter == "function" ? (a = r.filter,
    e = a("", e)) : bi(r.filter) && (a = r.filter,
    i = a);
    var l = [];
    if (typeof e != "object" || e === null)
        return "";
    var f = tA[r.arrayFormat]
      , h = f === "comma" && r.commaRoundTrip;
    i || (i = Object.keys(e)),
    r.sort && i.sort(r.sort);
    for (var p = eA(), m = 0; m < i.length; ++m) {
        var g = i[m]
          , b = e[g];
        r.skipNulls && b === null || nA(l, FH(b, g, f, h, r.allowEmptyArrays, r.strictNullHandling, r.skipNulls, r.encodeDotInKeys, r.encode ? r.encoder : null, r.filter, r.sort, r.allowDots, r.serializeDate, r.format, r.formatter, r.encodeValuesOnly, r.charset, p))
    }
    var E = l.join(r.delimiter)
      , S = r.addQueryPrefix === !0 ? "?" : "";
    return r.charsetSentinel && (r.charset === "iso-8859-1" ? S += "utf8=%26%2310003%3B&" : S += "utf8=%E2%9C%93&"),
    E.length > 0 ? S + E : ""
}
  , su = XS
  , i1 = Object.prototype.hasOwnProperty
  , DH = Array.isArray
  , Wn = {
    allowDots: !1,
    allowEmptyArrays: !1,
    allowPrototypes: !1,
    allowSparse: !1,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: !1,
    comma: !1,
    decodeDotInKeys: !1,
    decoder: su.decode,
    delimiter: "&",
    depth: 5,
    duplicates: "combine",
    ignoreQueryPrefix: !1,
    interpretNumericEntities: !1,
    parameterLimit: 1e3,
    parseArrays: !0,
    plainObjects: !1,
    strictDepth: !1,
    strictNullHandling: !1
}
  , qH = function(n) {
    return n.replace(/&#(\d+);/g, function(t, e) {
        return String.fromCharCode(parseInt(e, 10))
    })
}
  , rA = function(n, t) {
    return n && typeof n == "string" && t.comma && n.indexOf(",") > -1 ? n.split(",") : n
}
  , BH = "utf8=%26%2310003%3B"
  , kH = "utf8=%E2%9C%93"
  , zH = function(t, e) {
    var r = {
        __proto__: null
    }
      , i = e.ignoreQueryPrefix ? t.replace(/^\?/, "") : t;
    i = i.replace(/%5B/gi, "[").replace(/%5D/gi, "]");
    var a = e.parameterLimit === 1 / 0 ? void 0 : e.parameterLimit, l = i.split(e.delimiter, a), f = -1, h, p = e.charset;
    if (e.charsetSentinel)
        for (h = 0; h < l.length; ++h)
            l[h].indexOf("utf8=") === 0 && (l[h] === kH ? p = "utf-8" : l[h] === BH && (p = "iso-8859-1"),
            f = h,
            h = l.length);
    for (h = 0; h < l.length; ++h)
        if (h !== f) {
            var m = l[h], g = m.indexOf("]="), b = g === -1 ? m.indexOf("=") : g + 1, E, S;
            b === -1 ? (E = e.decoder(m, Wn.decoder, p, "key"),
            S = e.strictNullHandling ? null : "") : (E = e.decoder(m.slice(0, b), Wn.decoder, p, "key"),
            S = su.maybeMap(rA(m.slice(b + 1), e), function(B) {
                return e.decoder(B, Wn.decoder, p, "value")
            })),
            S && e.interpretNumericEntities && p === "iso-8859-1" && (S = qH(String(S))),
            m.indexOf("[]=") > -1 && (S = DH(S) ? [S] : S);
            var F = i1.call(r, E);
            F && e.duplicates === "combine" ? r[E] = su.combine(r[E], S) : (!F || e.duplicates === "last") && (r[E] = S)
        }
    return r
}
  , VH = function(n, t, e, r) {
    for (var i = r ? t : rA(t, e), a = n.length - 1; a >= 0; --a) {
        var l, f = n[a];
        if (f === "[]" && e.parseArrays)
            l = e.allowEmptyArrays && (i === "" || e.strictNullHandling && i === null) ? [] : [].concat(i);
        else {
            l = e.plainObjects ? {
                __proto__: null
            } : {};
            var h = f.charAt(0) === "[" && f.charAt(f.length - 1) === "]" ? f.slice(1, -1) : f
              , p = e.decodeDotInKeys ? h.replace(/%2E/g, ".") : h
              , m = parseInt(p, 10);
            !e.parseArrays && p === "" ? l = {
                0: i
            } : !isNaN(m) && f !== p && String(m) === p && m >= 0 && e.parseArrays && m <= e.arrayLimit ? (l = [],
            l[m] = i) : p !== "__proto__" && (l[p] = i)
        }
        i = l
    }
    return i
}
  , UH = function(t, e, r, i) {
    if (t) {
        var a = r.allowDots ? t.replace(/\.([^.[]+)/g, "[$1]") : t
          , l = /(\[[^[\]]*])/
          , f = /(\[[^[\]]*])/g
          , h = r.depth > 0 && l.exec(a)
          , p = h ? a.slice(0, h.index) : a
          , m = [];
        if (p) {
            if (!r.plainObjects && i1.call(Object.prototype, p) && !r.allowPrototypes)
                return;
            m.push(p)
        }
        for (var g = 0; r.depth > 0 && (h = f.exec(a)) !== null && g < r.depth; ) {
            if (g += 1,
            !r.plainObjects && i1.call(Object.prototype, h[1].slice(1, -1)) && !r.allowPrototypes)
                return;
            m.push(h[1])
        }
        if (h) {
            if (r.strictDepth === !0)
                throw new RangeError("Input depth exceeded depth option of " + r.depth + " and strictDepth is true");
            m.push("[" + a.slice(h.index) + "]")
        }
        return VH(m, e, r, i)
    }
}
  , jH = function(t) {
    if (!t)
        return Wn;
    if (typeof t.allowEmptyArrays < "u" && typeof t.allowEmptyArrays != "boolean")
        throw new TypeError("`allowEmptyArrays` option can only be `true` or `false`, when provided");
    if (typeof t.decodeDotInKeys < "u" && typeof t.decodeDotInKeys != "boolean")
        throw new TypeError("`decodeDotInKeys` option can only be `true` or `false`, when provided");
    if (t.decoder !== null && typeof t.decoder < "u" && typeof t.decoder != "function")
        throw new TypeError("Decoder has to be a function.");
    if (typeof t.charset < "u" && t.charset !== "utf-8" && t.charset !== "iso-8859-1")
        throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    var e = typeof t.charset > "u" ? Wn.charset : t.charset
      , r = typeof t.duplicates > "u" ? Wn.duplicates : t.duplicates;
    if (r !== "combine" && r !== "first" && r !== "last")
        throw new TypeError("The duplicates option must be either combine, first, or last");
    var i = typeof t.allowDots > "u" ? t.decodeDotInKeys === !0 ? !0 : Wn.allowDots : !!t.allowDots;
    return {
        allowDots: i,
        allowEmptyArrays: typeof t.allowEmptyArrays == "boolean" ? !!t.allowEmptyArrays : Wn.allowEmptyArrays,
        allowPrototypes: typeof t.allowPrototypes == "boolean" ? t.allowPrototypes : Wn.allowPrototypes,
        allowSparse: typeof t.allowSparse == "boolean" ? t.allowSparse : Wn.allowSparse,
        arrayLimit: typeof t.arrayLimit == "number" ? t.arrayLimit : Wn.arrayLimit,
        charset: e,
        charsetSentinel: typeof t.charsetSentinel == "boolean" ? t.charsetSentinel : Wn.charsetSentinel,
        comma: typeof t.comma == "boolean" ? t.comma : Wn.comma,
        decodeDotInKeys: typeof t.decodeDotInKeys == "boolean" ? t.decodeDotInKeys : Wn.decodeDotInKeys,
        decoder: typeof t.decoder == "function" ? t.decoder : Wn.decoder,
        delimiter: typeof t.delimiter == "string" || su.isRegExp(t.delimiter) ? t.delimiter : Wn.delimiter,
        depth: typeof t.depth == "number" || t.depth === !1 ? +t.depth : Wn.depth,
        duplicates: r,
        ignoreQueryPrefix: t.ignoreQueryPrefix === !0,
        interpretNumericEntities: typeof t.interpretNumericEntities == "boolean" ? t.interpretNumericEntities : Wn.interpretNumericEntities,
        parameterLimit: typeof t.parameterLimit == "number" ? t.parameterLimit : Wn.parameterLimit,
        parseArrays: t.parseArrays !== !1,
        plainObjects: typeof t.plainObjects == "boolean" ? t.plainObjects : Wn.plainObjects,
        strictDepth: typeof t.strictDepth == "boolean" ? !!t.strictDepth : Wn.strictDepth,
        strictNullHandling: typeof t.strictNullHandling == "boolean" ? t.strictNullHandling : Wn.strictNullHandling
    }
}
  , HH = function(n, t) {
    var e = jH(t);
    if (n === "" || n === null || typeof n > "u")
        return e.plainObjects ? {
            __proto__: null
        } : {};
    for (var r = typeof n == "string" ? zH(n, e) : n, i = e.plainObjects ? {
        __proto__: null
    } : {}, a = Object.keys(r), l = 0; l < a.length; ++l) {
        var f = a[l]
          , h = UH(f, r[f], e, typeof n == "string");
        i = su.merge(i, h, e)
    }
    return e.allowSparse === !0 ? i : su.compact(i)
}
  , GH = PH
  , WH = HH
  , JH = my
  , KH = {
    formats: JH,
    parse: WH,
    stringify: GH
};
const sA = j7(KH)
  , ZH = {
    class: "btn",
    href: "#"
}
  , iA = gs({
    __name: "DropdownGroup",
    props: {
        title: {}
    },
    emits: ["mouseenter"],
    setup(n, {expose: t}) {
        const e = te(null);
        function r() {
            if (e.value) {
                e.value.blur();
                for (const i of e.value.children)
                    i instanceof HTMLElement && i.blur()
            }
        }
        return t({
            blur: r
        }),
        (i, a) => (gt(),
        Fn("li", {
            ref_key: "element",
            ref: e,
            class: "btn-dropdown-group",
            onMouseenter: a[0] || (a[0] = l => i.$emit("mouseenter"))
        }, [se("a", ZH, ds(i.title) + " ", 1), h4(i.$slots, "default")], 544))
    }
});
class gy {
    constructor(t) {
        St(this, "event");
        this.event = t
    }
    parse() {
        if (this.event.target == null)
            throw new Error("Missing event target element");
        const t = this.event.target;
        if (t.files === null)
            throw new Error("Missing files");
        const e = t.files;
        if (!e.length)
            throw new Error("Missing file");
        const r = new FileReader;
        return new Promise( (i, a) => {
            r.addEventListener("load", () => i(this.parseText(r.result, e[0].name))),
            r.addEventListener("error", a),
            r.readAsText(e[0])
        }
        )
    }
}
class YH extends gy {
    parseText(t, e) {
        const r = t.split(kf);
        let i, a = !1;
        for (let m = 0; m < r.length; ++m)
            if (r[m].includes("[Info]"))
                a = !0;
            else if (a && r[m].trim().startsWith("Name")) {
                const g = /"(.*?)"/g
                  , b = r[m].match(g);
                if (b == null)
                    continue;
                i = b[0].replace(/"/g, "").replace(/\.tun/g, "")
            }
        i === void 0 && (i = e.slice(0, -4));
        let l = r.findIndex(m => m.includes("[Functional Tuning]") || m.includes("[Functional tuning]"));
        if (l < 0)
            throw new Error("Missing functional tuning");
        l += 1;
        const f = [];
        for (let m = l; m < r.length; ++m) {
            const g = m - l;
            if (r[m].includes("#=0") && f.push(r[m].substring(r[m].indexOf("#=0") + 6, r[m].length - 2).trim()),
            r[m].includes("#>")) {
                const b = (g + 1).toString()
                  , E = "note " + b + '="#>-' + b
                  , S = r[m].replace(E, "");
                f.push(S.substring(3, S.indexOf("~")).trim())
            }
        }
        const h = [];
        f.forEach(m => {
            m.length && h.push(m)
        }
        );
        const p = {
            sourceText: h.join(`
`),
            name: i
        };
        for (let m = l + 1; m < r.length; m++)
            r[m].includes("!") && (p.baseFrequency = parseFloat(r[m].substring(r[m].indexOf("!") + 2, r[m].length - 2)),
            p.baseMidiNote = parseInt(r[m].substring(0, r[m].indexOf("!") - 2).replace("note ", "")));
        return p
    }
}
class QH extends gy {
    parseText(t) {
        const e = t.split(kf);
        let r = 0
          , i = "";
        const a = [];
        for (let l of e)
            if (l = l.trim(),
            !l.startsWith("!") && (r++,
            !!l.length && (r === 1 && (i = l),
            r > 2))) {
                const f = l.split(/\s/);
                if (f.length === 1)
                    a.push(f[0]);
                else if (f.length > 1) {
                    let h = f.slice(1).join(" ").trim();
                    h.startsWith("!") && (h = h.slice(1).trim()),
                    a.push(f[0] + " " + JSON.stringify(h))
                }
            }
        return {
            name: i,
            sourceText: a.join(`
`)
        }
    }
}
class XH extends gy {
    parseText(t) {
        var a;
        const e = ut.parseAST(t)
          , r = ut.getSourceVisitor(!1);
        r.executeProgram(e);
        for (const l of r.currentScale)
            l.node = void 0,
            l.isRelative() && l.value.isFractional() && (l.domain = "linear");
        return {
            name: (a = r.rootContext) == null ? void 0 : a.title,
            sourceText: r.expand(new ut.RootContext)
        }
    }
}
const eG = {
    scalascl: QH,
    anamark: YH,
    xendevs: XH
};
async function tG(n, t) {
    return await new eG[n](t).parse()
}
const nG = gs({
    __name: "NewScale",
    emits: ["done", "mouseenter"],
    setup(n, {expose: t, emit: e}) {
        const r = e
          , i = lu()
          , a = un( () => Pt( () => import("./ConcordanceShell-4ab93d49.js"), ["assets/ConcordanceShell-4ab93d49.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js"]))
          , l = un( () => Pt( () => import("./CombinationProductSet-8319953b.js"), ["assets/CombinationProductSet-8319953b.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js"]))
          , f = un( () => Pt( () => import("./EnumerateChord-885641d9.js"), ["assets/EnumerateChord-885641d9.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , h = un( () => Pt( () => import("./EqualTemperament-882079e6.js"), ["assets/EqualTemperament-882079e6.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js"]))
          , p = un( () => Pt( () => import("./EulerGenus-c41699df.js"), ["assets/EulerGenus-c41699df.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , m = un( () => Pt( () => import("./GeneratorSequence-f6365631.js"), ["assets/GeneratorSequence-f6365631.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js"]))
          , g = un( () => Pt( () => import("./HarmonicSeries-ed2998ed.js"), ["assets/HarmonicSeries-ed2998ed.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , b = un( () => Pt( () => import("./HistoricalScale-ce136f72.js"), ["assets/HistoricalScale-ce136f72.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/HistoricalScale-6645aa1f.css"]))
          , E = un( () => Pt( () => import("./SpanLattice-48bd3594.js"), ["assets/SpanLattice-48bd3594.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/tempering-fb2fa385.js", "assets/SpanLattice-73777064.css"]))
          , S = un( () => Pt( () => import("./MosScale-ca713a56.js"), ["assets/MosScale-ca713a56.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/MosScale-fcd7d9b1.css"]))
          , F = un( () => Pt( () => import("./LoadPreset-6abe96f9.js"), ["assets/LoadPreset-6abe96f9.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , B = un( () => Pt( () => import("./RankTwo-c432e36e.js"), ["assets/RankTwo-c432e36e.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/tempering-fb2fa385.js", "assets/RankTwo-1c5b6710.css"]))
          , Q = un( () => Pt( () => import("./StackSteps-07367a15.js"), ["assets/StackSteps-07367a15.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , ae = un( () => Pt( () => import("./SubharmonicSeries-234e7a49.js"), ["assets/SubharmonicSeries-234e7a49.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , V = te(null)
          , k = te(null)
          , z = te(null)
          , Z = te(null)
          , re = te(!1)
          , C = te(!1)
          , D = te(!1)
          , R = te(!1)
          , W = te(!1)
          , I = te(!1)
          , N = te(!1)
          , P = te(!1)
          , J = te(!1)
          , X = te(!1)
          , ie = te(!1)
          , ce = te(!1)
          , Le = te(!1)
          , he = te(!1);
        function Fe(Se) {
            i.sourceText = Se,
            re.value = !1,
            C.value = !1,
            D.value = !1,
            R.value = !1,
            W.value = !1,
            I.value = !1,
            N.value = !1,
            P.value = !1,
            J.value = !1,
            X.value = !1,
            ie.value = !1,
            ce.value = !1,
            Le.value = !1,
            he.value = !1,
            i.computeScale(),
            r("done")
        }
        function Te() {
            i.name = "",
            i.sourceText = "",
            i.computeScale(),
            r("done")
        }
        async function ye(Se, L) {
            const K = await tG(Se, L);
            i.sourceText = K.sourceText,
            K.baseFrequency !== void 0 && (i.userBaseFrequency = K.baseFrequency,
            i.autoFrequency = !1),
            K.name !== void 0 && (i.name = K.name),
            K.baseMidiNote !== void 0 && (i.baseMidiNote = K.baseMidiNote),
            i.computeScale(),
            r("done")
        }
        function qe() {
            V.value && V.value.blur()
        }
        function Ge(Se) {
            i.userBaseFrequency = Se,
            i.autoFrequency = !1
        }
        return t({
            blur: qe
        }),
        (Se, L) => (gt(),
        Fn(Jn, null, [jt(iA, {
            ref_key: "element",
            ref: V,
            title: "New scale",
            onMouseenter: L[17] || (L[17] = K => Se.$emit("mouseenter"))
        }, {
            default: Wr( () => [se("ul", null, [se("a", {
                href: "#",
                onClick: L[0] || (L[0] = K => R.value = !0)
            }, L[51] || (L[51] = [se("li", null, "Equal temperament", -1)])), se("a", {
                href: "#",
                onClick: L[1] || (L[1] = K => ce.value = !0)
            }, L[52] || (L[52] = [se("li", null, "Rank-2 temperament", -1)])), se("a", {
                href: "#",
                onClick: L[2] || (L[2] = K => N.value = !0)
            }, L[53] || (L[53] = [se("li", null, "Harmonic series segment", -1)])), se("a", {
                href: "#",
                onClick: L[3] || (L[3] = K => he.value = !0)
            }, L[54] || (L[54] = [se("li", null, "Subharmonic series segment", -1)])), se("a", {
                href: "#",
                onClick: L[4] || (L[4] = K => D.value = !0)
            }, L[55] || (L[55] = [se("li", null, "Enumerate chord", -1)])), se("a", {
                href: "#",
                onClick: L[5] || (L[5] = K => Le.value = !0)
            }, L[56] || (L[56] = [se("li", null, "Stack steps", -1)])), se("a", {
                href: "#",
                onClick: L[6] || (L[6] = K => C.value = !0)
            }, L[57] || (L[57] = [se("li", null, "Combination product set", -1)])), se("a", {
                href: "#",
                onClick: L[7] || (L[7] = K => X.value = !0)
            }, L[58] || (L[58] = [se("li", null, "Moment of symmetry scale", -1)])), se("a", {
                href: "#",
                onClick: L[8] || (L[8] = K => P.value = !0)
            }, L[59] || (L[59] = [se("li", null, "Historical temperament", -1)])), se("a", {
                href: "#",
                onClick: L[9] || (L[9] = K => W.value = !0)
            }, L[60] || (L[60] = [se("li", null, "Euler-Fokker genus", -1)])), se("a", {
                href: "#",
                onClick: L[10] || (L[10] = K => J.value = !0)
            }, L[61] || (L[61] = [se("li", null, "Parallelotope / Lattice", -1)])), se("a", {
                href: "#",
                onClick: L[11] || (L[11] = K => I.value = !0)
            }, L[62] || (L[62] = [se("li", null, "Generator sequence", -1)])), se("a", {
                href: "#",
                onClick: L[12] || (L[12] = K => re.value = !0)
            }, L[63] || (L[63] = [se("li", null, "Concordance shell", -1)])), L[69] || (L[69] = se("li", {
                class: "divider"
            }, null, -1)), se("a", {
                href: "#",
                onClick: L[13] || (L[13] = K => k.value.click())
            }, L[64] || (L[64] = [se("li", null, "Import .scl", -1)])), se("a", {
                href: "#",
                onClick: L[14] || (L[14] = K => z.value.click())
            }, L[65] || (L[65] = [se("li", null, "Import .tun", -1)])), se("a", {
                href: "#",
                onClick: L[15] || (L[15] = K => Z.value.click())
            }, L[66] || (L[66] = [se("li", null, "Import .swi", -1)])), L[70] || (L[70] = se("li", {
                class: "divider"
            }, null, -1)), se("a", {
                href: "#",
                onClick: Te
            }, L[67] || (L[67] = [se("li", null, "Clear scale", -1)])), se("a", {
                href: "#",
                onClick: L[16] || (L[16] = K => ie.value = !0)
            }, L[68] || (L[68] = [se("li", null, "Load preset scale", -1)]))])]),
            _: 1
        }, 512), se("input", {
            type: "file",
            ref_key: "scalaFile",
            ref: k,
            accept: ".scl",
            style: {
                display: "none"
            },
            onChange: L[18] || (L[18] = K => ye("scalascl", K))
        }, null, 544), se("input", {
            type: "file",
            ref_key: "anamarkFile",
            ref: z,
            accept: ".tun",
            style: {
                display: "none"
            },
            onChange: L[19] || (L[19] = K => ye("anamark", K))
        }, null, 544), se("input", {
            type: "file",
            ref_key: "xendevsFile",
            ref: Z,
            accept: ".swi",
            style: {
                display: "none"
            },
            onChange: L[20] || (L[20] = K => ye("xendevs", K))
        }, null, 544), (gt(),
        Ut(O1, {
            to: "body"
        }, [D.value ? (gt(),
        Ut(Ee(f), {
            key: 0,
            show: D.value,
            "onUpdate:scaleName": L[21] || (L[21] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[22] || (L[22] = K => D.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), R.value ? (gt(),
        Ut(Ee(h), {
            key: 1,
            show: R.value,
            "onUpdate:scaleName": L[23] || (L[23] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[24] || (L[24] = K => R.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), W.value ? (gt(),
        Ut(Ee(p), {
            key: 2,
            show: W.value,
            "onUpdate:scaleName": L[25] || (L[25] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[26] || (L[26] = K => W.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), I.value ? (gt(),
        Ut(Ee(m), {
            key: 3,
            show: I.value,
            "onUpdate:scaleName": L[27] || (L[27] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[28] || (L[28] = K => I.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), re.value ? (gt(),
        Ut(Ee(a), {
            key: 4,
            show: re.value,
            "onUpdate:scaleName": L[29] || (L[29] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[30] || (L[30] = K => re.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), C.value ? (gt(),
        Ut(Ee(l), {
            key: 5,
            show: C.value,
            "onUpdate:scaleName": L[31] || (L[31] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[32] || (L[32] = K => C.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), N.value ? (gt(),
        Ut(Ee(g), {
            key: 6,
            show: N.value,
            "onUpdate:scaleName": L[33] || (L[33] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[34] || (L[34] = K => N.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), P.value ? (gt(),
        Ut(Ee(b), {
            key: 7,
            show: P.value,
            "onUpdate:scaleName": L[35] || (L[35] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            "onUpdate:baseFrequency": Ge,
            "onUpdate:baseMidiNote": L[36] || (L[36] = K => Ee(i).baseMidiNote = K),
            onCancel: L[37] || (L[37] = K => P.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), J.value ? (gt(),
        Ut(Ee(E), {
            key: 8,
            show: J.value,
            "onUpdate:scaleName": L[38] || (L[38] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[39] || (L[39] = K => J.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), X.value ? (gt(),
        Ut(Ee(S), {
            key: 9,
            show: X.value,
            "onUpdate:scaleName": L[40] || (L[40] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[41] || (L[41] = K => X.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), ie.value ? (gt(),
        Ut(Ee(F), {
            key: 10,
            show: ie.value,
            "onUpdate:scaleName": L[42] || (L[42] = K => Ee(i).name = K),
            "onUpdate:baseFrequency": Ge,
            "onUpdate:baseMidiNote": L[43] || (L[43] = K => Ee(i).baseMidiNote = K),
            "onUpdate:source": Fe,
            onCancel: L[44] || (L[44] = K => ie.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), ce.value ? (gt(),
        Ut(Ee(B), {
            key: 11,
            show: ce.value,
            "onUpdate:scaleName": L[45] || (L[45] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[46] || (L[46] = K => ce.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), Le.value ? (gt(),
        Ut(Ee(Q), {
            key: 12,
            show: Le.value,
            "onUpdate:scaleName": L[47] || (L[47] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[48] || (L[48] = K => Le.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), he.value ? (gt(),
        Ut(Ee(ae), {
            key: 13,
            show: he.value,
            "onUpdate:scaleName": L[49] || (L[49] = K => Ee(i).name = K),
            "onUpdate:source": Fe,
            onCancel: L[50] || (L[50] = K => he.value = !1)
        }, null, 8, ["show"])) : Kt("", !0)]))], 64))
    }
})
  , Wf = 1e-6;
function rG(n) {
    return Math.abs(Math.log(n) - Math.log(Math.round(n)))
}
function sG(n) {
    let t = 1;
    return n.forEach(e => {
        t *= e / Math.round(e)
    }
    ),
    Math.pow(t, -1 / n.length)
}
function iG(n, t=16) {
    let e = 1 / 0
      , r = 1;
    for (let i = 1; i <= t; ++i) {
        const a = i * sG(n.map(h => h * i))
          , f = n.map(h => h * a).map(rG).reduce( (h, p) => h + p);
        f + Wf < e && (e = f,
        r = a)
    }
    return r
}
function jW(n, t=16) {
    if (!n.length)
        return NaN;
    const e = n.map(i => i / n[0])
      , r = iG(e, t);
    return n[0] / r
}
function oG(n) {
    return Math.abs(Math.log(n) + Math.log(Math.round(1 / n)))
}
function aG(n) {
    let t = 1;
    return n.forEach(e => {
        t *= e * Math.round(1 / e)
    }
    ),
    Math.pow(t, 1 / n.length)
}
function lG(n, t=23) {
    let e = 1 / 0
      , r = 1;
    for (let i = 1; i <= t; ++i) {
        const a = i * aG(n.map(h => h / i))
          , f = n.map(h => h / a).map(oG).reduce( (h, p) => h + p);
        f + Wf < e && (e = f,
        r = a)
    }
    return r
}
function HW(n, t=23) {
    if (!n.length)
        return NaN;
    const e = n.map(i => i / n[0]);
    return lG(e, t) * n[0]
}
function oA(n, t) {
    const e = n.map(i => Math.round(i / t) * t);
    let r = 0;
    for (let i = 0; i < n.length; ++i)
        r = Math.max(r, Math.abs(n[i] - e[i]));
    return r
}
function aA(n, t) {
    if (!n.length)
        return {
            error: 0,
            degrees: []
        };
    let e, r = 1 / 0;
    for (let p = 0; p < n.length; ++p) {
        const m = n.map(b => b - n[p])
          , g = oA(m, t);
        g < r && (e = m,
        r = g)
    }
    const i = e.map(p => Math.round(p / t));
    let a = 1 / 0
      , l = -1 / 0
      , f = 1 / 0;
    for (let p = 0; p < i.length; ++p) {
        const m = e[p] - i[p] * t;
        a = Math.min(a, m),
        l = Math.max(l, m),
        i[p] < f && (f = i[p])
    }
    const h = .5 * Math.abs(a) + .5 * Math.abs(l);
    for (let p = 0; p < i.length; ++p)
        i[p] -= f;
    return {
        error: h,
        degrees: i
    }
}
function uG(n, t) {
    return aA(n.map(Ie.valueToCents), t)
}
function GW(n, t, e=1200) {
    const r = Ie.valueToCents(Math.abs(n[0]))
      , i = n.map(p => Ie.valueToCents(Math.abs(p)) - r);
    let a = 1 / 0
      , l = t;
    for (let p = 1; p <= t; ++p) {
        const m = oA(i, e / p);
        m + Wf < a && (a = m,
        l = p)
    }
    const f = e / l
      , h = i.map(p => Math.round(p / f));
    return {
        error: a,
        divisions: l,
        degrees: h
    }
}
function WW(n, t, e=1200) {
    const r = Ie.valueToCents(Math.abs(n[0]))
      , i = n.map(h => Ie.valueToCents(Math.abs(h)) - r);
    let a = 1 / 0
      , l = t
      , f = [];
    for (let h = 1; h <= t; ++h) {
        const {error: p, degrees: m} = aA(i, e / h);
        p + Wf < a && (a = p,
        l = h,
        f = m)
    }
    return {
        error: a,
        divisions: l,
        degrees: f
    }
}
function o1(n, t, e, r, i) {
    const a = i / e
      , l = []
      , f = Ie.valueToCents(n)
      , h = []
      , p = [];
    e: for (let m = n; m < t; ++m) {
        const g = Ie.valueToCents(m) - f
          , b = Math.round(g / a);
        if (!(Math.abs(g - b * a) > r)) {
            for (const E of l)
                if (Ie.circleDistance(g, E, i) < Wf)
                    continue e;
            l.push(g),
            h.push(m),
            p.push(b)
        }
    }
    return {
        harmonics: h,
        degrees: p
    }
}
function cG(n, t) {
    for (const e of n)
        if (!t.includes(e))
            return !1;
    return !0
}
function fG(n, t, e, r, i, a=5, l=20, f=1e4) {
    const h = i / e
      , p = o1(n, t, e, 2 * r, i).harmonics
      , m = p.shift()
      , g = [];
    function b(E, S, F) {
        if (E.length + S.length < a || g.length >= l)
            return;
        let B = !1;
        for (; S.length; ) {
            if (f-- < 0)
                return;
            const Q = [...E];
            Q.push(S.pop());
            const {error: ae, degrees: V} = uG(Q, h);
            ae <= r && (B = !0,
            b(Q, [...S], V))
        }
        if (!B) {
            for (const Q of g)
                if (cG(E, Q.harmonics))
                    return;
            g.push({
                harmonics: E,
                degrees: F
            })
        }
    }
    return p.reverse(),
    b([m], p, [0]),
    g.sort( (E, S) => S.harmonics.length - E.harmonics.length),
    g.length ? g : [o1(n, t, e, r, i)]
}
function Bd(n) {
    let t = "logarithmic"
      , e = "";
    n.isFractional() ? t = "linear" : e = n.totalCents().toFixed(1);
    const r = new ut.Interval(n,t);
    return r.label = e,
    r
}
function JW(n) {
    n = n.map(i => i.shallowClone());
    for (let i = 0; i < n.length; ++i)
        n[i].node = void 0,
        n[i].color = void 0,
        n[i].label = "";
    const t = Bd(n[n.length - 1].value)
      , r = [[Bd(t.value.div(t.value)), ...n.map(i => Bd(i.value))]];
    for (let i = 0; i < n.length - 1; ++i) {
        const a = n[i].value
          , l = [];
        for (let f = 0; f < n.length; ++f) {
            let h = n[f].value.div(a);
            f < i && (h = h.mul(t.value)),
            l[Ie.mmod(f - i, n.length)] = Bd(h)
        }
        l.push(t),
        r.push(l)
    }
    return r
}
function KW(n) {
    const t = [];
    for (let e = 0; e < n.length; ++e)
        t.push(Array(n[e].length).fill(!1));
    for (let e = 0; e < n[0].length; ++e)
        for (let r = 0; r < n.length; ++r) {
            if (t[r][e])
                continue;
            const i = n[r][e].value;
            for (let a = e + 1; a < n[0].length; ++a)
                for (let l = 0; l < n.length; ++l)
                    n[l][a].value.strictEquals(i) && (t[r][e] = !0,
                    t[l][a] = !0)
        }
    return t
}
function ZW(n, t) {
    const e = [];
    for (let r = 0; r < n.length; ++r)
        e.push(Array(n[r].length).fill(!1));
    for (let r = 0; r < n[0].length; ++r)
        for (let i = 0; i < n.length; ++i) {
            if (e[i][r])
                continue;
            const a = n[i][r];
            for (let l = r + 1; l < n[0].length; ++l)
                for (let f = 0; f < n.length; ++f)
                    Math.abs(n[f][l] - a) < t && (e[i][r] = !0,
                    e[f][l] = !0)
        }
    return e
}
function YW(n) {
    const t = [];
    if (!n.length)
        return t;
    for (let e = 0; e < n[0].length; ++e) {
        const r = [n[0][e].value];
        e: for (let i = 1; i < n.length; ++i) {
            const a = n[i][e].value;
            for (const l of r)
                if (l.strictEquals(a))
                    continue e;
            r.push(a)
        }
        t.push(r.length)
    }
    return t
}
function QW(n, t) {
    const e = [];
    if (!n.length)
        return e;
    for (let r = 0; r < n[0].length; ++r) {
        let i = 1;
        for (let a = 1; a < n.length; ++a) {
            i++;
            const l = n[a][r];
            for (let f = 0; f < a; ++f)
                if (Math.abs(n[f][r] - l) < t) {
                    i--;
                    break
                }
        }
        e.push(i)
    }
    return e
}
function XW(n) {
    const t = n.map(a => a.reduce( (l, f) => l + f, 0))
      , e = Math.min(...t)
      , r = Math.max(...t);
    if (e === r)
        return Array(n.length).fill(1);
    const i = 1 / (r - e);
    return t.map(a => (a - e) * i)
}
function kd(n, t) {
    const e = n[n.length - 1]
      , r = Math.floor(t / n.length);
    return n[Ie.mmod(t, n.length)].mul(e.pow(r))
}
const dG = Ti("modal", () => {
    const n = te("2/1")
      , t = te(Td)
      , e = te("")
      , r = te(!1)
      , [i,a] = rc( () => ut.parseChord(e.value), [])
      , l = te(2)
      , f = Ve( () => Math.max(1, i.value.length))
      , h = te(8)
      , p = te(16)
      , m = te("")
      , g = te(!1)
      , b = Ve( () => ut.parseChord(m.value))
      , E = te(5)
      , S = te(!0)
      , F = te("1 1 1 1 1")
      , B = te("1 2 3 4 5")
      , Q = Ve( () => E.value !== Math.round(E.value) || E.value < 1)
      , ae = Ve( () => Math.round(Ie.clamp(1, 1024, E.value)))
      , V = Ve( () => XE(F.value).map(De => parseInt(De, 10)))
      , k = Ve( () => XE(B.value).map(De => parseInt(De, 10)));
    function z() {
        Q.value ? (F.value = "",
        B.value = "") : (S.value = !0,
        F.value = Array(ae.value).fill("1").join(" "),
        B.value = [...Array(ae.value).keys()].map(De => (De + 1).toString()).join(" "))
    }
    function Z() {
        if (V.value.includes(NaN))
            return;
        const De = [];
        let zt = 0;
        V.value.forEach(kt => {
            zt += kt,
            De.push(zt.toString())
        }
        ),
        S.value = !1,
        E.value = zt,
        B.value = De.join(" ")
    }
    function re() {
        if (k.value.includes(NaN))
            return;
        const De = [];
        let zt = 0;
        k.value.forEach(kt => {
            De.push((kt - zt).toString()),
            zt = kt
        }
        ),
        S.value = !1,
        E.value = zt,
        F.value = De.join(" ")
    }
    const C = te(2)
      , D = te(45)
      , R = te(3);
    Jt(R, (De, zt) => {
        let kt = De < 1 || De > D.value;
        De = Ie.clamp(1, D.value, De);
        const Zn = zt < De ? 1 : -1;
        for (; D.value % De; )
            De += Zn,
            kt = !0;
        kt && (R.value = De)
    }
    ),
    Jt(D, De => {
        De % R.value && (R.value = R.value - 1)
    }
    );
    const W = te("2/1")
      , I = te(Td)
      , N = te(1)
      , P = te(5)
      , J = te("")
      , [X,ie] = rc( () => {
        let De = J.value;
        return De.includes(":") && (De = "geodiff(" + De + ")"),
        ut.parseChord(De)
    }
    , [])
      , ce = Cr([])
      , Le = te(2);
    function he(De) {
        if (isNaN(N.value) || De <= Le.value)
            return;
        const zt = I.value.value;
        if (!(zt instanceof ut.TimeMonzo) || zt.timeExponent.n)
            return;
        const kt = X.value.map(_n => _n.value);
        if (!kt.length)
            return;
        let Zn = zt.equals(Td.value);
        for (const _n of kt) {
            if (_n instanceof ut.TimeReal || _n.timeExponent.n)
                return;
            _n.isFractional() || (Zn = !1)
        }
        const be = [zt];
        let jn = new ut.TimeMonzo(new Ie.Fraction(0),[]);
        for (let _n = 0; _n < Le.value; ++_n)
            jn = jn.mul(kt[Ie.mmod(_n, kt.length)]),
            be.push(jn.reduce(zt, !0));
        if (Zn) {
            const _n = kt.map(fn => fn.dot(wS).valueOf())
              , ws = [Ml];
            let an = 0;
            for (let fn = 0; fn < Le.value; ++fn)
                an += _n[Ie.mmod(fn, _n.length)],
                ws.push(Ie.mmod(an, Ml) || Ml);
            for (let fn = Le.value; fn < De; ++fn) {
                jn = jn.mul(kt[Ie.mmod(fn, kt.length)]),
                be.push(jn.reduce(zt, !0)),
                an += _n[Ie.mmod(fn, _n.length)],
                ws.push(Ie.mmod(an, Ml) || Ml),
                ws.sort( (si, Es) => si - Es);
                const lo = Ie.falsifyConstantStructure(ws);
                if (lo) {
                    be.sort( (it, uo) => it.compare(uo));
                    const [[si,Es],[Di,ii]] = lo;
                    !kd(be, Es).div(kd(be, si)).equals(kd(be, ii).div(kd(be, Di))) && ut.hasConstantStructure(be) && ce.push(be.length * N.value)
                } else
                    ce.push(be.length * N.value)
            }
        } else
            for (let _n = Le.value; _n < De; ++_n)
                jn = jn.mul(kt[Ie.mmod(_n, kt.length)]),
                be.push(jn.reduce(zt, !0)),
                be.sort( (ws, an) => ws.compare(an)),
                ut.hasConstantStructure(be) && ce.push(be.length * N.value);
        Le.value = De
    }
    Jt([X, I, N], () => {
        Le.value = 2,
        ce.length = 0
    }
    ),
    Jt(P, De => {
        De = parseInt(De, 10),
        !(isNaN(De) || isNaN(N.value)) && (De % N.value && (P.value = Math.ceil(De / N.value) * N.value),
        De < 1 && (P.value = 1))
    }
    ),
    Jt(N, De => {
        De = parseInt(De, 10),
        !(isNaN(De) || isNaN(P.value)) && (P.value = Math.ceil(P.value / De) * De)
    }
    );
    const Fe = te(5)
      , Te = te(2)
      , ye = te(2)
      , qe = te(1)
      , Ge = te(5)
      , Se = te("none")
      , L = te("sharp")
      , K = te("sharp")
      , de = te("pyramid")
      , $e = te(12)
      , Re = te(0)
      , me = te(0)
      , T = Ve( () => Ie.clamp(1, 1e3, Math.round(Fe.value)))
      , j = Ve( () => Ie.clamp(1, 1e3, Math.round(Te.value)))
      , ge = Ve( () => Math.round(ye.value))
      , Me = Ve( () => Math.round(qe.value))
      , Oe = Ve( () => {
        const De = $e.value;
        return isNaN(De) || !isFinite(De) ? 12 : De < 2 ? 2 : Math.round(De)
    }
    )
      , Be = Ve( () => Math.abs(Ie.gcd(T.value, j.value)))
      , ze = Ve( () => T.value + j.value - Be.value)
      , Ye = Ve( () => Math.min(Math.floor(Ge.value / Be.value) * Be.value, ze.value))
      , He = Cr(Ms.makeEdoMap())
      , Ue = te(5)
      , at = te(12)
      , rt = te(5)
      , _e = Ve( () => {
        const De = Oe.value;
        return He.has(De) ? He.get(De) : [Ms.anyForEdo(De)]
    }
    )
      , xe = Ve( () => {
        const De = Ms.tamnamsInfo(T.value, j.value);
        return (De == null ? void 0 : De.name) === void 0 ? "" : De.name.split(";")[0]
    }
    )
      , Ze = Ve( () => Ms.modeInfo(T.value, j.value, {
        up: Ye.value,
        extraNames: !0
    }))
      , st = Ve( () => Ms.getHardness(ge.value, Me.value))
      , je = Ve( () => T.value * ge.value + j.value * Me.value)
      , ct = Ve( () => t.value.equals(Td) ? `${je.value}EDO` : `${je.value}ED${n.value}`)
      , Et = Ve( () => {
        const De = Ms.tamnamsInfo(Re.value, me.value);
        return (De == null ? void 0 : De.name) === void 0 ? "" : De.name
    }
    );
    Jt(Be, De => {
        Ge.value = Math.floor(Ge.value / De) * De
    }
    ),
    Jt(ze, De => {
        Ge.value = Math.min(Ge.value, De)
    }
    ),
    Jt(Ue, De => {
        at.value = Math.max(at.value, De)
    }
    );
    function It() {
        const De = Oe.value
          , zt = He.get(De) ?? [Ms.anyForEdo(De)];
        zt.sort( (kt, Zn) => kt.sizeOfLargeStep * Zn.sizeOfSmallStep - Zn.sizeOfLargeStep * kt.sizeOfSmallStep || kt.numberOfLargeSteps - Zn.numberOfLargeSteps),
        He.set(De, zt)
    }
    function Bt() {
        const De = Oe.value
          , zt = He.get(De) ?? [Ms.anyForEdo(De)];
        zt.sort( (kt, Zn) => kt.numberOfLargeSteps + kt.numberOfSmallSteps - Zn.numberOfLargeSteps - Zn.numberOfSmallSteps || kt.numberOfLargeSteps - Zn.numberOfLargeSteps),
        He.set(De, zt)
    }
    function yn() {
        const De = Oe.value;
        He.set(De, Ms.allForEdo(De, Ue.value, Math.min(De, at.value), rt.value))
    }
    const qt = te(128)
      , Nt = te("cents")
      , xt = te(0)
      , Lt = te(0)
      , pe = te(0)
      , Pe = te(0)
      , Xe = te(0)
      , ft = te(0)
      , Ht = te(0)
      , Yt = te(22)
      , $r = Ve( () => {
        const De = Yt.value;
        return isNaN(De) || !isFinite(De) || De < 1 ? 1 : Math.round(De)
    }
    )
      , Ds = te("drop")
      , xi = te("")
      , [vs,ys] = rc( () => {
        const De = xi.value;
        return De.includes(":") ? ut.evaluateExpression(De) : ut.parseChord(De)
    }
    , [])
      , as = te(10)
      , ri = te(!1)
      , Ii = te(2)
      , qs = te(0)
      , Fi = te(1.005)
      , Jo = te("")
      , Ri = te(Gz)
      , Ko = te("")
      , ro = te(W0);
    function Zo() {
        const De = ro.value.value.totalCents() / Ri.value.value.totalCents();
        De >= .001 && De <= 999.999 && (Fi.value = De)
    }
    const Mr = Cr(new Set);
    function bs(De) {
        Mr.has(De) ? Mr.delete(De) : Mr.add(De)
    }
    function so(De) {
        qs.value = Ie.clamp(0, De - 1, qs.value),
        Mr.clear(),
        Mr.add(0);
        for (let zt = 1; zt < De; ++zt)
            Mr.add(zt)
    }
    const Bs = te(3.5)
      , io = te("simplest")
      , oo = te(!1)
      , ks = te(32)
      , Pi = te("rooted")
      , ls = te(0)
      , ao = Ve( () => Pi.value === "rooted" ? [o1(ks.value, qt.value, $r.value, Bs.value, t.value.totalCents())] : fG(ks.value, qt.value, $r.value, Bs.value, t.value.totalCents()));
    Jt([ks, qt, Yt, Bs, t, Pi], () => {
        ls.value = 0
    }
    );
    const ts = te(!1)
      , x = te(!1);
    return {
        equaveString: n,
        equave: t,
        factorsString: e,
        addUnity: r,
        factors: i,
        factorsError: a,
        numElements: l,
        maxElements: f,
        integerEquave: C,
        lowInteger: h,
        highInteger: p,
        chord: m,
        retrovertChord: g,
        chordIntervals: b,
        divisions: E,
        jumpsString: F,
        degreesString: B,
        singleStepOnly: Q,
        safeScaleSize: ae,
        jumps: V,
        degrees: k,
        simpleEd: S,
        updateFromDivisions: z,
        updateFromJumps: Z,
        updateFromDegrees: re,
        guideTone: D,
        rootTone: R,
        periodString: W,
        period: I,
        numPeriods: N,
        size: P,
        generatorsString: J,
        generators: X,
        generatorsError: ie,
        constantStructureSizes: ce,
        maxSizeComputed: Le,
        computeConstantStructureSizes: he,
        numberOfLargeSteps: Fe,
        numberOfSmallSteps: Te,
        sizeOfLargeStep: ye,
        sizeOfSmallStep: qe,
        up: Ge,
        colorMethod: Se,
        parentColorAccidentals: L,
        daughterColorAccidentals: K,
        method: de,
        edo: $e,
        previewL: Re,
        previewS: me,
        safeNumLarge: T,
        safeNumSmall: j,
        safeSizeLarge: ge,
        safeSizeSmall: Me,
        boundedEdo: Oe,
        numberOfPeriods: Be,
        upMax: ze,
        safeUp: Ye,
        edoMap: He,
        minSize: Ue,
        maxSize: at,
        maxHardness: rt,
        edoList: _e,
        tamnamsName: xe,
        mosModeInfo: Ze,
        hardness: st,
        hostEd: je,
        ed: ct,
        previewName: Et,
        sortByHardness: It,
        sortBySize: Bt,
        moreForEdo: yn,
        mediumInteger: ks,
        vaoIndex: ls,
        vaos: ao,
        errorModel: Pi,
        largeInteger: qt,
        type: Nt,
        fractionTolerance: xt,
        preferredNumerator: Lt,
        preferredDenominator: pe,
        preferredEtNumerator: Pe,
        preferredEtDenominator: Xe,
        preferredEtEquaveNumerator: ft,
        preferredEtEquaveDenominator: Ht,
        largeDivisions: Yt,
        safeLargeDivisions: $r,
        offsets: vs,
        offsetsString: xi,
        offsetsError: ys,
        overflowType: Ds,
        varianceAmount: as,
        varyEquave: ri,
        numRepeats: Ii,
        newUnison: qs,
        stretchAmount: Fi,
        reference: Ri,
        referenceString: Jo,
        target: ro,
        targetString: Ko,
        calculateStretchAmount: Zo,
        selected: Mr,
        toggleSelected: bs,
        initialize: so,
        tolerance: Bs,
        coalescingAction: io,
        preserveBoundary: oo,
        simplify: ts,
        bleach: x
    }
}
)
  , hG = Ti("approximate-by-ratios", () => {
    const n = te(1)
      , t = te(0)
      , e = te(20)
      , r = te("convergents")
      , i = te(!0)
      , a = te(!1)
      , l = te(9)
      , f = te(7)
      , h = te(2)
      , p = te("")
      , m = Ve( () => Ie.clamp(3, 101, 2 * Math.floor(l.value / 2) + 1))
      , g = Ve( () => {
        const B = f.value;
        return B < 3 || B < 5 ? 3 : B < 7 ? 5 : B < 11 ? 7 : B < 13 ? 11 : B < 17 ? 13 : B < 19 ? 17 : B < 23 ? 19 : B < 29 ? 23 : B > 29 ? 29 : 3
    }
    )
      , b = Ve( () => {
        let B = 8;
        return g.value > 7 && (B = 6),
        g.value > 13 && (B = 3),
        g.value >= 29 && (B = 2),
        Ie.clamp(1, B, h.value)
    }
    );
    function E(B) {
        const Q = f.value
          , ae = parseInt(B.target.value);
        if (isNaN(ae))
            return;
        if (Ie.PRIMES.includes(ae)) {
            f.value = ae;
            return
        }
        const V = Ie.PRIMES.indexOf(f.value);
        if (ae < Q && V > 1) {
            f.value = Ie.PRIMES[V - 1];
            return
        }
        if (ae > Q && V < Ie.PRIMES.length - 1) {
            f.value = Ie.PRIMES[V + 1];
            return
        }
    }
    function S(B) {
        const Q = Ie.primeLimit(B, !1, 97);
        return Q < 1 / 0 ? `${Q}-limit` : ">97-limit"
    }
    function F(B) {
        n.value = 1,
        t.value = 0,
        p.value = B
    }
    return {
        degree: n,
        approximationIndex: t,
        maxError: e,
        method: r,
        includeSemiconvergents: i,
        includeNonMonotonic: a,
        oddLimit: l,
        primeLimit: f,
        maxExponent: h,
        safeOddLimit: m,
        safePrimeLimit: g,
        safeMaxExponent: b,
        originalSource: p,
        modifyPrimeLimit: E,
        primeLimitString: S,
        initialize: F
    }
}
)
  , pG = gs({
    __name: "ModifyScale",
    emits: ["done", "mouseenter"],
    setup(n, {expose: t, emit: e}) {
        const r = e
          , i = lu()
          , a = dG()
          , l = hG()
          , f = un( () => Pt( () => import("./ApproximateByHarmonics-19221bad.js"), ["assets/ApproximateByHarmonics-19221bad.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , h = un( () => Pt( () => import("./ApproximateByRatios-0ac54ce8.js"), ["assets/ApproximateByRatios-0ac54ce8.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , p = un( () => Pt( () => import("./ApproximateBySubharmonics-57ad0aa9.js"), ["assets/ApproximateBySubharmonics-57ad0aa9.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , m = un( () => Pt( () => import("./CoalesceDuplicates-87c5d5da.js"), ["assets/CoalesceDuplicates-87c5d5da.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , g = un( () => Pt( () => import("./ConvertType-767cbadf.js"), ["assets/ConvertType-767cbadf.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , b = un( () => Pt( () => import("./EnumerateScale-82e407a2.js"), ["assets/EnumerateScale-82e407a2.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , E = un( () => Pt( () => import("./EqualizeScale-a3d0cdbe.js"), ["assets/EqualizeScale-a3d0cdbe.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , S = un( () => Pt( () => import("./ExpandScale-e46beefb.js"), ["assets/ExpandScale-e46beefb.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , F = un( () => Pt( () => import("./MergeOffsets-465c112b.js"), ["assets/MergeOffsets-465c112b.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/MergeOffsets-926982ea.css"]))
          , B = un( () => Pt( () => import("./RandomVariance-9aaf5c33.js"), ["assets/RandomVariance-9aaf5c33.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , Q = un( () => Pt( () => import("./RepeatScale-c8dc14b6.js"), ["assets/RepeatScale-c8dc14b6.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , ae = un( () => Pt( () => import("./RotateScale-ab2a8615.js"), ["assets/RotateScale-ab2a8615.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , V = un( () => Pt( () => import("./StretchScale-df063355.js"), ["assets/StretchScale-df063355.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/StretchScale-7df60599.css"]))
          , k = un( () => Pt( () => import("./TakeSubset-0838ac94.js"), ["assets/TakeSubset-0838ac94.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/TakeSubset-5f785a4e.css"]))
          , z = un( () => Pt( () => import("./TemperScale-af9fabd1.js"), ["assets/TemperScale-af9fabd1.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/tempering-fb2fa385.js", "assets/TemperScale-85c0dcdf.css"]))
          , Z = te(null)
          , re = te(!1)
          , C = te(!1)
          , D = te(!1)
          , R = te(!1)
          , W = te(!1)
          , I = te(!1)
          , N = te(!1)
          , P = te(!1)
          , J = te(!1)
          , X = te(!1)
          , ie = te(!1)
          , ce = te(!1)
          , Le = te(!1)
          , he = te(!1)
          , Fe = te(!1);
        function Te() {
            re.value = !1,
            C.value = !1,
            D.value = !1,
            R.value = !1,
            W.value = !1,
            I.value = !1,
            N.value = !1,
            P.value = !1,
            J.value = !1,
            X.value = !1,
            ie.value = !1,
            ce.value = !1,
            Le.value = !1,
            he.value = !1,
            Fe.value = !1,
            r("done")
        }
        function ye() {
            const {visitor: Re, defaults: me} = i.getUserScopeVisitor();
            i.sourceText = Re.expand(me),
            i.computeScale(),
            r("done")
        }
        function qe() {
            i.sourceText += ";sort()",
            ye()
        }
        function Ge() {
            i.sourceText += ";reduce()",
            ye()
        }
        function Se() {
            i.sourceText += ";retrovert()",
            ye()
        }
        function L() {
            a.initialize(i.scale.size),
            ce.value = !0
        }
        function K() {
            a.initialize(i.scale.size),
            he.value = !0
        }
        function de() {
            l.initialize(i.sourceText),
            C.value = !0
        }
        function $e() {
            Z.value && Z.value.blur()
        }
        return t({
            blur: $e
        }),
        (Re, me) => (gt(),
        Fn(Jn, null, [jt(iA, {
            ref_key: "element",
            ref: Z,
            title: "Modify scale",
            onMouseenter: me[12] || (me[12] = T => Re.$emit("mouseenter"))
        }, {
            default: Wr( () => [se("ul", null, [se("a", {
                href: "#",
                onClick: me[0] || (me[0] = T => P.value = !0)
            }, me[28] || (me[28] = [se("li", null, "Expand/simplify lines", -1)])), se("a", {
                href: "#",
                onClick: qe
            }, me[29] || (me[29] = [se("li", null, "Sort ascending", -1)])), se("a", {
                href: "#",
                onClick: Ge
            }, [se("li", null, ds(Ee(CV)(Ee(i).nameOfEquave)) + " reduce", 1)]), se("a", {
                href: "#",
                onClick: Se
            }, me[30] || (me[30] = [se("li", null, "Retrovert (negative harmony)", -1)])), se("a", {
                href: "#",
                onClick: L
            }, me[31] || (me[31] = [se("li", null, "Rotate mode", -1)])), se("a", {
                href: "#",
                onClick: me[1] || (me[1] = T => ie.value = !0)
            }, me[32] || (me[32] = [se("li", null, "Repeat", -1)])), se("a", {
                href: "#",
                onClick: K
            }, me[33] || (me[33] = [se("li", null, "Subset", -1)])), se("a", {
                href: "#",
                onClick: me[2] || (me[2] = T => Le.value = !0)
            }, me[34] || (me[34] = [se("li", null, "Stretch/compress", -1)])), se("a", {
                href: "#",
                onClick: me[3] || (me[3] = T => X.value = !0)
            }, me[35] || (me[35] = [se("li", null, "Random variance", -1)])), se("a", {
                href: "#",
                onClick: me[4] || (me[4] = T => I.value = !0)
            }, me[36] || (me[36] = [se("li", null, "Enumerate", -1)])), se("a", {
                href: "#",
                onClick: me[5] || (me[5] = T => W.value = !0)
            }, me[37] || (me[37] = [se("li", null, "Coalesce duplicates", -1)])), se("a", {
                href: "#",
                onClick: de
            }, me[38] || (me[38] = [se("li", null, "Approximate by ratios", -1)])), se("a", {
                href: "#",
                onClick: me[6] || (me[6] = T => re.value = !0)
            }, me[39] || (me[39] = [se("li", null, "Approximate by harmonics", -1)])), se("a", {
                href: "#",
                onClick: me[7] || (me[7] = T => D.value = !0)
            }, me[40] || (me[40] = [se("li", null, "Approximate by subharmonics", -1)])), se("a", {
                href: "#",
                onClick: me[8] || (me[8] = T => N.value = !0)
            }, me[41] || (me[41] = [se("li", null, "Equalize", -1)])), se("a", {
                href: "#",
                onClick: me[9] || (me[9] = T => Fe.value = !0)
            }, me[42] || (me[42] = [se("li", null, "Temper", -1)])), se("a", {
                href: "#",
                onClick: me[10] || (me[10] = T => J.value = !0)
            }, me[43] || (me[43] = [se("li", null, "Merge offsets", -1)])), se("a", {
                href: "#",
                onClick: me[11] || (me[11] = T => R.value = !0)
            }, me[44] || (me[44] = [se("li", null, "Convert interval values", -1)]))])]),
            _: 1
        }, 512), (gt(),
        Ut(O1, {
            to: "body"
        }, [re.value ? (gt(),
        Ut(Ee(f), {
            key: 0,
            show: re.value,
            onDone: Te,
            onCancel: me[13] || (me[13] = T => re.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), C.value ? (gt(),
        Ut(Ee(h), {
            key: 1,
            show: C.value,
            onDone: Te,
            onCancel: me[14] || (me[14] = T => C.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), D.value ? (gt(),
        Ut(Ee(p), {
            key: 2,
            show: D.value,
            onDone: Te,
            onCancel: me[15] || (me[15] = T => D.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), W.value ? (gt(),
        Ut(Ee(m), {
            key: 3,
            show: W.value,
            onDone: Te,
            onCancel: me[16] || (me[16] = T => W.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), R.value ? (gt(),
        Ut(Ee(g), {
            key: 4,
            show: R.value,
            onDone: Te,
            onCancel: me[17] || (me[17] = T => R.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), I.value ? (gt(),
        Ut(Ee(b), {
            key: 5,
            show: I.value,
            onDone: Te,
            onCancel: me[18] || (me[18] = T => I.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), N.value ? (gt(),
        Ut(Ee(E), {
            key: 6,
            show: N.value,
            onDone: Te,
            onCancel: me[19] || (me[19] = T => N.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), P.value ? (gt(),
        Ut(Ee(S), {
            key: 7,
            show: P.value,
            onDone: Te,
            onCancel: me[20] || (me[20] = T => P.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), J.value ? (gt(),
        Ut(Ee(F), {
            key: 8,
            show: J.value,
            onDone: Te,
            onCancel: me[21] || (me[21] = T => J.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), X.value ? (gt(),
        Ut(Ee(B), {
            key: 9,
            show: X.value,
            onDone: Te,
            onCancel: me[22] || (me[22] = T => X.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), ie.value ? (gt(),
        Ut(Ee(Q), {
            key: 10,
            show: ie.value,
            onDone: Te,
            onCancel: me[23] || (me[23] = T => ie.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), ce.value ? (gt(),
        Ut(Ee(ae), {
            key: 11,
            show: ce.value,
            onDone: Te,
            onCancel: me[24] || (me[24] = T => ce.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), Le.value ? (gt(),
        Ut(Ee(V), {
            key: 12,
            show: Le.value,
            onDone: Te,
            onCancel: me[25] || (me[25] = T => Le.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), he.value ? (gt(),
        Ut(Ee(k), {
            key: 13,
            show: he.value,
            onDone: Te,
            onCancel: me[26] || (me[26] = T => he.value = !1)
        }, null, 8, ["show"])) : Kt("", !0), Fe.value ? (gt(),
        Ut(Ee(z), {
            key: 14,
            show: Fe.value,
            onDone: Te,
            onCancel: me[27] || (me[27] = T => Fe.value = !1)
        }, null, 8, ["show"])) : Kt("", !0)]))], 64))
    }
})
  , mG = {
    key: 0,
    width: "100%",
    height: "10"
}
  , gG = ["x1", "x2"]
  , vG = {
    key: 1,
    width: "10",
    height: "100%"
}
  , yG = ["y1", "y2"]
  , bG = gs({
    __name: "ScaleRule",
    props: {
        scale: {},
        orientation: {}
    },
    setup(n) {
        const t = n
          , e = Ve( () => {
            const r = Ie.valueToCents(t.scale.equaveRatio)
              , i = [];
            for (let a = 0; a < t.scale.size; ++a) {
                const f = Ie.valueToCents(t.scale.intervalRatios[a]) / r;
                let h = "var(--color-text)";
                f < 0 ? h = "blue" : f > 1 && (h = "red"),
                !isNaN(f) && isFinite(f) && i.push([`${.5 + 99 * Ie.mmod(f, 1)}%`, h])
            }
            return i.push(["99.5%", "var(--color-text)"]),
            i
        }
        );
        return (r, i) => r.orientation === "horizontal" ? (gt(),
        Fn("svg", mG, [i[0] || (i[0] = se("line", {
            x1: "0.5%",
            y1: "50%",
            x2: "99.5%",
            y2: "50%",
            style: {
                stroke: "var(--color-text)"
            }
        }, null, -1)), (gt(!0),
        Fn(Jn, null, fh(e.value, ([a,l], f) => (gt(),
        Fn("line", {
            key: f,
            x1: a,
            y1: "5%",
            x2: a,
            y2: "95%",
            style: Na("stroke:" + l + ";")
        }, null, 12, gG))), 128))])) : (gt(),
        Fn("svg", vG, [i[1] || (i[1] = se("line", {
            y1: "0.5%",
            x1: "50%",
            y2: "99.5%",
            x2: "50%",
            style: {
                stroke: "var(--color-text)"
            }
        }, null, -1)), (gt(!0),
        Fn(Jn, null, fh(e.value, ([a,l], f) => (gt(),
        Fn("line", {
            key: f,
            y1: a,
            x1: "5%",
            y2: a,
            x2: "95%",
            style: Na("stroke:" + l + ";")
        }, null, 12, yG))), 128))]))
    }
})
  , q_ = {
    "": "Natural sign. Signifies no change in pitch.",
    "": "Sharp sign. Raises pitch by <code>2187/2048</code>. E.g. F sharp four is spelled <code>F4</code>.",
    "": "Flat sign. Lowers pitch by <code>2187/2048</code>. E.g. B flat four is spelled <code>B4</code>.",
    "": "Double sharp sign. Raises pitch by <code>4782969/4194304</code>.",
    "": "Double flat sign. Lowers pitch by <code>4782969/4194304</code>.",
    : "Augmented interval quality. Capital A is reserved for absolute pitch so circumflexed <code>4</code> offers and alternative to <code>a4</code>.",
    "": "Quarter sharp sign. Raises pitch by <code>sqrt(2187/2048)</code>.",
    "": "Quarter sharp sign. Raises pitch by <code>sqrt(2187/2048)</code>.",
    "": "Quarter flat sign. Lowers pitch by <code>sqrt(2187/2048)</code>.",
    "": "Syntonic up sign. Raises pitch by <code>81/80</code>.",
    "": "Syntonic down sign. Lowers pitch by <code>81/80</code>.",
    "": "Sharp syntonic down sign. Raises pitch by <code>135/128</code>.",
    "": "Flat syntonic up sign. Lowers pitch by <code>135/128</code>.",
    "": "Sharp syntonic up sign. Raises pitch by <code>177147/163840</code>.",
    "": "Flat syntonic down sign. Lowers pitch by <code>177147/163840</code>.",
    "": "Semi-prefix. E.g. G semisharp four <code>G4</code>, semimajor third <code>M3</code>, perfect sesquith <code>P1</code>.",
    "": "Quarter-prefix. E.g. E quarter flat four <code>E4</code>.",
    "": "Sesqui-semi-prefix. E.g. D sesqui semisharp four <code>D4</code>.",
    "": "One-third-prefix. E.g. Third-major second <code>M2</code>.",
    "": "Two-thirds-prefix. E.g. E two-thirds flat four <code>E4</code>.",
    "": "Popped scale. E.g. <code> rdc [-1]</code> reduces all intervals in your scale by the equave.",
    "": "Times symbol. E.g. <code>4/3  4/3</code> is <code>16/9</code>.",
    "": "Division symbol. E.g. <code>9/8  81/80</code> is <code>10/9</code>.",
    "": "Dot product. E.g. <code>12@  3/2</code> is <code>7</code> i.e. a fifth is seven steps of 12-tone equal temperament.",
    "": "Square root. E.g. <code>9</code> is <code>3</code>.",
    "": "Tensoring symbol. Calculate all products between two arrays. E.g. <code>[9/8, 4/3, 3/2][1/1, 5/4]</code>.",
    "": "Reciprocal of the sum of of reciprocals. E.g. <code>23</code>.",
    "": "Reciprocal of the difference of reciprocals. E.g. <code>9/86</code>.",
    : "Interordinal nominal alpha. <code>4</code> is a semioctave below <code>A4</code>.",
    : "Interordinal nominal beta. <code>4</code> is a semioctave below <code>B4</code>.",
    : "Interordinal nominal gamma. <code>4</code> is a semioctave above <code>C4</code>.",
    : "Interordinal nominal delta. <code>4</code> is a semioctave above <code>D4</code>.",
    : "Interordinal nominal epsilon. <code>4</code> is a semioctave above <code>E4</code>.",
    : "Interordinal nominal zeta. <code>4</code> is a semioctave above <code>F4</code>.",
    : "Interordinal nominal eta. <code>4</code> is a semioctave below <code>G4</code>.",
    : "Interordinal nominal phi. <code>4</code> is a semifourth above <code>C4</code>.",
    : "Interordinal nominal chi. <code>4</code> is 9/8 above <code>4</code>.",
    : "Interordinal nominal psi. <code>4</code> is a semifourth below <code>C5</code>.",
    : "Interordinal nominal omega. <code>4</code> is 9/8 above <code>4</code>.",
    "": "Cent. <code>1</code> is equal to <code>1\\1200</code>.",
    : "Metric prefix micro. E.g. Period of oscillation <code>2000 s</code> corresponds to frequency of oscillation <code>500 Hz</code>.",
    "": "Val angle bracket. <code>12 19 28]</code>.",
    "": "Monzo angle bracket. <code>[-4 4 -1</code>."
}
  , wG = {
    class: "control-group"
}
  , EG = {
    class: "control"
}
  , _G = {
    class: "midi-name"
}
  , LG = {
    class: "control"
}
  , SG = ["disabled"]
  , AG = {
    class: "control checkbox-container"
}
  , CG = {
    class: "control-group"
}
  , $G = ["disabled"]
  , MG = ["disabled"]
  , OG = {
    class: "control"
}
  , NG = {
    key: 0,
    class: "error"
}
  , TG = {
    key: 1,
    class: "warning"
}
  , xG = {
    class: "control"
}
  , IG = ["innerHTML"]
  , FG = {
    class: "control-group"
}
  , RG = {
    class: "control radio-group"
}
  , PG = gs({
    __name: "ScaleControls",
    setup(n, {expose: t}) {
        const e = lu()
          , r = nc(e.computeScale)
          , i = te(null)
          , a = te("");
        function l(m) {
            const g = m.target.textContent;
            a.value = q_[g] ?? ""
        }
        function f() {
            a.value = ""
        }
        function h(m) {
            if (!i.value)
                return;
            const g = m.target.textContent
              , b = i.value.selectionStart
              , E = i.value.selectionEnd;
            e.sourceText = e.sourceText.substring(0, b) + g + e.sourceText.substring(E, e.sourceText.length),
            r()
        }
        function p() {
            i.value && i.value.focus()
        }
        return t({
            focus: p,
            clearPaletteInfo: f
        }),
        (m, g) => (gt(),
        Fn(Jn, null, [se("div", wG, [se("div", EG, [g[16] || (g[16] = se("label", {
            for: "base-midi-note"
        }, "MIDI note for base frequency", -1)), So(se("input", {
            id: "base-midi-note",
            type: "number",
            step: "1",
            "onUpdate:modelValue": g[0] || (g[0] = b => Ee(e).baseMidiNote = b),
            onInput: g[1] || (g[1] = b => Ee(r)())
        }, null, 544), [[Jd, Ee(e).baseMidiNote]]), se("span", _G, ds(Ee(Af)(Ee(e).baseMidiNote, -1, Ee(e).accidentalPreference)), 1)]), se("div", LG, [g[17] || (g[17] = se("label", {
            for: "base-frequency"
        }, "Base frequency", -1)), So(se("input", {
            id: "base-frequency",
            type: "number",
            step: "any",
            "onUpdate:modelValue": g[2] || (g[2] = b => Ee(e).baseFrequencyDisplay = b),
            disabled: Ee(e).autoFrequency,
            onInput: g[3] || (g[3] = b => Ee(r)())
        }, null, 40, SG), [[Jd, Ee(e).baseFrequencyDisplay]])]), se("div", AG, [So(se("input", {
            id: "auto-frequency",
            type: "checkbox",
            "onUpdate:modelValue": g[4] || (g[4] = b => Ee(e).autoFrequency = b),
            onInput: g[5] || (g[5] = b => Ee(r)())
        }, null, 544), [[$5, Ee(e).autoFrequency]]), g[18] || (g[18] = se("label", {
            for: "auto-frequency"
        }, "Automatic base frequency", -1))])]), se("div", CG, [se("h2", null, [g[19] || (g[19] = se("span", {
            class: "scale-data-header"
        }, "Scale data", -1)), se("button", {
            class: "undo",
            disabled: Ee(e).history.undoDisabled,
            onClick: g[6] || (g[6] = (...b) => Ee(e).history.undo && Ee(e).history.undo(...b))
        }, null, 8, $G), se("button", {
            class: "redo",
            disabled: Ee(e).history.redoDisabled,
            onClick: g[7] || (g[7] = (...b) => Ee(e).history.redo && Ee(e).history.redo(...b))
        }, null, 8, MG)]), se("div", OG, [So(se("textarea", {
            id: "scale-data",
            ref_key: "sourceEditor",
            ref: i,
            rows: "20",
            "onUpdate:modelValue": g[8] || (g[8] = b => Ee(e).sourceText = b),
            onInput: g[9] || (g[9] = b => Ee(r)()),
            onFocus: f
        }, null, 544), [[Jd, Ee(e).sourceText]])]), jt(bG, {
            scale: Ee(e).scale,
            orientation: "horizontal"
        }, null, 8, ["scale"]), Ee(e).error ? (gt(),
        Fn("p", NG, ds(Ee(e).error), 1)) : Ee(e).warning ? (gt(),
        Fn("p", TG, ds(Ee(e).warning), 1)) : Kt("", !0), g[20] || (g[20] = se("h3", null, "Character palette", -1)), se("div", xG, [(gt(!0),
        Fn(Jn, null, fh(Ee(q_), (b, E, S) => (gt(),
        Fn("button", {
            key: S,
            onClick: h,
            onMouseenter: l
        }, ds(E), 33))), 128))]), se("p", {
            class: "info",
            innerHTML: a.value
        }, null, 8, IG)]), se("div", FG, [se("div", RG, [g[24] || (g[24] = se("label", null, "Automatic Colors", -1)), se("span", null, [So(se("input", {
            type: "radio",
            id: "colors-silver",
            value: "silver",
            "onUpdate:modelValue": g[10] || (g[10] = b => Ee(e).autoColors = b),
            onInput: g[11] || (g[11] = b => Ee(r)())
        }, null, 544), [[hv, Ee(e).autoColors]]), g[21] || (g[21] = se("label", {
            for: "colors-silver"
        }, "Silver", -1))]), se("span", null, [So(se("input", {
            type: "radio",
            id: "colors-cents",
            value: "cents",
            "onUpdate:modelValue": g[12] || (g[12] = b => Ee(e).autoColors = b),
            onInput: g[13] || (g[13] = b => Ee(r)())
        }, null, 544), [[hv, Ee(e).autoColors]]), g[22] || (g[22] = se("label", {
            for: "colors-cents"
        }, "Cents", -1))]), se("span", null, [So(se("input", {
            type: "radio",
            id: "colors-factors",
            value: "factors",
            "onUpdate:modelValue": g[14] || (g[14] = b => Ee(e).autoColors = b),
            onInput: g[15] || (g[15] = b => Ee(r)())
        }, null, 544), [[hv, Ee(e).autoColors]]), g[23] || (g[23] = se("label", {
            for: "colors-factors"
        }, "Factors", -1))])])])], 64))
    }
});
const Jf = (n, t) => {
    const e = n.__vccOpts || n;
    for (const [r,i] of t)
        e[r] = i;
    return e
}
  , DG = Jf(PG, [["__scopeId", "data-v-2362aa12"]])
  , qG = gs({
    __name: "TuningTableRow",
    props: {
        index: {},
        frequency: {},
        cents: {},
        ratio: {},
        label: {},
        color: {},
        active: {
            type: Boolean
        },
        isRoot: {
            type: Boolean
        },
        equave: {
            type: Boolean
        }
    },
    setup(n) {
        const t = n
          , e = te(null);
        return If( () => {
            const r = window.matchMedia("screen and (min-width: 600px)").matches;
            t.isRoot && r && e.value.scrollIntoView({
                block: "center"
            })
        }
        ),
        (r, i) => (gt(),
        Fn("tr", {
            ref_key: "element",
            ref: e,
            class: Of({
                active: r.active,
                equave: r.equave
            }),
            style: Na("background-color:" + r.color + ";")
        }, [se("td", {
            class: "key-color",
            style: Na("background-color:" + r.color + " !important;")
        }, null, 4), se("td", null, ds(r.index), 1), se("td", null, ds(Ee(xV)(r.frequency)), 1), se("td", null, ds(Ee(rm)(r.cents)), 1), se("td", null, ds(Ee(rm)(r.ratio)), 1), se("td", null, ds(r.label), 1)], 6))
    }
});
const BG = Jf(qG, [["__scopeId", "data-v-cfba1c6d"]])
  , kG = gs({
    __name: "TuningTable",
    props: {
        baseFrequency: {},
        frequencies: {},
        centss: {},
        heldNotes: {},
        baseMidiNote: {},
        labels: {},
        colors: {}
    },
    setup(n) {
        const t = n
          , e = Ve( () => {
            const r = 1 / t.baseFrequency;
            return t.frequencies.map( (i, a) => {
                const l = (t.heldNotes.get(a) ?? 0) > 0
                  , f = a - t.baseMidiNote
                  , h = i * r
                  , p = t.centss[a];
                return {
                    index: a,
                    active: l,
                    frequency: i,
                    cents: p,
                    ratio: h,
                    label: t.labels[Ie.mmod(f - 1, t.labels.length)],
                    color: t.colors[Ie.mmod(f - 1, t.colors.length)],
                    isRoot: f === 0,
                    equave: Ie.mmod(f, t.labels.length) === 0
                }
            }
            )
        }
        );
        return (r, i) => (gt(),
        Fn("table", null, [i[0] || (i[0] = se("thead", null, [se("tr", null, [se("th", null, ""), se("th", null, "#"), se("th", null, "Freq"), se("th", null, "Cents"), se("th", null, "Ratio"), se("th", null, "Label")])], -1)), se("tbody", null, [(gt(!0),
        Fn(Jn, null, fh(e.value, a => (gt(),
        Ut(BG, ZL({
            key: a.index,
            ref_for: !0
        }, a), null, 16))), 128))])]))
    }
});
const zG = Jf(kG, [["__scopeId", "data-v-cc659c7b"]]);
class ni {
    constructor(t) {
        St(this, "params");
        this.params = t,
        this.validateParams()
    }
    validateParams() {
        for (const t of this.params.relativeIntervals)
            if (!t.isRelative())
                throw new Error("Intervals must be given relative to the base frequency.")
    }
    saveFile(t, e, r=!1, i="application/octet-stream,") {
        const a = document.createElement("a");
        if (a.download = t,
        r) {
            const l = new Blob([e],{
                type: "application/octet-stream"
            });
            a.href = window.URL.createObjectURL(l)
        } else
            a.href = "data:" + i + encodeURIComponent(e);
        a.dispatchEvent(new MouseEvent("click",{
            bubbles: !0,
            cancelable: !0,
            view: window
        }))
    }
}
const ac = class ac extends ni {
    constructor(e) {
        super(e);
        St(this, "name");
        St(this, "appTitle");
        this.name = e.scale.title || "Untitled tuning",
        this.appTitle = e.appTitle || no
    }
    getFileContents() {
        var f;
        const e = this.params.newline
          , r = this.params.relativeIntervals
          , i = this.params.labels
          , a = this.params.centsFractionDigits ?? 6;
        let l = "! " + this.params.filename + ".scl" + e;
        l += "! Created using " + this.appTitle + e,
        l += "!" + e,
        l += "! " + this.params.scaleUrl + e,
        l += "!" + e,
        l += this.name,
        l += e + " ",
        l += r.length.toString() + e,
        l += "!" + e;
        for (let h = 0; h < r.length; h++) {
            const p = r[h].value.abs();
            if (l += " ",
            p.isFractional()) {
                const {numerator: m, denominator: g} = p.toBigNumeratorDenominator();
                m <= ac.maxInteger && g <= ac.maxInteger ? l += `${m}/${g}` : l += p.toCents().toFixed(a)
            } else
                l += p.toCents().toFixed(a);
            (f = i[h]) != null && f.length && (l += i[h]),
            l += e
        }
        return l
    }
    saveFile() {
        super.saveFile(this.params.filename + ".scl", this.getFileContents())
    }
}
;
St(ac, "maxInteger", 2147483647n);
let a1 = ac;
class VG extends ni {
    constructor(t) {
        super(t)
    }
    getFileContents() {
        const t = this.params.newline
          , e = this.params.relativeIntervals
          , r = this.params.scale.baseFrequency
          , i = this.params.scale.baseMidiNote;
        let a = "! Template for a keyboard mapping" + t;
        a += "!" + t,
        a += "! Size of map. The pattern repeats every so many keys:" + t,
        a += e.length.toString() + t,
        a += "! First MIDI note number to retune:" + t,
        a += "0" + t,
        a += "! Last MIDI note number to retune:" + t,
        a += "127" + t,
        a += "! Middle note where the first entry of the mapping is mapped to:" + t,
        a += i.toString() + t,
        a += "! Reference note for which frequency is given:" + t,
        a += i.toString() + t,
        a += "! Frequency to tune the above note to" + t,
        a += r.toString() + t,
        a += "! Scale degree to consider as formal octave (determines difference in pitch" + t,
        a += "! between adjacent mapping patterns):" + t,
        a += e.length.toString() + t,
        a += "! Mapping." + t,
        a += "! The numbers represent scale degrees mapped to keys. The first entry is for" + t,
        a += "! the given middle note, the next for subsequent higher keys." + t,
        a += '! For an unmapped key, put in an "x". At the end, unmapped keys may be left out.' + t;
        for (let l = 0; l < e.length; l++)
            a += l + t;
        return a
    }
    saveFile() {
        super.saveFile(this.params.filename + ".kbm", this.getFileContents())
    }
}
const No = class No extends ni {
    constructor(e, r) {
        super(e);
        St(this, "version");
        St(this, "appTitle");
        St(this, "date");
        St(this, "sourceText");
        if (e.sourceText === void 0)
            throw new Error("Missing text lines");
        this.version = r,
        this.appTitle = e.appTitle || no,
        this.date = e.date || new Date,
        this.sourceText = e.sourceText
    }
    getFileContents() {
        const e = this.params.newline
          , r = this.params.relativeIntervals
          , i = this.params.scale
          , a = this.params.filename;
        let l = "; VAZ Plus/AnaMark softsynth tuning file" + e;
        if (l += "; " + this.params.scale.title + e,
        l += ";" + e,
        this.version >= 200 || this.params.scaleUrl.length <= 508)
            l += "; " + this.params.scaleUrl + e;
        else
            for (const f of this.sourceText.split(kf))
                l += "; " + f + e;
        l += ";" + e,
        l += "; VAZ Plus section" + e,
        l += "[Tuning]" + e;
        for (let f = 0; f < No.tuningMaxSize; f++) {
            const h = i.getFrequency(f)
              , p = Ie.valueToCents(h / No.baseFrequency);
            l += "note " + f.toString() + "=" + Math.round(p).toString() + e
        }
        l += e + "; AnaMark section" + e,
        l += "[Scale Begin]" + e,
        l += 'Format= "AnaMark-TUN"' + e,
        l += "FormatVersion= " + this.version.toString() + e,
        l += 'FormatSpecs= "http://www.mark-henning.de/eternity/tuningspecs.html"' + e + e,
        l += "[Info]" + e,
        l += 'Name= "' + a + '.tun"' + e,
        l += 'ID= "' + a.replace(/ /g, "") + '.tun"' + e,
        l += 'Filename= "' + a + '.tun"' + e,
        l += 'Description= "' + this.params.description + '"' + e,
        l += 'Date= "' + this.date.toISOString().slice(0, 10) + '"' + e,
        l += 'Editor= "' + this.appTitle + '"' + e + e,
        l += "[Exact Tuning]" + e;
        for (let f = 0; f < No.tuningMaxSize; f++) {
            const h = i.getFrequency(f)
              , p = Ie.valueToCents(h / No.baseFrequency);
            l += "note " + f + "= " + p.toFixed(6) + e
        }
        if (this.version >= 200) {
            l += e + "[Functional Tuning]" + e;
            for (let f = 1; f <= r.length; f++)
                f === r.length ? l += "note " + f + '="#>-' + f + " % " + r[f - 1].totalCents(!0).toFixed(6) + ' ~999"' + e : l += "note " + f + '="#=0 % ' + r[f - 1].totalCents(!0).toFixed(6) + '"' + e;
            l += e + "; Set reference key to absolute frequency (not scale note but midi key)" + e,
            l += "note " + i.baseMidiNote + '="! ' + i.baseFrequency.toFixed(6) + '"' + e
        }
        return l += e + "[Scale End]" + e,
        l
    }
    saveFile() {
        super.saveFile(this.params.filename + ".tun", this.getFileContents())
    }
}
;
St(No, "tuningMaxSize", 128),
St(No, "baseFrequency", Ie.mtof(0));
let dm = No;
class UG extends dm {
    constructor(t) {
        super(t, 100)
    }
}
class jG extends dm {
    constructor(t) {
        super(t, 200)
    }
}
const To = class To extends ni {
    constructor(e) {
        super(e);
        St(this, "appTitle");
        if (e.sourceText === void 0)
            throw new Error("Missing text lines");
        this.appTitle = e.appTitle || no
    }
    getFileContents() {
        const e = this.params.newline
          , r = this.params.scale.baseMidiNote;
        let i = "{**************************************" + e;
        i += this.params.scale.title + e,
        i += "MIDI note " + r.toString() + " (" + Af(r, this.params.midiOctaveOffset) + ") = " + this.params.scale.baseFrequency.toString() + " Hz" + e,
        i += "Created using " + this.appTitle + e + e,
        i += this.params.scaleUrl + e,
        i += "****************************************}" + e + e,
        i += "on init" + e,
        i += "declare %keynum[" + To.tuningMaxSize + "]" + e,
        i += "declare %tune[" + To.tuningMaxSize + "]" + e,
        i += "declare $bend" + e,
        i += "declare $key" + e + e;
        for (let a = 0; a < To.tuningMaxSize; a++) {
            const [l,f] = Ie.ftom(this.params.scale.getFrequency(a));
            l < 0 || l >= To.tuningMaxSize ? (i += "%keynum[" + a + "] := " + a + e,
            i += "%tune[" + a + "] := 0" + e) : (i += "%keynum[" + a + "] := " + l + e,
            i += "%tune[" + a + "] := " + (f * 1e3).toFixed() + e)
        }
        return i += "end on" + e + e,
        i += "on note" + e,
        i += "$key := %keynum[$EVENT_NOTE]" + e,
        i += "$bend := %tune[$EVENT_NOTE]" + e,
        i += "change_note ($EVENT_ID, $key)" + e,
        i += "change_tune ($EVENT_ID, $bend, 0)" + e,
        i += "end on" + e,
        i
    }
    saveFile() {
        super.saveFile(this.params.filename + ".txt", this.getFileContents())
    }
}
;
St(To, "tuningMaxSize", 128),
St(To, "baseFrequency", Ie.mtof(0));
let l1 = To;
const Il = class Il extends ni {
    constructor(e) {
        super(e);
        St(this, "appTitle");
        this.appTitle = e.appTitle || no
    }
    getFileContents(e=-256, r=256) {
        const i = this.params.newline;
        let a = this.params.description + i + "Reference for Deflemask note input - generated by " + this.appTitle + i + i;
        a += this.params.scaleUrl + i + i;
        for (let l = e; l <= r; l++) {
            const f = this.params.scale.getFrequency(l)
              , [h,p] = Ie.ftom(f);
            if (h < Il.minNote || h > Il.maxNote)
                continue;
            let m = Af(h, this.params.midiOctaveOffset);
            m = m.length == 2 ? m.slice(0, 1) + "-" + m.slice(1) : m;
            const g = Math.round(128 + p * 1.28).toString(16).toUpperCase()
              , b = "[" + m + " xx] [xx E5 " + g + "]";
            a += b + " ..... " + l + ": " + f.toFixed(2) + " Hz / " + Ie.frequencyToCentOffset(f).toFixed(2) + " cents" + i
        }
        return a
    }
    saveFile() {
        super.saveFile(this.params.filename + ".txt", this.getFileContents())
    }
}
;
St(Il, "minNote", 1),
St(Il, "maxNote", 95);
let u1 = Il;
const Sr = class Sr extends ni {
    constructor(e) {
        super(e);
        St(this, "params");
        this.params = e
    }
    getFileContents(e) {
        const r = this.params.scale
          , i = Math.log2(this.params.scale.baseFrequency / 440)
          , a = new ArrayBuffer(121 * 24)
          , l = new Float64Array(a)
          , f = new Uint32Array(a);
        for (let m = 0; m < Sr.numberOfNotes; m++) {
            const g = (m - 69) * 100
              , E = ((Ie.frequencyToCentOffset(r.getFrequency(m)) - g) / 1200 + i) / e * .5 + .5
              , S = Ie.clamp(0, 1, E);
            l[m * 3 + 1] = S,
            m !== 0 && (l[m * 3] = Sr.xStride,
            f[m * 6 + 4] = 0,
            f[m * 6 + 5] = Sr.curveData)
        }
        const h = new Uint8Array(Sr.headerBytes.length + a.byteLength + Sr.endingBytes.length);
        let p = 0;
        return h.set(Sr.headerBytes, p),
        p += Sr.headerBytes.length,
        h.set(new Uint8Array(a), p),
        p += a.byteLength,
        h.set(Sr.endingBytes, p),
        h
    }
    saveHarmorPitchMap() {
        super.saveFile(this.params.filename + ".fnv", this.getFileContents(5), !0)
    }
    saveSytrusPitchMap() {
        super.saveFile(this.params.filename + ".fnv", this.getFileContents(4), !0)
    }
}
;
St(Sr, "numberOfNotes", 121),
St(Sr, "headerBytes", Uint8Array.from([3, 0, 0, 0, 3, 0, 0, 0, Sr.numberOfNotes, 0, 0, 0])),
St(Sr, "endingBytes", Uint8Array.from([0, 0, 0, 0, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255])),
St(Sr, "xStride", 1 / Sr.numberOfNotes),
St(Sr, "curveData", 33554432);
let hm = Sr;
class HG extends hm {
    saveFile() {
        super.saveHarmorPitchMap()
    }
}
class GG extends hm {
    saveFile() {
        super.saveSytrusPitchMap()
    }
}
const pm = class pm extends ni {
    getFileContents() {
        let t = "";
        for (let e = 0; e < pm.tuningMaxSize; e++)
            t += this.params.scale.getFrequency(e).toFixed(7) + ";" + this.params.newline;
        return t
    }
    saveFile() {
        super.saveFile(this.params.filename + ".txt", this.getFileContents())
    }
}
;
St(pm, "tuningMaxSize", 128);
let c1 = pm;
const mm = class mm extends ni {
    getFileContents() {
        const t = this.params.newline
          , e = mm.tuningMaxSize;
        let r = "%XenSetup" + t
          , i = "";
        for (let a = 0; a < e; a++) {
            const [l,f] = Ie.ftom(this.params.scale.getFrequency(a));
            l < 0 || l >= e ? (r += "0" + t,
            i += "0" + t) : (r += (l - a).toString() + t,
            i += (f * 100).toFixed() + t)
        }
        return r += i,
        r += "0" + t,
        r
    }
    saveFile() {
        super.saveFile(this.params.filename + ".nka", this.getFileContents())
    }
}
;
St(mm, "tuningMaxSize", 128);
let f1 = mm;
const lc = class lc extends ni {
    constructor(e) {
        super(e);
        St(this, "name");
        St(this, "appTitle");
        this.name = e.scale.title || "Untitled tuning",
        this.appTitle = e.appTitle || no
    }
    getFileContents() {
        const e = this.params.newline
          , r = this.params.relativeIntervals
          , i = this.params.labels
          , a = this.params.scale.baseFrequency.toFixed(8);
        let l = "! " + this.params.filename + ".ascl" + e;
        l += "! Created using " + this.appTitle + e,
        l += "!" + e,
        l += this.name + e,
        l += "!" + e,
        l += `! default tuning: degree 0 = ${a} Hz` + e,
        l += "!" + e,
        l += r.length.toString() + e,
        l += "!" + e;
        const f = [];
        for (let p = 0; p < r.length; p++) {
            const m = r[p].value.abs();
            if (m.isFractional()) {
                const {numerator: g, denominator: b} = m.toBigNumeratorDenominator();
                g <= lc.maxInteger && b <= lc.maxInteger ? l += `${g}/${b}` : l += m.toCents().toFixed(8)
            } else
                l += m.toCents().toFixed(8);
            l += " ! " + i[p] + e,
            f.push('"' + i[p].replace('"', "") + '"')
        }
        f.length && f.unshift(f.pop());
        const h = Math.floor(Ie.ftom(this.params.scale.baseFrequency)[0] / 12) - 1;
        return l += "!" + e,
        l += "! @ABL NOTE_NAMES " + f.join(" ") + e,
        l += `! @ABL REFERENCE_PITCH ${h} 0 ${a}` + e,
        l += "! @ABL SOURCE Scale Workshop / Xenharmonic developers" + e,
        l += "! @ABL LINK " + this.params.scaleUrl + e,
        l
    }
    saveFile() {
        super.saveFile(this.params.filename + ".ascl", this.getFileContents())
    }
}
;
St(lc, "maxInteger", 2147483647);
let d1 = lc;
const gm = class gm extends ni {
    constructor(e) {
        super(e);
        St(this, "appTitle");
        this.appTitle = e.appTitle || no
    }
    getFileContents() {
        let e = "# Tuning file for Max/MSP coll objects. - Created using " + this.appTitle + this.params.newline;
        e += "# " + this.params.scale.title + this.params.newline,
        e += "#" + this.params.newline,
        e += "# " + this.params.scaleUrl + this.params.newline,
        e += "#" + this.params.newline;
        for (let r = 0; r < gm.tuningMaxSize; r++)
            e += r + ", " + this.params.scale.getFrequency(r).toFixed(7) + ";" + this.params.newline;
        return e
    }
    saveFile() {
        super.saveFile(this.params.filename + ".txt", this.getFileContents())
    }
}
;
St(gm, "tuningMaxSize", 128);
let h1 = gm;
class WG extends ni {
    constructor(t) {
        super(t)
    }
    getFileContents() {
        const t = this.params
          , e = [`(* Created using ${t.appTitle ?? no} *)`, ""];
        if (e.push(JSON.stringify(t.scale.title)),
        t.unisonFrequency) {
            const i = ut.literalToString(t.unisonFrequency.asInterchangeLiteral());
            e.push(`1 = ${i}`),
            e.push("")
        }
        const r = t.rawIntervals ?? t.relativeIntervals;
        for (const i of r) {
            const a = i.shallowClone();
            a.node = a.asMonzoLiteral(!0);
            let l = a.toString(void 0, !0);
            l.startsWith("(") && l.endsWith(")") && (l = l.slice(1, -1)),
            e.push(l)
        }
        return e.push(""),
        e.join(`
`)
    }
    saveFile() {
        super.saveFile(this.params.filename + ".swi", this.getFileContents())
    }
}
const JG = {
    scalascl: a1,
    scalakbm: VG,
    anamarkv1: UG,
    anamarkv2: jG,
    kontakt: l1,
    harmor: HG,
    sytrus: GG,
    deflemask: u1,
    ableton: d1,
    puredata: c1,
    soniccouture: f1,
    maxmsp: h1,
    xendevs: WG
};
function KG(n, t) {
    new JG[n](t).saveFile()
}
const ZG = Ti("edo-cycles", () => {
    const n = te(.15)
      , t = te(2)
      , e = te(!0)
      , r = te("12p")
      , i = te(7)
      , a = Ve( () => SS(r.value))
      , l = Ve( () => a.value.divisions.round().valueOf())
      , f = Ve( () => Ie.modInv(i.value, l.value, !1))
      , h = Ve( () => Ie.mmod(i.value * f.value, l.value) || 1)
      , p = Ve( () => l.value / h.value)
      , m = {
        size: n,
        labelOffset: t,
        showLabels: e,
        valString: r,
        generator: i
    };
    function g() {
        const E = {};
        for (const [S,F] of Object.entries(m))
            E[S] = F.value;
        return E
    }
    function b(E) {
        for (const S in m)
            m[S].value = E[S]
    }
    return {
        ...m,
        val: a,
        modulus: l,
        generatorPseudoInverse: f,
        numCycles: h,
        cycleLength: p,
        toJSON: g,
        fromJSON: b
    }
}
);
var Us = {}
  , eo = {};
Object.defineProperty(eo, "__esModule", {
    value: !0
});
eo.unproject = eo.project = eo.connect = void 0;
const i0 = Ie
  , YG = 1e-6;
function p1(n, t, e=YG) {
    if (n.length > t.length)
        return p1(t, n);
    let r = 0;
    for (let i = 0; i < n.length; ++i) {
        const a = Math.abs(n[i] - t[i])
          , l = Math.round(a);
        if (Math.abs(a - l) <= e)
            r += l;
        else
            return NaN
    }
    for (let i = n.length; i < t.length; ++i) {
        const a = Math.abs(t[i])
          , l = Math.round(a);
        if (Math.abs(a - l) <= e)
            r += l;
        else
            return NaN
    }
    return r
}
function QG(n, t) {
    var e, r, i, a;
    if (t > 2)
        throw new Error("Only up to max distance = 2 implemented.");
    const l = []
      , f = [];
    if (t > 1)
        for (let h = 0; h < n.length; ++h)
            for (let p = h + 1; p < n.length; ++p) {
                const m = p1(n[h], n[p]);
                if (m > 1 && m <= t) {
                    const g = Math.max(n[h].length, n[p].length);
                    e: for (let b = 0; b < g; ++b) {
                        const E = ((e = n[h][b]) !== null && e !== void 0 ? e : 0) - ((r = n[p][b]) !== null && r !== void 0 ? r : 0);
                        if (Math.abs(E) === 2) {
                            const S = [...n[p]];
                            for (let F = n[p].length; F < n[h].length; ++F)
                                S[F] = 0;
                            S[b] += E / 2;
                            for (const F of n.concat(f))
                                if ((0,
                                i0.monzosEqual)(S, F))
                                    break e;
                            f.push(S);
                            break
                        } else if (Math.abs(E) === 1)
                            for (let S = b + 1; S < g; ++S) {
                                const F = ((i = n[h][S]) !== null && i !== void 0 ? i : 0) - ((a = n[p][S]) !== null && a !== void 0 ? a : 0)
                                  , B = [...n[p]];
                                for (let k = n[p].length; k < n[h].length; ++k)
                                    B[k] = 0;
                                const Q = [...B];
                                B[b] += E,
                                Q[S] += F;
                                let ae = !0
                                  , V = !0;
                                for (const k of n.concat(f))
                                    (0,
                                    i0.monzosEqual)(B, k) && (ae = !1),
                                    (0,
                                    i0.monzosEqual)(Q, k) && (V = !1);
                                ae && f.push(B),
                                V && f.push(Q);
                                break e
                            }
                    }
                }
            }
    if (t >= 1) {
        const h = n.length;
        n = n.concat(f);
        for (let p = 0; p < n.length; ++p)
            for (let m = p + 1; m < n.length; ++m)
                p1(n[p], n[m]) === 1 && l.push({
                    index1: p,
                    index2: m,
                    type: p < h && m < h ? "primary" : "auxiliary"
                })
    }
    return {
        connections: l,
        connectingMonzos: f
    }
}
eo.connect = QG;
function XG(n, t) {
    const e = n.map(i => [...i])
      , r = Math.max(...t.map(i => i.length));
    for (const i of e)
        i.length = Math.min(r, i.length);
    for (let i = r - 1; i >= 0; --i)
        if (!t.map(a => a[i]).some(Boolean))
            for (const a of e)
                a.splice(i, 1);
    return e
}
eo.project = XG;
function eW(n, t) {
    if (!n.length)
        return [];
    const e = n.map(i => [...i])
      , r = Math.max(...t.map(i => i.length));
    for (let i = 0; i < r; ++i)
        if (!t.map(a => a[i]).some(Boolean))
            for (const a of e)
                a.splice(i, 0, 0);
    return e
}
eo.unproject = eW;
var lA = {};
Object.defineProperty(lA, "__esModule", {
    value: !0
});
var Si = {};
Object.defineProperty(Si, "__esModule", {
    value: !0
});
Si.primeSphere = Si.WGP9 = Si.spanLattice3D = Si.mergeEdges3D = void 0;
const Gi = Ie
  , zd = eo
  , tW = 1e-6
  , nW = [23, 40, 0, 0, -14, -8, -5, 0, 20]
  , rW = [-45, 0, -40, 0, -18, -4, -32, -25, -3]
  , sW = [19, 0, 0, 40, 13, 7, 5, 9, 15];
function uA(n) {
    const t = [];
    for (const i of n)
        i.x2 < i.x1 || i.x2 === i.x1 && i.y2 < i.y1 || i.y2 === i.y1 && i.z2 < i.z1 ? t.push({
            x1: i.x2,
            y1: i.y2,
            z1: i.z2,
            x2: i.x1,
            y2: i.y1,
            z2: i.z1,
            type: i.type
        }) : t.push(i);
    t.sort( (i, a) => i.x1 - a.x1 || i.y1 - a.y1 || i.z1 - a.z1);
    const e = []
      , r = new Set;
    for (let i = 0; i < t.length; ++i) {
        if (r.has(i))
            continue;
        let {x1: a, y1: l, x2: f, y2: h, z1: p, z2: m, type: g} = t[i];
        const b = f - a
          , E = h - l
          , S = m - p;
        for (let F = i + 1; F < t.length; ++F) {
            const B = t[F];
            if (B.x1 === f && B.y1 === h && B.z1 === B.z2 && B.type === g) {
                const Q = B.x2 - B.x1
                  , ae = B.y2 - B.y1
                  , V = B.z2 - B.z1;
                Q * E === b * ae && Q * S === S * V && (f = B.x2,
                h = B.y2,
                m = B.z2,
                r.add(F))
            }
        }
        e.push({
            x1: a,
            x2: f,
            y1: l,
            y2: h,
            z1: p,
            z2: m,
            type: g
        })
    }
    return e
}
Si.mergeEdges3D = uA;
function iW(n, t) {
    var e;
    const {horizontalCoordinates: r, verticalCoordinates: i, depthwiseCoordinates: a} = t
      , l = (e = t.maxDistance) !== null && e !== void 0 ? e : 1
      , f = [i, r, a];
    let h = (0,
    zd.project)(n, f);
    const {connections: p, connectingMonzos: m} = (0,
    zd.connect)(h, l)
      , g = (0,
    zd.unproject)(m, f)
      , b = [];
    let E = [];
    for (let S = 0; S < n.length; ++S)
        b.push({
            index: S,
            x: (0,
            Gi.dot)(n[S], r),
            y: (0,
            Gi.dot)(n[S], i),
            z: (0,
            Gi.dot)(n[S], a)
        });
    for (const S of g)
        b.push({
            index: void 0,
            x: (0,
            Gi.dot)(S, r),
            y: (0,
            Gi.dot)(S, i),
            z: (0,
            Gi.dot)(S, a)
        });
    for (const S of p) {
        const {index1: F, index2: B, type: Q} = S;
        E.push({
            x1: b[F].x,
            y1: b[F].y,
            z1: b[F].z,
            x2: b[B].x,
            y2: b[B].y,
            z2: b[B].z,
            type: Q
        })
    }
    if (t.edgeMonzos) {
        h = h.concat(m);
        let S = (0,
        zd.project)(t.edgeMonzos, f);
        S = S.concat(S.map(F => F.map(B => -B)));
        for (let F = 0; F < h.length; ++F)
            for (let B = F + 1; B < h.length; ++B) {
                const Q = (0,
                Gi.sub)(h[F], h[B]);
                for (const ae of S)
                    (0,
                    Gi.monzosEqual)(Q, ae) && E.push({
                        x1: b[F].x,
                        y1: b[F].y,
                        z1: b[F].z,
                        x2: b[B].x,
                        y2: b[B].y,
                        z2: b[B].z,
                        type: F < n.length && B < n.length ? "custom" : "auxiliary"
                    })
            }
    }
    return t.mergeEdges && (E = uA(E)),
    {
        vertices: b,
        edges: E
    }
}
Si.spanLattice3D = iW;
function oW(n=0) {
    const t = [...nW]
      , e = [...rW]
      , r = [...sW];
    return t[n] = 0,
    e[n] = 0,
    r[n] = 0,
    {
        horizontalCoordinates: t,
        verticalCoordinates: e,
        depthwiseCoordinates: r
    }
}
Si.WGP9 = oW;
function aW(n=0, t, e=1024) {
    t ?? (t = Gi.LOG_PRIMES.slice(0, 24));
    const r = 2 * Math.PI / e
      , i = []
      , a = []
      , l = []
      , f = 2 * Math.PI / t[n];
    for (const h of t) {
        const p = h * f
          , m = 1 - Math.cos(p)
          , g = Math.sin(p);
        let b = -g
          , E = 0;
        if (i.length > 1) {
            let S = 1 / 0;
            for (let F = 0; F < e; ++F) {
                const B = r * F
                  , Q = Math.cos(B) * g
                  , ae = Math.sin(-B) * g;
                let V = 0;
                for (let k = 0; k < i.length; ++k)
                    V += (m * i[k] + Q * a[k] + ae * l[k]) ** 2;
                V + tW < S && (S = V,
                b = Q,
                E = ae)
            }
        }
        i.push(m),
        a.push(b),
        l.push(E)
    }
    return {
        horizontalCoordinates: i,
        verticalCoordinates: a,
        depthwiseCoordinates: l
    }
}
Si.primeSphere = aW;
(function(n) {
    var t = Zt && Zt.__createBinding || (Object.create ? function(V, k, z, Z) {
        Z === void 0 && (Z = z);
        var re = Object.getOwnPropertyDescriptor(k, z);
        (!re || ("get"in re ? !k.__esModule : re.writable || re.configurable)) && (re = {
            enumerable: !0,
            get: function() {
                return k[z]
            }
        }),
        Object.defineProperty(V, Z, re)
    }
    : function(V, k, z, Z) {
        Z === void 0 && (Z = z),
        V[Z] = k[z]
    }
    )
      , e = Zt && Zt.__exportStar || function(V, k) {
        for (var z in V)
            z !== "default" && !Object.prototype.hasOwnProperty.call(k, z) && t(k, V, z)
    }
    ;
    Object.defineProperty(n, "__esModule", {
        value: !0
    }),
    n.shortestEdge = n.spanGrid = n.align = n.primeRing72 = n.scottDakota24 = n.kraigGrady9 = n.modVal = n.spanLattice = n.mergeEdges = void 0;
    const r = Ie
      , i = eo;
    e(lA, n),
    e(Si, n);
    const a = [-23, 40, 0, 13, -14, -8, -5, 7, 20]
      , l = [-45, 0, -40, -11, -18, -4, -32, -25, -6]
      , f = [0, 5, 9, 12, 14, 16, 17, 16, 14, 12, 9, 5, 0, -5, -9, -12, -14, -16, -17, -16, -14, -12, -9, -5];
    function h(V) {
        const k = [];
        for (const re of V)
            re.x2 < re.x1 || re.x2 === re.x1 && re.y2 < re.y1 ? k.push({
                x1: re.x2,
                y1: re.y2,
                x2: re.x1,
                y2: re.y1,
                type: re.type
            }) : k.push(re);
        k.sort( (re, C) => re.x1 - C.x1 || re.y1 - C.y1);
        const z = []
          , Z = new Set;
        for (let re = 0; re < k.length; ++re) {
            if (Z.has(re))
                continue;
            let {x1: C, y1: D, x2: R, y2: W, type: I} = k[re];
            const N = R - C
              , P = W - D;
            for (let J = re + 1; J < k.length; ++J) {
                const X = k[J];
                if (X.x1 === R && X.y1 === W && X.type === I) {
                    const ie = X.x2 - X.x1
                      , ce = X.y2 - X.y1;
                    ie * P === N * ce && (R = X.x2,
                    W = X.y2,
                    Z.add(J))
                }
            }
            z.push({
                x1: C,
                x2: R,
                y1: D,
                y2: W,
                type: I
            })
        }
        return z
    }
    n.mergeEdges = h;
    function p(V, k) {
        var z;
        const {horizontalCoordinates: Z, verticalCoordinates: re} = k
          , C = (z = k.maxDistance) !== null && z !== void 0 ? z : 1
          , D = [Z, re];
        let R = (0,
        i.project)(V, D);
        const {connections: W, connectingMonzos: I} = (0,
        i.connect)(R, C)
          , N = (0,
        i.unproject)(I, D)
          , P = [];
        let J = [];
        for (let X = 0; X < V.length; ++X)
            P.push({
                index: X,
                x: (0,
                r.dot)(V[X], Z),
                y: (0,
                r.dot)(V[X], re)
            });
        for (const X of N)
            P.push({
                index: void 0,
                x: (0,
                r.dot)(X, Z),
                y: (0,
                r.dot)(X, re)
            });
        for (const X of W) {
            const {index1: ie, index2: ce, type: Le} = X;
            J.push({
                x1: P[ie].x,
                y1: P[ie].y,
                x2: P[ce].x,
                y2: P[ce].y,
                type: Le
            })
        }
        if (k.edgeMonzos) {
            R = R.concat(I);
            let X = (0,
            i.project)(k.edgeMonzos, D);
            X = X.concat(X.map(ie => ie.map(ce => -ce)));
            for (let ie = 0; ie < R.length; ++ie)
                for (let ce = ie + 1; ce < R.length; ++ce) {
                    const Le = (0,
                    r.sub)(R[ie], R[ce]);
                    for (const he of X)
                        (0,
                        r.monzosEqual)(Le, he) && J.push({
                            x1: P[ie].x,
                            y1: P[ie].y,
                            x2: P[ce].x,
                            y2: P[ce].y,
                            type: ie < V.length && ce < V.length ? "custom" : "auxiliary"
                        })
                }
        }
        return k.mergeEdges && (J = h(J)),
        {
            vertices: P,
            edges: J
        }
    }
    n.spanLattice = p;
    function m(V) {
        for (let k = 0; k < V.length; ++k)
            for (let z = k + 1; z < V.length; ++z)
                if (V[k] === V[z])
                    return !1;
        return !0
    }
    function g(V, k, z, Z=0) {
        if (k.length > z)
            throw new Error(`Too many logarithms to fit into ${z} notes.`);
        for (let D = 0; D < Z; ++D) {
            const R = .5 * D / Z
              , W = (z + R) / k[V]
              , I = k.map(N => (0,
            r.mmod)(Math.round(N * W), z));
            if (m(I))
                return I;
            if (D) {
                const N = (z - R) / k[V]
                  , P = k.map(J => (0,
                r.mmod)(Math.round(J * N), z));
                if (m(P))
                    return P
            }
        }
        const re = z / k[V]
          , C = k.map(D => Math.round(D * re), z);
        for (let D = 1; D < C.length; ++D) {
            const R = new Set;
            for (let I = 0; I < D; ++I)
                R.add((0,
                r.mmod)(C[I], z));
            if (!R.has((0,
            r.mmod)(C[D], z)))
                continue;
            const W = Math.sign(k[D] * z - C[D]);
            for (let I = 0; 2 * I <= z; ++I) {
                if (!R.has((0,
                r.mmod)(C[D] + I * W, z))) {
                    C[D] += I * W;
                    break
                }
                if (!R.has((0,
                r.mmod)(C[D] - I * W, z))) {
                    C[D] -= I * W;
                    break
                }
            }
        }
        return C.map(D => (0,
        r.mmod)(D, z))
    }
    n.modVal = g;
    function b(V=0) {
        const k = [...a]
          , z = [...l];
        return k[V] = 0,
        z[V] = 0,
        {
            horizontalCoordinates: k,
            verticalCoordinates: z
        }
    }
    n.kraigGrady9 = b;
    function E(V=0, k) {
        k ?? (k = r.LOG_PRIMES.slice(0, 24));
        const z = g(V, k, 24)
          , Z = []
          , re = [];
        for (const C of z)
            Z.push(17 - f[(0,
            r.mmod)(C + 6, 24)]),
            re.push(-f[C]);
        return {
            horizontalCoordinates: Z,
            verticalCoordinates: re
        }
    }
    n.scottDakota24 = E;
    function S(V=0, k, z=!0) {
        k ?? (k = r.LOG_PRIMES.slice(0, 72));
        const Z = g(V, k, 72)
          , re = []
          , C = [];
        for (const D of Z) {
            const R = Math.PI * D / 36;
            z ? (re.push(37 - Math.round(Math.cos(R) * 36.7)),
            C.push(-Math.round(Math.sin(R) * 36.7))) : (re.push(36.7 - Math.cos(R) * 36.7),
            C.push(-Math.sin(R) * 36.7))
        }
        return {
            horizontalCoordinates: re,
            verticalCoordinates: C
        }
    }
    n.primeRing72 = S;
    function F(V, k, z) {
        var Z, re, C, D, R, W, I, N, P, J;
        const {horizontalCoordinates: X, verticalCoordinates: ie} = V
          , ce = Math.max(X.length, ie.length);
        if (z === void 0) {
            const Le = (Z = X[k]) !== null && Z !== void 0 ? Z : 0
              , he = (re = ie[k]) !== null && re !== void 0 ? re : 0
              , Fe = 1 / Math.sqrt(1 + he * he / (Le * Le))
              , Te = he / Le * Fe;
            for (let ye = 0; ye < ce; ++ye) {
                const qe = (C = X[ye]) !== null && C !== void 0 ? C : 0
                  , Ge = (D = ie[ye]) !== null && D !== void 0 ? D : 0;
                X[ye] = qe * Fe + Ge * Te,
                ie[ye] = Ge * Fe - qe * Te
            }
        } else {
            const Le = (R = X[k]) !== null && R !== void 0 ? R : 0
              , he = (W = ie[k]) !== null && W !== void 0 ? W : 0
              , Fe = (I = X[z]) !== null && I !== void 0 ? I : 0
              , Te = (N = ie[z]) !== null && N !== void 0 ? N : 0
              , ye = Math.hypot(Le, he)
              , qe = Fe * Fe + Te * Te
              , Ge = .5 * ye
              , Se = -Math.sqrt(qe - Ge * Ge)
              , L = (ye * Te - Ge * he) / (Le * Te - Fe * he)
              , K = -Se * he / (Le * Te - Fe * he)
              , de = (-ye * Fe + Ge * Le) / (Le * Te - Fe * he)
              , $e = Se * Le / (Le * Te - Fe * he);
            for (let Re = 0; Re < ce; ++Re) {
                const me = (P = X[Re]) !== null && P !== void 0 ? P : 0
                  , T = (J = ie[Re]) !== null && J !== void 0 ? J : 0;
                X[Re] = L * me + de * T,
                ie[Re] = K * me + $e * T
            }
        }
    }
    n.align = F;
    function B(V, k, z, Z, re) {
        var C;
        if (!z && !Z)
            return;
        const {minX: D, maxX: R, minY: W, maxY: I} = re
          , N = (C = re.range) !== null && C !== void 0 ? C : 100;
        let P, J, X;
        P = -N - 1;
        do
            P++,
            J = V + z * P,
            X = k + Z * P;
        while (P <= N && (J < D || J > R || X < W || X > I));
        if (P > N)
            return;
        P--;
        const ie = V + z * P
          , ce = k + Z * P;
        for (; J >= D && J <= R && X >= W && X <= I; )
            P++,
            J = V + z * P,
            X = k + Z * P;
        return {
            x1: ie,
            y1: ce,
            x2: J,
            y2: X,
            type: "gridline"
        }
    }
    function Q(V, k) {
        var z, Z, re, C;
        const {modulus: D, delta1: R, delta1X: W, delta1Y: I, delta2: N, delta2X: P, delta2Y: J, minX: X, maxX: ie, minY: ce, maxY: Le, edgeVectors: he, gridLines: Fe} = k
          , Te = (z = k.range) !== null && z !== void 0 ? z : 100
          , ye = (Z = k.maxVertices) !== null && Z !== void 0 ? Z : 1e3
          , qe = (re = k.maxEdges) !== null && re !== void 0 ? re : 2e3;
        V = V.map(K => (0,
        r.mmod)(K, D));
        const Ge = new Map;
        for (let K = 0; K < V.length; ++K) {
            const de = (C = Ge.get(V[K])) !== null && C !== void 0 ? C : [];
            de.push(K),
            Ge.set(V[K], de)
        }
        for (const K of Ge.values())
            K.sort();
        const Se = [];
        e: for (let K = -Te; K <= Te; ++K)
            for (let de = -Te; de <= Te; ++de) {
                const $e = W * K + P * de
                  , Re = I * K + J * de;
                if ($e >= X && $e <= ie && Re >= ce && Re <= Le) {
                    const me = (0,
                    r.mmod)(R * K + N * de, D);
                    if (Ge.has(me) && (Se.push({
                        x: $e,
                        y: Re,
                        indices: Ge.get(me)
                    }),
                    Se.length >= ye || !W && !I || !P && !J))
                        break e
                }
            }
        const L = [];
        if (he)
            if (k.mergeEdges)
                e: for (const [K,de] of he) {
                    const $e = new Set;
                    for (let Re = 0; Re < Se.length; ++Re) {
                        if ($e.has(Re))
                            continue;
                        let me = Se[Re].x
                          , T = Se[Re].y
                          , j = Se[Re].x
                          , ge = Se[Re].y;
                        for (let Me = Re + 1; Me < Se.length; ++Me)
                            Se[Me].x - j === K && Se[Me].y - ge === de && (j = Se[Me].x,
                            ge = Se[Me].y,
                            $e.add(Me)),
                            me - Se[Me].x === K && T - Se[Me].y === de && (me = Se[Me].x,
                            T = Se[Me].y,
                            $e.add(Me));
                        if ((me !== j || T !== ge) && L.push({
                            x1: me,
                            y1: T,
                            x2: j,
                            y2: ge,
                            type: "custom"
                        }),
                        L.length >= qe)
                            break e
                    }
                }
            else {
                let K = [...he];
                K = K.concat(K.map(de => de.map($e => -$e)));
                e: for (let de = 0; de < Se.length; ++de)
                    for (let $e = de + 1; $e < Se.length; ++$e) {
                        const Re = Se[de].x - Se[$e].x
                          , me = Se[de].y - Se[$e].y;
                        for (const [T,j] of K)
                            if (Re === T && me === j && (L.push({
                                x1: Se[de].x,
                                y1: Se[de].y,
                                x2: Se[$e].x,
                                y2: Se[$e].y,
                                type: "custom"
                            }),
                            L.length >= qe))
                                break e
                    }
            }
        if (Fe) {
            for (let K = -Te; K <= Te && !(L.length >= qe); ++K) {
                if (Fe.delta1) {
                    const de = B(P * K, J * K, W, I, k);
                    de && L.push(de)
                }
                if (!P && !J)
                    break
            }
            for (let K = -Te; K <= Te && !(L.length >= qe); ++K) {
                let de;
                const $e = W * K
                  , Re = I * K;
                if (Fe.delta2 && (de = B($e, Re, P, J, k),
                de && L.push(de)),
                Fe.diagonal1 && (de = B($e, Re, W - P, I - J, k),
                de && L.push(de)),
                Fe.diagonal2 && (de = B($e, Re, W + P, I + J, k),
                de && L.push(de)),
                !W && !I)
                    break
            }
        }
        return {
            vertices: Se,
            edges: L
        }
    }
    n.spanGrid = Q;
    function ae(V, k) {
        var z, Z;
        const {modulus: re, delta1: C, delta1X: D, delta1Y: R, delta2: W, delta2X: I, delta2Y: N, minX: P, maxX: J, minY: X, maxY: ie} = k
          , ce = (z = k.range) !== null && z !== void 0 ? z : 100
          , Le = (Z = k.maxVertices) !== null && Z !== void 0 ? Z : 1e3;
        V = (0,
        r.mmod)(V, re);
        const he = [];
        e: for (let qe = -ce; qe <= ce; ++qe)
            for (let Ge = -ce; Ge <= ce; ++Ge) {
                const Se = D * qe + I * Ge
                  , L = R * qe + N * Ge;
                if (Se >= 2 * P && Se <= 2 * J && L >= 2 * X && L <= 2 * ie && (0,
                r.mmod)(C * qe + W * Ge, re) === V && (he.push({
                    x: Se,
                    y: L
                }),
                he.length >= Le || !D && !R || !I && !N))
                    break e
            }
        if (!he.length)
            throw new Error("Step not found on grid.");
        let Fe = NaN
          , Te = NaN
          , ye = 1 / 0;
        for (let qe = 0; qe < he.length; ++qe) {
            const Ge = he[qe].x
              , Se = he[qe].y
              , L = Ge * Ge + Se * Se;
            L < ye && (ye = L,
            Fe = Ge,
            Te = Se)
        }
        return [Fe, Te]
    }
    n.shortestEdge = ae
}
)(Us);
const lW = Ti("grid", () => {
    const n = te(.15)
      , t = te(0)
      , e = te(-.1)
      , r = te(2.5)
      , i = te(2)
      , a = te(!0)
      , l = te("12p")
      , f = te("")
      , h = te(7)
      , p = te(1)
      , m = te(0)
      , g = te(4)
      , b = te(0)
      , E = te(-1)
      , S = te(-3.1)
      , F = te(3.1)
      , B = te(-2.1)
      , Q = te(2.1)
      , ae = te(!0)
      , V = te(!0)
      , k = te(!1)
      , z = te(!1)
      , Z = Ve( () => SS(l.value))
      , re = Ve( () => Z.value.divisions.round().valueOf())
      , [C,D] = rc( () => ut.parseChord(f.value), [])
      , R = Ve( () => {
        const Te = {
            modulus: re.value,
            delta1: h.value,
            delta1X: p.value,
            delta1Y: m.value,
            delta2: g.value,
            delta2X: b.value,
            delta2Y: E.value,
            minX: S.value,
            maxX: F.value,
            minY: B.value,
            maxY: Q.value
        }
          , ye = [];
        try {
            for (const qe of C.value) {
                const Ge = qe.dot(Z.value).valueOf();
                ye.push(Us.shortestEdge(Ge, Te))
            }
        } catch {
            return []
        }
        return ye
    }
    )
      , W = Ve( () => ({
        modulus: re.value,
        delta1: h.value,
        delta1X: p.value,
        delta1Y: m.value,
        delta2: g.value,
        delta2X: b.value,
        delta2Y: E.value,
        minX: S.value,
        maxX: F.value,
        minY: B.value,
        maxY: Q.value,
        edgeVectors: R.value,
        gridLines: {
            delta1: ae.value,
            delta2: V.value,
            diagonal1: k.value,
            diagonal2: z.value
        },
        mergeEdges: !0
    }));
    function I() {
        S.value = -3.1,
        F.value = 3.1,
        B.value = -2.1,
        Q.value = 2.1
    }
    function N(Te) {
        I(),
        n.value = .15,
        r.value = 3.1,
        t.value = 0,
        e.value = -.1,
        l.value = `${Te}p`,
        h.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[1] / Ie.LOG_PRIMES[0]), Te),
        p.value = 1,
        m.value = 0,
        g.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[2] / Ie.LOG_PRIMES[0]), Te),
        b.value = 0,
        E.value = -1,
        ae.value = !0,
        V.value = !0,
        k.value = !1,
        z.value = !1,
        f.value = "3/2 5/4"
    }
    function P() {
        I(),
        n.value = .15,
        r.value = 3.1,
        t.value = 0,
        e.value = -.1;
        const Te = C.value[0] ?? W0;
        h.value = Z.value.dot(Te).valueOf(),
        p.value = 1,
        m.value = 0;
        const ye = C.value[1] ?? KE;
        g.value = Z.value.dot(ye).valueOf(),
        b.value = 0,
        E.value = -1,
        ae.value = !0,
        V.value = !0,
        k.value = !1,
        z.value = !1
    }
    function J(Te) {
        I(),
        n.value = .15,
        r.value = 3.1,
        t.value = 0,
        e.value = -.1,
        l.value = `b${Te}p`,
        h.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[2] / Ie.LOG_PRIMES[1]), Te),
        p.value = 1,
        m.value = 0,
        g.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[3] / Ie.LOG_PRIMES[1]), Te),
        b.value = 0,
        E.value = -1,
        ae.value = !0,
        V.value = !0,
        k.value = !1,
        z.value = !1,
        f.value = "5/3 7/3"
    }
    function X(Te) {
        I(),
        n.value = 1,
        r.value = 30.1,
        t.value = 0,
        e.value = 0,
        l.value = `${Te}p`,
        h.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[1] / Ie.LOG_PRIMES[0]), Te),
        p.value = 6,
        m.value = 0,
        g.value = Ie.mmod(Math.round(Te * Ie.LOG_PRIMES[2] / Ie.LOG_PRIMES[0]), Te),
        b.value = 3,
        E.value = -5,
        ae.value = !0,
        V.value = !0,
        k.value = !0,
        z.value = !1,
        f.value = "3/2 5/4 6/5"
    }
    function ie() {
        I(),
        n.value = 1,
        r.value = 30.1,
        t.value = 0,
        e.value = 0;
        const Te = C.value[0] ?? W0;
        h.value = Z.value.dot(Te).valueOf(),
        p.value = 6,
        m.value = 0;
        const ye = C.value[1] ?? KE;
        g.value = Z.value.dot(ye).valueOf(),
        b.value = 3,
        E.value = -5,
        ae.value = !0,
        V.value = !0,
        k.value = !0,
        z.value = !1
    }
    function ce() {
        I(),
        n.value = 8,
        r.value = 200,
        t.value = 0,
        e.value = 0,
        l.value = "311p",
        h.value = 296,
        p.value = 28,
        m.value = 2,
        g.value = 242,
        b.value = 15,
        E.value = -8,
        ae.value = !0,
        V.value = !0,
        k.value = !1,
        z.value = !1,
        f.value = "3/2 5/4 6/5 7/4 11/8 13/8"
    }
    const Le = {
        size: n,
        viewCenterX: t,
        viewCenterY: e,
        viewScale: r,
        labelOffset: i,
        showLabels: a,
        valString: l,
        edgesString: f,
        delta1: h,
        delta1X: p,
        delta1Y: m,
        delta2: g,
        delta2X: b,
        delta2Y: E,
        minX: S,
        maxX: F,
        minY: B,
        maxY: Q,
        gridlines1: ae,
        gridlines2: V,
        diagonals1: k,
        diagonals2: z
    };
    function he() {
        const Te = {};
        for (const [ye,qe] of Object.entries(Le))
            Te[ye] = qe.value;
        return Te
    }
    function Fe(Te) {
        for (const ye in Le)
            Le[ye].value = Te[ye]
    }
    return {
        ...Le,
        edges: C,
        edgesError: D,
        edgeVectors: R,
        val: Z,
        modulus: re,
        gridOptions: W,
        square: N,
        squareBP: J,
        tonnetz: X,
        preset311: ce,
        autoSquare: P,
        autoTonnetz: ie,
        toJSON: he,
        fromJSON: Fe
    }
}
)
  , uW = Ti("ji-lattice", () => {
    const n = Us.kraigGrady9()
      , t = Cr(n.horizontalCoordinates)
      , e = Cr(n.verticalCoordinates)
      , r = te(1)
      , i = te("")
      , a = te(2)
      , l = te(2)
      , f = te(!0)
      , h = te(0)
      , p = te(!1)
      , m = te(!1)
      , [g,b] = rc( () => ut.parseChord(i.value), [])
      , E = Ve({
        get() {
            return t.join(" ")
        },
        set(ye) {
            t.length = 0,
            t.push(...ye.split(" ").map(qe => {
                const Ge = parseInt(qe);
                return isNaN(Ge) ? 0 : Ge
            }
            ))
        }
    })
      , S = Ve({
        get() {
            return e.join(" ")
        },
        set(ye) {
            e.length = 0,
            e.push(...ye.split(" ").map(qe => {
                const Ge = parseInt(qe);
                return isNaN(Ge) ? 0 : Ge
            }
            ))
        }
    })
      , F = Ve({
        get() {
            return z.map(ye => ye.toFixed(2)).join(" ")
        },
        set(ye) {
            z.length = 0,
            z.push(...ye.split(" ").map(qe => {
                const Ge = parseFloat(qe);
                return isNaN(Ge) ? 0 : Ge
            }
            ))
        }
    })
      , B = Ve({
        get() {
            return Z.map(ye => ye.toFixed(2)).join(" ")
        },
        set(ye) {
            Z.length = 0,
            Z.push(...ye.split(" ").map(qe => {
                const Ge = parseFloat(qe);
                return isNaN(Ge) ? 0 : Ge
            }
            ))
        }
    })
      , Q = Ve({
        get() {
            return re.map(ye => ye.toFixed(2)).join(" ")
        },
        set(ye) {
            re.length = 0,
            re.push(...ye.split(" ").map(qe => {
                const Ge = parseFloat(qe);
                return isNaN(Ge) ? 0 : Ge
            }
            ))
        }
    })
      , ae = Ve( () => {
        const ye = t.length
          , qe = [];
        for (const Ge of g.value) {
            const Se = Ge.value.clone();
            if (Se instanceof ut.TimeMonzo) {
                Se.numberOfComponents = ye;
                const L = Se.primeExponents.map(K => K.valueOf());
                qe.push(L)
            } else
                qe.push(Array(ye).fill(0))
        }
        return qe
    }
    )
      , V = Ve( () => ({
        horizontalCoordinates: t,
        verticalCoordinates: e,
        maxDistance: r.value,
        edgeMonzos: ae.value,
        mergeEdges: !0
    }))
      , k = Us.WGP9(0)
      , z = Cr(k.horizontalCoordinates)
      , Z = Cr(k.verticalCoordinates)
      , re = Cr(k.depthwiseCoordinates)
      , C = te(100)
      , D = Ve( () => ({
        horizontalCoordinates: z,
        verticalCoordinates: Z,
        depthwiseCoordinates: re,
        maxDistance: r.value,
        edgeMonzos: ae.value,
        mergeEdges: !1
    }));
    Jt(h, ye => {
        (ye < 0 || ye >= 360) && (h.value = Ie.mmod(ye, 360))
    }
    );
    function R(ye=0) {
        a.value = 2;
        const qe = Us.kraigGrady9(ye);
        t.length = 0,
        t.push(...qe.horizontalCoordinates),
        e.length = 0,
        e.push(...qe.verticalCoordinates),
        i.value = ""
    }
    function W(ye=0) {
        a.value = 2;
        const qe = Us.scottDakota24(ye);
        t.length = 0,
        t.push(...qe.horizontalCoordinates),
        e.length = 0,
        e.push(...qe.verticalCoordinates),
        ye === 0 ? i.value = "6/5" : i.value = ""
    }
    function I(ye=0) {
        a.value = 4;
        const qe = Us.primeRing72(ye);
        t.length = 0,
        t.push(...qe.horizontalCoordinates),
        e.length = 0,
        e.push(...qe.verticalCoordinates),
        ye === 0 ? i.value = "6/5" : i.value = ""
    }
    function N(ye=0) {
        a.value = 4;
        const qe = Us.primeRing72(ye, void 0, !1);
        Us.align(qe, ye + 1, ye + 2),
        t.length = 0,
        t.push(...qe.horizontalCoordinates.map(Math.round)),
        e.length = 0,
        e.push(...qe.verticalCoordinates.map(Math.round)),
        ye === 0 ? i.value = "6/5" : i.value = ""
    }
    function P(ye) {
        if (!z.length || !Z.length || !re.length)
            return;
        const qe = ye.map(K => Ie.dot(K, z))
          , Ge = ye.map(K => Ie.dot(K, Z))
          , Se = ye.map(K => Ie.dot(K, re))
          , L = Math.max(Math.max(...qe) - Math.min(...qe), Math.max(...Ge) - Math.min(...Ge), Math.max(...Se) - Math.min(...Se));
        C.value = Math.ceil(2 * L)
    }
    function J(ye=0) {
        a.value = 2,
        C.value = 100;
        const qe = Us.WGP9(ye);
        z.length = 0,
        z.push(...qe.horizontalCoordinates),
        Z.length = 0,
        Z.push(...qe.verticalCoordinates),
        re.length = 0,
        re.push(...qe.depthwiseCoordinates),
        i.value = ""
    }
    function X(ye=0, qe=24) {
        a.value = 2,
        C.value = 300;
        const Ge = Us.primeSphere(ye, Ie.LOG_PRIMES.slice(0, qe))
          , Se = 3e3;
        z.length = 0,
        z.push(...Ge.horizontalCoordinates.map(L => Math.round(L * Se) / 100)),
        Z.length = 0,
        Z.push(...Ge.verticalCoordinates.map(L => Math.round(L * Se) / 100)),
        re.length = 0,
        re.push(...Ge.depthwiseCoordinates.map(L => Math.round(L * Se) / 100)),
        ye === 0 ? i.value = "6/5" : i.value = ""
    }
    function ie(ye) {
        const qe = ye / 180 * Math.PI
          , Ge = Math.cos(qe)
          , Se = Math.sin(qe);
        for (let L = 0; L < Math.max(Z.length, re.length); ++L) {
            const K = Z[L] ?? 0
              , de = re[L] ?? 0;
            Z[L] = Ge * K + Se * de,
            re[L] = Ge * de - Se * K
        }
    }
    function ce(ye) {
        const qe = ye / 180 * Math.PI
          , Ge = Math.cos(qe)
          , Se = Math.sin(qe);
        for (let L = 0; L < Math.max(z.length, re.length); ++L) {
            const K = z[L] ?? 0
              , de = re[L] ?? 0;
            z[L] = Ge * K + Se * de,
            re[L] = Ge * de - Se * K
        }
    }
    function Le(ye) {
        const qe = ye / 180 * Math.PI
          , Ge = Math.cos(qe)
          , Se = Math.sin(qe);
        for (let L = 0; L < Math.max(z.length, Z.length); ++L) {
            const K = z[L] ?? 0
              , de = Z[L] ?? 0;
            z[L] = Ge * K + Se * de,
            Z[L] = Ge * de - Se * K
        }
    }
    const he = {
        maxDistance: r,
        size: a,
        labelOffset: l,
        edgesString: i,
        showLabels: f,
        rotation: h,
        drawArrows: p,
        grayExtras: m,
        depth: C
    };
    function Fe() {
        const ye = {
            horizontalCoordinates: t,
            verticalCoordinates: e,
            xCoords: z,
            yCoords: Z,
            zCoords: re
        };
        for (const [qe,Ge] of Object.entries(he))
            ye[qe] = Ge.value;
        return ye
    }
    function Te(ye) {
        for (const qe in he)
            he[qe].value = ye[qe];
        t.length = 0,
        t.push(...ye.horizontalCoordinates),
        e.length = 0,
        e.push(...ye.verticalCoordinates),
        z.length = 0,
        z.push(...ye.xCoords),
        Z.length = 0,
        Z.push(...ye.yCoords),
        re.length = 0,
        re.push(...ye.zCoords)
    }
    return {
        ...he,
        horizontalCoordinates: t,
        verticalCoordinates: e,
        xCoords: z,
        yCoords: Z,
        zCoords: re,
        edgeMonzos: ae,
        edgesError: b,
        horizontals: E,
        verticals: S,
        latticeOptions: V,
        latticeOptions3D: D,
        xs: F,
        ys: B,
        zs: Q,
        kraigGrady: R,
        scott24: W,
        pr72: I,
        pe72: N,
        autoDepth: P,
        WGP: J,
        sphere: X,
        pitch: ie,
        yaw: ce,
        roll: Le,
        toJSON: Fe,
        fromJSON: Te
    }
}
)
  , cW = {
    key: 0
}
  , fW = gs({
    __name: "ExporterButtons",
    setup(n, {expose: t}) {
        const e = un( () => Pt( () => import("./ScalaExport-2956af8c.js"), ["assets/ScalaExport-2956af8c.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/export-82b48f7f.js"]))
          , r = un( () => Pt( () => import("./KorgExport-02dcc4f8.js"), ["assets/KorgExport-02dcc4f8.js", "assets/export-82b48f7f.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , i = un( () => Pt( () => import("./MtsSysexExport-694fd486.js"), ["assets/MtsSysexExport-694fd486.js", "assets/export-82b48f7f.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css"]))
          , a = un( () => Pt( () => import("./ReaperExport-71a69228.js"), ["assets/ReaperExport-71a69228.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/export-82b48f7f.js"]))
          , l = oy()
          , f = lu()
          , h = xS()
          , p = uW()
          , m = lW()
          , g = ZG()
          , b = te("Copy this scale's unique URL to clipboard")
          , E = te(!1)
          , S = te(!1)
          , F = te(!1)
          , B = te(!1)
          , Q = Ve( () => JSON.stringify({
            id: f.id,
            payload: {
                scale: f.toJSON(),
                audio: h.toJSON(),
                state: l.toJSON(),
                "ji-lattice": p.toJSON(),
                grid: m.toJSON(),
                "edo-cycles": g.toJSON()
            },
            envelope: BV(l.shareStatistics)
        }))
          , ae = Ve( () => `${window.location.origin}/scale/${f.uploadedId}`);
        function V(re=1) {
            const C = f.id;
            return f.uploadedId === C ? Promise.resolve(`${window.location.origin}/scale/${C}`) : new Promise(D => {
                fetch(new URL("scale",GE), {
                    method: "POST",
                    body: Q.value
                }).then(R => R.status === 409 && re > 0 ? (f.rerollId(),
                V(re - 1).then(D)) : R.ok ? (f.uploadedId = C,
                D(`${window.location.origin}/scale/${C}`)) : D(window.location.origin)).catch( () => D(window.location.origin))
            }
            )
        }
        t({
            uploadScale: V
        });
        function k() {
            const re = document.createElement("a");
            re.download = e_(f.scale.title) + ".json",
            re.href = "data:application/json," + encodeURIComponent(Q.value),
            re.dispatchEvent(new MouseEvent("click",{
                bubbles: !0,
                cancelable: !0,
                view: window
            }))
        }
        function z() {
            V().then(re => {
                window.navigator.clipboard.writeText(re),
                b.value = "[Copied URL to clipboard]",
                window.setTimeout( () => {
                    b.value = "Copy this scale's unique URL to clipboard"
                }
                , 5e3)
            }
            )
        }
        function Z(re) {
            V().then(C => {
                const D = {
                    newline: l.newline,
                    scaleUrl: C,
                    filename: e_(f.scale.title),
                    relativeIntervals: f.relativeIntervals,
                    scale: f.scale,
                    labels: f.labels,
                    midiOctaveOffset: -1,
                    description: f.scale.title,
                    sourceText: f.sourceText,
                    appTitle: no,
                    date: new Date
                };
                if (re === "xendevs") {
                    const {rawIntervals: R, unisonFrequency: W} = f.computeRawScale();
                    D.rawIntervals = R,
                    D.unisonFrequency = W
                }
                KG(re, D)
            }
            )
        }
        return (re, C) => (gt(),
        Fn(Jn, null, [(gt(),
        Ut(O1, {
            to: "body"
        }, [E.value ? (gt(),
        Ut(Ee(e), {
            key: 0,
            show: E.value,
            onConfirm: C[0] || (C[0] = D => E.value = !1),
            onCancel: C[1] || (C[1] = D => E.value = !1),
            scaleUrl: ae.value,
            newline: Ee(l).newline,
            relativeIntervals: Ee(f).relativeIntervals,
            midiOctaveOffset: -1,
            scale: Ee(f).scale,
            labels: Ee(f).labels,
            colors: Ee(f).colors
        }, null, 8, ["show", "scaleUrl", "newline", "relativeIntervals", "scale", "labels", "colors"])) : Kt("", !0), S.value ? (gt(),
        Ut(Ee(r), {
            key: 1,
            show: S.value,
            onConfirm: C[2] || (C[2] = D => S.value = !1),
            onCancel: C[3] || (C[3] = D => S.value = !1),
            newline: Ee(l).newline,
            relativeIntervals: Ee(f).relativeIntervals,
            midiOctaveOffset: -1,
            scale: Ee(f).scale,
            labels: Ee(f).labels
        }, null, 8, ["show", "newline", "relativeIntervals", "scale", "labels"])) : Kt("", !0), F.value ? (gt(),
        Ut(Ee(i), {
            key: 2,
            show: F.value,
            onConfirm: C[4] || (C[4] = D => F.value = !1),
            onCancel: C[5] || (C[5] = D => F.value = !1),
            newline: Ee(l).newline,
            relativeIntervals: Ee(f).relativeIntervals,
            midiOctaveOffset: -1,
            scale: Ee(f).scale,
            labels: Ee(f).labels
        }, null, 8, ["show", "newline", "relativeIntervals", "scale", "labels"])) : Kt("", !0), B.value ? (gt(),
        Ut(Ee(a), {
            key: 3,
            show: B.value,
            onConfirm: C[6] || (C[6] = D => B.value = !1),
            onCancel: C[7] || (C[7] = D => B.value = !1),
            newline: Ee(l).newline,
            relativeIntervals: Ee(f).relativeIntervals,
            midiOctaveOffset: -1,
            scale: Ee(f).scale,
            labels: Ee(f).labels
        }, null, 8, ["show", "newline", "relativeIntervals", "scale", "labels"])) : Kt("", !0)])), C[45] || (C[45] = se("h2", null, "Export current settings", -1)), se("a", {
            href: "#",
            class: Of({
                btn: !0,
                disabled: !Ee(GE)
            }),
            onClick: z
        }, [C[25] || (C[25] = se("p", null, [se("strong", null, "Share scale")], -1)), se("p", null, ds(b.value), 1)], 2), Ee(Vz) && Ee(l).showSafariWarning ? (gt(),
        Fn("div", cW, [C[26] || (C[26] = se("h3", {
            class: "warning"
        }, "Warning", -1)), C[27] || (C[27] = se("p", {
            class: "warning"
        }, "File export is known to be broken on Safari. Root cause unknown.", -1)), se("button", {
            class: "warning",
            onClick: C[8] || (C[8] = D => Ee(l).showSafariWarning = !1)
        }, "Dismiss")])) : Kt("", !0), Ee(l).debug ? (gt(),
        Fn("a", {
            key: 1,
            href: "#",
            class: "btn debug",
            onClick: k
        }, C[28] || (C[28] = [se("p", null, [se("strong", null, "Debug dump (.json)")], -1), se("p", null, "Copy of the data sent to the server.", -1)]))) : Kt("", !0), se("a", {
            href: "#",
            class: "btn",
            onClick: C[9] || (C[9] = D => Z("anamarkv1"))
        }, C[29] || (C[29] = [se("p", null, [se("strong", null, "AnaMark v1 tuning (.tun)")], -1), se("p", null, "Tuning file for various synths", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[10] || (C[10] = D => Z("anamarkv2"))
        }, C[30] || (C[30] = [se("p", null, [se("strong", null, "AnaMark v2 tuning (.tun)")], -1), se("p", null, "Tuning file for various synths", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[11] || (C[11] = D => E.value = !0)
        }, C[31] || (C[31] = [se("p", null, [se("strong", null, "Scala scale (.scl)")], -1), se("p", null, [dr(" Scale file for various synths."), se("br"), dr("If you use this file without an accompanying .kbm file, most synths will assume your scale starts on C  262Hz ")], -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[12] || (C[12] = D => Z("scalakbm"))
        }, C[32] || (C[32] = [se("p", null, [se("strong", null, "Scala keyboard mapping (.kbm)")], -1), se("p", null, "Maps an accompanying .scl file to start on a specific MIDI note and frequency", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[13] || (C[13] = D => Z("ableton"))
        }, C[33] || (C[33] = [se("p", null, [se("strong", null, "Ableton scale (.ascl)")], -1), se("p", null, "Scale file for Ableton Live 12", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[14] || (C[14] = D => Z("maxmsp"))
        }, C[34] || (C[34] = [se("p", null, [se("strong", null, "Max/MSP coll tuning (.txt)")], -1), se("p", null, "List of frequencies (Hz) in a text file to load into a Max/MSP coll object", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[15] || (C[15] = D => Z("puredata"))
        }, C[35] || (C[35] = [se("p", null, [se("strong", null, "PureData text tuning (.txt)")], -1), se("p", null, "List of frequencies (Hz) in a text file to load into a PureData text object", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[16] || (C[16] = D => Z("kontakt"))
        }, C[36] || (C[36] = [se("p", null, [se("strong", null, "Kontakt tuning script (.txt)")], -1), se("p", null, " Tuning script for Native Instruments Kontakt. Some instrument libraries allow this custom script ", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[17] || (C[17] = D => Z("soniccouture"))
        }, C[37] || (C[37] = [se("p", null, [se("strong", null, "Soniccouture tuning file (.nka)")], -1), se("p", null, "For Soniccouture sample libraries", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[18] || (C[18] = D => Z("harmor"))
        }, C[38] || (C[38] = [se("p", null, [se("strong", null, "Harmor pitch map (.fnv)")], -1), se("p", null, "Envelope state file for the pitch envelope in Image-Line Harmor", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[19] || (C[19] = D => Z("sytrus"))
        }, C[39] || (C[39] = [se("p", null, [se("strong", null, "Sytrus pitch map (.fnv)")], -1), se("p", null, "Envelope state file for the pitch envelope in Image-Line Sytrus", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[20] || (C[20] = D => S.value = !0)
        }, C[40] || (C[40] = [se("p", null, [se("strong", null, "Korg Sound Librarian scale (.mnlgtuns + others)")], -1), se("p", null, "Tuning formats for use with Monologue, Minilogue, Minilogue XD, and Prologue synthesizers", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[21] || (C[21] = D => Z("deflemask"))
        }, C[41] || (C[41] = [se("p", null, [se("strong", null, "Deflemask reference (.txt)")], -1), se("p", null, "List of 'fine tune' values for Deflemask", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[22] || (C[22] = D => B.value = !0)
        }, C[42] || (C[42] = [se("p", null, [se("strong", null, "Reaper note name map (.txt)")], -1), se("p", null, "Displays custom note names on Reaper's piano roll", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[23] || (C[23] = D => F.value = !0)
        }, C[43] || (C[43] = [se("p", null, [se("strong", null, "MTS Sysex Bulk Tuning Dump (.syx)")], -1), se("p", null, "Binary data of a Bulk Tuning Dump SysEx message", -1)])), se("a", {
            href: "#",
            class: "btn",
            onClick: C[24] || (C[24] = D => Z("xendevs"))
        }, C[44] || (C[44] = [se("p", null, [se("strong", null, "SonicWeave Interchange (.swi)")], -1), se("p", null, "Simplified Scale Workshop 3 format", -1)])), C[46] || (C[46] = se("h3", null, "Documentation", -1)), C[47] || (C[47] = se("p", null, [dr(" You can read about the new SonicWeave syntax "), se("a", {
            href: "https://github.com/xenharmonic-devs/sonic-weave?tab=readme-ov-file#sonic-weave",
            target: "_blank"
        }, "here"), dr(". ")], -1)), C[48] || (C[48] = se("p", null, [dr(" Remember to check out the "), se("a", {
            href: "https://github.com/xenharmonic-devs/sonic-weave/tree/main/examples",
            target: "_blank"
        }, "examples"), dr(" too. ")], -1))], 64))
    }
});
const dW = Jf(fW, [["__scopeId", "data-v-cfe3850f"]])
  , hW = {
    class: "columns-container"
}
  , pW = {
    class: "column scale-builder"
}
  , mW = {
    class: "btn-group"
}
  , gW = {
    class: "column tuning-table"
}
  , vW = gs({
    __name: "ScaleView",
    setup(n) {
        const t = lu()
          , e = oy()
          , r = te(null)
          , i = te(null)
          , a = te(null)
          , l = te(null)
          , f = nc(t.computeScale);
        return If( () => {
            ut.setNumberOfComponents(Ps),
            setTimeout( () => ut.getSourceVisitor(), 1)
        }
        ),
        Sm( () => {
            t.rerollId()
        }
        ),
        (h, p) => (gt(),
        Fn("main", null, [se("div", hW, [se("div", pW, [So(se("textarea", {
            id: "scale-name",
            rows: "1",
            placeholder: "Untitled scale",
            "onUpdate:modelValue": p[0] || (p[0] = m => Ee(t).name = m),
            onFocus: p[1] || (p[1] = (...m) => r.value.clearPaletteInfo && r.value.clearPaletteInfo(...m)),
            onInput: p[2] || (p[2] = m => Ee(f)())
        }, null, 544), [[Jd, Ee(t).name]]), se("ul", mW, [jt(nG, {
            ref_key: "newScale",
            ref: i,
            onDone: p[3] || (p[3] = m => r.value.focus()),
            onMouseenter: p[4] || (p[4] = m => a.value.blur())
        }, null, 512), jt(pG, {
            ref_key: "modifyScale",
            ref: a,
            onDone: p[5] || (p[5] = m => r.value.focus()),
            onMouseenter: p[6] || (p[6] = m => i.value.blur())
        }, null, 512)]), jt(DG, {
            ref_key: "controls",
            ref: r
        }, null, 512)]), se("div", gW, [jt(zG, {
            heldNotes: Ee(e).heldNotes,
            frequencies: Ee(t).frequencies,
            centss: Ee(t).centss,
            baseFrequency: Ee(t).scale.baseFrequency,
            baseMidiNote: Ee(t).scale.baseMidiNote,
            colors: Ee(t).colors,
            labels: Ee(t).labels
        }, null, 8, ["heldNotes", "frequencies", "centss", "baseFrequency", "baseMidiNote", "colors", "labels"])]), se("div", {
            class: "column exporters",
            onMouseenter: p[7] || (p[7] = m => l.value.uploadScale())
        }, [jt(dW, {
            ref_key: "exporterButtons",
            ref: l
        }, null, 512)], 32)])]))
    }
});
const yW = Jf(vW, [["__scopeId", "data-v-94d862b3"]]);
function bW(n) {
    const t = sA.parse(n);
    return Object.keys(t).forEach(e => {
        if (t[e] === void 0)
            throw new Error("Failed to parse query string")
    }
    ),
    t
}
const cA = z7({
    history: y7("/"),
    parseQuery: bW,
    stringifyQuery: sA.stringify,
    routes: [{
        path: "/",
        name: "scale",
        component: yW
    }, {
        path: "/about",
        name: "about",
        component: () => Pt( () => import("./AboutView-5c314f1d.js"), ["assets/AboutView-5c314f1d.js", "assets/spoob-659f8fbc.js", "assets/AboutView-bc3c1147.css"])
    }, {
        path: "/scale/:id",
        name: "load-scale",
        component: () => Pt( () => import("./LoadScaleView-a699c7c7.js"), ["assets/LoadScaleView-a699c7c7.js", "assets/LoadScaleView-082bc193.css"])
    }, {
        path: "/privacy-policy",
        name: "privacy-policy",
        component: () => Pt( () => import("./PrivacyPolicy-6915feb0.js"), ["assets/PrivacyPolicy-6915feb0.js", "assets/PrivacyPolicy-5427a11c.css"])
    }, {
        path: "/terms-of-service",
        name: "terms-of-service",
        component: () => Pt( () => import("./TermsOfService-ca97e81a.js"), ["assets/TermsOfService-ca97e81a.js", "assets/TermsOfService-47585b54.css"])
    }, {
        path: "/analysis",
        name: "analysis",
        component: () => Pt( () => import("./AnalysisView-3c31e6fb.js"), ["assets/AnalysisView-3c31e6fb.js", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/index.esm-31ea5966.js", "assets/AnalysisView-a18e4fdf.css"])
    }, {
        path: "/lattice",
        name: "lattice",
        component: () => Pt( () => import("./LatticeView-61cb654e.js"), ["assets/LatticeView-61cb654e.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/LatticeView-71741957.css"])
    }, {
        path: "/midi",
        name: "midi",
        component: () => Pt( () => import("./MidiView-d79f8d68.js"), ["assets/MidiView-d79f8d68.js", "assets/MidiView-815cb9c7.css"])
    }, {
        path: "/prefs",
        name: "preferencess",
        component: () => Pt( () => import("./PreferencesView-a97b0368.js"), ["assets/PreferencesView-a97b0368.js", "assets/PreferencesView-f0979740.css"])
    }, {
        path: "/synth",
        name: "synth",
        component: () => Pt( () => import("./SynthView-6941baad.js"), ["assets/SynthView-6941baad.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/SynthView-e06b67c4.css"])
    }, {
        path: "/vk",
        name: "virtualKeyboard",
        component: () => Pt( () => import("./VirtualKeyboardView-9ca7cecb.js"), ["assets/VirtualKeyboardView-9ca7cecb.js", "assets/index.esm-31ea5966.js", "assets/VirtualKeyboardView-ac5f2256.css"])
    }, {
        path: "/qwerty",
        name: "qwerty",
        component: () => Pt( () => import("./VirtualQwerty-a7f08644.js"), ["assets/VirtualQwerty-a7f08644.js", "assets/VirtualQwerty-6f12a24a.css"])
    }, {
        path: "/mos",
        name: "mos",
        component: () => Pt( () => import("./MosView-864fd0db.js"), ["assets/MosView-864fd0db.js", "assets/spoob-659f8fbc.js", "assets/MosView-d55ac1c8.css"])
    }, {
        path: "/index.html",
        redirect: "/"
    }, {
        path: "/index.htm",
        redirect: "/"
    }, {
        path: "/:pathMatch(.*)*",
        name: "notFound",
        component: () => Pt( () => import("./NotFoundView-506f7d99.js"), ["assets/NotFoundView-506f7d99.js", "assets/ModalDialog.vue_vue_type_style_index_0_lang-948bb410.js", "assets/ModalDialog-12e6d9bf.css", "assets/ScaleLineInput.vue_vue_type_script_setup_true_lang-9726be7a.js", "assets/NotFoundView-74747071.css"])
    }]
});
function B_(n) {
    return !!Object.keys(n.query).length
}
cA.beforeEach( (n, t, e) => {
    n.name == null ? e() : !B_(n) && B_(t) ? e({
        name: n.name,
        query: t.query
    }) : e()
}
);
localStorage.getItem("uuid") || localStorage.setItem("uuid", crypto.randomUUID());
const vy = x5(CU);
vy.use(P5());
vy.use(cA);
vy.mount("#app");
export {WW as $, GE as A, Ie as B, jW as C, HW as D, FS as E, Jn as F, fh as G, ZL as H, Vz as I, Cr as J, Ee as K, So as L, hv as M, SW as N, Jd as O, $5 as P, Td as Q, ut as R, JW as S, ZW as T, NW as U, KW as V, QW as W, YW as X, XW as Y, GW as Z, Jf as _, Fn as a, Jt as a0, zW as a1, VW as a2, Us as a3, nc as a4, _m as a5, Ut as a6, AW as a7, PW as a8, ql as a9, DW as aA, AS as aB, CW as aC, Ml as aD, TW as aE, RW as aF, hG as aG, LW as aH, qW as aI, XE as aJ, oA as aK, aA as aL, Gz as aM, OV as aN, e_ as aO, a1 as aP, Zt as aQ, ni as aR, sU as aa, rU as ab, ot as ac, MW as ad, bS as ae, O1 as af, ZV as ag, UW as ah, h4 as ai, Na as aj, OW as ak, FW as al, rm as am, xV as an, j7 as ao, Ns as ap, Ms as aq, bG as ar, rc as as, xW as at, dG as au, IW as av, Ti as aw, W0 as ax, Ps as ay, MV as az, se as b, Ve as c, gs as d, Kt as e, _W as f, xS as g, oy as h, uW as i, lW as j, ZG as k, If as l, BW as m, Of as n, gt as o, kW as p, U7 as q, te as r, $W as s, ds as t, lu as u, EW as v, dr as w, jt as x, Wr as y, Sm as z};
