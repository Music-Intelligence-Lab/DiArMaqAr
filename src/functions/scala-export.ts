import TuningSystem from "@/models/TuningSystem";
import PitchClass from "@/models/PitchClass";
import getTuningSystemPitchClasses from "./getTuningSystemPitchClasses";
import { Jins } from "@/models/Jins";
import { Maqam } from "@/models/Maqam";
import JinsData from "@/models/Jins";
import MaqamData from "@/models/Maqam";
import { classifyMaqamat } from "./classifyMaqamat12PitchClassSets";
import { getMaqamat, getAjnas } from "./import";
import { standardizeText } from "./export";
import { getIpnReferenceNoteName, getIpnReferenceNoteNameWithOctave } from "./getIpnReferenceNoteName";

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Removes duplicate pitch classes based on cents value within a tolerance
 * @param pitchClasses - Array of pitch classes to deduplicate
 * @param tolerance - Cents tolerance for considering two pitches as duplicates (default: 1)
 * @returns Array of unique pitch classes
 */
function removeDuplicatePitchClasses(pitchClasses: PitchClass[], tolerance: number = 1): PitchClass[] {
  const unique: PitchClass[] = [];
  for (const pc of pitchClasses) {
    const cents = parseFloat(pc.cents);
    if (!unique.some((existing) => Math.abs(parseFloat(existing.cents) - cents) < tolerance)) {
      unique.push(pc);
    }
  }
  return unique;
}

/**
 * Filters pitch classes to a single octave range
 * @param pitchClasses - Array of pitch classes to filter
 * @param minCents - Minimum cents value (inclusive, default: 0)
 * @param maxCents - Maximum cents value (inclusive, default: 1200)
 * @returns Filtered and sorted pitch classes within the octave range
 */
function filterToOctave(pitchClasses: PitchClass[], minCents: number = 0, maxCents: number = 1200): PitchClass[] {
  return pitchClasses
    .filter((pc) => {
      const cents = parseFloat(pc.cents);
      // Include the maxCents boundary (octave note) for proper .kbm mapping
      return cents >= minCents && cents <= maxCents;
    })
    .sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
}

/**
 * Builds Scala file header with metadata
 * @param description - Main description line
 * @param metadata - Optional metadata fields to include in header
 * @returns Array of header lines
 */
function buildScalaHeader(
  maqamName: string,
  metadata: {
    sourceMaqam?: string;
    rootNote?: string;
    direction?: string;
    tuningSystem?: string;
    tuningSystemStartingNote?: string;
    tuningSystemStartingNoteRefFreq?: number;
    referenceFrequency?: number;
    referenceFrequencyNoteName?: string;
    sourceMaqamTonicNoteName?: string;
    sourceMaqamFrequency?: number;
    sourceMaqamIpnWithOctave?: string;
    a4Frequency?: number | null;
    a4NoteName?: string;
    exportedMaqamName?: string;
    exportedMaqamFrequency?: number | null;
    exportedMaqamIpnWithOctave?: string;
    exportedMaqamTonicNoteName?: string;
    baseUrl?: string;
    url?: string;
    compatibleMaqamat?: Array<{
      name: string;
      tonicIpn: string;
      tonicNoteName: string;
      position: number;
      ascendingIpnNames?: string[];
      descendingIpnNames?: string[];
      ascendingPositions?: number[];
      descendingPositions?: number[];
      isSymmetrical?: boolean;
    }>;
  } = {}
): string[] {
  // Helper function to convert to sentence case (first letter capitalized, rest lowercase)
  const toSentenceCase = (str: string): string => {
    if (!str) return str;
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  };

  // Helper function to lowercase note names and maqām names
  const lowercaseMusicTerms = (str: string): string => {
    return str.toLowerCase();
  };

  // First line: maqam name + "(12 pitch class chromatic set)"
  const lines = [
    `! ${lowercaseMusicTerms(maqamName)} (12 pitch class chromatic set)`,
  ];

  // Second line: Generated by + base URL
  const baseUrl = metadata.baseUrl || 'https://diarmaqar.netlify.app';
  lines.push(`! Generated by the Digital Arabic Maqām Archive (DiArMaqAr) ${baseUrl}`);

  // Source Maqām (if provided, though it should always be provided)
  if (metadata.sourceMaqam) {
    lines.push(`! Source maqām: ${lowercaseMusicTerms(metadata.sourceMaqam)}`);
    // Source maqām tonic note name right after Source Maqām
    if (metadata.sourceMaqamTonicNoteName) {
      lines.push(`! Source maqām tonic note name: ${lowercaseMusicTerms(metadata.sourceMaqamTonicNoteName)}`);
    }
  }

  if (metadata.rootNote) {
    lines.push(`! Root note: ${lowercaseMusicTerms(metadata.rootNote)}`);
  }
  if (metadata.direction) {
    lines.push(`! Direction: ${toSentenceCase(metadata.direction)}`);
  }
  
  // Source tuning system with starting note name and reference frequency
  if (metadata.tuningSystem) {
    let tuningSystemLine = `! Source tuning system: ${metadata.tuningSystem}`;
    if (metadata.tuningSystemStartingNote) {
      // Ensure we use the actual note name, not a number
      const startingNoteName = metadata.tuningSystemStartingNote;
      tuningSystemLine += ` (starting note: ${lowercaseMusicTerms(startingNoteName)}`;
      if (metadata.tuningSystemStartingNoteRefFreq !== undefined) {
        tuningSystemLine += `, reference frequency: ${metadata.tuningSystemStartingNoteRefFreq.toFixed(2)} Hz`;
      }
      tuningSystemLine += ')';
    }
    lines.push(tuningSystemLine);
  }
  
  // Scala file reference frequency
  if (metadata.referenceFrequency !== undefined) {
    const frequencyNoteName = metadata.referenceFrequencyNoteName || '';
    const frequencyDisplay = frequencyNoteName
      ? `${metadata.referenceFrequency.toFixed(2)} Hz (${frequencyNoteName})`
      : `${metadata.referenceFrequency.toFixed(2)} Hz`;
    lines.push(`! Scala file 1/1 (0 cents) reference frequency: ${frequencyDisplay}`);
  }

  // Source maqām reference frequency
  if (metadata.sourceMaqam && metadata.sourceMaqamFrequency !== undefined && metadata.sourceMaqamIpnWithOctave && metadata.sourceMaqamTonicNoteName) {
    lines.push(`! Source maqām (${lowercaseMusicTerms(metadata.sourceMaqam)}) reference frequency: ${metadata.sourceMaqamIpnWithOctave}/${lowercaseMusicTerms(metadata.sourceMaqamTonicNoteName)} = ${metadata.sourceMaqamFrequency.toFixed(2)} Hz`);
  }

  // A4 reference frequency
  if (metadata.a4Frequency !== null && metadata.a4Frequency !== undefined && metadata.a4NoteName) {
    lines.push(`! A4 reference frequency: A4/${lowercaseMusicTerms(metadata.a4NoteName)} = ${metadata.a4Frequency.toFixed(2)} Hz`);
  }

  // Exported maqām tonic and frequency
  if (metadata.exportedMaqamName && metadata.exportedMaqamFrequency !== null && metadata.exportedMaqamFrequency !== undefined && metadata.exportedMaqamIpnWithOctave && metadata.exportedMaqamTonicNoteName) {
    lines.push(`! ${lowercaseMusicTerms(metadata.exportedMaqamName)} tonic and frequency: ${metadata.exportedMaqamIpnWithOctave}/${lowercaseMusicTerms(metadata.exportedMaqamTonicNoteName)} = ${metadata.exportedMaqamFrequency.toFixed(2)} Hz`);
  }

  if (metadata.url) {
    lines.push(`! More information: ${metadata.url}`);
  }
  
  if (metadata.compatibleMaqamat && metadata.compatibleMaqamat.length > 0) {
    lines.push(`!`);
    // Get total count from first maqam if available, otherwise use array length
    // The total count includes all octave equivalents (before grouping)
    const compatibleMaqamat = metadata.compatibleMaqamat;
    const totalCount = (compatibleMaqamat[0] as any)?.totalCount || compatibleMaqamat.length;
    const uniqueCount = compatibleMaqamat.length;
    lines.push(`! Compatible maqāmāt in this set: ${uniqueCount} unique / ${totalCount} inc. transpositions:`);
    compatibleMaqamat.forEach((maqam, index) => {
      lines.push(`! - ${lowercaseMusicTerms(maqam.name)}`);
      // Extract IPN without octave (e.g., "C3" -> "C")
      const tonicIpnWithoutOctave = maqam.tonicIpn.replace(/\d+$/, '');
      lines.push(`!   Tonic: ${tonicIpnWithoutOctave} (${lowercaseMusicTerms(maqam.tonicNoteName)}), position ${maqam.position}`);
      
      // Check if maqam is symmetrical - if so, show only one sequence
      const isSymmetrical = maqam.isSymmetrical ?? false;
      
      if (isSymmetrical) {
        // Symmetrical maqam - show only ascending sequence
        if (maqam.ascendingIpnNames && maqam.ascendingIpnNames.length > 0) {
          const ascendingStr = maqam.ascendingIpnNames.join(' → ');
          lines.push(`!   Sequence: ${ascendingStr}`);
          if (maqam.ascendingPositions && maqam.ascendingPositions.length > 0) {
            const positionsStr = maqam.ascendingPositions.join(' → ');
            lines.push(`!   Positions: ${positionsStr}`);
          }
        }
      } else {
        // Asymmetrical maqam - show both sequences
        // Add ascending sequence with positions if available
        if (maqam.ascendingIpnNames && maqam.ascendingIpnNames.length > 0) {
          const ascendingStr = maqam.ascendingIpnNames.join(' → ');
          if (maqam.ascendingPositions && maqam.ascendingPositions.length > 0) {
            const positionsStr = maqam.ascendingPositions.join(' → ');
            lines.push(`!   Ascending sequence: ${ascendingStr}`);
            lines.push(`!   Ascending positions: ${positionsStr}`);
          } else {
            lines.push(`!   Ascending sequence: ${ascendingStr}`);
          }
        }

        // Add descending sequence with positions if available
        if (maqam.descendingIpnNames && maqam.descendingIpnNames.length > 0) {
          const descendingStr = maqam.descendingIpnNames.join(' → ');
          lines.push(`!   Descending sequence: ${descendingStr}`);
          if (maqam.descendingPositions && maqam.descendingPositions.length > 0) {
            const positionsStr = maqam.descendingPositions.join(' → ');
            lines.push(`!   Descending positions: ${positionsStr}`);
          }
        }
      }
      
      // Add line break between maqamat (except after the last one)
      if (index < compatibleMaqamat.length - 1) {
        lines.push(`!`);
      }
    });
  }

  lines.push(`!`);
  return lines;
}

/**
 * Formats a pitch class value for Scala export
 *
 * For Scala files, only fraction/ratio formats are preserved from the original tuning system.
 * All other input types (stringLength, fretDivision, etc.) are converted to cents,
 * as cents is the preferred format for microtonal scales in Scala.
 *
 * @param pitchClass - Pitch class to format
 * @param formatType - Format type from the tuning system (any string)
 * @param precision - Number of decimal places for cents (default: 2)
 * @returns Formatted value string (fraction, decimalRatio, or cents)
 */
function formatPitchClassValue(
  pitchClass: PitchClass,
  formatType: string = 'cents',
  precision: number = 2
): string {
  // Only use fraction/ratio formats if explicitly specified
  // All other formats (stringLength, fretDivision, etc.) default to cents
  if (formatType === 'fraction') {
    return pitchClass.fraction;
  } else if (formatType === 'decimalRatio') {
    return pitchClass.decimalRatio;
  } else {
    // Default to cents for: 'cents', 'stringLength', 'fretDivision', and any other type
    return parseFloat(pitchClass.cents).toFixed(precision);
  }
}

/**
 * Builds a 12-tone chromatic keymap (.kbm) content string
 * @param maqamName - Display name of the maqam
 * @param tonicIpnRef - IPN reference of the tonic (e.g., "C", "D#")
 * @param tonicPosition - Position in chromatic scale (0-11)
 * @param tuningSystem - Primary tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system
 * @param refFreq - Reference frequency in Hz
 * @param actualMapSize - MIDI map size (default: 128)
 * @param scaleSize - Scale size (always 12 for chromatic)
 * @returns Formatted keymap content string
 */
function build12ToneKeymapContent(
  maqamName: string,
  tonicIpnRef: string,
  tonicPosition: number,
  tuningSystem: TuningSystem,
  alKindiTuningSystem: TuningSystem,
  refFreq: number,
  actualMapSize: number = 128,
  scaleSize: number = 12
): string {
  const referenceNoteIndex = 0; // Always C for 12-tone chromatic sets
  const mapping = Array.from({ length: actualMapSize }, (_, i) => i % scaleSize);

  const desc = `${maqamName} (tonic: ${tonicIpnRef}) - 12-Tone Chromatic Set Keymap (${tuningSystem.getTitleEnglish()} + al-Kindi)`;

  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Maqam: ${maqamName}`,
    `! Tonic: ${tonicIpnRef} (position ${tonicPosition})`,
    `! Tuning: ${tuningSystem.getTitleEnglish()} + ${alKindiTuningSystem.getTitleEnglish()}`,
    `! Reference note: C (IPN)`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${referenceNoteIndex}`, // Reference note index (C = 0)
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size (always 12)
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}


// ============================================================================
// Tuning System Exports
// ============================================================================

/**
 * Exports a tuning system to Scala (.scl) format
 * https://www.huygens-fokker.org/scala/scl_format.html
 */
export function exportTuningSystemToScala(tuningSystem: TuningSystem, startingNote: string, description?: string): string {
  // Filter to single octave and remove duplicates
  const pitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote);
  const octavePitchClasses = filterToOctave(pitchClasses);
  const uniquePitchClasses = removeDuplicatePitchClasses(octavePitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Ensure the octave (1200 cents) is included as the final value
  const hasOctave = scaleNotes.some(pc => Math.abs(parseFloat(pc.cents) - 1200) < 0.01);
  if (!hasOctave) {
    // Add the octave as the final note
    scaleNotes.push({
      ...scaleNotes[0], // Base it on first note
      cents: '1200.00',
      frequency: scaleNotes[0]?.frequency ? (parseFloat(scaleNotes[0].frequency) * 2).toString() : '',
      octave: (scaleNotes[0]?.octave || 0) + 1
    } as PitchClass);
  }

  // Sort by cents to ensure proper order
  scaleNotes.sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));

  // Generate description
  const desc = description || `${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content
  const headerLines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Starting note: ${startingNote}`,
    `! Source: ${tuningSystem.getSourceEnglish()}`,
    `!`,
  ];

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a tuning system to Scala keymap (.kbm) format
 * https://www.huygens-fokker.org/scala/help.htm#mappings
 */
export function exportTuningSystemToScalaKeymap(tuningSystem: TuningSystem, startingNote: string, referenceNote?: string, referenceFrequency?: number, mapSize?: number): string {
  // Filter to single octave and remove duplicates
  const pitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote);
  const octavePitchClasses = filterToOctave(pitchClasses);
  const uniquePitchClasses = removeDuplicatePitchClasses(octavePitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || startingNote;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${tuningSystem.getTitleEnglish()} Keymap (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Starting note: ${startingNote}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a jins to Scala (.scl) format
 */
export function exportJinsToScala(jinsInput: Jins | JinsData, tuningSystem: TuningSystem, startingNote?: string, description?: string): string {
  let jins: Jins;

  // Check if input is a Jins instance or JinsData
  if ("jinsId" in jinsInput) {
    // It's a Jins instance - use directly
    jins = jinsInput;
  } else {
    // It's a JinsData instance - convert to Jins using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    jins = jinsInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = jins.jinsPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Generate description
  const desc = description || `${jins.name} - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content using helper
  const headerLines = buildScalaHeader(desc, {
    rootNote: pitchClasses[0]?.noteName,
    tuningSystem: tuningSystem.getTitleEnglish(),
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a jins to Scala keymap (.kbm) format
 */
export function exportJinsToScalaKeymap(
  jinsInput: Jins | JinsData,
  tuningSystem: TuningSystem,
  startingNote?: string,
  referenceNote?: string,
  referenceFrequency?: number,
  mapSize?: number
): string {
  let jins: Jins;

  // Check if input is a Jins instance or JinsData
  if ("jinsId" in jinsInput) {
    // It's a Jins instance - use directly
    jins = jinsInput;
  } else {
    // It's a JinsData instance - convert to Jins using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    jins = jinsInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = jins.jinsPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || pitchClasses[0]?.noteName;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${jins.name} Keymap - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Jins: ${jins.name}`,
    `! Root note: ${pitchClasses[0]?.noteName}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam to Scala (.scl) format
 */
export function exportMaqamToScala(maqamInput: Maqam | MaqamData, tuningSystem: TuningSystem, startingNote?: string, useAscending: boolean = true, description?: string): string {
  let maqam: Maqam;

  // Check if input is a Maqam instance or MaqamData
  if ("maqamId" in maqamInput) {
    // It's a Maqam instance - use directly
    maqam = maqamInput;
  } else {
    // It's a MaqamData instance - convert to Maqam using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    maqam = maqamInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = useAscending ? maqam.ascendingPitchClasses : maqam.descendingPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Generate description
  const desc = description || `${maqam.name} (${useAscending ? "Ascending" : "Descending"}) - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content using helper
  const headerLines = buildScalaHeader(desc, {
    direction: useAscending ? "Ascending" : "Descending",
    rootNote: pitchClasses[0]?.noteName,
    tuningSystem: tuningSystem.getTitleEnglish(),
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam to Scala keymap (.kbm) format
 */
export function exportMaqamToScalaKeymap(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote?: string,
  useAscending: boolean = true,
  referenceNote?: string,
  referenceFrequency?: number,
  mapSize?: number
): string {
  let maqam: Maqam;

  // Check if input is a Maqam instance or MaqamData
  if ("maqamId" in maqamInput) {
    // It's a Maqam instance - use directly
    maqam = maqamInput;
  } else {
    // It's a MaqamData instance - convert to Maqam using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    maqam = maqamInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = useAscending ? maqam.ascendingPitchClasses : maqam.descendingPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || pitchClasses[0]?.noteName;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${maqam.name} (${useAscending ? "Ascending" : "Descending"}) Keymap - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Maqam: ${maqam.name}`,
    `! Direction: ${useAscending ? "Ascending" : "Descending"}`,
    `! Root note: ${pitchClasses[0]?.noteName}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

// ============================================================================
// 12-Tone Chromatic Set Exports
// ============================================================================

/**
 * Exports a maqam as a complete 12-tone chromatic set to Scala (.scl) format
 *
 * This function creates a 12-pitch-class set by merging the maqam's pitch classes
 * with al-Kindi (874) filler pitch classes, suitable for MIDI keyboard mapping.
 * The set ALWAYS starts from IPN C for maximum MIDI compatibility.
 *
 * The header lists ALL compatible maqāmāt that can be played using this set,
 * along with their tonic positions in the chromatic scale.
 *
 * @param maqamData - MaqamData instance to export
 * @param tuningSystem - Tuning system to realize the maqam in
 * @param startingNote - Starting note for the tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system for filler pitches
 * @param alKindiStartingNote - Starting note for al-Kindi tuning system
 * @param description - Optional custom description
 * @returns Scala .scl file content as string, or null if maqam is incompatible
 */
export function exportMaqamTo12ToneScala(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote: string,
  alKindiTuningSystem: TuningSystem,
  alKindiStartingNote: string,
  description?: string,
  currentUrl?: string
): string | null {
  // Get dependencies
  const allMaqamat = getMaqamat();
  const ajnas = getAjnas();

  // Get the MaqamData
  let maqamData: MaqamData;
  if ("maqamId" in maqamInput) {
    const foundMaqam = allMaqamat.find(m => m.getId() === maqamInput.maqamId);
    if (!foundMaqam) {
      return null;
    }
    maqamData = foundMaqam;
  } else {
    maqamData = maqamInput;
  }

  // Run global classification to find sets (matches API behavior)
  const classificationResult = classifyMaqamat(
    allMaqamat,
    tuningSystem,
    startingNote,
    alKindiTuningSystem,
    alKindiStartingNote,
    ajnas,
    5 // cents tolerance
  );

  // Find the set for this maqam
  // STRATEGY:
  // 1. First try to find a set where this maqam is the SOURCE
  // 2. If not found, find ANY set where this maqam appears in compatibleMaqamat
  //    and use that set's source maqam instead
  const maqamIdStandardized = standardizeText(maqamData.getId());

  // Try to find set where this maqam is the SOURCE
  let matchingSet = classificationResult.sets.find(set =>
    standardizeText(set.sourceMaqam.id) === maqamIdStandardized ||
    set.sourceMaqam.idName === maqamIdStandardized
  );

  // If not a source maqam, find the set where this maqam appears as compatible
  if (!matchingSet) {
    matchingSet = classificationResult.sets.find(set =>
      set.compatibleMaqamat.some(cm =>
        standardizeText(cm.maqamData.getId()) === maqamIdStandardized
      )
    );

    if (!matchingSet) {
      return null; // Maqam doesn't appear in any 12-pitch-class set
    }
  }

  // Use the set's pitch class data
  // CRITICAL: Pitch classes are already in chromatic ascending order from create12PitchClassSet
  // with correct octave selection. Do NOT re-sort them or the octave selection will break.
  const pitchClassSetResult = matchingSet.pitchClassSet;

  // Get all tuning system pitch classes for octave shifting (always needed for Scala export)
  // This matches the API endpoint behavior when startSetFromC=true
  const allTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote as any);

  // Get all 12 pitch classes from the original set
  const allPitchClasses: Array<{ ipnRef: string; pitchClass: PitchClass }> = [];

  // Get the maqam tonic IPN reference (first entry in the Map, which is ordered from tonic)
  // This matches the API endpoint logic exactly
  const maqamTonicIpnRef = pitchClassSetResult.pitchClasses.entries().next().value?.[0] || 'C';

  // Define chromatic order for comparison
  const chromaticOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const tonicIndex = chromaticOrder.indexOf(maqamTonicIpnRef);

  // Build pitch class array with octave shifting for Scala mode
  // This matches the API endpoint logic when startSetFromC=true
  for (const [ipnRef, pc] of pitchClassSetResult.pitchClasses.entries()) {
    let pitchClassToUse = pc;

    // For Scala mode: shift octave 2 notes that come BEFORE the tonic to octave 1
    // This handles cases where the maqam starts mid-octave (e.g., D)
    // and we need C and C# from octave 1 instead of octave 2
    // This matches the API endpoint logic exactly
    if (pc.octave === 2 && allTuningSystemPitchClasses) {
      const currentIndex = chromaticOrder.indexOf(ipnRef);
      // If this note comes before the tonic in chromatic order, get octave 1 equivalent
      if (currentIndex < tonicIndex) {
        const octave1Equivalent = allTuningSystemPitchClasses.find(
          tpc => tpc.referenceNoteName === ipnRef && tpc.octave === 1
        );

        if (octave1Equivalent) {
          pitchClassToUse = octave1Equivalent;
        }
      }
    }

    allPitchClasses.push({ ipnRef, pitchClass: pitchClassToUse });
  }

  // For Scala mode: rotate array to start from C
  // This matches the API endpoint logic when startSetFromC=true
  let orderedPitchClasses = allPitchClasses;
  const cIndex = allPitchClasses.findIndex(item => item.ipnRef === 'C');
  if (cIndex !== -1 && cIndex > 0) {
    orderedPitchClasses = [
      ...allPitchClasses.slice(cIndex),
      ...allPitchClasses.slice(0, cIndex)
    ];
  }

  // Get reference cents from the FIRST pitch class in the ordered array
  // This will be C (since we're in Scala mode, always starting from C)
  // This matches the API endpoint logic when startSetFromC=true
  const referenceCents = orderedPitchClasses.length > 0
    ? parseFloat(orderedPitchClasses[0].pitchClass.cents)
    : 0;

  // Add relativeCents property to each pitch class
  // This matches the API endpoint logic exactly
  const pitchClassSetWithRelativeCents = orderedPitchClasses.map(item => {
    const pitchClass = item.pitchClass;
    const cents = parseFloat(pitchClass.cents);

    // Calculate cents relative to reference
    // The rebuild function already ensures chromatic ascending order
    // so relativeCents should naturally be positive and ascending
    let relativeCents = cents - referenceCents;

    // Handle octave wrap-around for Scala mode
    // When pitch classes from lower octaves are rotated to come after C,
    // add 1200 cents to make the relative cents positive
    // This matches the API endpoint logic exactly
    if (relativeCents < 0) {
      relativeCents += 1200;
    }

    return {
      ...pitchClass,
      relativeCents: relativeCents.toFixed(2)
    };
  });

  // Calculate reference frequency for Middle C (the 1/1 note at position 0)
  // The C pitch class is at position 0 in orderedPitchClasses (after rotation)
  // The pitch class frequency field already contains the correct frequency based on the tuning system
  const cPitchClass = orderedPitchClasses[0]?.pitchClass;
  let referenceFrequency: number;
  let referenceFrequencyNoteName: string = '';
  
  if (cPitchClass && cPitchClass.frequency) {
    // Use the frequency directly from the pitch class (already calculated correctly)
    referenceFrequency = parseFloat(cPitchClass.frequency);
    // Get the English note name with octave (e.g., C4, A4)
    referenceFrequencyNoteName = getIpnReferenceNoteNameWithOctave(cPitchClass);
  } else {
    // Fallback: calculate from tuning system reference frequency
    // Formula: frequency = referenceFrequency * 2^(cents/1200)
    const cCents = cPitchClass ? parseFloat(cPitchClass.cents) : 0;
    const tuningSystemRefFreq = tuningSystem.getDefaultReferenceFrequency() || 440.0;
    
    // Get the starting note's pitch class to calculate C's frequency relative to it
    const startingNotePitchClass = allTuningSystemPitchClasses.find(
      pc => pc.noteName === startingNote
    );
    
    if (startingNotePitchClass) {
      // Calculate C's frequency relative to the starting note
      // If starting note is at X cents and C is at Y cents, then:
      // C_frequency = starting_note_frequency * 2^((Y - X)/1200)
      const startingNoteCents = parseFloat(startingNotePitchClass.cents);
      const startingNoteFreq = parseFloat(startingNotePitchClass.frequency);
      const centsDiff = cCents - startingNoteCents;
      referenceFrequency = startingNoteFreq * Math.pow(2, centsDiff / 1200);
      if (cPitchClass) {
        referenceFrequencyNoteName = getIpnReferenceNoteNameWithOctave(cPitchClass);
      }
    } else {
      // Final fallback: use default reference frequency
      referenceFrequency = tuningSystemRefFreq;
    }
  }
  
  // Get base maqam tonic note name from the source maqam transposition
  const baseMaqamTonicPitchClass = matchingSet.sourceTransposition.ascendingPitchClasses?.[0];
  const baseMaqamTonicNoteName = baseMaqamTonicPitchClass?.noteName || '';

  // Use compatible maqamat from the classification result
  // Enhanced with tonic note names, IPN sequences, and position numbers
  const compatibleMaqamatInfo: Array<{
    name: string;
    baseMaqamId: string;
    tonicIpn: string;
    tonicNoteName: string;
    position: number;
    ascendingIpnNames: string[];
    descendingIpnNames: string[];
    ascendingPositions: number[];
    descendingPositions: number[];
    isSymmetrical: boolean;
    isTransposition: boolean;
  }> = [];
  const seenMaqamatByTonic = new Set<string>(); // Track maqam:tonic combinations to avoid duplicates

  // Create a map of IPN reference to position in the ordered pitch classes for quick lookup
  const ipnToPositionMap = new Map<string, number>();
  orderedPitchClasses.forEach((item, index) => {
    ipnToPositionMap.set(item.ipnRef, index);
  });

  for (const maqamInfo of matchingSet.compatibleMaqamat) {
    // Get the tonic for this specific maqam from its ascending pitch classes
    // This matches the API endpoint logic exactly
    const maqamTonicPitchClass = maqamInfo.maqam.ascendingPitchClasses?.[0];
    
    // Get the tonic note name (e.g., "dūgāh", "segāh")
    const tonicNoteName = maqamTonicPitchClass?.noteName || '';
    
    // Get the IPN reference note name for the tonic (e.g., "D", "C#")
    // This works even if the tonic is in a different octave (e.g., qarār dūgāh -> "D")
    const tonicIpnRef = maqamTonicPitchClass?.referenceNoteName || '';

    // Find the matching IPN in the 12-pitch-class set (after rotation to start from C)
    // This finds the octave equivalent within the set
    // This matches the API endpoint logic exactly
    const maqamTonicPitchClassMatch = tonicIpnRef
      ? orderedPitchClasses.find(item => item.ipnRef === tonicIpnRef)
      : null;

    const maqamTonicIpnRef = maqamTonicPitchClassMatch?.ipnRef || tonicIpnRef;
    const maqamTonicPositionInSet = maqamTonicPitchClassMatch
      ? orderedPitchClasses.findIndex(item => item.ipnRef === tonicIpnRef)
      : -1;

    // Get pitch class details for ascending sequence
    // Use the same approach as the API endpoint - get pitch classes directly from the maqam
    // Format: Persian-Arab-Ottoman note name first, then English name in brackets (e.g., "rāst (C4)")
    const ascendingIpnNames: string[] = [];
    const ascendingPositions: number[] = [];
    if (maqamInfo.maqam.ascendingPitchClasses) {
      for (const pc of maqamInfo.maqam.ascendingPitchClasses) {
        const ipnRef = getIpnReferenceNoteName(pc);
        if (ipnRef) {
          const position = ipnToPositionMap.get(ipnRef);
          if (position !== undefined) {
            // Get English note name (should already include octave, e.g., "C4", "D4")
            const englishName = pc.englishName || '';
            // Get Persian-Arab-Ottoman note name
            const noteName = pc.noteName || '';
            // Format: "noteName (englishName)" or just "englishName" if noteName is empty
            const formattedName = noteName && englishName
              ? `${noteName} (${englishName})`
              : englishName || noteName || '';
            
            ascendingIpnNames.push(formattedName);
            ascendingPositions.push(position);
          }
        }
      }
    }

    // Get pitch class details for descending sequence
    const descendingIpnNames: string[] = [];
    const descendingPositions: number[] = [];
    if (maqamInfo.maqam.descendingPitchClasses) {
      for (const pc of maqamInfo.maqam.descendingPitchClasses) {
        const ipnRef = getIpnReferenceNoteName(pc);
        if (ipnRef) {
          const position = ipnToPositionMap.get(ipnRef);
          if (position !== undefined) {
            // Get English note name (should already include octave, e.g., "C4", "D4")
            const englishName = pc.englishName || '';
            // Get Persian-Arab-Ottoman note name
            const noteName = pc.noteName || '';
            // Format: "noteName (englishName)" or just "englishName" if noteName is empty
            const formattedName = noteName && englishName
              ? `${noteName} (${englishName})`
              : englishName || noteName || '';
            
            descendingIpnNames.push(formattedName);
            descendingPositions.push(position);
          }
        }
      }
    }
    
    // Check if maqam is symmetrical (ascending == descending when reversed)
    const isSymmetrical = ascendingIpnNames.length === descendingIpnNames.length &&
      ascendingIpnNames.length > 0 &&
      JSON.stringify(ascendingIpnNames) === JSON.stringify([...descendingIpnNames].reverse());

    // Use transposition name + tonic IPN as key to avoid listing duplicates
    // This matches the API endpoint which shows all transpositions separately
    // Note: The classification result may contain duplicates, so we deduplicate here
    // Use maqam.name (transposition name) instead of maqamData.getName() (base name)
    // to show all transpositions separately, matching the API behavior
    const transpositionName = maqamInfo.maqam.name;
    const key = `${transpositionName}:${maqamTonicIpnRef}`;
    if (!seenMaqamatByTonic.has(key)) {
      // Get the full English name with octave for the tonic (e.g., "C4", "C2")
      // ALWAYS use getIpnReferenceNoteNameWithOctave to ensure uppercase and correct format
      const tonicIpnWithOctave = maqamTonicPitchClass
        ? getIpnReferenceNoteNameWithOctave(maqamTonicPitchClass)
        : 'Unknown';

      compatibleMaqamatInfo.push({
        name: transpositionName,
        baseMaqamId: maqamInfo.maqamData.getId(),
        tonicIpn: tonicIpnWithOctave,
        tonicNoteName: tonicNoteName,
        position: maqamTonicPositionInSet >= 0 ? maqamTonicPositionInSet : 0,
        ascendingIpnNames: ascendingIpnNames,
        descendingIpnNames: descendingIpnNames,
        ascendingPositions: ascendingPositions,
        descendingPositions: descendingPositions,
        isSymmetrical: isSymmetrical,
        isTransposition: !!maqamInfo.maqam.transposition,
      });
      seenMaqamatByTonic.add(key);
    }
  }

  // Store the total count BEFORE grouping (includes all octave equivalents)
  // This matches the API response which counts all compatible maqamat individually
  const totalCompatibleMaqamatCount = compatibleMaqamatInfo.length;
  
  // Group octave equivalent maqamat together
  // Octave equivalents have the same base maqam ID but different octave transpositions
  const maqamGroups = new Map<string, Array<typeof compatibleMaqamatInfo[0]>>();
  
  for (const maqam of compatibleMaqamatInfo) {
    // Group by base maqam ID
    const baseId = maqam.baseMaqamId;
    
    if (!maqamGroups.has(baseId)) {
      maqamGroups.set(baseId, []);
    }
    maqamGroups.get(baseId)!.push(maqam);
  }
  
  // Rebuild compatibleMaqamatInfo with grouped octave equivalents
  const groupedMaqamatInfo: Array<typeof compatibleMaqamatInfo[0] & { totalCount?: number }> = [];
  
  for (const maqamat of maqamGroups.values()) {
    if (maqamat.length === 1) {
      // Single maqam, no octave equivalents
      groupedMaqamatInfo.push({
        ...maqamat[0],
        totalCount: totalCompatibleMaqamatCount
      });
    } else {
      // Multiple maqamat - prioritize tahlil (non-transposed) version first
      // Then sort remaining transpositions by MIDI note (ascending pitch order)
      maqamat.sort((a, b) => {
        // PRIORITY 1: Tahlil (non-transposed) versions come first
        if (a.isTransposition !== b.isTransposition) {
          return a.isTransposition ? 1 : -1; // Non-transposed (false) comes before transposed (true)
        }

        // PRIORITY 2: Sort by MIDI note (ascending pitch order)
        // Extract MIDI note from tonicIpn (e.g., "C3" -> MIDI 48)
        const getMidiNote = (ipn: string): number => {
          const match = ipn.match(/^([A-G][#b]?)(\d+)$/);
          if (!match) return 60; // Default to middle C
          const [, note, octaveStr] = match;
          const octave = parseInt(octaveStr);
          const noteToChroma: { [key: string]: number } = {
            'C': 0, 'C#': 1, 'D': 2, 'D#': 3, 'E': 4, 'F': 5,
            'F#': 6, 'G': 7, 'G#': 8, 'A': 9, 'A#': 10, 'B': 11, 'Bb': 10, 'Eb': 3, 'Ab': 8
          };
          const chroma = noteToChroma[note] || 0;
          return (octave + 1) * 12 + chroma;
        };

        const aMidi = getMidiNote(a.tonicIpn);
        const bMidi = getMidiNote(b.tonicIpn);
        if (aMidi !== bMidi) {
          return aMidi - bMidi; // Sort by ascending pitch
        }

        // PRIORITY 3: If MIDI notes are equal, prefer ones without "al-" prefix
        const aHasAl = a.name.includes(' al-');
        const bHasAl = b.name.includes(' al-');
        if (aHasAl !== bHasAl) {
          return aHasAl ? 1 : -1;
        }

        // PRIORITY 4: Shorter name first
        return a.name.length - b.name.length;
      });

      const mainMaqam = maqamat[0];
      // Build transposition list with IPN in parentheses
      const transpositions = maqamat.slice(1).map(m => `${m.name} (${m.tonicIpn})`);

      groupedMaqamatInfo.push({
        ...mainMaqam,
        name: transpositions.length > 0
          ? `${mainMaqam.name} (and its transposition${transpositions.length > 1 ? 's' : ''}: ${transpositions.join(', ')})`
          : mainMaqam.name,
        totalCount: totalCompatibleMaqamatCount
      });
    }
  }
  
  // Sort by position
  groupedMaqamatInfo.sort((a, b) => a.position - b.position);
  
  // Update compatibleMaqamatInfo reference
  compatibleMaqamatInfo.length = 0;
  compatibleMaqamatInfo.push(...groupedMaqamatInfo);

  // Remove the root note (0 cents relative) as it's implicit in Scala format
  const scaleNotes = pitchClassSetWithRelativeCents.filter((pc) => parseFloat(pc.relativeCents) > 0);

  // For a 12-tone chromatic set, we need 12 notes total:
  // - 11 intervals (excluding root at 0 cents)
  // - 1 octave at 1200 cents
  // Add the octave (1200.00 cents) as the final note if it's not already present
  const hasOctave = scaleNotes.some(pc => Math.abs(parseFloat(pc.relativeCents) - 1200) < 0.01);
  if (!hasOctave) {
    // Create an octave pitch class based on the root note (first pitch class)
    const rootPitchClass = orderedPitchClasses[0]?.pitchClass;
    if (rootPitchClass) {
      // Create octave version: same pitch class, one octave up
      const octavePitchClass = {
        ...rootPitchClass,
        relativeCents: '1200.00',
        octave: rootPitchClass.octave + 1,
        // Update frequency to be double (one octave up)
        frequency: rootPitchClass.frequency ? (parseFloat(rootPitchClass.frequency) * 2).toFixed(2) : '',
        // Update cents to be +1200 from root
        cents: rootPitchClass.cents ? (parseFloat(rootPitchClass.cents) + 1200).toFixed(2) : '1200.00',
      };
      scaleNotes.push(octavePitchClass);
    }
  }

  // Ensure we have exactly 12 notes (11 intervals + 1 octave)
  // Sort by relative cents to ensure proper order
  scaleNotes.sort((a, b) => parseFloat(a.relativeCents) - parseFloat(b.relativeCents));

  // Generate description (for the Scala file body, not header)
  const desc = description || `${maqamData.getName().toLowerCase()} - 12-tone chromatic set (${tuningSystem.stringify()} + ${alKindiTuningSystem.stringify()})`;

  // Extract base URL from currentUrl (e.g., "http://localhost:3000" or "https://diarmaqar.netlify.app")
  let baseUrl = 'https://diarmaqar.netlify.app'; // Default fallback
  if (currentUrl) {
    try {
      const urlObj = new URL(currentUrl);
      baseUrl = `${urlObj.protocol}//${urlObj.host}`;
    } catch {
      // If URL parsing fails, use default
    }
  }

  // Get the actual note name from the tuning system's note name sets
  // This matches the API endpoint logic (route.ts lines 293-311)
  // It ensures we use the proper note name with diacritics
  const noteNameSets = tuningSystem.getNoteNameSets();
  const validNoteSet = noteNameSets.find(
    (set) => standardizeText(set[0] || "") === standardizeText(startingNote)
  );
  const actualStartingNoteName = validNoteSet?.[0] || startingNote;

  // Get starting note's reference frequency from tuning system
  const referenceFrequencies = tuningSystem.getReferenceFrequencies();
  const startingNoteRefFreq = referenceFrequencies[actualStartingNoteName] || tuningSystem.getDefaultReferenceFrequency();

  // Calculate SOURCE maqam reference frequency
  const sourceMaqamName = matchingSet.sourceMaqam.name;
  const sourceMaqamFrequency = baseMaqamTonicPitchClass?.frequency
    ? parseFloat(baseMaqamTonicPitchClass.frequency)
    : referenceFrequency;
  const sourceMaqamIpnWithOctave = baseMaqamTonicPitchClass
    ? getIpnReferenceNoteNameWithOctave(baseMaqamTonicPitchClass)
    : 'Unknown';

  // Find A4 in the pitch classes
  // A4 = MIDI note 69, frequency ~440 Hz
  // Search for EXACTLY A4 with no microtonal modifiers (natural A4)
  const a4PitchClass = allTuningSystemPitchClasses.find(pc => {
    return pc.englishName === 'A4';
  });
  const a4Frequency = a4PitchClass?.frequency ? parseFloat(a4PitchClass.frequency) : null;
  const a4NoteName = a4PitchClass?.noteName || '';

  // Get EXPORTED maqam tonic frequency
  // Find the exported maqam in compatibleMaqamat
  const exportedMaqamInfo = matchingSet.compatibleMaqamat.find(cm =>
    standardizeText(cm.maqamData.getId()) === maqamIdStandardized
  );
  const exportedMaqamTonicPitchClass = exportedMaqamInfo?.maqam.ascendingPitchClasses?.[0];
  const exportedMaqamFrequency = exportedMaqamTonicPitchClass?.frequency
    ? parseFloat(exportedMaqamTonicPitchClass.frequency)
    : null;
  const exportedMaqamIpnWithOctave = exportedMaqamTonicPitchClass
    ? getIpnReferenceNoteNameWithOctave(exportedMaqamTonicPitchClass)
    : 'Unknown';
  const exportedMaqamTonicNoteName = exportedMaqamTonicPitchClass?.noteName || '';

  // Build Scala file content with compatible maqāmāt listing
  const headerLines = buildScalaHeader(maqamData.getName(), {
    sourceMaqam: sourceMaqamName,
    tuningSystem: `${tuningSystem.stringify()} + ${alKindiTuningSystem.stringify()}`,
    tuningSystemStartingNote: actualStartingNoteName,
    tuningSystemStartingNoteRefFreq: startingNoteRefFreq,
    referenceFrequency: referenceFrequency,
    referenceFrequencyNoteName: referenceFrequencyNoteName,
    sourceMaqamTonicNoteName: baseMaqamTonicNoteName,
    sourceMaqamFrequency: sourceMaqamFrequency,
    sourceMaqamIpnWithOctave: sourceMaqamIpnWithOctave,
    a4Frequency: a4Frequency,
    a4NoteName: a4NoteName,
    exportedMaqamName: maqamData.getName(),
    exportedMaqamFrequency: exportedMaqamFrequency,
    exportedMaqamIpnWithOctave: exportedMaqamIpnWithOctave,
    exportedMaqamTonicNoteName: exportedMaqamTonicNoteName,
    baseUrl: baseUrl,
    url: currentUrl,
    compatibleMaqamat: compatibleMaqamatInfo,
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`, // Should be 12 for a 12-tone chromatic set
    `!`,
    ...scaleNotes.map((pc) => pc.relativeCents), // Already formatted as string with 2 decimal places
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam as a complete 12-tone chromatic set to Scala keymap (.kbm) format
 *
 * Creates multiple keymaps - one for each compatible maqām transposition in the 12-pitch-class set.
 * Includes all transpositions but excludes octave duplicates (only one keymap per IPN tonic).
 * All keymaps reference the same .scl file but map MIDI keys differently based on each maqām's tonic.
 *
 * @param maqamData - MaqamData instance to export
 * @param tuningSystem - Tuning system to realize the maqam in
 * @param startingNote - Starting note for the tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system for filler pitches
 * @param alKindiStartingNote - Starting note for al-Kindi tuning system
 * @param referenceFrequency - Optional reference frequency (default: from tuning system)
 * @param mapSize - Optional map size (default: 128 for full MIDI range)
 * @returns Array of keymap objects with metadata, or null if maqam is incompatible
 */
export function exportMaqamTo12ToneScalaKeymap(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote: string,
  alKindiTuningSystem: TuningSystem,
  alKindiStartingNote: string,
  referenceFrequency?: number,
  mapSize?: number
): Array<{
  maqamName: string;
  maqamId: string;
  tonic: string;
  tonicPosition: number;
  keymapContent: string;
}> | null {
  // Get dependencies
  const allMaqamat = getMaqamat();
  const ajnas = getAjnas();

  // Get the MaqamData
  let maqamData: MaqamData;
  if ("maqamId" in maqamInput) {
    const foundMaqam = allMaqamat.find(m => m.getId() === maqamInput.maqamId);
    if (!foundMaqam) {
      return null;
    }
    maqamData = foundMaqam;
  } else {
    maqamData = maqamInput;
  }

  // Run global classification to find sets (matches API behavior)
  const classificationResult = classifyMaqamat(
    allMaqamat,
    tuningSystem,
    startingNote,
    alKindiTuningSystem,
    alKindiStartingNote,
    ajnas,
    5 // cents tolerance
  );

  // Find the set for this maqam
  // STRATEGY:
  // 1. First try to find a set where this maqam is the SOURCE
  // 2. If not found, find ANY set where this maqam appears in compatibleMaqamat
  //    and use that set's source maqam instead
  const maqamIdStandardized = standardizeText(maqamData.getId());

  // Try to find set where this maqam is the SOURCE
  let matchingSet = classificationResult.sets.find(set =>
    standardizeText(set.sourceMaqam.id) === maqamIdStandardized ||
    set.sourceMaqam.idName === maqamIdStandardized
  );

  // If not a source maqam, find the set where this maqam appears as compatible
  if (!matchingSet) {
    matchingSet = classificationResult.sets.find(set =>
      set.compatibleMaqamat.some(cm =>
        standardizeText(cm.maqamData.getId()) === maqamIdStandardized
      )
    );

    if (!matchingSet) {
      return null; // Maqam doesn't appear in any 12-pitch-class set
    }
  }

  // Use compatible maqamat from the classification result (deduplicated by IPN tonic)
  const chromaticOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const uniqueTranspositions = new Map<string, {
    maqamData: MaqamData;
    tonicIpnRef: string;
    tonicPosition: number;
  }>();

  for (const maqamInfo of matchingSet.compatibleMaqamat) {
    // Find the tonic IPN reference for this transposition
    const tonicIpnRef = maqamInfo.maqam.ascendingPitchClasses[0]?.referenceNoteName;
    if (!tonicIpnRef) continue;

    const tonicPosition = chromaticOrder.indexOf(tonicIpnRef);
    if (tonicPosition < 0) continue;

    // Use maqamId:ipnTonic as key to deduplicate octave equivalents
    const key = `${maqamInfo.maqamData.getId()}:${tonicIpnRef}`;

    // Only add if not already present
    if (!uniqueTranspositions.has(key)) {
      uniqueTranspositions.set(key, {
        maqamData: maqamInfo.maqamData,
        tonicIpnRef,
        tonicPosition,
      });
    }
  }

  // Generate one keymap per unique transposition
  const actualMapSize = mapSize || 128;
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;

  const keymaps = Array.from(uniqueTranspositions.values()).map(entry => ({
    maqamName: entry.maqamData.getName(),
    maqamId: entry.maqamData.getId(),
    tonic: entry.tonicIpnRef,
    tonicPosition: entry.tonicPosition,
    keymapContent: build12ToneKeymapContent(
      entry.maqamData.getName(),
      entry.tonicIpnRef,
      entry.tonicPosition,
      tuningSystem,
      alKindiTuningSystem,
      refFreq,
      actualMapSize
    ),
  }));

  // Sort by tonic position for better organization
  keymaps.sort((a, b) => a.tonicPosition - b.tonicPosition);

  return keymaps;
}

// ============================================================================
// Tuning System Octave + Maqam/Jins Keymap Exports
// ============================================================================

/**
 * Maps maqam or jins pitch classes to tuning system degrees with cents tolerance
 * @param maqamOrJinsPitchClasses - Pitch classes from maqam or jins
 * @param tuningSystemPitchClasses - Pitch classes from tuning system octave 1
 * @param tolerance - Cents tolerance for matching (default: 5)
 * @returns Array of tuning system degree indices (0-based), or null if any pitch class cannot be matched
 */
function mapPitchClassesToTuningSystemDegrees(
  maqamOrJinsPitchClasses: PitchClass[],
  tuningSystemPitchClasses: PitchClass[],
  tolerance: number = 5
): number[] | null {
  const degrees: number[] = [];

  for (const pc of maqamOrJinsPitchClasses) {
    const cents = parseFloat(pc.cents);

    // Normalize cents to octave 1 range (0-1200) for comparison
    // This handles cases where maqam pitch classes are in different octaves
    const normalizedCents = ((cents % 1200) + 1200) % 1200;

    // Find matching tuning system pitch class within tolerance
    const matchIndex = tuningSystemPitchClasses.findIndex(tspc => {
      const tsCents = parseFloat(tspc.cents);
      const tsCentsNormalized = ((tsCents % 1200) + 1200) % 1200;

      // Compare normalized values
      const diff = Math.abs(normalizedCents - tsCentsNormalized);

      // Also check wrap-around case (e.g., 5 cents vs 1195 cents should be close)
      const diffWrapped = Math.min(diff, 1200 - diff);

      return diffWrapped < tolerance;
    });

    if (matchIndex === -1) {
      // Cannot find matching pitch class in tuning system
      return null;
    }

    degrees.push(matchIndex);
  }

  return degrees;
}

/**
 * Converts an IPN englishName (e.g., "A2", "G#3", "Bb2") to a MIDI note number
 * MIDI note 0 = C-1, MIDI note 60 = C4 (middle C)
 */
function englishNameToMidiNote(englishName: string): number {
  // Extract note letter, accidental, and octave from englishName
  const match = englishName.match(/^([A-G])([#b]?)(-?\d+)$/);
  if (!match) {
    return 60; // Default to middle C if parsing fails
  }

  const [, noteLetter, accidental, octaveStr] = match;
  const octave = parseInt(octaveStr);

  // Convert note letter to pitch class number (C=0, D=2, E=4, F=5, G=7, A=9, B=11)
  const noteLetterToPitchClass: {[key: string]: number} = {
    'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11
  };

  let pitchClass = noteLetterToPitchClass[noteLetter];

  // Apply accidental
  if (accidental === '#') {
    pitchClass += 1;
  } else if (accidental === 'b') {
    pitchClass -= 1;
  }

  // Normalize pitch class to 0-11 range
  pitchClass = ((pitchClass % 12) + 12) % 12;

  // Calculate MIDI note: (octave + 1) * 12 + pitchClass
  // Note: MIDI note 0 = C-1, so C0 = 12, C1 = 24, C2 = 36, etc.
  return (octave + 1) * 12 + pitchClass;
}

/**
 * Normalizes IPN reference note names to use only sharps (no flats)
 * This ensures consistent chromatic mapping regardless of enharmonic spelling
 */
function normalizeIpnToSharps(ipn: string): string {
  const flatToSharp: { [key: string]: string } = {
    'Db': 'C#',
    'Eb': 'D#',
    'Gb': 'F#',
    'Ab': 'G#',
    'Bb': 'A#',
  };
  return flatToSharp[ipn] || ipn;
}

/**
 * Builds a keymap (.kbm) content string for mapping maqam/jins to tuning system degrees
 * Uses IPN-based mapping where each MIDI key corresponds to a chromatic pitch class.
 * Missing pitch classes in the maqam/jins are mapped to 'x' (unmapped).
 * The mapping pattern is 12 notes (chromatic octave) and repeats across all octaves.
 *
 * @param name - Display name of the maqam or jins
 * @param type - Type: "maqam" or "jins"
 * @param maqamOrJinsPitchClasses - Pitch classes from the maqam or jins
 * @param tuningSystemPitchClasses - Pitch classes from tuning system octave 1
 * @param tuningSystem - Tuning system
 * @param startingNote - Starting note for the tuning system
 * @param scaleSize - Number of pitch classes in the tuning system octave
 * @param refFreq - Reference frequency in Hz
 * @param scalaFilename - Associated .scl filename for reference
 * @returns Formatted keymap content string
 */
function buildTuningSystemKeymapContent(
  name: string,
  type: "maqam" | "jins",
  maqamOrJinsPitchClasses: PitchClass[],
  tuningSystemPitchClasses: PitchClass[],
  tuningSystem: TuningSystem,
  startingNote: string,
  scaleSize: number,
  refFreq: number,
  scalaFilename: string
): string {
  const chromaticOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

  // ============================================================================
  // STEP 1: Map each maqam/jins pitch class to its tuning system degree
  // ============================================================================

  type MappedPitchClass = {
    pitchClass: PitchClass;
    ipnRef: string;
    degree: number;
    midiNote: number;
  };

  const mappedPitchClasses: MappedPitchClass[] = [];

  for (const pc of maqamOrJinsPitchClasses) {
    const ipnRef = getIpnReferenceNoteName(pc);
    if (!ipnRef) continue;

    const normalizedIpn = normalizeIpnToSharps(ipnRef);
    const pcCents = parseFloat(pc.cents);
    const centsInOctave = pcCents % 1200;

    // Find matching pitch class in tuning system octave 1
    const matchIndex = tuningSystemPitchClasses.findIndex(tspc => {
      const tsCents = parseFloat(tspc.cents);
      const diff = Math.abs(centsInOctave - tsCents);
      const diffWrapped = Math.min(diff, 1200 - diff);
      return diffWrapped < 5; // 5 cents tolerance
    });

    if (matchIndex >= 0) {
      // CRITICAL: Always use midiNoteDeviation to extract accurate MIDI note numbers
      // midiNoteDeviation format: "MIDI_NOTE CENTS_DEVIATION" (e.g., "50 -2.0")
      // Extract the MIDI note number (first part before space)
      let midiNote: number;
      if (pc.midiNoteDeviation) {
        const parts = pc.midiNoteDeviation.split(' ');
        midiNote = parseInt(parts[0], 10);
      } else {
        midiNote = englishNameToMidiNote(pc.englishName);
      }

      // Use matchIndex as degree (base degree in tuning system)
      const degree = matchIndex;

      mappedPitchClasses.push({
        pitchClass: pc,
        ipnRef: normalizedIpn,
        degree: degree,
        midiNote: midiNote
      });

      console.log(`[buildTuningSystemKeymapContent] Mapped ${normalizedIpn}:`, {
        noteName: pc.noteName,
        englishName: pc.englishName,
        cents: pcCents,
        degree: degree,
        midiNote: midiNote,
        midiNoteDeviation: pc.midiNoteDeviation
      });
    }
  }

  // ============================================================================
  // STEP 2: Sort by tuning system degree (ascending) to find the lowest
  // ============================================================================

  mappedPitchClasses.sort((a, b) => a.degree - b.degree);

  // ============================================================================
  // STEP 3: Determine middle note and reference note
  // ============================================================================

  // The maqam/jins tonic is always the first pitch class (before sorting)
  const tonicPc = maqamOrJinsPitchClasses[0];
  const tonicMapped = mappedPitchClasses.find(mpc => mpc.pitchClass === tonicPc);

  if (!tonicMapped) {
    throw new Error(`Cannot find tonic in mapped pitch classes for ${name}`);
  }

  // Position 0 must map to the pitch class with the LOWEST degree
  const lowestDegreeMapped = mappedPitchClasses[0];
  const lowestDegreeIpn = lowestDegreeMapped.ipnRef;
  const lowestDegreePosition = chromaticOrder.indexOf(lowestDegreeIpn);

  // CRITICAL: Reference note = tonic's MIDI note (always mapped)
  // The tonic must be the reference note with its frequency from DiArMaqAr data
  const referenceNoteMidi = tonicMapped.midiNote;
  const actualRefFreq = tonicPc?.frequency ? parseFloat(tonicPc.frequency) : refFreq;

  // CRITICAL: Middle note = lowest degree's MIDI note (where position 0 maps to)
  // BUT if the lowest degree's MIDI note is HIGHER than the tonic's MIDI note,
  // we must shift the middle note DOWN by one octave (subtract 12) so that
  // the middle note is lower than the reference note (tonic).
  //
  // Example: Bayyāt Shūrī on D3 (MIDI 50, degree 11)
  //   - Lowest degree: 5 (B3, MIDI 59)
  //   - Tonic: degree 11 (D3, MIDI 50)
  //   - B3 (59) > D3 (50), so middle note = 59 - 12 = 47 (B2)
  let middleNote = lowestDegreeMapped.midiNote;
  if (lowestDegreeMapped.midiNote > referenceNoteMidi) {
    middleNote = lowestDegreeMapped.midiNote - 12;
  }

  const tonicIpnRef = tonicMapped.ipnRef;

  console.log('[buildTuningSystemKeymapContent] Reference setup:', {
    lowestDegree: lowestDegreeMapped.degree,
    lowestDegreeIpn: lowestDegreeIpn,
    lowestDegreeNote: lowestDegreeMapped.pitchClass.englishName,
    lowestDegreeMidiOriginal: lowestDegreeMapped.midiNote,
    tonicNote: tonicPc.englishName,
    tonicIpn: tonicIpnRef,
    tonicDegree: tonicMapped.degree,
    tonicMidi: tonicMapped.midiNote,
    middleNote: middleNote,
    middleNoteShifted: lowestDegreeMapped.midiNote > referenceNoteMidi,
    referenceNote: referenceNoteMidi,
    referenceFrequency: actualRefFreq
  });

  // ============================================================================
  // STEP 4: Build chromatic mapping in ascending degree order
  // ============================================================================

  // Build IPN-to-degree map for quick lookup
  const ipnToDegreeMap = new Map<string, number>();
  for (const mpc of mappedPitchClasses) {
    ipnToDegreeMap.set(mpc.ipnRef, mpc.degree);
  }

  // Build mapping: 12-note chromatic pattern starting from the LOWEST degree's IPN
  // Position 0 = lowest degree, and degrees must be in ASCENDING order
  // Example: [5, 6, x, 11, x, 14, 17, x, 22, 24, x, x]
  const mapping: Array<string | number> = [];
  const mapPatternSize = 12; // Chromatic octave

  for (let i = 0; i < mapPatternSize; i++) {
    // Rotate chromatic order to start from the lowest degree's IPN
    const rotatedIndex = (lowestDegreePosition + i) % mapPatternSize;
    const ipn = chromaticOrder[rotatedIndex];

    // Check if this IPN exists in the maqam/jins
    if (ipnToDegreeMap.has(ipn)) {
      mapping.push(ipnToDegreeMap.get(ipn)!);
    } else {
      mapping.push('x'); // Unmapped in Scala format
    }
  }

  // Debug: log the complete mapping
  console.log('[buildTuningSystemKeymapContent] Complete mapping array:', {
    mapPatternSize,
    scaleSize,
    middleNote,
    referenceNote: referenceNoteMidi,
    actualRefFreq,
    lowestDegreePosition,
    mapping: mapping.map((deg, idx) => ({
      position: idx,
      ipn: chromaticOrder[(lowestDegreePosition + idx) % 12],
      degree: deg
    }))
  });

  // Get tuning system starting note details
  const tuningSystemStartingPc = tuningSystemPitchClasses[0]; // First pitch class at 0 cents
  const tuningSystemStartingFreq = tuningSystemStartingPc?.frequency
    ? parseFloat(tuningSystemStartingPc.frequency)
    : refFreq;

  // Extract MIDI note number from starting note's midiNoteDeviation
  let tuningSystemStartingMidi: number;
  if (tuningSystemStartingPc?.midiNoteDeviation) {
    const parts = tuningSystemStartingPc.midiNoteDeviation.split(' ');
    tuningSystemStartingMidi = parseInt(parts[0], 10);
  } else {
    tuningSystemStartingMidi = 0; // Fallback
  }

  const tuningSystemStartingEnglishName = tuningSystemStartingPc?.englishName || '';

  const desc = `${name} (tonic: ${tonicIpnRef}) - Mapped to ${tuningSystem.stringify()}`;

  const lines = [
    `! ${desc}`,
    `! Generated by the Digital Arabic Maqām Archive (DiArMaqAr) https://diarmaqar.netlify.app`,
    `!`,
    `! === ASSOCIATED SCALA FILE ===`,
    `! This keyboard mapping uses the following .scl file:`,
    `! ${scalaFilename}`,
    `!`,
    `! === ${type === "maqam" ? "MAQAM" : "JINS"} DETAILS ===`,
    `! ${type === "maqam" ? "Maqam" : "Jins"}: ${name}`,
    `! Tonic: ${tonicPc?.noteName}`,
    `! Tonic IPN: ${tonicIpnRef}`,
    `! Tonic degree in tuning system: ${tonicMapped.degree}`,
    `!`,
    `! === TUNING SYSTEM DETAILS ===`,
    `! Tuning system: ${tuningSystem.stringify()}`,
    `! Starting note name: ${startingNote}`,
    `! Starting note MIDI note number: ${tuningSystemStartingMidi}`,
    `! Starting note IPN and octave: ${tuningSystemStartingEnglishName}`,
    `! Starting note frequency (1/1 at 0 cents): ${tuningSystemStartingFreq.toFixed(2)} Hz`,
    `! Total Scale degrees in .scl file: ${scaleSize}`,
    `! Formal octave (2/1 1200 cents): degree ${scaleSize}`,
    `!`,
    `! === KEYBOARD MAPPING (.kbm) REFERENCE SETTINGS ===`,
    `! Middle note (where position 0 maps to): MIDI ${middleNote}`,
    `!   - Position 0 pitch: ${lowestDegreeMapped.pitchClass.noteName} (${lowestDegreeMapped.pitchClass.englishName})`,
    `!   - Position 0 degree: ${lowestDegreeMapped.degree}`,
    ...(lowestDegreeMapped.midiNote > referenceNoteMidi
      ? [`!   - Note: Middle note shifted down one octave (${lowestDegreeMapped.midiNote} → ${middleNote}) to be lower than reference note`]
      : []),
    `! Reference note (gets reference frequency): MIDI ${referenceNoteMidi}`,
    `!   - Reference pitch: ${tonicPc?.noteName} (${tonicPc?.englishName})`,
    `!   - Reference frequency: ${actualRefFreq.toFixed(2)} Hz`,
    `!`,
    `${mapPatternSize}`, // Map size: pattern repeats every so many keys (12 for chromatic)
    `0`, // First MIDI note to retune
    `127`, // Last MIDI note to retune (full MIDI range)
    `${middleNote}`, // Middle note: where first entry of mapping is mapped to
    `${referenceNoteMidi}`, // Reference note: which MIDI note gets the reference frequency
    `${actualRefFreq}`, // Reference frequency in Hz
    `${scaleSize}`, // Scale degree to consider as formal octave
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n");
}

/**
 * Exports a tuning system's octave 1 as .scl and a maqam as .kbm (mapping to tuning system degrees)
 *
 * This function exports TWO files:
 * 1. A .scl file containing the tuning system's octave 1 pitch classes
 * 2. A .kbm file that maps the maqam's pitch classes to degrees within that tuning system
 *
 * The keymap uses a chromatic mapping pattern (12 notes) that repeats across all octaves.
 *
 * @param maqamInput - Maqam or MaqamData instance to export
 * @param tuningSystem - Tuning system to realize the maqam in
 * @param startingNote - Starting note for the tuning system
 * @param useAscending - Use ascending (true) or descending (false) pitch classes
 * @param referenceFrequency - Optional reference frequency (default: from tuning system)
 * @returns Object with .scl and .kbm file contents, or null if maqam cannot be mapped
 */
export function exportMaqamWithTuningSystemOctave(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote: string,
  useAscending: boolean = true,
  referenceFrequency?: number
): {
  scalaContent: string;
  scalaFilename: string;
  keymapContent: string;
  keymapFilename: string;
} | null {
  // Convert MaqamData to Maqam if needed
  let maqam: Maqam;
  if ("maqamId" in maqamInput) {
    maqam = maqamInput;
  } else {
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(
      tuningSystem,
      startingNote as any
    );
    maqam = maqamInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  // Get tuning system octave 1 pitch classes
  const allPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote as any);
  const octave1PitchClasses = filterToOctave(allPitchClasses, 0, 1200);
  const uniqueOctave1PitchClasses = removeDuplicatePitchClasses(octave1PitchClasses);

  // Get maqam pitch classes (ascending or descending)
  const maqamPitchClasses = useAscending
    ? maqam.ascendingPitchClasses
    : maqam.descendingPitchClasses;

  // Map maqam pitch classes to tuning system degrees
  const degrees = mapPitchClassesToTuningSystemDegrees(
    maqamPitchClasses,
    uniqueOctave1PitchClasses,
    5 // 5 cents tolerance
  );

  if (!degrees) {
    // Cannot map maqam to tuning system
    return null;
  }

  // Generate .scl file content (tuning system octave 1)
  const scalaContent = exportTuningSystemToScala(
    tuningSystem,
    startingNote,
    `${tuningSystem.getTitleEnglish()} Octave 1 (starting note: ${startingNote})`
  );

  // Generate filenames with starting note
  const tuningSystemId = tuningSystem.getId();
  const maqamName = maqam.name.toLowerCase().replace(/\s+/g, '_');
  const startingNoteForFilename = startingNote.toLowerCase().replace(/\s+/g, '_');
  const scalaFilename = `${tuningSystemId}_${startingNoteForFilename}_octave1.scl`;
  const keymapFilename = `${maqamName}_${tuningSystemId}_${startingNoteForFilename}.kbm`;

  // Generate .kbm file content (maqam mapping)
  // Get reference frequency from the starting note's pitch class
  const startingNoteFreq = uniqueOctave1PitchClasses[0]?.frequency
    ? parseFloat(uniqueOctave1PitchClasses[0].frequency)
    : tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refFreq = referenceFrequency || startingNoteFreq;
  // Scale size should match the .scl file count (which excludes the root note at 0 cents)
  const scaleSize = uniqueOctave1PitchClasses.length - 1;
  const keymapContent = buildTuningSystemKeymapContent(
    maqam.name,
    "maqam",
    maqamPitchClasses,
    uniqueOctave1PitchClasses,
    tuningSystem,
    startingNote,
    scaleSize,
    refFreq,
    scalaFilename
  );

  return {
    scalaContent,
    scalaFilename,
    keymapContent,
    keymapFilename,
  };
}

/**
 * Exports a tuning system's octave 1 as .scl and a jins as .kbm (mapping to tuning system degrees)
 *
 * This function exports TWO files:
 * 1. A .scl file containing the tuning system's octave 1 pitch classes
 * 2. A .kbm file that maps the jins's pitch classes to degrees within that tuning system
 *
 * The keymap uses a chromatic mapping pattern (12 notes) that repeats across all octaves.
 *
 * @param jinsInput - Jins or JinsData instance to export
 * @param tuningSystem - Tuning system to realize the jins in
 * @param startingNote - Starting note for the tuning system
 * @param referenceFrequency - Optional reference frequency (default: from tuning system)
 * @returns Object with .scl and .kbm file contents, or null if jins cannot be mapped
 */
export function exportJinsWithTuningSystemOctave(
  jinsInput: Jins | JinsData,
  tuningSystem: TuningSystem,
  startingNote: string,
  referenceFrequency?: number
): {
  scalaContent: string;
  scalaFilename: string;
  keymapContent: string;
  keymapFilename: string;
} | null {
  // Convert JinsData to Jins if needed
  let jins: Jins;
  if ("jinsId" in jinsInput) {
    jins = jinsInput;
  } else {
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(
      tuningSystem,
      startingNote as any
    );
    jins = jinsInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  // Get tuning system octave 1 pitch classes
  const allPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote as any);
  const octave1PitchClasses = filterToOctave(allPitchClasses, 0, 1200);
  const uniqueOctave1PitchClasses = removeDuplicatePitchClasses(octave1PitchClasses);

  // Get jins pitch classes
  const jinsPitchClasses = jins.jinsPitchClasses;

  // Map jins pitch classes to tuning system degrees
  const degrees = mapPitchClassesToTuningSystemDegrees(
    jinsPitchClasses,
    uniqueOctave1PitchClasses,
    5 // 5 cents tolerance
  );

  if (!degrees) {
    // Cannot map jins to tuning system
    return null;
  }

  // Generate .scl file content (tuning system octave 1)
  const scalaContent = exportTuningSystemToScala(
    tuningSystem,
    startingNote,
    `${tuningSystem.getTitleEnglish()} Octave 1 (starting note: ${startingNote})`
  );

  // Generate filenames with starting note
  const tuningSystemId = tuningSystem.getId();
  const jinsName = jins.name.toLowerCase().replace(/\s+/g, '_');
  const startingNoteForFilename = startingNote.toLowerCase().replace(/\s+/g, '_');
  const scalaFilename = `${tuningSystemId}_${startingNoteForFilename}_octave1.scl`;
  const keymapFilename = `${jinsName}_${tuningSystemId}_${startingNoteForFilename}.kbm`;

  // Generate .kbm file content (jins mapping)
  // Get reference frequency from the starting note's pitch class
  const startingNoteFreq = uniqueOctave1PitchClasses[0]?.frequency
    ? parseFloat(uniqueOctave1PitchClasses[0].frequency)
    : tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refFreq = referenceFrequency || startingNoteFreq;
  // Scale size should match the .scl file count (which excludes the root note at 0 cents)
  const scaleSize = uniqueOctave1PitchClasses.length - 1;
  const keymapContent = buildTuningSystemKeymapContent(
    jins.name,
    "jins",
    jinsPitchClasses,
    uniqueOctave1PitchClasses,
    tuningSystem,
    startingNote,
    scaleSize,
    refFreq,
    scalaFilename
  );

  return {
    scalaContent,
    scalaFilename,
    keymapContent,
    keymapFilename,
  };
}
