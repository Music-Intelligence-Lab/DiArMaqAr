import TuningSystem from "@/models/TuningSystem";
import PitchClass from "@/models/PitchClass";
import getTuningSystemPitchClasses from "./getTuningSystemPitchClasses";
import { Jins } from "@/models/Jins";
import { Maqam } from "@/models/Maqam";
import JinsData from "@/models/Jins";
import MaqamData from "@/models/Maqam";
import { classifyMaqamat } from "./classifyMaqamat12PitchClassSets";
import { getMaqamat, getAjnas } from "./import";
import { standardizeText } from "./export";
import { getIpnReferenceNoteName, getIpnReferenceNoteNameWithOctave } from "./getIpnReferenceNoteName";

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Removes duplicate pitch classes based on cents value within a tolerance
 * @param pitchClasses - Array of pitch classes to deduplicate
 * @param tolerance - Cents tolerance for considering two pitches as duplicates (default: 1)
 * @returns Array of unique pitch classes
 */
function removeDuplicatePitchClasses(pitchClasses: PitchClass[], tolerance: number = 1): PitchClass[] {
  const unique: PitchClass[] = [];
  for (const pc of pitchClasses) {
    const cents = parseFloat(pc.cents);
    if (!unique.some((existing) => Math.abs(parseFloat(existing.cents) - cents) < tolerance)) {
      unique.push(pc);
    }
  }
  return unique;
}

/**
 * Filters pitch classes to a single octave range
 * @param pitchClasses - Array of pitch classes to filter
 * @param minCents - Minimum cents value (inclusive, default: 0)
 * @param maxCents - Maximum cents value (exclusive, default: 1200)
 * @returns Filtered and sorted pitch classes within the octave range
 */
function filterToOctave(pitchClasses: PitchClass[], minCents: number = 0, maxCents: number = 1200): PitchClass[] {
  return pitchClasses
    .filter((pc) => {
      const cents = parseFloat(pc.cents);
      return cents >= minCents && cents < maxCents;
    })
    .sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
}

/**
 * Builds Scala file header with metadata
 * @param description - Main description line
 * @param metadata - Optional metadata fields to include in header
 * @returns Array of header lines
 */
function buildScalaHeader(
  maqamName: string,
  metadata: {
    sourceMaqam?: string;
    rootNote?: string;
    direction?: string;
    tuningSystem?: string;
    tuningSystemStartingNote?: string;
    tuningSystemStartingNoteRefFreq?: number;
    referenceFrequency?: number;
    referenceFrequencyNoteName?: string;
    sourceMaqamTonicNoteName?: string;
    baseUrl?: string;
    url?: string;
    compatibleMaqamat?: Array<{ 
      name: string; 
      tonicIpn: string; 
      tonicNoteName: string;
      position: number;
      ascendingIpnNames?: string[];
      descendingIpnNames?: string[];
      ascendingPositions?: number[];
      descendingPositions?: number[];
      isSymmetrical?: boolean;
    }>;
  } = {}
): string[] {
  // Helper function to convert to sentence case (first letter capitalized, rest lowercase)
  const toSentenceCase = (str: string): string => {
    if (!str) return str;
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  };

  // Helper function to lowercase note names and maqām names
  const lowercaseMusicTerms = (str: string): string => {
    return str.toLowerCase();
  };

  // First line: maqam name + "(12 pitch class chromatic set)"
  const lines = [
    `! ${lowercaseMusicTerms(maqamName)} (12 pitch class chromatic set)`,
  ];

  // Second line: Generated by + base URL
  const baseUrl = metadata.baseUrl || 'https://diarmaqar.netlify.app';
  lines.push(`! Generated by the Digital Arabic Maqām Archive (DiArMaqAr) ${baseUrl}`);

  // Source Maqām (if provided, though it should always be provided)
  if (metadata.sourceMaqam) {
    lines.push(`! Source maqām: ${lowercaseMusicTerms(metadata.sourceMaqam)}`);
    // Source maqām tonic note name right after Source Maqām
    if (metadata.sourceMaqamTonicNoteName) {
      lines.push(`! Source maqām tonic note name: ${lowercaseMusicTerms(metadata.sourceMaqamTonicNoteName)}`);
    }
  }

  if (metadata.rootNote) {
    lines.push(`! Root note: ${lowercaseMusicTerms(metadata.rootNote)}`);
  }
  if (metadata.direction) {
    lines.push(`! Direction: ${toSentenceCase(metadata.direction)}`);
  }
  
  // Source tuning system with starting note name and reference frequency
  if (metadata.tuningSystem) {
    let tuningSystemLine = `! Source tuning system: ${metadata.tuningSystem}`;
    if (metadata.tuningSystemStartingNote) {
      // Ensure we use the actual note name, not a number
      const startingNoteName = metadata.tuningSystemStartingNote;
      tuningSystemLine += ` (starting note: ${lowercaseMusicTerms(startingNoteName)}`;
      if (metadata.tuningSystemStartingNoteRefFreq !== undefined) {
        tuningSystemLine += `, reference frequency: ${metadata.tuningSystemStartingNoteRefFreq.toFixed(2)} Hz`;
      }
      tuningSystemLine += ')';
    }
    lines.push(tuningSystemLine);
  }
  
  // Scala file reference frequency
  if (metadata.referenceFrequency !== undefined) {
    const frequencyNoteName = metadata.referenceFrequencyNoteName || '';
    const frequencyDisplay = frequencyNoteName 
      ? `${metadata.referenceFrequency.toFixed(2)} Hz (${frequencyNoteName})`
      : `${metadata.referenceFrequency.toFixed(2)} Hz`;
    lines.push(`! Scala file 1/1 (0 cents) reference frequency: ${frequencyDisplay}`);
  }
  
  if (metadata.url) {
    lines.push(`! More information: ${metadata.url}`);
  }
  
  if (metadata.compatibleMaqamat && metadata.compatibleMaqamat.length > 0) {
    lines.push(`!`);
    // Get total count from first maqam if available, otherwise use array length
    // The total count includes all octave equivalents (before grouping)
    const compatibleMaqamat = metadata.compatibleMaqamat;
    const totalCount = (compatibleMaqamat[0] as any)?.totalCount || compatibleMaqamat.length;
    lines.push(`! Compatible maqāmāt in this set (${totalCount} total):`);
    compatibleMaqamat.forEach((maqam, index) => {
      lines.push(`! - ${lowercaseMusicTerms(maqam.name)}`);
      lines.push(`!   Tonic: ${maqam.tonicIpn} (${lowercaseMusicTerms(maqam.tonicNoteName)}), position ${maqam.position}`);
      
      // Check if maqam is symmetrical - if so, show only one sequence
      const isSymmetrical = maqam.isSymmetrical ?? false;
      
      if (isSymmetrical) {
        // Symmetrical maqam - show only ascending sequence
        if (maqam.ascendingIpnNames && maqam.ascendingIpnNames.length > 0) {
          const ascendingStr = maqam.ascendingIpnNames.join(' → ');
          lines.push(`!   Sequence: ${ascendingStr}`);
          if (maqam.ascendingPositions && maqam.ascendingPositions.length > 0) {
            const positionsStr = maqam.ascendingPositions.join(' → ');
            lines.push(`!   Positions: ${positionsStr}`);
          }
        }
      } else {
        // Asymmetrical maqam - show both sequences
        // Add ascending IPN sequence with positions if available
        if (maqam.ascendingIpnNames && maqam.ascendingIpnNames.length > 0) {
          const ascendingStr = maqam.ascendingIpnNames.join(' → ');
          if (maqam.ascendingPositions && maqam.ascendingPositions.length > 0) {
            const positionsStr = maqam.ascendingPositions.join(' → ');
            lines.push(`!   Ascending IPN sequence: ${ascendingStr}`);
            lines.push(`!   Ascending positions: ${positionsStr}`);
          } else {
            lines.push(`!   Ascending IPN sequence: ${ascendingStr}`);
          }
        }
        
        // Add descending IPN sequence with positions if available
        if (maqam.descendingIpnNames && maqam.descendingIpnNames.length > 0) {
          const descendingStr = maqam.descendingIpnNames.join(' → ');
          lines.push(`!   Descending IPN sequence: ${descendingStr}`);
          if (maqam.descendingPositions && maqam.descendingPositions.length > 0) {
            const positionsStr = maqam.descendingPositions.join(' → ');
            lines.push(`!   Descending positions: ${positionsStr}`);
          }
        }
      }
      
      // Add line break between maqamat (except after the last one)
      if (index < compatibleMaqamat.length - 1) {
        lines.push(`!`);
      }
    });
  }

  lines.push(`!`);
  return lines;
}

/**
 * Formats a pitch class value for Scala export
 *
 * For Scala files, only fraction/ratio formats are preserved from the original tuning system.
 * All other input types (stringLength, fretDivision, etc.) are converted to cents,
 * as cents is the preferred format for microtonal scales in Scala.
 *
 * @param pitchClass - Pitch class to format
 * @param formatType - Format type from the tuning system (any string)
 * @param precision - Number of decimal places for cents (default: 2)
 * @returns Formatted value string (fraction, decimalRatio, or cents)
 */
function formatPitchClassValue(
  pitchClass: PitchClass,
  formatType: string = 'cents',
  precision: number = 2
): string {
  // Only use fraction/ratio formats if explicitly specified
  // All other formats (stringLength, fretDivision, etc.) default to cents
  if (formatType === 'fraction') {
    return pitchClass.fraction;
  } else if (formatType === 'decimalRatio') {
    return pitchClass.decimalRatio;
  } else {
    // Default to cents for: 'cents', 'stringLength', 'fretDivision', and any other type
    return parseFloat(pitchClass.cents).toFixed(precision);
  }
}

/**
 * Builds a 12-tone chromatic keymap (.kbm) content string
 * @param maqamName - Display name of the maqam
 * @param tonicIpnRef - IPN reference of the tonic (e.g., "C", "D#")
 * @param tonicPosition - Position in chromatic scale (0-11)
 * @param tuningSystem - Primary tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system
 * @param refFreq - Reference frequency in Hz
 * @param actualMapSize - MIDI map size (default: 128)
 * @param scaleSize - Scale size (always 12 for chromatic)
 * @returns Formatted keymap content string
 */
function build12ToneKeymapContent(
  maqamName: string,
  tonicIpnRef: string,
  tonicPosition: number,
  tuningSystem: TuningSystem,
  alKindiTuningSystem: TuningSystem,
  refFreq: number,
  actualMapSize: number = 128,
  scaleSize: number = 12
): string {
  const referenceNoteIndex = 0; // Always C for 12-tone chromatic sets
  const mapping = Array.from({ length: actualMapSize }, (_, i) => i % scaleSize);

  const desc = `${maqamName} (tonic: ${tonicIpnRef}) - 12-Tone Chromatic Set Keymap (${tuningSystem.getTitleEnglish()} + al-Kindi)`;

  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Maqam: ${maqamName}`,
    `! Tonic: ${tonicIpnRef} (position ${tonicPosition})`,
    `! Tuning: ${tuningSystem.getTitleEnglish()} + ${alKindiTuningSystem.getTitleEnglish()}`,
    `! Reference note: C (IPN)`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${referenceNoteIndex}`, // Reference note index (C = 0)
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size (always 12)
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}


// ============================================================================
// Tuning System Exports
// ============================================================================

/**
 * Exports a tuning system to Scala (.scl) format
 * https://www.huygens-fokker.org/scala/scl_format.html
 */
export function exportTuningSystemToScala(tuningSystem: TuningSystem, startingNote: string, description?: string): string {
  // Filter to single octave and remove duplicates
  const pitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote);
  const octavePitchClasses = filterToOctave(pitchClasses);
  const uniquePitchClasses = removeDuplicatePitchClasses(octavePitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Generate description
  const desc = description || `${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content
  const headerLines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Starting note: ${startingNote}`,
    `! Source: ${tuningSystem.getSourceEnglish()}`,
    `!`,
  ];

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a tuning system to Scala keymap (.kbm) format
 * https://www.huygens-fokker.org/scala/help.htm#mappings
 */
export function exportTuningSystemToScalaKeymap(tuningSystem: TuningSystem, startingNote: string, referenceNote?: string, referenceFrequency?: number, mapSize?: number): string {
  // Filter to single octave and remove duplicates
  const pitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote);
  const octavePitchClasses = filterToOctave(pitchClasses);
  const uniquePitchClasses = removeDuplicatePitchClasses(octavePitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || startingNote;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${tuningSystem.getTitleEnglish()} Keymap (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Starting note: ${startingNote}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a jins to Scala (.scl) format
 */
export function exportJinsToScala(jinsInput: Jins | JinsData, tuningSystem: TuningSystem, startingNote?: string, description?: string): string {
  let jins: Jins;

  // Check if input is a Jins instance or JinsData
  if ("jinsId" in jinsInput) {
    // It's a Jins instance - use directly
    jins = jinsInput;
  } else {
    // It's a JinsData instance - convert to Jins using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    jins = jinsInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = jins.jinsPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Generate description
  const desc = description || `${jins.name} - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content using helper
  const headerLines = buildScalaHeader(desc, {
    rootNote: pitchClasses[0]?.noteName,
    tuningSystem: tuningSystem.getTitleEnglish(),
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a jins to Scala keymap (.kbm) format
 */
export function exportJinsToScalaKeymap(
  jinsInput: Jins | JinsData,
  tuningSystem: TuningSystem,
  startingNote?: string,
  referenceNote?: string,
  referenceFrequency?: number,
  mapSize?: number
): string {
  let jins: Jins;

  // Check if input is a Jins instance or JinsData
  if ("jinsId" in jinsInput) {
    // It's a Jins instance - use directly
    jins = jinsInput;
  } else {
    // It's a JinsData instance - convert to Jins using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    jins = jinsInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = jins.jinsPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || pitchClasses[0]?.noteName;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${jins.name} Keymap - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Jins: ${jins.name}`,
    `! Root note: ${pitchClasses[0]?.noteName}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam to Scala (.scl) format
 */
export function exportMaqamToScala(maqamInput: Maqam | MaqamData, tuningSystem: TuningSystem, startingNote?: string, useAscending: boolean = true, description?: string): string {
  let maqam: Maqam;

  // Check if input is a Maqam instance or MaqamData
  if ("maqamId" in maqamInput) {
    // It's a Maqam instance - use directly
    maqam = maqamInput;
  } else {
    // It's a MaqamData instance - convert to Maqam using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    maqam = maqamInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = useAscending ? maqam.ascendingPitchClasses : maqam.descendingPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  // Remove the root note (0 cents) as it's implicit in Scala format
  const scaleNotes = uniquePitchClasses.filter((pc) => parseFloat(pc.cents) > 0);

  // Generate description
  const desc = description || `${maqam.name} (${useAscending ? "Ascending" : "Descending"}) - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala file content using helper
  const headerLines = buildScalaHeader(desc, {
    direction: useAscending ? "Ascending" : "Descending",
    rootNote: pitchClasses[0]?.noteName,
    tuningSystem: tuningSystem.getTitleEnglish(),
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`,
    `!`,
    ...scaleNotes.map((pc) => formatPitchClassValue(pc, 'cents')),
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam to Scala keymap (.kbm) format
 */
export function exportMaqamToScalaKeymap(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote?: string,
  useAscending: boolean = true,
  referenceNote?: string,
  referenceFrequency?: number,
  mapSize?: number
): string {
  let maqam: Maqam;

  // Check if input is a Maqam instance or MaqamData
  if ("maqamId" in maqamInput) {
    // It's a Maqam instance - use directly
    maqam = maqamInput;
  } else {
    // It's a MaqamData instance - convert to Maqam using getTahlil
    const fullRangeTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote || tuningSystem.getNoteNameSets()[0]?.[0] || "");
    maqam = maqamInput.getTahlil(fullRangeTuningSystemPitchClasses);
  }

  const pitchClasses = useAscending ? maqam.ascendingPitchClasses : maqam.descendingPitchClasses;

  // Sort and remove duplicates
  const sortedPitchClasses = [...pitchClasses].sort((a, b) => parseFloat(a.cents) - parseFloat(b.cents));
  const uniquePitchClasses = removeDuplicatePitchClasses(sortedPitchClasses);

  const scaleSize = uniquePitchClasses.length;
  const actualMapSize = mapSize || 128; // Default to 128 keys (full MIDI range)
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;
  const refNote = referenceNote || pitchClasses[0]?.noteName;

  // Find the reference note index in the scale
  const referenceNoteIndex = uniquePitchClasses.findIndex((pc) => pc.noteName === refNote);

  // Default mapping: map each key to the corresponding scale degree
  const mapping = Array.from({ length: actualMapSize }, (_, i) => {
    if (i < scaleSize) {
      return i;
    }
    return i % scaleSize;
  });

  // Generate description
  const desc = `${maqam.name} (${useAscending ? "Ascending" : "Descending"}) Keymap - ${tuningSystem.getTitleEnglish()} (${tuningSystem.getCreatorEnglish()}, ${tuningSystem.getYear()})`;

  // Build Scala keymap file content
  const lines = [
    `! ${desc}`,
    `! Generated by Digital Arabic Maqām Archive`,
    `! Maqam: ${maqam.name}`,
    `! Direction: ${useAscending ? "Ascending" : "Descending"}`,
    `! Root note: ${pitchClasses[0]?.noteName}`,
    `! Reference note: ${refNote}`,
    `! Reference frequency: ${refFreq} Hz`,
    `!`,
    `${actualMapSize}`, // Map size
    `0`, // First MIDI note (C)
    `0`, // Last MIDI note (relative to first)
    `${Math.max(0, referenceNoteIndex)}`, // Reference note index
    `${refFreq}`, // Reference frequency
    `${scaleSize}`, // Scale size
    `! Key mapping:`,
    ...mapping.map((degree) => `${degree}`),
  ];

  return lines.join("\n") + "\n";
}

// ============================================================================
// 12-Tone Chromatic Set Exports
// ============================================================================

/**
 * Exports a maqam as a complete 12-tone chromatic set to Scala (.scl) format
 *
 * This function creates a 12-pitch-class set by merging the maqam's pitch classes
 * with al-Kindi (874) filler pitch classes, suitable for MIDI keyboard mapping.
 * The set ALWAYS starts from IPN C for maximum MIDI compatibility.
 *
 * The header lists ALL compatible maqāmāt that can be played using this set,
 * along with their tonic positions in the chromatic scale.
 *
 * @param maqamData - MaqamData instance to export
 * @param tuningSystem - Tuning system to realize the maqam in
 * @param startingNote - Starting note for the tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system for filler pitches
 * @param alKindiStartingNote - Starting note for al-Kindi tuning system
 * @param description - Optional custom description
 * @returns Scala .scl file content as string, or null if maqam is incompatible
 */
export function exportMaqamTo12ToneScala(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote: string,
  alKindiTuningSystem: TuningSystem,
  alKindiStartingNote: string,
  description?: string,
  currentUrl?: string
): string | null {
  // Get dependencies
  const allMaqamat = getMaqamat();
  const ajnas = getAjnas();

  // Get the MaqamData
  let maqamData: MaqamData;
  if ("maqamId" in maqamInput) {
    const foundMaqam = allMaqamat.find(m => m.getId() === maqamInput.maqamId);
    if (!foundMaqam) {
      return null;
    }
    maqamData = foundMaqam;
  } else {
    maqamData = maqamInput;
  }

  // Run global classification to find sets (matches API behavior)
  const classificationResult = classifyMaqamat(
    allMaqamat,
    tuningSystem,
    startingNote,
    alKindiTuningSystem,
    alKindiStartingNote,
    ajnas,
    5 // cents tolerance
  );

  // Find the set where this maqam is the SOURCE (matching API setId filtering logic)
  const maqamIdStandardized = standardizeText(maqamData.getId());
  const matchingSet = classificationResult.sets.find(set =>
    standardizeText(set.sourceMaqam.id) === maqamIdStandardized ||
    set.sourceMaqam.idName === maqamIdStandardized
  );

  if (!matchingSet) {
    return null; // Maqam is not a source for any 12-pitch-class set
  }

  // Use the set's pitch class data
  // CRITICAL: Pitch classes are already in chromatic ascending order from create12PitchClassSet
  // with correct octave selection. Do NOT re-sort them or the octave selection will break.
  const pitchClassSetResult = matchingSet.pitchClassSet;

  // Get all tuning system pitch classes for octave shifting (always needed for Scala export)
  // This matches the API endpoint behavior when startSetFromC=true
  const allTuningSystemPitchClasses = getTuningSystemPitchClasses(tuningSystem, startingNote as any);

  // Get all 12 pitch classes from the original set
  const allPitchClasses: Array<{ ipnRef: string; pitchClass: PitchClass }> = [];

  // Get the maqam tonic IPN reference (first entry in the Map, which is ordered from tonic)
  // This matches the API endpoint logic exactly
  const maqamTonicIpnRef = pitchClassSetResult.pitchClasses.entries().next().value?.[0] || 'C';

  // Define chromatic order for comparison
  const chromaticOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const tonicIndex = chromaticOrder.indexOf(maqamTonicIpnRef);

  // Build pitch class array with octave shifting for Scala mode
  // This matches the API endpoint logic when startSetFromC=true
  for (const [ipnRef, pc] of pitchClassSetResult.pitchClasses.entries()) {
    let pitchClassToUse = pc;

    // For Scala mode: shift octave 2 notes that come BEFORE the tonic to octave 1
    // This handles cases where the maqam starts mid-octave (e.g., D)
    // and we need C and C# from octave 1 instead of octave 2
    // This matches the API endpoint logic exactly
    if (pc.octave === 2 && allTuningSystemPitchClasses) {
      const currentIndex = chromaticOrder.indexOf(ipnRef);
      // If this note comes before the tonic in chromatic order, get octave 1 equivalent
      if (currentIndex < tonicIndex) {
        const octave1Equivalent = allTuningSystemPitchClasses.find(
          tpc => tpc.referenceNoteName === ipnRef && tpc.octave === 1
        );

        if (octave1Equivalent) {
          pitchClassToUse = octave1Equivalent;
        }
      }
    }

    allPitchClasses.push({ ipnRef, pitchClass: pitchClassToUse });
  }

  // For Scala mode: rotate array to start from C
  // This matches the API endpoint logic when startSetFromC=true
  let orderedPitchClasses = allPitchClasses;
  const cIndex = allPitchClasses.findIndex(item => item.ipnRef === 'C');
  if (cIndex !== -1 && cIndex > 0) {
    orderedPitchClasses = [
      ...allPitchClasses.slice(cIndex),
      ...allPitchClasses.slice(0, cIndex)
    ];
  }

  // Get reference cents from the FIRST pitch class in the ordered array
  // This will be C (since we're in Scala mode, always starting from C)
  // This matches the API endpoint logic when startSetFromC=true
  const referenceCents = orderedPitchClasses.length > 0
    ? parseFloat(orderedPitchClasses[0].pitchClass.cents)
    : 0;

  // Add relativeCents property to each pitch class
  // This matches the API endpoint logic exactly
  const pitchClassSetWithRelativeCents = orderedPitchClasses.map(item => {
    const pitchClass = item.pitchClass;
    const cents = parseFloat(pitchClass.cents);

    // Calculate cents relative to reference
    // The rebuild function already ensures chromatic ascending order
    // so relativeCents should naturally be positive and ascending
    let relativeCents = cents - referenceCents;

    // Handle octave wrap-around for Scala mode
    // When pitch classes from lower octaves are rotated to come after C,
    // add 1200 cents to make the relative cents positive
    // This matches the API endpoint logic exactly
    if (relativeCents < 0) {
      relativeCents += 1200;
    }

    return {
      ...pitchClass,
      relativeCents: relativeCents.toFixed(2)
    };
  });

  // Calculate reference frequency for Middle C (the 1/1 note at position 0)
  // The C pitch class is at position 0 in orderedPitchClasses (after rotation)
  // The pitch class frequency field already contains the correct frequency based on the tuning system
  const cPitchClass = orderedPitchClasses[0]?.pitchClass;
  let referenceFrequency: number;
  let referenceFrequencyNoteName: string = '';
  
  if (cPitchClass && cPitchClass.frequency) {
    // Use the frequency directly from the pitch class (already calculated correctly)
    referenceFrequency = parseFloat(cPitchClass.frequency);
    // Get the English note name with octave (e.g., C4, A4)
    referenceFrequencyNoteName = getIpnReferenceNoteNameWithOctave(cPitchClass);
  } else {
    // Fallback: calculate from tuning system reference frequency
    // Formula: frequency = referenceFrequency * 2^(cents/1200)
    const cCents = cPitchClass ? parseFloat(cPitchClass.cents) : 0;
    const tuningSystemRefFreq = tuningSystem.getDefaultReferenceFrequency() || 440.0;
    
    // Get the starting note's pitch class to calculate C's frequency relative to it
    const startingNotePitchClass = allTuningSystemPitchClasses.find(
      pc => pc.noteName === startingNote
    );
    
    if (startingNotePitchClass) {
      // Calculate C's frequency relative to the starting note
      // If starting note is at X cents and C is at Y cents, then:
      // C_frequency = starting_note_frequency * 2^((Y - X)/1200)
      const startingNoteCents = parseFloat(startingNotePitchClass.cents);
      const startingNoteFreq = parseFloat(startingNotePitchClass.frequency);
      const centsDiff = cCents - startingNoteCents;
      referenceFrequency = startingNoteFreq * Math.pow(2, centsDiff / 1200);
      if (cPitchClass) {
        referenceFrequencyNoteName = getIpnReferenceNoteNameWithOctave(cPitchClass);
      }
    } else {
      // Final fallback: use default reference frequency
      referenceFrequency = tuningSystemRefFreq;
    }
  }
  
  // Get base maqam tonic note name from the source maqam transposition
  const baseMaqamTonicPitchClass = matchingSet.sourceTransposition.ascendingPitchClasses?.[0];
  const baseMaqamTonicNoteName = baseMaqamTonicPitchClass?.noteName || '';

  // Use compatible maqamat from the classification result
  // Enhanced with tonic note names, IPN sequences, and position numbers
  const compatibleMaqamatInfo: Array<{ 
    name: string;
    baseMaqamId: string;
    tonicIpn: string; 
    tonicNoteName: string;
    position: number;
    ascendingIpnNames: string[];
    descendingIpnNames: string[];
    ascendingPositions: number[];
    descendingPositions: number[];
    isSymmetrical: boolean;
  }> = [];
  const seenMaqamatByTonic = new Set<string>(); // Track maqam:tonic combinations to avoid duplicates

  // Create a map of IPN reference to position in the ordered pitch classes for quick lookup
  const ipnToPositionMap = new Map<string, number>();
  orderedPitchClasses.forEach((item, index) => {
    ipnToPositionMap.set(item.ipnRef, index);
  });

  for (const maqamInfo of matchingSet.compatibleMaqamat) {
    // Get the tonic for this specific maqam from its ascending pitch classes
    // This matches the API endpoint logic exactly
    const maqamTonicPitchClass = maqamInfo.maqam.ascendingPitchClasses?.[0];
    
    // Get the tonic note name (e.g., "dūgāh", "segāh")
    const tonicNoteName = maqamTonicPitchClass?.noteName || '';
    
    // Get the IPN reference note name for the tonic (e.g., "D", "C#")
    // This works even if the tonic is in a different octave (e.g., qarār dūgāh -> "D")
    const tonicIpnRef = maqamTonicPitchClass?.referenceNoteName || '';

    // Find the matching IPN in the 12-pitch-class set (after rotation to start from C)
    // This finds the octave equivalent within the set
    // This matches the API endpoint logic exactly
    const maqamTonicPitchClassMatch = tonicIpnRef
      ? orderedPitchClasses.find(item => item.ipnRef === tonicIpnRef)
      : null;

    const maqamTonicIpnRef = maqamTonicPitchClassMatch?.ipnRef || tonicIpnRef;
    const maqamTonicPositionInSet = maqamTonicPitchClassMatch
      ? orderedPitchClasses.findIndex(item => item.ipnRef === tonicIpnRef)
      : -1;

    // Get pitch class details for ascending sequence
    // Use the same approach as the API endpoint - get pitch classes directly from the maqam
    // Format: Persian-Arab-Ottoman note name first, then English name in brackets (e.g., "rāst (C4)")
    const ascendingIpnNames: string[] = [];
    const ascendingPositions: number[] = [];
    if (maqamInfo.maqam.ascendingPitchClasses) {
      for (const pc of maqamInfo.maqam.ascendingPitchClasses) {
        const ipnRef = getIpnReferenceNoteName(pc);
        if (ipnRef) {
          const position = ipnToPositionMap.get(ipnRef);
          if (position !== undefined) {
            // Get English note name (should already include octave, e.g., "C4", "D4")
            const englishName = pc.englishName || '';
            // Get Persian-Arab-Ottoman note name
            const noteName = pc.noteName || '';
            // Format: "noteName (englishName)" or just "englishName" if noteName is empty
            const formattedName = noteName && englishName
              ? `${noteName} (${englishName})`
              : englishName || noteName || '';
            
            ascendingIpnNames.push(formattedName);
            ascendingPositions.push(position);
          }
        }
      }
    }

    // Get pitch class details for descending sequence
    const descendingIpnNames: string[] = [];
    const descendingPositions: number[] = [];
    if (maqamInfo.maqam.descendingPitchClasses) {
      for (const pc of maqamInfo.maqam.descendingPitchClasses) {
        const ipnRef = getIpnReferenceNoteName(pc);
        if (ipnRef) {
          const position = ipnToPositionMap.get(ipnRef);
          if (position !== undefined) {
            // Get English note name (should already include octave, e.g., "C4", "D4")
            const englishName = pc.englishName || '';
            // Get Persian-Arab-Ottoman note name
            const noteName = pc.noteName || '';
            // Format: "noteName (englishName)" or just "englishName" if noteName is empty
            const formattedName = noteName && englishName
              ? `${noteName} (${englishName})`
              : englishName || noteName || '';
            
            descendingIpnNames.push(formattedName);
            descendingPositions.push(position);
          }
        }
      }
    }
    
    // Check if maqam is symmetrical (ascending == descending when reversed)
    const isSymmetrical = ascendingIpnNames.length === descendingIpnNames.length &&
      ascendingIpnNames.length > 0 &&
      JSON.stringify(ascendingIpnNames) === JSON.stringify([...descendingIpnNames].reverse());

    // Use transposition name + tonic IPN as key to avoid listing duplicates
    // This matches the API endpoint which shows all transpositions separately
    // Note: The classification result may contain duplicates, so we deduplicate here
    // Use maqam.name (transposition name) instead of maqamData.getName() (base name)
    // to show all transpositions separately, matching the API behavior
    const transpositionName = maqamInfo.maqam.name;
    const key = `${transpositionName}:${maqamTonicIpnRef}`;
    if (!seenMaqamatByTonic.has(key)) {
      compatibleMaqamatInfo.push({
        name: transpositionName,
        baseMaqamId: maqamInfo.maqamData.getId(),
        tonicIpn: maqamTonicIpnRef || 'Unknown',
        tonicNoteName: tonicNoteName,
        position: maqamTonicPositionInSet >= 0 ? maqamTonicPositionInSet : 0,
        ascendingIpnNames: ascendingIpnNames,
        descendingIpnNames: descendingIpnNames,
        ascendingPositions: ascendingPositions,
        descendingPositions: descendingPositions,
        isSymmetrical: isSymmetrical,
      });
      seenMaqamatByTonic.add(key);
    }
  }

  // Store the total count BEFORE grouping (includes all octave equivalents)
  // This matches the API response which counts all compatible maqamat individually
  const totalCompatibleMaqamatCount = compatibleMaqamatInfo.length;
  
  // Group octave equivalent maqamat together
  // Octave equivalents have the same base maqam ID but different octave transpositions
  const maqamGroups = new Map<string, Array<typeof compatibleMaqamatInfo[0]>>();
  
  for (const maqam of compatibleMaqamatInfo) {
    // Group by base maqam ID
    const baseId = maqam.baseMaqamId;
    
    if (!maqamGroups.has(baseId)) {
      maqamGroups.set(baseId, []);
    }
    maqamGroups.get(baseId)!.push(maqam);
  }
  
  // Rebuild compatibleMaqamatInfo with grouped octave equivalents
  const groupedMaqamatInfo: Array<typeof compatibleMaqamatInfo[0] & { totalCount?: number }> = [];
  
  for (const maqamat of maqamGroups.values()) {
    if (maqamat.length === 1) {
      // Single maqam, no octave equivalents
      groupedMaqamatInfo.push({
        ...maqamat[0],
        totalCount: totalCompatibleMaqamatCount
      });
    } else {
      // Multiple maqamat - find the "main" one (usually the one without "al-" prefix or shortest name)
      // Sort by name length, shortest first (main maqam usually has shorter name)
      maqamat.sort((a, b) => {
        const aHasAl = a.name.includes(' al-');
        const bHasAl = b.name.includes(' al-');
        if (aHasAl !== bHasAl) {
          return aHasAl ? 1 : -1; // Prefer ones without "al-"
        }
        return a.name.length - b.name.length; // Shorter name first
      });
      
      const mainMaqam = maqamat[0];
      const octaveEquivalents = maqamat.slice(1).map(m => m.name);
      
      groupedMaqamatInfo.push({
        ...mainMaqam,
        name: octaveEquivalents.length > 0
          ? `${mainMaqam.name} (and its octave equivalent${octaveEquivalents.length > 1 ? 's' : ''}: ${octaveEquivalents.join(', ')})`
          : mainMaqam.name,
        totalCount: totalCompatibleMaqamatCount
      });
    }
  }
  
  // Sort by position
  groupedMaqamatInfo.sort((a, b) => a.position - b.position);
  
  // Update compatibleMaqamatInfo reference
  compatibleMaqamatInfo.length = 0;
  compatibleMaqamatInfo.push(...groupedMaqamatInfo);

  // Remove the root note (0 cents relative) as it's implicit in Scala format
  const scaleNotes = pitchClassSetWithRelativeCents.filter((pc) => parseFloat(pc.relativeCents) > 0);

  // For a 12-tone chromatic set, we need 12 notes total:
  // - 11 intervals (excluding root at 0 cents)
  // - 1 octave at 1200 cents
  // Add the octave (1200.00 cents) as the final note if it's not already present
  const hasOctave = scaleNotes.some(pc => Math.abs(parseFloat(pc.relativeCents) - 1200) < 0.01);
  if (!hasOctave) {
    // Create an octave pitch class based on the root note (first pitch class)
    const rootPitchClass = orderedPitchClasses[0]?.pitchClass;
    if (rootPitchClass) {
      // Create octave version: same pitch class, one octave up
      const octavePitchClass = {
        ...rootPitchClass,
        relativeCents: '1200.00',
        octave: rootPitchClass.octave + 1,
        // Update frequency to be double (one octave up)
        frequency: rootPitchClass.frequency ? (parseFloat(rootPitchClass.frequency) * 2).toFixed(2) : '',
        // Update cents to be +1200 from root
        cents: rootPitchClass.cents ? (parseFloat(rootPitchClass.cents) + 1200).toFixed(2) : '1200.00',
      };
      scaleNotes.push(octavePitchClass);
    }
  }

  // Ensure we have exactly 12 notes (11 intervals + 1 octave)
  // Sort by relative cents to ensure proper order
  scaleNotes.sort((a, b) => parseFloat(a.relativeCents) - parseFloat(b.relativeCents));

  // Generate description (for the Scala file body, not header)
  const desc = description || `${maqamData.getName().toLowerCase()} - 12-tone chromatic set (${tuningSystem.stringify()} + ${alKindiTuningSystem.stringify()})`;

  // Extract base URL from currentUrl (e.g., "http://localhost:3000" or "https://diarmaqar.netlify.app")
  let baseUrl = 'https://diarmaqar.netlify.app'; // Default fallback
  if (currentUrl) {
    try {
      const urlObj = new URL(currentUrl);
      baseUrl = `${urlObj.protocol}//${urlObj.host}`;
    } catch {
      // If URL parsing fails, use default
    }
  }

  // Get the actual note name from the tuning system's note name sets
  // This matches the API endpoint logic (route.ts lines 293-311)
  // It ensures we use the proper note name with diacritics
  const noteNameSets = tuningSystem.getNoteNameSets();
  const validNoteSet = noteNameSets.find(
    (set) => standardizeText(set[0] || "") === standardizeText(startingNote)
  );
  const actualStartingNoteName = validNoteSet?.[0] || startingNote;

  // Get starting note's reference frequency from tuning system
  const referenceFrequencies = tuningSystem.getReferenceFrequencies();
  const startingNoteRefFreq = referenceFrequencies[actualStartingNoteName] || tuningSystem.getDefaultReferenceFrequency();

  // Build Scala file content with compatible maqāmāt listing
  const headerLines = buildScalaHeader(maqamData.getName(), {
    sourceMaqam: maqamData.getName(),
    tuningSystem: `${tuningSystem.stringify()} + ${alKindiTuningSystem.stringify()}`,
    tuningSystemStartingNote: actualStartingNoteName,
    tuningSystemStartingNoteRefFreq: startingNoteRefFreq,
    referenceFrequency: referenceFrequency,
    referenceFrequencyNoteName: referenceFrequencyNoteName,
    sourceMaqamTonicNoteName: baseMaqamTonicNoteName,
    baseUrl: baseUrl,
    url: currentUrl,
    compatibleMaqamat: compatibleMaqamatInfo,
  });

  const lines = [
    ...headerLines,
    `${desc}`,
    `${scaleNotes.length}`, // Should be 12 for a 12-tone chromatic set
    `!`,
    ...scaleNotes.map((pc) => pc.relativeCents), // Already formatted as string with 2 decimal places
  ];

  return lines.join("\n") + "\n";
}

/**
 * Exports a maqam as a complete 12-tone chromatic set to Scala keymap (.kbm) format
 *
 * Creates multiple keymaps - one for each compatible maqām transposition in the 12-pitch-class set.
 * Includes all transpositions but excludes octave duplicates (only one keymap per IPN tonic).
 * All keymaps reference the same .scl file but map MIDI keys differently based on each maqām's tonic.
 *
 * @param maqamData - MaqamData instance to export
 * @param tuningSystem - Tuning system to realize the maqam in
 * @param startingNote - Starting note for the tuning system
 * @param alKindiTuningSystem - al-Kindi tuning system for filler pitches
 * @param alKindiStartingNote - Starting note for al-Kindi tuning system
 * @param referenceFrequency - Optional reference frequency (default: from tuning system)
 * @param mapSize - Optional map size (default: 128 for full MIDI range)
 * @returns Array of keymap objects with metadata, or null if maqam is incompatible
 */
export function exportMaqamTo12ToneScalaKeymap(
  maqamInput: Maqam | MaqamData,
  tuningSystem: TuningSystem,
  startingNote: string,
  alKindiTuningSystem: TuningSystem,
  alKindiStartingNote: string,
  referenceFrequency?: number,
  mapSize?: number
): Array<{
  maqamName: string;
  maqamId: string;
  tonic: string;
  tonicPosition: number;
  keymapContent: string;
}> | null {
  // Get dependencies
  const allMaqamat = getMaqamat();
  const ajnas = getAjnas();

  // Get the MaqamData
  let maqamData: MaqamData;
  if ("maqamId" in maqamInput) {
    const foundMaqam = allMaqamat.find(m => m.getId() === maqamInput.maqamId);
    if (!foundMaqam) {
      return null;
    }
    maqamData = foundMaqam;
  } else {
    maqamData = maqamInput;
  }

  // Run global classification to find sets (matches API behavior)
  const classificationResult = classifyMaqamat(
    allMaqamat,
    tuningSystem,
    startingNote,
    alKindiTuningSystem,
    alKindiStartingNote,
    ajnas,
    5 // cents tolerance
  );

  // Find the set where this maqam is the SOURCE (matching API setId filtering logic)
  const maqamIdStandardized = standardizeText(maqamData.getId());
  const matchingSet = classificationResult.sets.find(set =>
    standardizeText(set.sourceMaqam.id) === maqamIdStandardized ||
    set.sourceMaqam.idName === maqamIdStandardized
  );

  if (!matchingSet) {
    return null; // Maqam is not a source for any 12-pitch-class set
  }

  // Use compatible maqamat from the classification result (deduplicated by IPN tonic)
  const chromaticOrder = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
  const uniqueTranspositions = new Map<string, {
    maqamData: MaqamData;
    tonicIpnRef: string;
    tonicPosition: number;
  }>();

  for (const maqamInfo of matchingSet.compatibleMaqamat) {
    // Find the tonic IPN reference for this transposition
    const tonicIpnRef = maqamInfo.maqam.ascendingPitchClasses[0]?.referenceNoteName;
    if (!tonicIpnRef) continue;

    const tonicPosition = chromaticOrder.indexOf(tonicIpnRef);
    if (tonicPosition < 0) continue;

    // Use maqamId:ipnTonic as key to deduplicate octave equivalents
    const key = `${maqamInfo.maqamData.getId()}:${tonicIpnRef}`;

    // Only add if not already present
    if (!uniqueTranspositions.has(key)) {
      uniqueTranspositions.set(key, {
        maqamData: maqamInfo.maqamData,
        tonicIpnRef,
        tonicPosition,
      });
    }
  }

  // Generate one keymap per unique transposition
  const actualMapSize = mapSize || 128;
  const refFreq = referenceFrequency || tuningSystem.getDefaultReferenceFrequency() || 440.0;

  const keymaps = Array.from(uniqueTranspositions.values()).map(entry => ({
    maqamName: entry.maqamData.getName(),
    maqamId: entry.maqamData.getId(),
    tonic: entry.tonicIpnRef,
    tonicPosition: entry.tonicPosition,
    keymapContent: build12ToneKeymapContent(
      entry.maqamData.getName(),
      entry.tonicIpnRef,
      entry.tonicPosition,
      tuningSystem,
      alKindiTuningSystem,
      refFreq,
      actualMapSize
    ),
  }));

  // Sort by tonic position for better organization
  keymaps.sort((a, b) => a.tonicPosition - b.tonicPosition);

  return keymaps;
}
